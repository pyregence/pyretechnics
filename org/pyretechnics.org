#+TITLE: The Pyretechnics Fire Behavior Library
#+SUBTITLE: Copyright Â© 2023-2025 Spatial Informatics Group, LLC
#+AUTHOR: Gary W. Johnson, Valentin Waeselynck, Chris Lautenberger, David Saah

* Document Settings :noexport:

# ================================
# HTML Export Settings
# ================================

#+EXPORT_FILE_NAME: ../docs/index.html
#+OPTIONS: H:3 toc:t ^:{} <:nil date:nil timestamp:nil
#+TOC: tables
#+HTML_DOCTYPE: html5
#+DESCRIPTION: A Python library for simulating fire behavior in a variety of ways.
#+KEYWORDS: pyretechnics fire behavior model python library pyregence pyrecast
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="pyretechnics-base.css" />
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="pyretechnics-custom.css" />
#+INFOJS_OPT: view:info path:org-info.js

# ================================
# Code Block Settings
# ================================

#+PROPERTY: header-args:python+ :preamble "import sys\nsys.path.extend(['../src','../test'])"
#+PROPERTY: header-args:python+ :eval     no-export
#+PROPERTY: header-args:python+ :results  value verbatim pp silent
#+PROPERTY: header-args:python+ :mkdirp   yes
#+PROPERTY: header-args:python+ :padline  no
#+PROPERTY: header-args:python+ :comments link

* Preface
  :PROPERTIES:
  :CUSTOM_ID: preface
  :END:

This document is a Literate
Program[fn::https://en.wikipedia.org/wiki/Literate_programming],
containing both the source code of the software it describes as well
as the rationale used in each step of its design and implementation.
The purpose of this approach is to enable both programmers and
non-programmers alike to retrace the author's footsteps as they read
through the text and code. By the time they have reached the end of
this document, the reader should have just as strong a grasp of the
system as the original programmer.

The source code repository containing this document provides a
comprehensive reproducible development environment through the use of
the open source GNU Guix[fn::https://guix.gnu.org] transactional
package manager. This tool will automatically install all the software
needed to tangle, detangle, weave, test, build, and install this
library on your machine without conflicting with the main package
manager of your operating system. See [[file:../README.md][README.md]] for more details.

* Data Model
  :PROPERTIES:
  :CUSTOM_ID: data-model
  :END:
** Working in a 3D Space-Time Cube
   :PROPERTIES:
   :CUSTOM_ID: working-in-a-3d-space-time-cube
   :END:

In Pyretechnics, a fire is viewed as a three-dimensional event
occurring within a bounded region of space-time $(T,Y,X)$. In this
mental model, the environment in which a fire develops can be
visualized as a cube in which space is described in 2D by the $X$ and
$Y$ dimensions and time projects this 2D world into 3D along the $T$
dimension.

Note, in particular, that this is not the same thing as a
three-dimensional model of fire behavior that incorporates surface
elevation as the third dimension. Although terrain data (such as
elevation, slope, and aspect) and tree cover characteristics (such as
canopy height and canopy base height) are incorporated into the
implemented spread equations in order to determine the rate,
direction, and mode of fire spread, the outputs of the fire behavior
algorithms in Pyretechnics currently only use two dimensions to
describe spatial heterogeneity within the simulation environment. The
third dimension is instead reserved for temporal variations in the
model inputs and outputs.

** Fires as Conical Shapes in Space-Time
   :PROPERTIES:
   :CUSTOM_ID: fires-as-conical-shapes-in-space-time
   :END:

All fire events begin from an ignition somewhere in space-time. As
combustion and propagation occur in burnable fuels, the burned area
(a.k.a "burn scar") of a fire spreads monotonically outward in space.
Viewed from the lens of our 3D space-time cube, these monotonically
expanding burn scars form conical solids within the simulation
environment, with the bottom point of the cone representing the
initial ignition point and the upper edge of the cone representing the
actively burning fire perimeter. Of course, we only expect idealized
fire cones to appear in environments with homogeneous topography,
weather, fuels, and fuel moisture. As these inputs become more
heterogenous throughout the burned region of space-time, these
idealized cones will become distorted in the directions of faster or
slower spread and their perimeters may become more finely dissected.
However, we use this conical shape description of fire events within
the simulated space-time cube to convey both their monotonically
increasing spatial area over time as well as to provide the foundation
for a more visually intuitive understanding of the effect of
temporally varying environmental conditions on the behavior (and thus
shape) of fires.

** Support for Input Datasets of Varying Dimensionality
   :PROPERTIES:
   :CUSTOM_ID: support-for-input-datasets-of-varying-dimensionality
   :END:

At the beginning of a fire behavior simulation, our 3D space-time cube
will be populated with all of the information that describes the
environment and will remain effectively static as the fire event
unfolds. This includes (but is not limited to) topography, weather,
fuels, and fuel moisture. In many common simulation scenarios, we
expect that topography and fuels will probably vary in space but not
in time, and weather and fuel moisture may vary in both space and
time. However, we use "may" in these statements because the data model
within Pyretechnics is flexibly designed to allow any of these
environmental input variables to take on any of these forms:

- Constant :: Constant in both space and time. \\
  *Ex*: A single constant foliar moisture value could be used over the
  simulation area for the entire simulation duration.

- Temporal :: Constant in space but variable in time. \\
  *Ex*: An hourly sequence of spread rate adjustment factors could be
  used to globally ramp up and down fire spread rates throughout a
  day/night cycle, creating burn periods of arbitrary length and
  intensity.

- Spatial :: Variable in space but constant in time. \\
  *Ex*: A raster layer downloaded from
  LANDFIRE[fn::https://landfire.gov] can be used to specify the
  spatial distribution of FBFM40 fuel model values on a landscape.

- Spatio-temporal :: Variable in both space and time. \\
  *Ex*: Hourly
  RTMA[fn::https://www.nco.ncep.noaa.gov/pmb/products/rtma/] weather
  data can be loaded from a multi-band raster and used to specify the
  spatio-temporal distribution of wind speed and direction throughout
  the simulation domain.

This is accomplished by representing each such input value as an
abstract datatype with a set of 3D space-time lookup functions for
accessing its values within 0D, 1D, 2D, and 3D slices of the
space-time cube at the simulation resolution. Such lookups should
always be referentially transparent, so as to ensure that subsequent
lookups with the same coordinate will always yield the same values.
See section [[Loading Data into the 3D Space-Time Cube
(pyretechnics.space_time_cube)]] for implementation details.

** Support for Input Datasets of Varying Resolution
   :PROPERTIES:
   :CUSTOM_ID: support-for-input-datasets-of-varying-resolution
   :END:

Even when dimensions are the same between input datasets, they may be
provided at different resolutions from one another, provided that the
following conditions are met:

- Same Projection :: All spatially varying datasets must share the
  same projection.

- Same Extent :: All spatial and temporal extents must match.

- Data Resolutions Divide Simulation Resolutions Evenly :: All
  spatial and temporal resolutions must be exact divisors of the
  simulation resolution.

The simulated space-time cube will share the same projection and
extent as the input datasets, but its resolution may be specified by
the user, provided that it meets condition 3 above. The 3D lookup
functions for each input will then be responsible for translating the
space-time coordinates they receive at the simulation resolution into
the correct coordinates for their underlying dataset's native
resolution. See section [[Loading Data into the 3D Space-Time Cube
(pyretechnics.space_time_cube)]] for implementation details.

* Loading Data into the 3D Space-Time Cube (pyretechnics.space_time_cube)
  :PROPERTIES:
  :CUSTOM_ID: loading-data-into-the-3d-space-time-cube-(pyretechnics.space_time_cube)
  :END:
** For Developers
   :PROPERTIES:
   :CUSTOM_ID: for-developers-spacetimecube
   :header-args:python+: :session *pyretechnics.space_time_cube*
   :header-args:python+: :tangle  ../src/pyretechnics/space_time_cube.py
   :header-args:python+: :exports code
   :END:

The following sections define Python classes that construct 3D
space-time cubes corresponding to the data model described above for
various types of input datasets.

*** Module Imports
    :PROPERTIES:
    :CUSTOM_ID: module-imports-space-time-cube
    :END:

#+NAME: space-time-cube-imports
#+begin_src python
import cython
import cython as cy
from functools import reduce
import numpy as np
if cython.compiled:
    from cython.cimports.pyretechnics.cy_types import pyidx
else:
    from pyretechnics.py_types import pyidx
#+end_src

*** Utility Functions
    :PROPERTIES:
    :CUSTOM_ID: utility-functions
    :END:

#+NAME: space-time-cube-utilities
#+begin_src python
@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def is_pos_int(x: object) -> cy.bint:
    return isinstance(x, int) and x > 0


@cy.cfunc
@cy.exceptval(-1)
def divide_evenly(dividend: cy.int, divisor: cy.int) -> cy.int:
    if divisor == 0:
        raise ValueError(str(divisor) + " may not be zero.")
    else:
        quotient : cy.int = dividend // divisor
        remainder: cy.int = dividend % divisor
        if remainder == 0:
            return quotient
        else:
            raise ValueError(str(dividend) + " must be an exact multiple of " + str(divisor) + ".")


@cy.cfunc
@cy.exceptval(check=False)
def to_positive_index_range(index_range: tuple[pyidx, pyidx]|None, axis_length: pyidx) -> tuple[pyidx, pyidx]:
    """
    Translate None and negative indices to positive indices.
    """
    if index_range == None:
        return (0, axis_length)
    else:
        start: pyidx|None = index_range[0]
        stop : pyidx|None = index_range[1]
        return (
            0 if start == None else axis_length + start if start < 0 else start,
            axis_length if stop == None else axis_length + stop if stop < 0 else stop
        )


def maybe_repeat_array(array, axis_repetitions):
    """
    Return a new array that is created by repeating the elements from the input
    array repetitions times along the specified array axis. Avoid allocating
    new memory if repetitions == 1 or if the repeated array axis has length 1.
    """
    (axis, repetitions) = axis_repetitions
    if repetitions == 1:
        return array
    else:
        array_shape = list(np.shape(array))
        if array_shape[axis] == 1:
            array_shape[axis] = repetitions
            return np.broadcast_to(array, array_shape)
        else:
            return np.repeat(array, repetitions, axis)
#+end_src

*** ISpaceTimeCube Class
    :PROPERTIES:
    :CUSTOM_ID: ispacetimecube-class
    :END:

The ISpaceTimeCube class provides an abstract parent class from which
both the SpaceTimeCube and LazySpaceTimeCube classes inherit. Because
of this, functions which accept an ISpaceTimeCube can provide
polymorphism over these two child classes.

#+NAME: ispace-time-cube-class
#+begin_src python
@cy.cclass
class ISpaceTimeCube:
    @cy.cfunc
    @cy.exceptval(check=False)
    def get(self, t: pyidx, y: pyidx, x: pyidx) -> cy.float:
        pass
#+end_src

*** SpaceTimeCube Class
    :PROPERTIES:
    :CUSTOM_ID: spacetimecube-class
    :END:

When an input dataset is already loaded into memory as either a single
scalar value or a 1D, 2D, or 3D array of values, it can be made
available to the various Pyretechnics algorithms by wrapping it in a
=SpaceTimeCube= object. As described in sections [[Support for Input
Datasets of Varying Dimensionality]] and [[Support for Input Datasets of
Varying Resolution]], this input data can be provided in a variety of
dimensions and resolutions, subject to some simple constraints.

The =SpaceTimeCube= object will be created with a tuple of
user-specified spatio-temporal resolutions, called the /cube shape/,
which must be equal to or exact multiples of those of the underlying
data. For memory efficiency, input values are stored within the
=SpaceTimeCube= object at their native resolution but can be accessed
at any spatio-temporal point or region within the =SpaceTimeCube='s
extent using coordinates from the /cube shape/ resolution.

The various accessor functions provided by this class receive 3D
space-time coordinates at the /cube shape/ resolution and will
correctly map them into the corresponding index within the native
dataset. Whenever a bounded region of space-time is requested via an
accessor function, the underlying data will be expanded to fill a new
Numpy array at the /cube shape/ resolution. Whenever possible, Numpy
array broadcasting will be used instead of data copying for any
constant input dimensions.

#+NAME: space-time-cube-class
#+begin_src python
@cy.cclass
class SpaceTimeCube(ISpaceTimeCube):
    """
    Create an object that represents a 3D array with dimensions (T,Y,X) given by cube_shape.
    Internally, data is stored as a 3D Numpy array at the resolution of the provided base data.
    Whenever a point value or contiguous space-time region of values is requested, translate
    the given cube_shape coordinates into base coordinates, look up the values from the base data,
    expand them (if necessary) back into the cube_shape resolution, and return the resulting scalar
    value or array to the caller.
    """
    ndim         : cy.int
    size         : cy.ulong
    shape        : tuple[cy.int, cy.int, cy.int]
    base         : object
    t_repetitions: cy.int
    y_repetitions: cy.int
    x_repetitions: cy.int
    data         : cy.float[:,:,::1] # FIXME: Restore polymorphism for the underlying Numpy arrays


    def __init__(self, cube_shape: tuple[int, int, int], base: object) -> cy.void:
        """
        NOTE: The resolutions in cube_shape must be exact multiples of any existing dimensions
              in the base data.
        """
        # Ensure that cube_shape contains 3 values or throw an error
        if len(cube_shape) != 3:
            raise ValueError("The cube_shape must contain exactly three values.")

        # Unpack the cube_shape values without type-checking
        cube_bands_: object = cube_shape[0]
        cube_rows_ : object = cube_shape[1]
        cube_cols_ : object = cube_shape[2]

        # Ensure that cube_shape only contains positive integers or throw an error
        if not(is_pos_int(cube_bands_) and is_pos_int(cube_rows_) and is_pos_int(cube_cols_)):
            raise ValueError("The cube_shape must contain only positive integers.")

        # Cast the cube_shape values as primitive ints
        cube_bands: cy.int = cube_bands_
        cube_rows : cy.int = cube_rows_
        cube_cols : cy.int = cube_cols_

        # Store the cube metadata for later
        self.ndim  = 3
        self.size  = cube_bands * cube_rows * cube_cols
        self.shape = (cube_bands, cube_rows, cube_cols)
        self.base  = base

        # Store the base data as a 3D array along with its axis repetitions
        base_dimensions: cy.int = np.ndim(base)

        if base_dimensions == 0:
            # 0D: Constant Input
            self.t_repetitions = cube_bands
            self.y_repetitions = cube_rows
            self.x_repetitions = cube_cols
            self.data          = np.asarray([[[base]]], dtype=np.float32)

        elif base_dimensions == 1:
            # 1D: Time-Series Input
            base_bands: cy.int = len(base)
            self.t_repetitions = divide_evenly(cube_bands, base_bands)
            self.y_repetitions = cube_rows
            self.x_repetitions = cube_cols
            # Expand (base_bands) -> (base_bands,1,1)
            self.data = np.expand_dims(np.asarray(base, dtype=np.float32), axis=(1,2))

        elif base_dimensions == 2:
            # 2D: Spatial Input
            base_shape: tuple  = np.shape(base)
            base_rows : cy.int = base_shape[0]
            base_cols : cy.int = base_shape[1]
            self.t_repetitions = cube_bands
            self.y_repetitions = divide_evenly(cube_rows, base_rows)
            self.x_repetitions = divide_evenly(cube_cols, base_cols)
            # Expand (base_rows,base_cols) -> (1,base_rows,base_cols)
            self.data = np.expand_dims(np.asarray(base, dtype=np.float32), axis=0)

        elif base_dimensions == 3:
            # 3D: Spatio-Temporal Input
            base_shape: tuple  = np.shape(base)
            base_bands: cy.int = base_shape[0]
            base_rows : cy.int = base_shape[1]
            base_cols : cy.int = base_shape[2]
            self.t_repetitions = divide_evenly(cube_bands, base_bands)
            self.y_repetitions = divide_evenly(cube_rows, base_rows)
            self.x_repetitions = divide_evenly(cube_cols, base_cols)
            self.data          = np.asarray(base, dtype=np.float32)

        else:
            # 4D+: Invalid Input
            raise ValueError("Invalid input: base must have 0-3 dimensions.")


    @cy.ccall
    @cy.exceptval(check=False)
    def get(self, t: pyidx, y: pyidx, x: pyidx) -> cy.float:
        """
        Return the scalar value at index (t,y,x) by translating these cube coordinates
        to base coordinates and looking up the value within the base data.

        NOTE: Indices may be negative.
        """
        # Select value by spatio-temporal coordinate
        return self.data[t // self.t_repetitions,
                         y // self.y_repetitions,
                         x // self.x_repetitions]


    def getTimeSeries(self, t_range, y, x):
        """
        Return the 1D array given by the slice (t_range,y,x) by translating these cube
        coordinates to base coordinates, looking up the array slice within the base data,
        and expanding it back to the cube_shape resolution.

        NOTE: Indices may be negative.
        NOTE: Range indices may include one or more None values and
              provide (inclusion, exclusion) semantics like Python array slice notation.
        """
        # Destructure the argument range
        (t_start, t_stop_exclusive) = to_positive_index_range(t_range, self.shape[0])
        t_stop = t_stop_exclusive - 1
        # Translate high-res coordinates to low-res coordinates
        t_start_chunk = t_start // self.t_repetitions
        t_stop_chunk  = t_stop  // self.t_repetitions
        y_chunk       = y       // self.y_repetitions
        x_chunk       = x       // self.x_repetitions
        # Select the array slice that completely contains all low-res coordinates
        low_res_time = self.data[t_start_chunk:(t_stop_chunk + 1),
                                 y_chunk,
                                 x_chunk]
        # Expand the low-res slice into a high-res slice
        high_res_time = maybe_repeat_array(low_res_time, (0, self.t_repetitions))
        # Translate high-res global coordinates to high-res slice coordinates
        t_chunk_origin = t_start_chunk * self.t_repetitions
        t_start_idx    = t_start - t_chunk_origin
        t_stop_idx     = t_stop  - t_chunk_origin
        # Select the array slice that matches the high-res slice coordinates
        return np.asarray(high_res_time[t_start_idx:(t_stop_idx + 1)])


    def getSpatialPlane(self, t, y_range, x_range):
        """
        Return the 2D array given by the slice (t,y_range,x_range) by translating these
        cube coordinates to base coordinates, looking up the array slice within the base
        data, and expanding it back to the cube_shape resolution.

        NOTE: Indices may be negative.
        NOTE: Range indices may include one or more None values and
              provide (inclusion, exclusion) semantics like Python array slice notation.
        """
        # Destructure the argument ranges
        (y_start, y_stop_exclusive) = to_positive_index_range(y_range, self.shape[1])
        (x_start, x_stop_exclusive) = to_positive_index_range(x_range, self.shape[2])
        y_stop = y_stop_exclusive - 1
        x_stop = x_stop_exclusive - 1
        # Translate high-res coordinates to low-res coordinates
        t_chunk       = t       // self.t_repetitions
        y_start_chunk = y_start // self.y_repetitions
        y_stop_chunk  = y_stop  // self.y_repetitions
        x_start_chunk = x_start // self.x_repetitions
        x_stop_chunk  = x_stop  // self.x_repetitions
        # Select the array slice that completely contains all low-res coordinates
        low_res_space = self.data[t_chunk,
                                  y_start_chunk:(y_stop_chunk + 1),
                                  x_start_chunk:(x_stop_chunk + 1)]
        # Expand the low-res slice into a high-res slice
        high_res_space = reduce(maybe_repeat_array,
                                ((0, self.y_repetitions),
                                 (1, self.x_repetitions)),
                                low_res_space)
        # Translate high-res global coordinates to high-res slice coordinates
        y_chunk_origin = y_start_chunk * self.y_repetitions
        x_chunk_origin = x_start_chunk * self.x_repetitions
        y_start_idx    = y_start - y_chunk_origin
        y_stop_idx     = y_stop  - y_chunk_origin
        x_start_idx    = x_start - x_chunk_origin
        x_stop_idx     = x_stop  - x_chunk_origin
        # Select the array slice that matches the high-res slice coordinates
        return np.asarray(high_res_space[y_start_idx:(y_stop_idx + 1),
                                         x_start_idx:(x_stop_idx + 1)])


    def getSubcube(self, t_range, y_range, x_range):
        """
        Return the 3D array given by the slice (t_range,y_range,x_range) by translating
        these cube coordinates to base coordinates, looking up the array slice within the
        base data, and expanding it back to the cube_shape resolution.

        NOTE: Indices may be negative.
        NOTE: Range indices may include one or more None values and
              provide (inclusion, exclusion) semantics like Python array slice notation.
        """
        # Destructure the argument ranges
        (t_start, t_stop_exclusive) = to_positive_index_range(t_range, self.shape[0])
        (y_start, y_stop_exclusive) = to_positive_index_range(y_range, self.shape[1])
        (x_start, x_stop_exclusive) = to_positive_index_range(x_range, self.shape[2])
        t_stop = t_stop_exclusive - 1
        y_stop = y_stop_exclusive - 1
        x_stop = x_stop_exclusive - 1
        # Translate high-res coordinates to low-res coordinates
        t_start_chunk = t_start // self.t_repetitions
        t_stop_chunk  = t_stop  // self.t_repetitions
        y_start_chunk = y_start // self.y_repetitions
        y_stop_chunk  = y_stop  // self.y_repetitions
        x_start_chunk = x_start // self.x_repetitions
        x_stop_chunk  = x_stop  // self.x_repetitions
        # Select the array slice that completely contains all low-res coordinates
        low_res_cube = self.data[t_start_chunk:(t_stop_chunk + 1),
                                 y_start_chunk:(y_stop_chunk + 1),
                                 x_start_chunk:(x_stop_chunk + 1)]
        # Expand the low-res slice into a high-res slice
        high_res_cube = reduce(maybe_repeat_array,
                               ((0, self.t_repetitions),
                                (1, self.y_repetitions),
                                (2, self.x_repetitions)),
                               low_res_cube)
        # Translate high-res global coordinates to high-res slice coordinates
        t_chunk_origin = t_start_chunk * self.t_repetitions
        y_chunk_origin = y_start_chunk * self.y_repetitions
        x_chunk_origin = x_start_chunk * self.x_repetitions
        t_start_idx    = t_start - t_chunk_origin
        t_stop_idx     = t_stop  - t_chunk_origin
        y_start_idx    = y_start - y_chunk_origin
        y_stop_idx     = y_stop  - y_chunk_origin
        x_start_idx    = x_start - x_chunk_origin
        x_stop_idx     = x_stop  - x_chunk_origin
        # Select the array slice that matches the high-res slice coordinates
        return np.asarray(high_res_cube[t_start_idx:(t_stop_idx + 1),
                                        y_start_idx:(y_stop_idx + 1),
                                        x_start_idx:(x_stop_idx + 1)])


    def __getFullyRealizedCube(self):
        """
        Return the 3D array created by expanding the base data to the cube_shape resolution.
        Wherever possible, Numpy broadcasting is used to avoid memory allocation along
        constant array dimensions.
        """
        base_dimensions = np.ndim(self.base)

        if base_dimensions == 0:
            # 0D: Constant Input
            # Broadcast (0,0,0) -> (t,y,x)
            return np.broadcast_to(self.data, self.shape)

        elif base_dimensions == 1:
            # 1D: Time-Series Input
            # Repeat (t0,1,1) -> (t,1,1)
            repeated_array = maybe_repeat_array(self.data, (0, self.t_repetitions))
            # Broadcast (t,1,1) -> (t,y,x)
            return np.broadcast_to(repeated_array, self.shape)

        elif base_dimensions == 2:
            # 2D: Spatial Input
            # Repeat (1,y0,x0) -> (1,y,x)
            repeated_array = reduce(maybe_repeat_array,
                                    ((1, self.y_repetitions),
                                     (2, self.x_repetitions)),
                                    self.data)
            # Broadcast (1,y,x) -> (t,y,x)
            return np.broadcast_to(repeated_array, self.shape)

        else:
            # 3D: Spatio-Temporal Input
            # Repeat (t0,y0,x0) -> (t,y,x)
            return np.asarray(reduce(maybe_repeat_array,
                                     ((0, self.t_repetitions),
                                      (1, self.y_repetitions),
                                      (2, self.x_repetitions)),
                                     self.data))


    def getFullyRealizedCube(self, cache=False):
        """
        Return the 3D array created by expanding the base data to the cube_shape resolution.
        Wherever possible, Numpy broadcasting is used to avoid memory allocation along
        constant array dimensions. When cache == True, this expanded 3D array is cached
        within the SpaceTimeCube object for future immediate retrieval.
        """
        if hasattr(self, "cube"):
            return self.cube
        else:
            cube = self.__getFullyRealizedCube()
            if cache is True:
                self.cube = cube
            return cube


    def releaseFullyRealizedCube(self):
        """
        Deletes the cached fully realized cube if it exists.
        """
        if hasattr(self, "cube"):
            delattr(self, "cube")
#+end_src

*** LazySpaceTimeCube Class
    :PROPERTIES:
    :CUSTOM_ID: lazyspacetimecube-class
    :END:

When a dataset is too large to fit easily into memory, it can be
partitioned into a collection of subcubes, which will be lazily loaded
on demand into a 3D cache grid of =SpaceTimeCube= objects provided by
the =LazySpaceTimeCube= class.

The =LazySpaceTimeCube= object will be created with a tuple of
user-specified spatio-temporal resolutions, called the /cube shape/,
which must be equal to or exact multiples of the /subcube shape/.

The various accessor functions provided by this class receive 3D
space-time coordinates at the /cube shape/ resolution and will
correctly map them into the corresponding cache and subcube indexes.
Any intersected subcubes that are not already present in the cache
grid will be loaded on demand by calling a user-supplied
=load_subcube= function and stored in the cache grid for faster
retrieval later. If a bounded region of space-time that spans multiple
subcubes is requested via an accessor function, each of the
intersected subcubes will be loaded and cached, their relevant array
slices will be extracted, and these slices will be merged into a new
array at the /cube shape/ resolution.

Fire spread simulations that use the =LazySpaceTimeCube= class will
only need to load into memory those subcubes which are intersected by
the expanding conical burn scar (see section [[Fires as Conical Shapes
in Space-Time]]). In simulations of fires that are small relative to the
extent of the full 3D space-time environment, these memory savings may
be substantial and may make it possible to run simulations over larger
extents and/or finer resolutions than have been used previously.

#+NAME: lazy-space-time-cube-class
#+begin_src python
@cy.cclass
class LazySpaceTimeCube(ISpaceTimeCube):
    """
    Create an object that represents a 3D array with dimensions (T,Y,X) given by cube_shape.
    Internally, data is stored as an initially empty 3D array of SpaceTimeCube objects.
    Whenever a point value or contiguous space-time region of values is requested, identify
    which SpaceTimeCubes contain the requested coordinates, load them into the cache array
    by calling load_subcube for any that are not already present, request the values from
    these SpaceTimeCubes, combine them together if necessary, and return the resulting scalar
    value or array to the caller.
    """
    ndim         : cy.int
    size         : cy.ulong
    shape        : tuple[cy.int, cy.int, cy.int]
    subcube_shape: tuple[cy.int, cy.int, cy.int]
    cache_shape  : tuple[cy.int, cy.int, cy.int]
    cache        : np.ndarray
    load_subcube : object


    def __init__(self,
                 cube_shape   : tuple[int, int, int],
                 subcube_shape: tuple[int, int, int],
                 load_subcube : object) -> cy.void:
        """
        NOTE: The resolutions in cube_shape must be exact multiples of those in subcube_shape.
        """
        # Ensure that cube_shape and subcube_shape both contain 3 values or throw an error
        if len(cube_shape) != 3:
            raise ValueError("The cube_shape must contain exactly three values.")

        if len(subcube_shape) != 3:
            raise ValueError("The subcube_shape must contain exactly three values.")

        # Unpack the cube_shape values without type-checking
        cube_bands_: object = cube_shape[0]
        cube_rows_ : object = cube_shape[1]
        cube_cols_ : object = cube_shape[2]

        # Unpack the subcube_shape values without type-checking
        subcube_bands_: object = subcube_shape[0]
        subcube_rows_ : object = subcube_shape[1]
        subcube_cols_ : object = subcube_shape[2]

        # Ensure that cube_shape and subcube_shape only contain positive integers or throw an error
        if not(is_pos_int(cube_bands_) and is_pos_int(cube_rows_) and is_pos_int(cube_cols_)):
            raise ValueError("The cube_shape must contain only positive integers.")

        if not(is_pos_int(subcube_bands_) and is_pos_int(subcube_rows_) and is_pos_int(subcube_cols_)):
            raise ValueError("The subcube_shape must contain only positive integers.")

        # Cast the cube_shape values as primitive ints
        cube_bands: cy.int = cube_bands_
        cube_rows : cy.int = cube_rows_
        cube_cols : cy.int = cube_cols_

        # Cast the subcube_shape values as primitive ints
        subcube_bands: cy.int = subcube_bands_
        subcube_rows : cy.int = subcube_rows_
        subcube_cols : cy.int = subcube_cols_

        # Ensure that cube_shape is divided evenly by subcube_shape or throw an error
        cache_bands: cy.int = divide_evenly(cube_bands, subcube_bands)
        cache_rows : cy.int = divide_evenly(cube_rows, subcube_rows)
        cache_cols : cy.int = divide_evenly(cube_cols, subcube_cols)

        # Store the cube metadata, subcube_shape, cache_shape, cache, and load_subcube functions for later
        self.ndim          = 3
        self.size          = cube_bands * cube_rows * cube_cols
        self.shape         = (cube_bands, cube_rows, cube_cols)
        self.subcube_shape = (subcube_bands, subcube_rows, subcube_cols)
        self.cache_shape   = (cache_bands, cache_rows, cache_cols)
        self.cache         = np.empty(self.cache_shape, dtype=object)
        self.load_subcube  = load_subcube


    @cy.cfunc
    def __getOrLoadSubcube(self, cache_t: pyidx, cache_y: pyidx, cache_x: pyidx) -> SpaceTimeCube:
        """
        Return the SpaceTimeCube stored at self.cache[cache_t, cache_y, cache_x] if it
        has already been loaded. Otherwise, call self.load_subcube to load it, store
        it in self.cache, and return it.
        """
        subcube: SpaceTimeCube = cy.cast(SpaceTimeCube, self.cache[cache_t, cache_y, cache_x])
        if subcube:
            return subcube
        else:
            subcube = self.load_subcube((cache_t, cache_y, cache_x), self.subcube_shape)
            self.cache[cache_t, cache_y, cache_x] = subcube
            return subcube


    @cy.ccall
    @cy.exceptval(check=False)
    def get(self, t: pyidx, y: pyidx, x: pyidx) -> cy.float:
        """
        Return the scalar value at index (t,y,x) by translating these cube coordinates
        to cache and subcube coordinates, loading the matching subcube into the cache grid
        if not already present, and looking up the value within this subcube.

        NOTE: Indices may be negative provided that your load_subcube function can handle
              negative indices in its cache_index argument.
        """
        # Grab the subcube_shape tuple
        subcube_shape: tuple[cy.int, cy.int, cy.int] = self.subcube_shape

        # Unpack the subcube_shape values
        subcube_bands: cy.int = subcube_shape[0]
        subcube_rows : cy.int = subcube_shape[1]
        subcube_cols : cy.int = subcube_shape[2]

        # Calculate the cache index
        cache_t: pyidx = t // subcube_bands
        cache_y: pyidx = y // subcube_rows
        cache_x: pyidx = x // subcube_cols

        # Calculate the subcube index
        subcube_t: pyidx = t % subcube_bands
        subcube_y: pyidx = y % subcube_rows
        subcube_x: pyidx = x % subcube_cols

        # Fetch the subcube from the cache
        subcube: SpaceTimeCube = self.__getOrLoadSubcube(cache_t, cache_y, cache_x)

        # Look up the scalar value in the subcube at the subcube index
        return subcube.get(subcube_t, subcube_y, subcube_x)


    def getTimeSeries(self, t_range, y, x):
        """
        Return the 1D array given by the slice (t_range,y,x) by translating these cube
        coordinates to cache and subcube coordinates, loading the matching subcubes into
        the cache grid if not already present, looking up the array slices within each
        subcube, and merging them together into a single 1D array.

        NOTE: Indices may be negative provided that your load_subcube function can handle
              negative indices in its cache_index argument.
        NOTE: Range indices may include one or more None values and
              provide (inclusion, exclusion) semantics like Python array slice notation.
        """
        # Destructure the argument range
        (t_start, t_stop_exclusive) = to_positive_index_range(t_range, self.shape[0])
        t_stop = t_stop_exclusive - 1
        # Translate high-res coordinates to cache and subcube coordinates
        (subcube_bands, subcube_rows, subcube_cols) = self.subcube_shape
        (cache_t_start, subcube_t_start) = divmod(t_start, subcube_bands)
        (cache_t_stop,  subcube_t_stop)  = divmod(t_stop,  subcube_bands)
        (cache_y,       subcube_y)       = divmod(y,       subcube_rows)
        (cache_x,       subcube_x)       = divmod(x,       subcube_cols)
        # Load, expand, and combine subcubes
        return np.concatenate(
            [self.__getOrLoadSubcube(cache_t,
                                     cache_y,
                                     cache_x
                                    ).getTimeSeries(
                                        (subcube_t_start    if cache_t == cache_t_start else 0,
                                         subcube_t_stop + 1 if cache_t == cache_t_stop  else subcube_bands),
                                        subcube_y,
                                        subcube_x
                                    )
             for cache_t in range(cache_t_start, cache_t_stop + 1)]
        )


    def getSpatialPlane(self, t, y_range, x_range):
        """
        Return the 2D array given by the slice (t,y_range,x_range) by translating these
        cube coordinates to cache and subcube coordinates, loading the matching subcubes
        into the cache grid if not already present, looking up the array slices within each
        subcube, and merging them together into a single 2D array.

        NOTE: Indices may be negative provided that your load_subcube function can handle
              negative indices in its cache_index argument.
        NOTE: Range indices may include one or more None values and
              provide (inclusion, exclusion) semantics like Python array slice notation.
        """
        # Destructure the argument ranges
        (y_start, y_stop_exclusive) = to_positive_index_range(y_range, self.shape[1])
        (x_start, x_stop_exclusive) = to_positive_index_range(x_range, self.shape[2])
        y_stop = y_stop_exclusive - 1
        x_stop = x_stop_exclusive - 1
        # Translate high-res coordinates to cache and subcube coordinates
        (subcube_bands, subcube_rows, subcube_cols) = self.subcube_shape
        (cache_t,       subcube_t)       = divmod(t,       subcube_bands)
        (cache_y_start, subcube_y_start) = divmod(y_start, subcube_rows)
        (cache_y_stop,  subcube_y_stop)  = divmod(y_stop,  subcube_rows)
        (cache_x_start, subcube_x_start) = divmod(x_start, subcube_cols)
        (cache_x_stop,  subcube_x_stop)  = divmod(x_stop,  subcube_cols)
        # Load, expand, and combine subcubes
        return np.block(
            [[self.__getOrLoadSubcube(cache_t,
                                      cache_y,
                                      cache_x
                                      ).getSpatialPlane(
                                          subcube_t,
                                          (subcube_y_start    if cache_y == cache_y_start else 0,
                                           subcube_y_stop + 1 if cache_y == cache_y_stop  else subcube_rows),
                                          (subcube_x_start    if cache_x == cache_x_start else 0,
                                           subcube_x_stop + 1 if cache_x == cache_x_stop  else subcube_cols)
                                      )
              for cache_x in range(cache_x_start, cache_x_stop + 1)]
             for cache_y in range(cache_y_start, cache_y_stop + 1)]
        )


    def getSubcube(self, t_range, y_range, x_range):
        """
        Return the 3D array given by the slice (t_range,y_range,x_range) by translating
        these cube coordinates to cache and subcube coordinates, loading the matching
        subcubes into the cache grid if not already present, looking up the array slices
        within each subcube, and merging them together into a single 3D array.

        NOTE: Indices may be negative provided that your load_subcube function can handle
              negative indices in its cache_index argument.
        NOTE: Range indices may include one or more None values and
              provide (inclusion, exclusion) semantics like Python array slice notation.
        """
        # Destructure the argument ranges
        (t_start, t_stop_exclusive) = to_positive_index_range(t_range, self.shape[0])
        (y_start, y_stop_exclusive) = to_positive_index_range(y_range, self.shape[1])
        (x_start, x_stop_exclusive) = to_positive_index_range(x_range, self.shape[2])
        t_stop = t_stop_exclusive - 1
        y_stop = y_stop_exclusive - 1
        x_stop = x_stop_exclusive - 1
        # Translate high-res coordinates to cache and subcube coordinates
        (subcube_bands, subcube_rows, subcube_cols) = self.subcube_shape
        (cache_t_start, subcube_t_start) = divmod(t_start, subcube_bands)
        (cache_t_stop,  subcube_t_stop)  = divmod(t_stop,  subcube_bands)
        (cache_y_start, subcube_y_start) = divmod(y_start, subcube_rows)
        (cache_y_stop,  subcube_y_stop)  = divmod(y_stop,  subcube_rows)
        (cache_x_start, subcube_x_start) = divmod(x_start, subcube_cols)
        (cache_x_stop,  subcube_x_stop)  = divmod(x_stop,  subcube_cols)
        # Load, expand, and combine subcubes
        return np.block(
            [[[self.__getOrLoadSubcube(cache_t,
                                       cache_y,
                                       cache_x
                                       ).getSubcube(
                                           (subcube_t_start    if cache_t == cache_t_start else 0,
                                            subcube_t_stop + 1 if cache_t == cache_t_stop  else subcube_bands),
                                           (subcube_y_start    if cache_y == cache_y_start else 0,
                                            subcube_y_stop + 1 if cache_y == cache_y_stop  else subcube_rows),
                                           (subcube_x_start    if cache_x == cache_x_start else 0,
                                            subcube_x_stop + 1 if cache_x == cache_x_stop  else subcube_cols)
                                       )
               for cache_x in range(cache_x_start, cache_x_stop + 1)]
              for cache_y in range(cache_y_start, cache_y_stop + 1)]
             for cache_t in range(cache_t_start, cache_t_stop + 1)]
        )


    def getFullyRealizedCube(self, cache=False):
        raise ValueError("getFullyRealizedCube is not implemented for LazySpaceTimeCube.\n"
                         + "You probably don't want to do this anyway.")


    def releaseFullyRealizedCube(self):
        raise ValueError("releaseFullyRealizedCube is not implemented for LazySpaceTimeCube.\n"
                         + "You probably don't want to do this anyway.")
#+end_src

** For Users
   :PROPERTIES:
   :CUSTOM_ID: for-users-spacetimecube
   :header-args:python+: :session *examples:pyretechnics.space_time_cube*
   :header-args:python+: :results output replace
   :header-args:python+: :exports both
   :END:

In the following sections, we will use functions from [[https://pypi.org/project/numpy/][numpy]] and the
Python standard library to construct arrays of different resolutions
in memory to use in our =SpaceTimeCube= and =LazySpaceTimeCube=
examples. In many real world applications, this array data will
probably be read in from files or databases using Python libraries
such as [[https://pypi.org/project/rasterio/][rasterio]] or [[https://pypi.org/project/psycopg2/][psycopg2]]. All examples should apply equally well
in either case.

*** How to Use SpaceTimeCube
    :PROPERTIES:
    :CUSTOM_ID: how-to-use-spacetimecube
    :END:
**** Create a SpaceTimeCube from 0D, 1D, 2D, or 3D Input Data
     :PROPERTIES:
     :CUSTOM_ID: create-a-spacetimecube-from-0d,-1d,-2d,-or-3d-input-data
     :END:

#+NAME: space-time-cube-create
#+begin_src python :results silent
import numpy as np
from pyretechnics.space_time_cube import SpaceTimeCube

#==============================================================
# Set a Random Seed
#==============================================================

np.random.seed(0)

#==============================================================
# Specify the SpaceTimeCube Dimensions
#==============================================================

cube_shape = (
    240,  # bands: 10 days @ 1 hour/band
    1000, # rows:  30 km @ 30 meters/row
    1000, # cols:  30 km @ 30 meters/col
)

#=====================================================================================================
# Constant Data: foliar moisture = 70% everywhere
#=====================================================================================================

foliar_moisture = 0.7
constant_cube   = SpaceTimeCube(cube_shape, foliar_moisture)

#=====================================================================================================
# Temporal Data: 24-hour burn period with ramp up and ramp down for 10 days
#=====================================================================================================

spread_rate_adjustments = ([0] * 6 + [0.33, 0.66] + [1] * 12 + [0.66, 0.33] + [0] * 2) * 10
time_series_cube        = SpaceTimeCube(cube_shape, spread_rate_adjustments)

#=====================================================================================================
# Spatial Data: 2D elevation raster with 1000 (30m) x 1000 (30m) cells
#=====================================================================================================

elevation_raster = np.random.normal(500, 100, 1000000).astype("int").reshape(1000,1000)
spatial_cube     = SpaceTimeCube(cube_shape, elevation_raster)

#=====================================================================================================
# Spatio-Temporal Data: 3D daily max wind speed raster with 10 (days) x 100 (300m) x 100 (300m) cells
#=====================================================================================================

wind_speed_raster   = np.random.normal(30, 5, 100000).astype("int").reshape(10,100,100)
spatiotemporal_cube = SpaceTimeCube(cube_shape, wind_speed_raster)
#+end_src

**** Retrieve a Scalar Value at a Space-Time Coordinate
     :PROPERTIES:
     :CUSTOM_ID: retrieve-a-scalar-value-at-a-space-time-coordinate
     :END:

#+NAME: space-time-cube-get-point
#+begin_src python
# Space-Time Coordinate
band = 12
row  = 100
col  = 100

print("Value from Constant Data: Foliar Moisture")
print(constant_cube.get(band, row, col), "\n")

print("Value from Time Series Data: Spread Rate Adjustment")
print(time_series_cube.get(band, row, col), "\n")

print("Value from Spatial Data: Elevation")
print(spatial_cube.get(band, row, col), "\n")

print("Value from Spatio-Temporal Data: Wind Speed")
print(spatiotemporal_cube.get(band, row, col))
#+end_src

#+NAME: space-time-cube-get-point-results
#+RESULTS: space-time-cube-get-point
#+begin_example
Value from Constant Data: Foliar Moisture
0.699999988079071 

Value from Time Series Data: Spread Rate Adjustment
1.0 

Value from Spatial Data: Elevation
564.0 

Value from Spatio-Temporal Data: Wind Speed
32.0
#+end_example

**** Retrieve a Time Series at a Spatial Coordinate
     :PROPERTIES:
     :CUSTOM_ID: retrieve-a-time-series-at-a-spatial-coordinate
     :END:

#+NAME: space-time-cube-get-time-series
#+begin_src python
# Space-Time Coordinates
band_range = (18,30)
row        = 100
col        = 100

print("Time Series from Constant Data: Foliar Moisture")
print(constant_cube.getTimeSeries(band_range, row, col), "\n")

print("Time Series from Time Series Data: Spread Rate Adjustment")
print(time_series_cube.getTimeSeries(band_range, row, col), "\n")

print("Time Series from Spatial Data: Elevation")
print(spatial_cube.getTimeSeries(band_range, row, col), "\n")

print("Time Series from Spatio-Temporal Data: Wind Speed")
print(spatiotemporal_cube.getTimeSeries(band_range, row, col))
#+end_src

#+NAME: space-time-cube-get-time-series-results
#+RESULTS: space-time-cube-get-time-series
#+begin_example
Time Series from Constant Data: Foliar Moisture
[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7] 

Time Series from Time Series Data: Spread Rate Adjustment
[1.   1.   0.66 0.33 0.   0.   0.   0.   0.   0.   0.   0.  ] 

Time Series from Spatial Data: Elevation
[564. 564. 564. 564. 564. 564. 564. 564. 564. 564. 564. 564.] 

Time Series from Spatio-Temporal Data: Wind Speed
[32. 32. 32. 32. 32. 32. 37. 37. 37. 37. 37. 37.]
#+end_example

**** Retrieve a Spatial Plane at a Temporal Coordinate
     :PROPERTIES:
     :CUSTOM_ID: retrieve-a-spatial-plane-at-a-temporal-coordinate
     :END:

#+NAME: space-time-cube-get-spatial-plane
#+begin_src python
# Space-Time Coordinates
band      = 12
row_range = (95,105)
col_range = (95,105)

print("Spatial Plane from Constant Data: Foliar Moisture")
print(constant_cube.getSpatialPlane(band, row_range, col_range), "\n")

print("Spatial Plane from Time Series Data: Spread Rate Adjustment")
print(time_series_cube.getSpatialPlane(band, row_range, col_range), "\n")

print("Spatial Plane from Spatial Data: Elevation")
print(spatial_cube.getSpatialPlane(band, row_range, col_range), "\n")

print("Spatial Plane from Spatio-Temporal Data: Wind Speed")
print(spatiotemporal_cube.getSpatialPlane(band, row_range, col_range))
#+end_src

#+NAME: space-time-cube-get-spatial-plane-results
#+RESULTS: space-time-cube-get-spatial-plane
#+begin_example
Spatial Plane from Constant Data: Foliar Moisture
[[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]] 

Spatial Plane from Time Series Data: Spread Rate Adjustment
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]] 

Spatial Plane from Spatial Data: Elevation
[[574. 369. 544. 310. 517. 488. 565. 549. 450. 470.]
 [443. 551. 480. 476. 432. 561. 578. 361. 468. 480.]
 [520. 712. 396. 393. 584. 292. 424. 391. 494. 586.]
 [707. 534. 246. 423. 521. 500. 426. 340. 288. 482.]
 [542. 285. 607. 555. 645. 559. 461. 603. 330. 452.]
 [498. 497. 664. 445. 518. 564. 461. 508. 600. 380.]
 [454. 500. 276. 487. 447. 591. 413. 378. 458. 508.]
 [573. 890. 485. 501. 357. 413. 356. 635. 374. 618.]
 [535. 558. 491. 482. 539. 572. 598. 703. 463. 329.]
 [487. 555. 580. 492. 462. 484. 495. 396. 711. 356.]] 

Spatial Plane from Spatio-Temporal Data: Wind Speed
[[31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
 [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
 [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
 [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
 [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
 [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
 [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
 [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
 [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
 [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]]
#+end_example

**** Retrieve a Subcube within a Space-Time Region
     :PROPERTIES:
     :CUSTOM_ID: retrieve-a-subcube-within-a-space-time-region
     :END:

#+NAME: space-time-cube-get-subcube
#+begin_src python
# Space-Time Coordinates
band_range = (23,25)
row_range  = (95,105)
col_range  = (95,105)

print("Subcube from Constant Data: Foliar Moisture")
print(constant_cube.getSubcube(band_range, row_range, col_range), "\n")

print("Subcube from Time Series Data: Spread Rate Adjustment")
print(time_series_cube.getSubcube(band_range, row_range, col_range), "\n")

print("Subcube from Spatial Data: Elevation")
print(spatial_cube.getSubcube(band_range, row_range, col_range), "\n")

print("Subcube from Spatio-Temporal Data: Wind Speed")
print(spatiotemporal_cube.getSubcube(band_range, row_range, col_range))
#+end_src

#+NAME: space-time-cube-get-subcube-results
#+RESULTS: space-time-cube-get-subcube
#+begin_example
Subcube from Constant Data: Foliar Moisture
[[[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]]

 [[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]]] 

Subcube from Time Series Data: Spread Rate Adjustment
[[[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]]

 [[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]]] 

Subcube from Spatial Data: Elevation
[[[574. 369. 544. 310. 517. 488. 565. 549. 450. 470.]
  [443. 551. 480. 476. 432. 561. 578. 361. 468. 480.]
  [520. 712. 396. 393. 584. 292. 424. 391. 494. 586.]
  [707. 534. 246. 423. 521. 500. 426. 340. 288. 482.]
  [542. 285. 607. 555. 645. 559. 461. 603. 330. 452.]
  [498. 497. 664. 445. 518. 564. 461. 508. 600. 380.]
  [454. 500. 276. 487. 447. 591. 413. 378. 458. 508.]
  [573. 890. 485. 501. 357. 413. 356. 635. 374. 618.]
  [535. 558. 491. 482. 539. 572. 598. 703. 463. 329.]
  [487. 555. 580. 492. 462. 484. 495. 396. 711. 356.]]

 [[574. 369. 544. 310. 517. 488. 565. 549. 450. 470.]
  [443. 551. 480. 476. 432. 561. 578. 361. 468. 480.]
  [520. 712. 396. 393. 584. 292. 424. 391. 494. 586.]
  [707. 534. 246. 423. 521. 500. 426. 340. 288. 482.]
  [542. 285. 607. 555. 645. 559. 461. 603. 330. 452.]
  [498. 497. 664. 445. 518. 564. 461. 508. 600. 380.]
  [454. 500. 276. 487. 447. 591. 413. 378. 458. 508.]
  [573. 890. 485. 501. 357. 413. 356. 635. 374. 618.]
  [535. 558. 491. 482. 539. 572. 598. 703. 463. 329.]
  [487. 555. 580. 492. 462. 484. 495. 396. 711. 356.]]] 

Subcube from Spatio-Temporal Data: Wind Speed
[[[31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
  [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
  [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
  [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
  [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
  [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
  [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
  [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
  [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
  [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]]

 [[30. 30. 30. 30. 30. 36. 36. 36. 36. 36.]
  [30. 30. 30. 30. 30. 36. 36. 36. 36. 36.]
  [30. 30. 30. 30. 30. 36. 36. 36. 36. 36.]
  [30. 30. 30. 30. 30. 36. 36. 36. 36. 36.]
  [30. 30. 30. 30. 30. 36. 36. 36. 36. 36.]
  [34. 34. 34. 34. 34. 37. 37. 37. 37. 37.]
  [34. 34. 34. 34. 34. 37. 37. 37. 37. 37.]
  [34. 34. 34. 34. 34. 37. 37. 37. 37. 37.]
  [34. 34. 34. 34. 34. 37. 37. 37. 37. 37.]
  [34. 34. 34. 34. 34. 37. 37. 37. 37. 37.]]]
#+end_example

*** How to Use LazySpaceTimeCube
    :PROPERTIES:
    :CUSTOM_ID: how-to-use-lazyspacetimecube
    :END:
**** Create a LazySpaceTimeCube from 0D, 1D, 2D, or 3D Input Data
     :PROPERTIES:
     :CUSTOM_ID: create-a-lazyspacetimecube-from-0d,-1d,-2d,-or-3d-input-data
     :END:

#+NAME: lazy-space-time-cube-create
#+begin_src python :results silent
import numpy as np
from pyretechnics.space_time_cube import SpaceTimeCube, LazySpaceTimeCube

#==============================================================
# Set a Random Seed
#==============================================================

np.random.seed(0)

#==============================================================
# Specify the SpaceTimeCube Dimensions
#==============================================================

cube_shape = (
    240,  # bands: 10 days @ 1 hour/band
    1000, # rows:  30 km @ 30 meters/row
    1000, # cols:  30 km @ 30 meters/col
)

#=====================================================================================================
# Constant Data: foliar moisture = 70% everywhere
#=====================================================================================================

foliar_moisture               = 0.7
foliar_moisture_subcube_shape = cube_shape # Only 1 subcube necessary

def foliar_moisture_load_subcube(_, subcube_shape):
    return SpaceTimeCube(subcube_shape, foliar_moisture)

constant_cube = LazySpaceTimeCube(cube_shape,
                                  foliar_moisture_subcube_shape,
                                  foliar_moisture_load_subcube)

#=====================================================================================================
# Temporal Data: 24-hour burn period with ramp up and ramp down for 10 days
#=====================================================================================================

spread_rate_adjustments               = ([0] * 6 + [0.33, 0.66] + [1] * 12 + [0.66, 0.33] + [0] * 2) * 10
spread_rate_adjustments_subcube_shape = (24, 1000, 1000) # 1 subcube per day (10 total)

def spread_rate_adjustments_load_subcube(cache_index, subcube_shape):
    (cache_t, _, _) = cache_index
    t_start = 24 * cache_t
    t_stop  = 24 * (cache_t + 1)
    return SpaceTimeCube(subcube_shape,
                         spread_rate_adjustments[t_start:t_stop])

time_series_cube = LazySpaceTimeCube(cube_shape,
                                     spread_rate_adjustments_subcube_shape,
                                     spread_rate_adjustments_load_subcube)

#=====================================================================================================
# Spatial Data: 2D elevation raster with 1000 (30m) x 1000 (30m) cells
#=====================================================================================================

elevation_raster               = np.random.normal(500, 100, 1000000).astype("int").reshape(1000,1000)
elevation_raster_subcube_shape = (240, 100, 100) # 1 subcube per 100x100 cell region (10x10 = 100 total)

def elevation_raster_load_subcube(cache_index, subcube_shape):
    (_, cache_y, cache_x) = cache_index
    y_start = 100 * cache_y
    y_stop  = 100 * (cache_y + 1)
    x_start = 100 * cache_x
    x_stop  = 100 * (cache_x + 1)
    return SpaceTimeCube(subcube_shape,
                         elevation_raster[y_start:y_stop,
                                          x_start:x_stop])

spatial_cube = LazySpaceTimeCube(cube_shape,
                                 elevation_raster_subcube_shape,
                                 elevation_raster_load_subcube)

#=====================================================================================================
# Spatio-Temporal Data: 3D daily max wind speed raster with 10 (days) x 100 (300m) x 100 (300m) cells
#=====================================================================================================

wind_speed_raster               = np.random.normal(30, 5, 100000).astype("int").reshape(10,100,100)
wind_speed_raster_subcube_shape = (24, 100, 100) # 1 subcube per day per 100x100 cell region (10x10x10 = 1000 total)

def wind_speed_raster_load_subcube(cache_index, subcube_shape):
    (cache_t, cache_y, cache_x) = cache_index
    t_start = cache_t
    t_stop  = cache_t + 1
    y_start = 10 * cache_y
    y_stop  = 10 * (cache_y + 1)
    x_start = 10 * cache_x
    x_stop  = 10 * (cache_x + 1)
    return SpaceTimeCube(subcube_shape,
                         wind_speed_raster[t_start:t_stop,
                                           y_start:y_stop,
                                           x_start:x_stop])

spatiotemporal_cube = LazySpaceTimeCube(cube_shape,
                                        wind_speed_raster_subcube_shape,
                                        wind_speed_raster_load_subcube)
#+end_src

**** Retrieve a Scalar Value at a Space-Time Coordinate
     :PROPERTIES:
     :CUSTOM_ID: retrieve-a-scalar-value-at-a-space-time-coordinate
     :END:

#+NAME: lazy-space-time-cube-get-point
#+begin_src python
# Space-Time Coordinate
band = 12
row  = 100
col  = 100

print("Value from Constant Data: Foliar Moisture")
print(constant_cube.get(band, row, col), "\n")

print("Value from Time Series Data: Spread Rate Adjustment")
print(time_series_cube.get(band, row, col), "\n")

print("Value from Spatial Data: Elevation")
print(spatial_cube.get(band, row, col), "\n")

print("Value from Spatio-Temporal Data: Wind Speed")
print(spatiotemporal_cube.get(band, row, col))
#+end_src

#+NAME: lazy-space-time-cube-get-point-results
#+RESULTS: lazy-space-time-cube-get-point
#+begin_example
Value from Constant Data: Foliar Moisture
0.699999988079071 

Value from Time Series Data: Spread Rate Adjustment
1.0 

Value from Spatial Data: Elevation
564.0 

Value from Spatio-Temporal Data: Wind Speed
32.0
#+end_example

**** Retrieve a Time Series at a Spatial Coordinate
     :PROPERTIES:
     :CUSTOM_ID: retrieve-a-time-series-at-a-spatial-coordinate
     :END:

#+NAME: lazy-space-time-cube-get-time-series
#+begin_src python
# Space-Time Coordinates
band_range = (18,30)
row        = 100
col        = 100

print("Time Series from Constant Data: Foliar Moisture")
print(constant_cube.getTimeSeries(band_range, row, col), "\n")

print("Time Series from Time Series Data: Spread Rate Adjustment")
print(time_series_cube.getTimeSeries(band_range, row, col), "\n")

print("Time Series from Spatial Data: Elevation")
print(spatial_cube.getTimeSeries(band_range, row, col), "\n")

print("Time Series from Spatio-Temporal Data: Wind Speed")
print(spatiotemporal_cube.getTimeSeries(band_range, row, col))
#+end_src

#+NAME: lazy-space-time-cube-get-time-series-results
#+RESULTS: lazy-space-time-cube-get-time-series
#+begin_example
Time Series from Constant Data: Foliar Moisture
[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7] 

Time Series from Time Series Data: Spread Rate Adjustment
[1.   1.   0.66 0.33 0.   0.   0.   0.   0.   0.   0.   0.  ] 

Time Series from Spatial Data: Elevation
[564. 564. 564. 564. 564. 564. 564. 564. 564. 564. 564. 564.] 

Time Series from Spatio-Temporal Data: Wind Speed
[32. 32. 32. 32. 32. 32. 37. 37. 37. 37. 37. 37.]
#+end_example

**** Retrieve a Spatial Plane at a Temporal Coordinate
     :PROPERTIES:
     :CUSTOM_ID: retrieve-a-spatial-plane-at-a-temporal-coordinate
     :END:

#+NAME: lazy-space-time-cube-get-spatial-plane
#+begin_src python
# Space-Time Coordinates
band      = 12
row_range = (95,105)
col_range = (95,105)

print("Spatial Plane from Constant Data: Foliar Moisture")
print(constant_cube.getSpatialPlane(band, row_range, col_range), "\n")

print("Spatial Plane from Time Series Data: Spread Rate Adjustment")
print(time_series_cube.getSpatialPlane(band, row_range, col_range), "\n")

print("Spatial Plane from Spatial Data: Elevation")
print(spatial_cube.getSpatialPlane(band, row_range, col_range), "\n")

print("Spatial Plane from Spatio-Temporal Data: Wind Speed")
print(spatiotemporal_cube.getSpatialPlane(band, row_range, col_range))
#+end_src

#+NAME: lazy-space-time-cube-get-spatial-plane-results
#+RESULTS: lazy-space-time-cube-get-spatial-plane
#+begin_example
Spatial Plane from Constant Data: Foliar Moisture
[[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]] 

Spatial Plane from Time Series Data: Spread Rate Adjustment
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]] 

Spatial Plane from Spatial Data: Elevation
[[574. 369. 544. 310. 517. 488. 565. 549. 450. 470.]
 [443. 551. 480. 476. 432. 561. 578. 361. 468. 480.]
 [520. 712. 396. 393. 584. 292. 424. 391. 494. 586.]
 [707. 534. 246. 423. 521. 500. 426. 340. 288. 482.]
 [542. 285. 607. 555. 645. 559. 461. 603. 330. 452.]
 [498. 497. 664. 445. 518. 564. 461. 508. 600. 380.]
 [454. 500. 276. 487. 447. 591. 413. 378. 458. 508.]
 [573. 890. 485. 501. 357. 413. 356. 635. 374. 618.]
 [535. 558. 491. 482. 539. 572. 598. 703. 463. 329.]
 [487. 555. 580. 492. 462. 484. 495. 396. 711. 356.]] 

Spatial Plane from Spatio-Temporal Data: Wind Speed
[[31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
 [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
 [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
 [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
 [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
 [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
 [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
 [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
 [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
 [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]]
#+end_example

**** Retrieve a Subcube within a Space-Time Region
     :PROPERTIES:
     :CUSTOM_ID: retrieve-a-subcube-within-a-space-time-region
     :END:

#+NAME: lazy-space-time-cube-get-subcube
#+begin_src python
# Space-Time Coordinates
band_range = (23,25)
row_range  = (95,105)
col_range  = (95,105)

print("Subcube from Constant Data: Foliar Moisture")
print(constant_cube.getSubcube(band_range, row_range, col_range), "\n")

print("Subcube from Time Series Data: Spread Rate Adjustment")
print(time_series_cube.getSubcube(band_range, row_range, col_range), "\n")

print("Subcube from Spatial Data: Elevation")
print(spatial_cube.getSubcube(band_range, row_range, col_range), "\n")

print("Subcube from Spatio-Temporal Data: Wind Speed")
print(spatiotemporal_cube.getSubcube(band_range, row_range, col_range))
#+end_src

#+NAME: lazy-space-time-cube-get-subcube-results
#+RESULTS: lazy-space-time-cube-get-subcube
#+begin_example
Subcube from Constant Data: Foliar Moisture
[[[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]]

 [[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]]] 

Subcube from Time Series Data: Spread Rate Adjustment
[[[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]]

 [[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]]] 

Subcube from Spatial Data: Elevation
[[[574. 369. 544. 310. 517. 488. 565. 549. 450. 470.]
  [443. 551. 480. 476. 432. 561. 578. 361. 468. 480.]
  [520. 712. 396. 393. 584. 292. 424. 391. 494. 586.]
  [707. 534. 246. 423. 521. 500. 426. 340. 288. 482.]
  [542. 285. 607. 555. 645. 559. 461. 603. 330. 452.]
  [498. 497. 664. 445. 518. 564. 461. 508. 600. 380.]
  [454. 500. 276. 487. 447. 591. 413. 378. 458. 508.]
  [573. 890. 485. 501. 357. 413. 356. 635. 374. 618.]
  [535. 558. 491. 482. 539. 572. 598. 703. 463. 329.]
  [487. 555. 580. 492. 462. 484. 495. 396. 711. 356.]]

 [[574. 369. 544. 310. 517. 488. 565. 549. 450. 470.]
  [443. 551. 480. 476. 432. 561. 578. 361. 468. 480.]
  [520. 712. 396. 393. 584. 292. 424. 391. 494. 586.]
  [707. 534. 246. 423. 521. 500. 426. 340. 288. 482.]
  [542. 285. 607. 555. 645. 559. 461. 603. 330. 452.]
  [498. 497. 664. 445. 518. 564. 461. 508. 600. 380.]
  [454. 500. 276. 487. 447. 591. 413. 378. 458. 508.]
  [573. 890. 485. 501. 357. 413. 356. 635. 374. 618.]
  [535. 558. 491. 482. 539. 572. 598. 703. 463. 329.]
  [487. 555. 580. 492. 462. 484. 495. 396. 711. 356.]]] 

Subcube from Spatio-Temporal Data: Wind Speed
[[[31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
  [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
  [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
  [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
  [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
  [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
  [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
  [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
  [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
  [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]]

 [[30. 30. 30. 30. 30. 36. 36. 36. 36. 36.]
  [30. 30. 30. 30. 30. 36. 36. 36. 36. 36.]
  [30. 30. 30. 30. 30. 36. 36. 36. 36. 36.]
  [30. 30. 30. 30. 30. 36. 36. 36. 36. 36.]
  [30. 30. 30. 30. 30. 36. 36. 36. 36. 36.]
  [34. 34. 34. 34. 34. 37. 37. 37. 37. 37.]
  [34. 34. 34. 34. 34. 37. 37. 37. 37. 37.]
  [34. 34. 34. 34. 34. 37. 37. 37. 37. 37.]
  [34. 34. 34. 34. 34. 37. 37. 37. 37. 37.]
  [34. 34. 34. 34. 34. 37. 37. 37. 37. 37.]]]
#+end_example

* [WIP] Fire Behavior Model :noexport:
  :PROPERTIES:
  :CUSTOM_ID: [wip]-fire-behavior-model
  :END:
# TODO: Refactor this text into the following sections and remove this section

Pyretechnics implements the following fire behavior formulas from the
fire science literature:

- Surface Fire Spread: Rothermel 1972 with FIREMODS adjustments from Albini 1976
- Crown Fire Initiation: Van Wagner 1977
- Passive/Active Crown Fire Spread: Cruz 2005
- Flame Length and Fireline Intensity: Byram 1959
- Midflame Wind Adjustment Factor: Albini & Baughman 1979 parameterized as in BehavePlus, FARSITE, FlamMap, FSPro, and FPA according to Andrews 2012
- Fire Spread on a Raster Grid: Morais 2001 (method of adaptive timesteps and fractional distances)
- Spot Fire: Perryman 2013

The following fuel models are supported:

- Anderson 13: no dynamic loading
- Scott & Burgan 40: dynamic loading implemented according to Scott & Burgan 2005

As a library, Pyretechnics has the flexibility to implement more than
one such algorithm for the purposes of comparison in both performance
and accuracy. The following sections will introduce the spread
algorithms implemented thus far.

* Fuel Model and Moisture Definitions (pyretechnics.fuel_models)
  :PROPERTIES:
  :CUSTOM_ID: fuel-model-and-moisture-definitions-(pyretechnics.fuel_models)
  :END:
** For Developers
   :PROPERTIES:
   :CUSTOM_ID: for-developers-fuel
   :header-args:python+: :session *pyretechnics.fuel_models*
   :header-args:python+: :tangle  ../src/pyretechnics/fuel_models.py
   :header-args:python+: :exports code
   :END:

The following sections encode various fire behavior fuel models as
Python dictionaries and then provide functions to augment their static
properties with additional information that is dependent upon fuel
moisture. This combination of fuel models and moisture form the basis
of many fire behavior analyses.

*** Module Imports
    :PROPERTIES:
    :CUSTOM_ID: module-imports-fuel-models
    :END:

#+NAME: fuel-models-imports
#+begin_src python
import cython
import cython as cy
if cython.compiled:
    from cython.cimports.libc.math import exp
    from cython.cimports.pyretechnics.cy_types import fcatarr, fclaarr, CompactFuelModel, FuelModel
else:
    from math import exp
    from pyretechnics.py_types import fcatarr, fclaarr, CompactFuelModel, FuelModel
#+end_src

*** Fuel Model Properties
    :PROPERTIES:
    :CUSTOM_ID: fuel-model-properties
    :END:

All fires ignite and travel through some form of burnable fuel.
Although the effects of wind and slope on the rate of fire spread can
be quite pronounced, its fundamental thermodynamic characteristics are
largely determined by the fuel type in which it is sustained. For
wildfires, these fuels are predominantly herbaceous and woody
vegetation (both alive and dead) as well as decomposing elements of
dead vegetation, such as duff or leaf litter. To estimate the heat
output and rate of spread of a fire burning through any of these
fuels, we must determine those physical properties that affect heat
absorption and release.

Of course, measuring these fuel properties for every kind of
vegetation that may be burned in a wildfire is an intractable task. To
cope with this, fuels are classified into categories called "fuel
models" which share similar burning characteristics. Each fuel model
is then assigned a set of representative values for each of the
thermally relevant physical properties shown in Table
[[tab:fuel-model-properties]].

#+NAME: tab:fuel-model-properties
#+caption: Physical properties assigned to each fuel model
|----------+--------------------------------------------+-----------------------------------------------------------|
| Property | Description                                | Units                                                     |
|----------+--------------------------------------------+-----------------------------------------------------------|
| $\delta$ | fuel depth                                 | $\text{ft}$                                               |
| $w_o$    | ovendry fuel loading                       | $\text{lb}/\text{ft}^2$                                   |
| $\rho_p$ | ovendry particle density                   | $\text{lb}/\text{ft}^3$                                   |
| $\sigma$ | fuel particle surface-area-to-volume ratio | $\text{ft}^2/\text{ft}^3$                                 |
| $h$      | fuel particle low heat content             | $\text{Btu}/\text{lb}$                                    |
| $S_T$    | fuel particle total mineral content        | $\text{lb minerals}/\text{lb ovendry weight}$             |
| $S_e$    | fuel particle effective mineral content    | $\text{lb silica-free minerals}/\text{lb ovendry weight}$ |
| $M_x$    | fuel particle moisture of extinction       | $\text{lb moisture}/\text{lb ovendry weight}$             |
| $M_f$    | fuel particle moisture content             | $\text{lb moisture}/\text{lb ovendry weight}$             |
|----------+--------------------------------------------+-----------------------------------------------------------|

While $M_f$ is not, in fact, directly assigned to any of these fuel
models, their definitions remain incomplete for the purposes of fire
spread modelling (particularly those reliant on the curing formulas of
dynamic fuel loading) until it is provided as a characteristic of
local weather conditions.

Although most fuel model properties are static with respect to
environmental conditions, the fuel moisture content can have two
significant impacts on a fuel model's burning potential:

- Dynamic fuel loading
- Live moisture of extinction

These two topics are discussed in sections [[Dynamic Fuel Loading]] and
[[Live Moisture of Extinction]].

*** Fuel Model Definitions
    :PROPERTIES:
    :CUSTOM_ID: fuel-model-definitions
    :END:

The fuel models supported by Pyretechnics include the standard 13 fuel
models of Rothermel, Albini, and Anderson[fn::Anderson1982] and the
additional 40 fuel models defined by Scott and Burgan[fn::Scott2005].
These are all concisely encoded in an internal data structure, which
may be updated to include additional custom fuel models desired by the
user.

#+NAME: fuel-model-compact-table
#+begin_src python
# FIXME: Replace this dictionary with something more efficient
# Lookup table including entries for each of the Anderson 13 and Scott & Burgan 40 fuel models.
#
# The fields have the following meanings:
#   {
#     fuel_model_number: (delta,
#                         M_x_dead,
#                         h,
#                         w_o_dead_1hr,
#                         w_o_dead_10hr,
#                         w_o_dead_100hr,
#                         w_o_live_herbaceous,
#                         w_o_live_woody,
#                         sigma_dead_1hr,
#                         sigma_dead_10hr,
#                         sigma_dead_100hr,
#                         sigma_live_herbaceous,
#                         sigma_live_woody), # name
#   }
compact_fuel_model_table = cy.declare(dict[int, CompactFuelModel], {
    # Anderson 13:
    # Grass and Grass-dominated (short-grass,timber-grass-and-understory,tall-grass)
    1  : (1.0, 12.0, 8.0, 0.0340, 0.0000, 0.0000, 0.0000, 0.0000, 3500.0,   0.0,  0.0,    0.0,    0.0), # R01
    2  : (1.0, 15.0, 8.0, 0.0920, 0.0460, 0.0230, 0.0230, 0.0000, 3000.0, 109.0, 30.0, 1500.0,    0.0), # R02
    3  : (2.5, 25.0, 8.0, 0.1380, 0.0000, 0.0000, 0.0000, 0.0000, 1500.0,   0.0,  0.0,    0.0,    0.0), # R03
    # Chaparral and Shrubfields (chaparral,brush,dormant-brush-hardwood-slash,southern-rough)
    4  : (6.0, 20.0, 8.0, 0.2300, 0.1840, 0.0920, 0.2300, 0.0000, 2000.0, 109.0, 30.0, 1500.0,    0.0), # R04
    5  : (2.0, 20.0, 8.0, 0.0460, 0.0230, 0.0000, 0.0920, 0.0000, 2000.0, 109.0,  0.0, 1500.0,    0.0), # R05
    6  : (2.5, 25.0, 8.0, 0.0690, 0.1150, 0.0920, 0.0000, 0.0000, 1750.0, 109.0, 30.0,    0.0,    0.0), # R06
    7  : (2.5, 40.0, 8.0, 0.0520, 0.0860, 0.0690, 0.0170, 0.0000, 1750.0, 109.0, 30.0, 1550.0,    0.0), # R07
    # Timber Litter (closed-timber-litter,hardwood-litter,timber-litter-and-understory)
    8  : (0.2, 30.0, 8.0, 0.0690, 0.0460, 0.1150, 0.0000, 0.0000, 2000.0, 109.0, 30.0,    0.0,    0.0), # R08
    9  : (0.2, 25.0, 8.0, 0.1340, 0.0190, 0.0070, 0.0000, 0.0000, 2500.0, 109.0, 30.0,    0.0,    0.0), # R09
    10 : (1.0, 25.0, 8.0, 0.1380, 0.0920, 0.2300, 0.0920, 0.0000, 2000.0, 109.0, 30.0, 1500.0,    0.0), # R10
    # Logging Slash (light-logging-slash,medium-logging-slash,heavy-logging-slash)
    11 : (1.0, 15.0, 8.0, 0.0690, 0.2070, 0.2530, 0.0000, 0.0000, 1500.0, 109.0, 30.0,    0.0,    0.0), # R11
    12 : (2.3, 20.0, 8.0, 0.1840, 0.6440, 0.7590, 0.0000, 0.0000, 1500.0, 109.0, 30.0,    0.0,    0.0), # R12
    13 : (3.0, 25.0, 8.0, 0.3220, 1.0580, 1.2880, 0.0000, 0.0000, 1500.0, 109.0, 30.0,    0.0,    0.0), # R13
    # Nonburnable (NB)
    91 : (0.0,  0.0, 0.0, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,    0.0,   0.0,  0.0,    0.0,    0.0), # NB1
    92 : (0.0,  0.0, 0.0, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,    0.0,   0.0,  0.0,    0.0,    0.0), # NB2
    93 : (0.0,  0.0, 0.0, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,    0.0,   0.0,  0.0,    0.0,    0.0), # NB3
    98 : (0.0,  0.0, 0.0, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,    0.0,   0.0,  0.0,    0.0,    0.0), # NB4
    99 : (0.0,  0.0, 0.0, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,    0.0,   0.0,  0.0,    0.0,    0.0), # NB5
    # Scott & Burgan 40:
    # Grass (GR)
    101: (0.4, 15.0, 8.0, 0.0046, 0.0000, 0.0000, 0.0138, 0.0000, 2200.0, 109.0, 30.0, 2000.0,    0.0), # GR1
    102: (1.0, 15.0, 8.0, 0.0046, 0.0000, 0.0000, 0.0459, 0.0000, 2000.0, 109.0, 30.0, 1800.0,    0.0), # GR2
    103: (2.0, 30.0, 8.0, 0.0046, 0.0184, 0.0000, 0.0689, 0.0000, 1500.0, 109.0, 30.0, 1300.0,    0.0), # GR3
    104: (2.0, 15.0, 8.0, 0.0115, 0.0000, 0.0000, 0.0872, 0.0000, 2000.0, 109.0, 30.0, 1800.0,    0.0), # GR4
    105: (1.5, 40.0, 8.0, 0.0184, 0.0000, 0.0000, 0.1148, 0.0000, 1800.0, 109.0, 30.0, 1600.0,    0.0), # GR5
    106: (1.5, 40.0, 9.0, 0.0046, 0.0000, 0.0000, 0.1561, 0.0000, 2200.0, 109.0, 30.0, 2000.0,    0.0), # GR6
    107: (3.0, 15.0, 8.0, 0.0459, 0.0000, 0.0000, 0.2479, 0.0000, 2000.0, 109.0, 30.0, 1800.0,    0.0), # GR7
    108: (4.0, 30.0, 8.0, 0.0230, 0.0459, 0.0000, 0.3352, 0.0000, 1500.0, 109.0, 30.0, 1300.0,    0.0), # GR8
    109: (5.0, 40.0, 8.0, 0.0459, 0.0459, 0.0000, 0.4132, 0.0000, 1800.0, 109.0, 30.0, 1600.0,    0.0), # GR9
    # Grass-Shrub (GS)
    121: (0.9, 15.0, 8.0, 0.0092, 0.0000, 0.0000, 0.0230, 0.0298, 2000.0, 109.0, 30.0, 1800.0, 1800.0), # GS1
    122: (1.5, 15.0, 8.0, 0.0230, 0.0230, 0.0000, 0.0275, 0.0459, 2000.0, 109.0, 30.0, 1800.0, 1800.0), # GS2
    123: (1.8, 40.0, 8.0, 0.0138, 0.0115, 0.0000, 0.0666, 0.0574, 1800.0, 109.0, 30.0, 1600.0, 1600.0), # GS3
    124: (2.1, 40.0, 8.0, 0.0872, 0.0138, 0.0046, 0.1561, 0.3260, 1800.0, 109.0, 30.0, 1600.0, 1600.0), # GS4
    # Shrub (SH)
    141: (1.0, 15.0, 8.0, 0.0115, 0.0115, 0.0000, 0.0069, 0.0597, 2000.0, 109.0, 30.0, 1800.0, 1600.0), # SH1
    142: (1.0, 15.0, 8.0, 0.0620, 0.1102, 0.0344, 0.0000, 0.1768, 2000.0, 109.0, 30.0,    0.0, 1600.0), # SH2
    143: (2.4, 40.0, 8.0, 0.0207, 0.1377, 0.0000, 0.0000, 0.2847, 1600.0, 109.0, 30.0,    0.0, 1400.0), # SH3
    144: (3.0, 30.0, 8.0, 0.0390, 0.0528, 0.0092, 0.0000, 0.1171, 2000.0, 109.0, 30.0, 1800.0, 1600.0), # SH4
    145: (6.0, 15.0, 8.0, 0.1653, 0.0964, 0.0000, 0.0000, 0.1331,  750.0, 109.0, 30.0,    0.0, 1600.0), # SH5
    146: (2.0, 30.0, 8.0, 0.1331, 0.0666, 0.0000, 0.0000, 0.0643,  750.0, 109.0, 30.0,    0.0, 1600.0), # SH6
    147: (6.0, 15.0, 8.0, 0.1607, 0.2433, 0.1010, 0.0000, 0.1561,  750.0, 109.0, 30.0,    0.0, 1600.0), # SH7
    148: (3.0, 40.0, 8.0, 0.0941, 0.1561, 0.0390, 0.0000, 0.1997,  750.0, 109.0, 30.0,    0.0, 1600.0), # SH8
    149: (4.4, 40.0, 8.0, 0.2066, 0.1125, 0.0000, 0.0712, 0.3214,  750.0, 109.0, 30.0, 1800.0, 1500.0), # SH9
    # Timber-Understory (TU)
    161: (0.6, 20.0, 8.0, 0.0092, 0.0413, 0.0689, 0.0092, 0.0413, 2000.0, 109.0, 30.0, 1800.0, 1600.0), # TU1
    162: (1.0, 30.0, 8.0, 0.0436, 0.0826, 0.0574, 0.0000, 0.0092, 2000.0, 109.0, 30.0,    0.0, 1600.0), # TU2
    163: (1.3, 30.0, 8.0, 0.0505, 0.0069, 0.0115, 0.0298, 0.0505, 1800.0, 109.0, 30.0, 1600.0, 1400.0), # TU3
    164: (0.5, 12.0, 8.0, 0.2066, 0.0000, 0.0000, 0.0000, 0.0918, 2300.0, 109.0, 30.0,    0.0, 2000.0), # TU4
    165: (1.0, 25.0, 8.0, 0.1837, 0.1837, 0.1377, 0.0000, 0.1377, 1500.0, 109.0, 30.0,    0.0,  750.0), # TU5
    # Timber Litter (TL)
    181: (0.2, 30.0, 8.0, 0.0459, 0.1010, 0.1653, 0.0000, 0.0000, 2000.0, 109.0, 30.0,    0.0,    0.0), # TL1
    182: (0.2, 25.0, 8.0, 0.0643, 0.1056, 0.1010, 0.0000, 0.0000, 2000.0, 109.0, 30.0,    0.0,    0.0), # TL2
    183: (0.3, 20.0, 8.0, 0.0230, 0.1010, 0.1286, 0.0000, 0.0000, 2000.0, 109.0, 30.0,    0.0,    0.0), # TL3
    184: (0.4, 25.0, 8.0, 0.0230, 0.0689, 0.1928, 0.0000, 0.0000, 2000.0, 109.0, 30.0,    0.0,    0.0), # TL4
    185: (0.6, 25.0, 8.0, 0.0528, 0.1148, 0.2020, 0.0000, 0.0000, 2000.0, 109.0, 30.0,    0.0, 1600.0), # TL5
    186: (0.3, 25.0, 8.0, 0.1102, 0.0551, 0.0551, 0.0000, 0.0000, 2000.0, 109.0, 30.0,    0.0,    0.0), # TL6
    187: (0.4, 25.0, 8.0, 0.0138, 0.0643, 0.3719, 0.0000, 0.0000, 2000.0, 109.0, 30.0,    0.0,    0.0), # TL7
    188: (0.3, 35.0, 8.0, 0.2663, 0.0643, 0.0505, 0.0000, 0.0000, 1800.0, 109.0, 30.0,    0.0,    0.0), # TL8
    189: (0.6, 35.0, 8.0, 0.3053, 0.1515, 0.1905, 0.0000, 0.0000, 1800.0, 109.0, 30.0,    0.0, 1600.0), # TL9
    # Slash-Blowdown (SB)
    201: (1.0, 25.0, 8.0, 0.0689, 0.1377, 0.5051, 0.0000, 0.0000, 2000.0, 109.0, 30.0,    0.0,    0.0), # SB1
    202: (1.0, 25.0, 8.0, 0.2066, 0.1951, 0.1837, 0.0000, 0.0000, 2000.0, 109.0, 30.0,    0.0,    0.0), # SB2
    203: (1.2, 25.0, 8.0, 0.2525, 0.1263, 0.1377, 0.0000, 0.0000, 2000.0, 109.0, 30.0,    0.0,    0.0), # SB3
    204: (2.7, 25.0, 8.0, 0.2410, 0.1607, 0.2410, 0.0000, 0.0000, 2000.0, 109.0, 30.0,    0.0,    0.0), # SB4
})
#+end_src

Although this compact data structure contains all the properties that
vary by fuel model (i.e., $\delta$, $w_o$, $\sigma$,
$M_{x-\text{dead}}$, $h$), several of their values need to be
multiplied by a coefficient to make their units match those listed in
Table [[tab:fuel-model-properties]]. We also need to add in the missing
$\rho_p$, $S_T$, and $S_e$ values, which are constant across all of
these fuel models, and to expand those properties whose values may
vary by size class into lists with the following encoding:

#+NAME: fuel-model-categories-and-size-classes
#+begin_example
[dead_1hr dead_10hr dead_100hr dead_herbaceous live_herbaceous live_woody]
#+end_example

As a performance optimization, we set the dead herbaceous values that
don't depend on fuel moisture for the dynamic Scott & Burgan 40 fuel
models. Finally, we add two boolean properties (=dynamic= and
=burnable=) to each fuel model for reference in later calculations.

#+NAME: expand-compact-fuel-model-table
#+begin_src python
@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def is_burnable_fuel_model_number(fuel_model_number: cy.int) -> cy.bint:
    return not (91 <= fuel_model_number <= 99)


@cy.cfunc
@cy.exceptval(check=False)
def compute_exp_A_sigma(A: cy.float, sigma_ij: cy.float) -> cy.float:
    if sigma_ij > 0.0:
        return exp(A / sigma_ij)
    else:
        return 0.0


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def compute_firemod_size_class(sigma_i: cy.float) -> cy.float:
    return (
        1.0 if (sigma_i >= 1200.0)
        else 2.0 if (sigma_i >= 192.0)
        else 3.0 if (sigma_i >= 96.0)
        else 4.0 if (sigma_i >= 48.0)
        else 5.0 if (sigma_i >= 16.0)
        else 6.0
    )


@cy.cfunc
@cy.exceptval(check=False)
def expand_compact_fuel_model(fuel_model_number: cy.int) -> FuelModel:
    # Look up the CompactFuelModel by fuel_model_number
    cfm: CompactFuelModel = compact_fuel_model_table[fuel_model_number]
    # Unpack the CompactFuelModel values
    delta                : cy.float = cfm[0]
    M_x_dead             : cy.float = cfm[1]
    h                    : cy.float = cfm[2]
    w_o_dead_1hr         : cy.float = cfm[3]
    w_o_dead_10hr        : cy.float = cfm[4]
    w_o_dead_100hr       : cy.float = cfm[5]
    w_o_live_herbaceous  : cy.float = cfm[6]
    w_o_live_woody       : cy.float = cfm[7]
    sigma_dead_1hr       : cy.float = cfm[8]
    sigma_dead_10hr      : cy.float = cfm[9]
    sigma_dead_100hr     : cy.float = cfm[10]
    sigma_live_herbaceous: cy.float = cfm[11]
    sigma_live_woody     : cy.float = cfm[12]
    # Expand compressed values
    M_x_dead: cy.float = M_x_dead * 0.01
    h       : cy.float = h * 1000.0
    # Pre-compute some dynamic fuel model values
    dynamic              : cy.bint  = fuel_model_number > 100 and w_o_live_herbaceous > 0.0
    M_x_dead_herbaceous  : cy.float = M_x_dead              if dynamic else 0.0
    sigma_dead_herbaceous: cy.float = sigma_live_herbaceous if dynamic else 0.0
    # Re-pack everything into a FuelModel struct
    return FuelModel(
        number               = fuel_model_number,
        delta                = delta,
        M_x                  = (M_x_dead,
                                M_x_dead,
                                M_x_dead,
                                M_x_dead_herbaceous,
                                0.0,
                                0.0),
        M_f                  = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0),
        w_o                  = (w_o_dead_1hr,
                                w_o_dead_10hr,
                                w_o_dead_100hr,
                                0.0,
                                w_o_live_herbaceous,
                                w_o_live_woody),
        sigma                = (sigma_dead_1hr,
                                sigma_dead_10hr,
                                sigma_dead_100hr,
                                sigma_dead_herbaceous,
                                sigma_live_herbaceous,
                                sigma_live_woody),
        h                    = (h, h, h, h, h, h),
        rho_p                = (32.0, 32.0, 32.0, 32.0, 32.0, 32.0),
        S_T                  = (0.0555, 0.0555, 0.0555, 0.0555, 0.0555, 0.0555),
        S_e                  = (0.01, 0.01, 0.01, 0.01, 0.01, 0.01),
        dynamic              = dynamic,
        burnable             = is_burnable_fuel_model_number(fuel_model_number),
        exp_A_sigma          = (compute_exp_A_sigma(-138.0, sigma_dead_1hr),
                                compute_exp_A_sigma(-138.0, sigma_dead_10hr),
                                compute_exp_A_sigma(-138.0, sigma_dead_100hr),
                                compute_exp_A_sigma(-138.0, sigma_dead_herbaceous),
                                compute_exp_A_sigma(-500.0, sigma_live_herbaceous),
                                compute_exp_A_sigma(-500.0, sigma_live_woody)),
        firemod_size_classes = (compute_firemod_size_class(sigma_dead_1hr),
                                compute_firemod_size_class(sigma_dead_10hr),
                                compute_firemod_size_class(sigma_dead_100hr),
                                compute_firemod_size_class(sigma_dead_herbaceous),
                                compute_firemod_size_class(sigma_live_herbaceous),
                                compute_firemod_size_class(sigma_live_woody)),
        f_ij                 = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0),
        f_i                  = (0.0, 0.0),
        g_ij                 = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0),
    )


# FIXME: Replace this dictionary with something more efficient
fuel_model_table = cy.declare(dict[int, FuelModel], {
    k: expand_compact_fuel_model(k) for k in compact_fuel_model_table.keys()
})


@cy.ccall
@cy.inline
@cy.exceptval(check=False)
def fuel_model_exists(fuel_model_number: cy.int) -> cy.bint:
    return fuel_model_number in fuel_model_table


@cy.ccall
@cy.inline
@cy.exceptval(check=False)
def get_fuel_model(fuel_model_number: cy.int) -> FuelModel:
    return cy.cast(FuelModel, fuel_model_table[fuel_model_number])
#+end_src

*** Fuel Categories and Size Classes
    :PROPERTIES:
    :CUSTOM_ID: fuel-categories-and-size-classes
    :END:

Each fuel model applies to a collection of burnable material that may
be live or dead and whose constituent elements may vary in size
considerably.

The two terms *category* and *size class* are used to describe this
heterogeneity within each fuel model.

In Pyretechnics, when we refer to a fuel category, we mean one of
these two values:

- Dead
- Live

When we refer to a fuel size class, we mean one of these six values:

- Dead 1 hour (< 1/4" diameter)
- Dead 10 hour (1/4"-1" diameter)
- Dead 100 hour (1"-3" diameter)
- Dead herbaceous (dynamic fuel models only)
- Live herbaceous
- Live woody

*** Dynamic Fuel Loading
    :PROPERTIES:
    :CUSTOM_ID: dynamic-fuel-loading
    :END:

All of the Scott & Burgan 40 fuel models with a live herbaceous
component are considered dynamic. In these models, a fraction of the
live herbaceous load is transferred to a new dead herbaceous category
as a function of live herbaceous moisture content (see equation
below).[fn::Burgan1979] The dead herbaceous size class uses the dead 1
hour moisture content, dead moisture of extinction, and live
herbaceous surface-area-to-volume-ratio. In the following formula,
$M_f^{lh}$ is the live herbaceous moisture content.

\begin{align}
  \text{FractionGreen} &= \left\{
    \begin{array}{lr}
      0 & M_f^{lh} \le 0.3 \\
      1 & M_f^{lh} \ge 1.2 \\
      M_f^{lh} / 0.9 - 1/3 & \text{else}
    \end{array}
  \right. \\
  \nonumber \\
  \text{FractionCured} &= 1 - \text{FractionGreen}
\end{align}

#+NAME: add-dynamic-fuel-loading
#+begin_src python
@cy.cfunc
@cy.exceptval(check=False)
def add_dynamic_fuel_loading(fuel_model: FuelModel, M_f: fclaarr) -> FuelModel:
    """
    Updates M_f and w_o.
    """
    if fuel_model.dynamic:
        # dynamic fuel model
        w_o                     : fclaarr   = fuel_model.w_o
        live_herbaceous_load    : cy.float  = w_o[4]
        live_herbaceous_moisture: cy.float  = M_f[4]
        fraction_green          : cy.float  = max(0.0, min(1.0, (live_herbaceous_moisture / 0.9) - 0.3333333333333333))
        fraction_cured          : cy.float  = 1.0 - fraction_green
        dynamic_fuel_model      : FuelModel = fuel_model  # FIXME: Restore Python compatibility
        M_f_copy                : fclaarr   = M_f         # FIXME: Restore Python compatibility
        M_f_copy[3]                         = M_f_copy[0] # set dead_herbaceous to dead_1hr
        dynamic_fuel_model.M_f              = M_f_copy
        w_o_copy                : fclaarr   = w_o
        w_o_copy[3]                         = live_herbaceous_load * fraction_cured # dead_herbaceous
        w_o_copy[4]                         = live_herbaceous_load * fraction_green # live_herbaceous
        dynamic_fuel_model.w_o              = w_o_copy
        return dynamic_fuel_model
    else:
        # static fuel model
        static_fuel_model: FuelModel = fuel_model # FIXME: Restore Python compatibility
        static_fuel_model.M_f        = M_f
        return static_fuel_model
#+end_src

*** Size Class Weighting Factors
    :PROPERTIES:
    :CUSTOM_ID: size-class-weighting-factors
    :END:

Once the dynamic fuel loading is applied, we can compute the size
class weighting factors expressed in equations 53-57 in Rothermel
1972[fn::Rothermel1972]. For brevity, these formulas are elided from
this text.

#+NAME: add-weighting-factors
#+begin_src python
# TODO: OPTIM pre-compute this conditional branching since it's fully determined by sigma.
#       This information might be represented efficiently in bit flags.
@cy.cfunc
@cy.exceptval(check=False)
def compute_gij(firemod_size_classes : fclaarr,
                f_ij                 : fclaarr,
                firemod_size_class_ij: cy.float,
                is_dead              : cy.bint) -> cy.float:
    """
    Sums the f_ij of the same category (dead/live) as i, and having the same firemod_size_class.

    NOTE: There may be repetitions in firemod_size_classes, which is why this expression is not
          trivially equal to f_ij[i].
    """
    if is_dead:
        f_ij_0: cy.float = (f_ij[0] if (firemod_size_class_ij == firemod_size_classes[0]) else 0.0)
        f_ij_1: cy.float = (f_ij[1] if (firemod_size_class_ij == firemod_size_classes[1]) else 0.0)
        f_ij_2: cy.float = (f_ij[2] if (firemod_size_class_ij == firemod_size_classes[2]) else 0.0)
        f_ij_3: cy.float = (f_ij[3] if (firemod_size_class_ij == firemod_size_classes[3]) else 0.0)
        return f_ij_0 + f_ij_1 + f_ij_2 + f_ij_3
    else:
        f_ij_4: cy.float = (f_ij[4] if (firemod_size_class_ij == firemod_size_classes[4]) else 0.0)
        f_ij_5: cy.float = (f_ij[5] if (firemod_size_class_ij == firemod_size_classes[5]) else 0.0)
        return f_ij_4 + f_ij_5


@cy.cfunc
@cy.exceptval(check=False)
def add_weighting_factors(fuel_model: FuelModel) -> FuelModel:
    """
    Assigns f_ij, f_i, and g_ij.
    """
    w_o  : fclaarr  = fuel_model.w_o
    sigma: fclaarr  = fuel_model.sigma
    rho_p: fclaarr  = fuel_model.rho_p
    A_ij : fclaarr  = ((sigma[0] * w_o[0]) / rho_p[0],
                       (sigma[1] * w_o[1]) / rho_p[1],
                       (sigma[2] * w_o[2]) / rho_p[2],
                       (sigma[3] * w_o[3]) / rho_p[3],
                       (sigma[4] * w_o[4]) / rho_p[4],
                       (sigma[5] * w_o[5]) / rho_p[5]) # TODO: OPTIM pre-compute sigma/rho_p
    A_0  : cy.float = A_ij[0] + A_ij[1] + A_ij[2] + A_ij[3]
    A_1  : cy.float = A_ij[4] + A_ij[5]
    A_i  : fcatarr  = (A_0, A_1)
    A_T  : cy.float = A_0 + A_1
    f_ij : fclaarr  = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    f_i  : fcatarr  = (0.0, 0.0)
    if A_0 > 0.0:
        A_0_inv: cy.float = 1.0 / A_0
        f_ij[0] = A_ij[0] * A_0_inv
        f_ij[1] = A_ij[1] * A_0_inv
        f_ij[2] = A_ij[2] * A_0_inv
        f_ij[3] = A_ij[3] * A_0_inv
    if A_1 > 0.0:
        A_1_inv: cy.float = 1.0 / A_1
        f_ij[4] = A_ij[4] * A_1_inv
        f_ij[5] = A_ij[5] * A_1_inv
    if A_T > 0.0:
        A_T_inv: cy.float = 1.0 / A_T
        f_i[0] = A_0 * A_T_inv
        f_i[1] = A_1 * A_T_inv
    firemod_size_classes: fclaarr   = fuel_model.firemod_size_classes
    g_ij                : fclaarr   = (compute_gij(firemod_size_classes, f_ij, firemod_size_classes[0], True),
                                       compute_gij(firemod_size_classes, f_ij, firemod_size_classes[1], True),
                                       compute_gij(firemod_size_classes, f_ij, firemod_size_classes[2], True),
                                       compute_gij(firemod_size_classes, f_ij, firemod_size_classes[3], True),
                                       compute_gij(firemod_size_classes, f_ij, firemod_size_classes[4], False),
                                       compute_gij(firemod_size_classes, f_ij, firemod_size_classes[5], False))
    weighted_fuel_model : FuelModel = fuel_model # FIXME: Restore Python compatibility
    weighted_fuel_model.f_ij = f_ij
    weighted_fuel_model.f_i  = f_i
    weighted_fuel_model.g_ij = g_ij
    return weighted_fuel_model
#+end_src

*** Live Moisture of Extinction
    :PROPERTIES:
    :CUSTOM_ID: live-moisture-of-extinction
    :END:

The live moisture of extinction for each fuel model is determined from
the dead fuel moisture content, the dead moisture of extinction, and
the ratio of dead fuel loading to live fuel loading using Equation 88
from Rothermel 1972, adjusted according to Albini 1976 Appendix III to
match the behavior of Albini's original FIREMODS
library.[fn::Rothermel1972][fn::Albini1976] Whenever the fuel moisture
content becomes greater than or equal to the moisture of extinction, a
fire will no longer spread through that fuel. Here are the formulas
referenced above:

\begin{align}
  M_x^l &= \max(M_x^d, 2.9 \, W' \, (1 - M_f^d / M_x^d) - 0.226) \\
  \nonumber \\
  W' &= \frac{\sum_{c \in D}{w_o^c \> e^{-138/\sigma^c}}}{\sum_{c \in L}{w_o^c \> e^{-500/\sigma^c}}} \\
  \nonumber \\
  M_f^d &= \frac{\sum_{c \in D}{w_o^c \> M_f^c \> e^{-138/\sigma^c}}}{\sum_{c \in D}{w_o^c \> e^{-138/\sigma^c}}}
\end{align}

where $M_{x}^{l}$ is the live moisture of extinction, $M_{x}^{d}$ is
the dead moisture of extinction, $D$ is the set of dead fuel size
classes (1hr, 10hr, 100hr, herbaceous), $L$ is the set of live fuel
size classes (herbaceous, woody), $w_{o}^{c}$ is the dry weight
loading of size class $c$, $\sigma^{c}$ is the surface area to volume
ratio of size class $c$, and $M_{f}^{c}$ is the moisture content of
size class $c$.

#+NAME: add-live-moisture-of-extinction
#+begin_src python
@cy.cfunc
@cy.exceptval(check=False)
def add_live_moisture_of_extinction(fuel_model: FuelModel) -> FuelModel:
    """
    Equation 88 from Rothermel 1972 adjusted by Albini 1976 Appendix III.

    Updates M_x.
    """
    w_o                 : fclaarr  = fuel_model.w_o
    sigma               : fclaarr  = fuel_model.sigma
    M_f                 : fclaarr  = fuel_model.M_f
    M_x                 : fclaarr  = fuel_model.M_x
    exp_A_sigma         : fclaarr  = fuel_model.exp_A_sigma
    loading_factors     : fclaarr  = (w_o[0] * exp_A_sigma[0],
                                      w_o[1] * exp_A_sigma[1],
                                      w_o[2] * exp_A_sigma[2],
                                      w_o[3] * exp_A_sigma[3],
                                      w_o[4] * exp_A_sigma[4],
                                      w_o[5] * exp_A_sigma[5])
    dead_loading_factor : cy.float = loading_factors[0] + loading_factors[1] + loading_factors[2] + loading_factors[3]
    live_loading_factor : cy.float = loading_factors[4] + loading_factors[5]
    dead_moisture_factor: cy.float = (M_f[0] * loading_factors[0] +
                                      M_f[1] * loading_factors[1] +
                                      M_f[2] * loading_factors[2] +
                                      M_f[3] * loading_factors[3])
    dead_fuel_moisture  : cy.float = ((dead_moisture_factor / dead_loading_factor)
                                      if (dead_loading_factor > 0.0) else 0.0)
    M_x_dead            : cy.float = M_x[0]
    M_x_live            : cy.float
    if (live_loading_factor > 0.0):
        dead_to_live_ratio: cy.float = dead_loading_factor / live_loading_factor
        M_x_live = max(M_x_dead, (2.9 * dead_to_live_ratio * (1.0 - (dead_fuel_moisture / M_x_dead))) - 0.226)
    else:
        M_x_live = M_x_dead
    moisturized_fuel_model: FuelModel = fuel_model # FIXME: Restore Python compatibility
    M_x_new               : fclaarr   = (M_x[0],
                                         M_x[1],
                                         M_x[2],
                                         M_x[3],
                                         M_x_live,
                                         M_x_live)
    moisturized_fuel_model.M_x = M_x_new
    return moisturized_fuel_model
#+end_src

*** Applying Fuel Moisture to a Fuel Model
    :PROPERTIES:
    :CUSTOM_ID: applying-fuel-moisture-to-a-fuel-model
    :END:

The preceding sections augmented the baseline fuel models by adding
dynamic fuel loading (section [[Dynamic Fuel Loading]]), size class
weighting factors (section [[Size Class Weighting Factors]]), and live
moisture of extinction (section [[Live Moisture of Extinction]]). In
typical usage, we will want to carry out all three of these steps when
applying fuel moisture to a fuel model. To simplify this task,
Pyretechnics provides the =moisturize= utility function.

#+NAME: moisturize
#+begin_src python
# TODO: If these functions aren't called anywhere else, create a copy
#       of the fuel model here and mutate it in the called functions.
@cy.ccall
@cy.exceptval(check=False)
def moisturize(fuel_model: FuelModel, fuel_moisture: fclaarr) -> FuelModel:
    """
    Updates w_o, M_f, and M_x and assigns f_ij, f_i, and g_ij.
    """
    dynamic_fuel_model    : FuelModel = add_dynamic_fuel_loading(fuel_model, fuel_moisture)
    weighted_fuel_model   : FuelModel = add_weighting_factors(dynamic_fuel_model)
    moisturized_fuel_model: FuelModel = add_live_moisture_of_extinction(weighted_fuel_model)
    return moisturized_fuel_model
#+end_src

This concludes our coverage of fuel models and fuel moisture.

** For Users
   :PROPERTIES:
   :CUSTOM_ID: for-users-fuel
   :header-args:python+: :session *examples:pyretechnics.fuel_models*
   :header-args:python+: :results output replace
   :header-args:python+: :exports both
   :END:

In the following sections, we will demonstrate how to access fuel
model properties by fuel model number both alone and combined with
fuel moisture.

*** How to Look Up a Fuel Model's Properties
    :PROPERTIES:
    :CUSTOM_ID: how-to-look-up-a-fuel-model's-properties
    :END:

#+NAME: look-up-fuel-model-properties
#+begin_src python
from pprint import pprint
from pyretechnics.fuel_models import get_fuel_model

static_fuel_model_number  = 1   # R01
dynamic_fuel_model_number = 101 # GR1

static_fuel_model  = get_fuel_model(static_fuel_model_number)
dynamic_fuel_model = get_fuel_model(dynamic_fuel_model_number)

print("Static Fuel Model: R01")
pprint(static_fuel_model)

print("\nDynamic Fuel Model: GR1")
pprint(dynamic_fuel_model)
#+end_src

#+NAME: look-up-fuel-model-properties-results
#+RESULTS: look-up-fuel-model-properties
#+begin_example
Static Fuel Model: R01
{'M_f': (0.0, 0.0, 0.0, 0.0, 0.0, 0.0),
 'M_x': (0.11999999731779099,
         0.11999999731779099,
         0.11999999731779099,
         0.0,
         0.0,
         0.0),
 'S_T': (0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574),
 'S_e': (0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582),
 'burnable': True,
 'delta': 1.0,
 'dynamic': False,
 'exp_A_sigma': (0.9613386392593384, 0.0, 0.0, 0.0, 0.0, 0.0),
 'f_i': (0.0, 0.0),
 'f_ij': (0.0, 0.0, 0.0, 0.0, 0.0, 0.0),
 'firemod_size_classes': (1.0, 6.0, 6.0, 6.0, 6.0, 6.0),
 'g_ij': (0.0, 0.0, 0.0, 0.0, 0.0, 0.0),
 'h': (8000.0, 8000.0, 8000.0, 8000.0, 8000.0, 8000.0),
 'number': 1,
 'rho_p': (32.0, 32.0, 32.0, 32.0, 32.0, 32.0),
 'sigma': (3500.0, 0.0, 0.0, 0.0, 0.0, 0.0),
 'w_o': (0.03400000184774399, 0.0, 0.0, 0.0, 0.0, 0.0)}

Dynamic Fuel Model: GR1
{'M_f': (0.0, 0.0, 0.0, 0.0, 0.0, 0.0),
 'M_x': (0.15000000596046448,
         0.15000000596046448,
         0.15000000596046448,
         0.15000000596046448,
         0.0,
         0.0),
 'S_T': (0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574),
 'S_e': (0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582),
 'burnable': True,
 'delta': 0.4000000059604645,
 'dynamic': True,
 'exp_A_sigma': (0.9391995668411255,
                 0.281941682100296,
                 0.010051836259663105,
                 0.9333266615867615,
                 0.7788007855415344,
                 0.0),
 'f_i': (0.0, 0.0),
 'f_ij': (0.0, 0.0, 0.0, 0.0, 0.0, 0.0),
 'firemod_size_classes': (1.0, 3.0, 5.0, 1.0, 1.0, 6.0),
 'g_ij': (0.0, 0.0, 0.0, 0.0, 0.0, 0.0),
 'h': (8000.0, 8000.0, 8000.0, 8000.0, 8000.0, 8000.0),
 'number': 101,
 'rho_p': (32.0, 32.0, 32.0, 32.0, 32.0, 32.0),
 'sigma': (2200.0, 109.0, 30.0, 2000.0, 2000.0, 0.0),
 'w_o': (0.004600000102072954, 0.0, 0.0, 0.0, 0.013799999840557575, 0.0)}
#+end_example

*** How to Apply Fuel Moisture to a Fuel Model
    :PROPERTIES:
    :CUSTOM_ID: how-to-apply-fuel-moisture-to-a-fuel-model
    :END:

#+NAME: moisturize-fuel-model
#+begin_src python
from pprint import pprint
from pyretechnics.fuel_models import get_fuel_model, moisturize

static_fuel_model_number  = 1   # R01
dynamic_fuel_model_number = 101 # GR1

static_fuel_model  = get_fuel_model(static_fuel_model_number)
dynamic_fuel_model = get_fuel_model(dynamic_fuel_model_number)

fuel_moisture = [
    0.05, # dead_1hr
    0.10, # dead_10hr
    0.15, # dead_100hr
    0.00, # dead_herbaceous (will be set by moisturize for dynamic fuel models)
    0.30, # live_herbaceous
    0.50, # live_woody
]

print("Moisturized Static Fuel Model: R01")
pprint(moisturize(static_fuel_model, fuel_moisture))

print("\nMoisturized Dynamic Fuel Model: GR1")
pprint(moisturize(dynamic_fuel_model, fuel_moisture))
#+end_src

#+NAME: moisturize-fuel-model-results
#+RESULTS: moisturize-fuel-model
#+begin_example
Moisturized Static Fuel Model: R01
{'M_f': (0.05000000074505806,
         0.10000000149011612,
         0.15000000596046448,
         0.0,
         0.30000001192092896,
         0.5),
 'M_x': (0.11999999731779099,
         0.11999999731779099,
         0.11999999731779099,
         0.0,
         0.11999999731779099,
         0.11999999731779099),
 'S_T': (0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574),
 'S_e': (0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582),
 'burnable': True,
 'delta': 1.0,
 'dynamic': False,
 'exp_A_sigma': (0.9613386392593384, 0.0, 0.0, 0.0, 0.0, 0.0),
 'f_i': (1.0, 0.0),
 'f_ij': (1.0, 0.0, 0.0, 0.0, 0.0, 0.0),
 'firemod_size_classes': (1.0, 6.0, 6.0, 6.0, 6.0, 6.0),
 'g_ij': (1.0, 0.0, 0.0, 0.0, 0.0, 0.0),
 'h': (8000.0, 8000.0, 8000.0, 8000.0, 8000.0, 8000.0),
 'number': 1,
 'rho_p': (32.0, 32.0, 32.0, 32.0, 32.0, 32.0),
 'sigma': (3500.0, 0.0, 0.0, 0.0, 0.0, 0.0),
 'w_o': (0.03400000184774399, 0.0, 0.0, 0.0, 0.0, 0.0)}

Moisturized Dynamic Fuel Model: GR1
{'M_f': (0.05000000074505806,
         0.10000000149011612,
         0.15000000596046448,
         0.05000000074505806,
         0.30000001192092896,
         0.5),
 'M_x': (0.15000000596046448,
         0.15000000596046448,
         0.15000000596046448,
         0.15000000596046448,
         233597312.0,
         233597312.0),
 'S_T': (0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574),
 'S_e': (0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582),
 'burnable': True,
 'delta': 0.4000000059604645,
 'dynamic': True,
 'exp_A_sigma': (0.9391995668411255,
                 0.281941682100296,
                 0.010051836259663105,
                 0.9333266615867615,
                 0.7788007855415344,
                 0.0),
 'f_i': (1.0, 9.691811797551964e-09),
 'f_ij': (0.2682926654815674, 0.0, 0.0, 0.7317073345184326, 1.0, 0.0),
 'firemod_size_classes': (1.0, 3.0, 5.0, 1.0, 1.0, 6.0),
 'g_ij': (1.0, 0.0, 0.0, 1.0, 1.0, 0.0),
 'h': (8000.0, 8000.0, 8000.0, 8000.0, 8000.0, 8000.0),
 'number': 101,
 'rho_p': (32.0, 32.0, 32.0, 32.0, 32.0, 32.0),
 'sigma': (2200.0, 109.0, 30.0, 2000.0, 2000.0, 0.0),
 'w_o': (0.004600000102072954,
         0.0,
         0.0,
         0.013799999840557575,
         1.8278757674128343e-10,
         0.0)}
#+end_example

* Surface Fire Equations (pyretechnics.surface_fire)
  :PROPERTIES:
  :CUSTOM_ID: surface-fire-equations-(pyretechnics.surface_fire)
  :END:
** For Developers
   :PROPERTIES:
   :CUSTOM_ID: for-developers-surface
   :header-args:python+: :session *pyretechnics.surface_fire*
   :header-args:python+: :tangle  ../src/pyretechnics/surface_fire.py
   :header-args:python+: :exports code
   :END:

The following sections define functions that calculate the spread rate
and intensity of a fire burning through surface fuels. These functions
combine fuel models and fuel moisture values (as defined in section
[[Fuel Model and Moisture Definitions (pyretechnics.fuel_models)]]) with
wind and topography inputs to determine the maximum spread rate and
direction of a surface fire as well as its fireline intensity and
flame length.

*** Module Imports
    :PROPERTIES:
    :CUSTOM_ID: module-imports-surface-fire
    :END:

#+NAME: surface-fire-imports
#+begin_src python
import cython
import cython as cy
if cython.compiled:
    from cython.cimports.libc.math import sqrt, pow, log, exp
    from cython.cimports.pyretechnics.cy_types import \
        vec_xy, vec_xyz, fcatarr, fclaarr, FuelModel, ProjectedVectors, FireBehaviorMin, \
        FireBehaviorMax, SpreadBehavior
    import cython.cimports.pyretechnics.conversion as conv
    import cython.cimports.pyretechnics.vector_utils as vu
else:
    from math import sqrt, pow, log, exp
    from pyretechnics.py_types import \
        vec_xy, vec_xyz, fcatarr, fclaarr, FuelModel, ProjectedVectors, FireBehaviorMin, \
        FireBehaviorMax, SpreadBehavior
    import pyretechnics.conversion as conv
    import pyretechnics.vector_utils as vu
#+end_src

*** Rothermel's Surface Fire Rate of Spread Equation
    :PROPERTIES:
    :CUSTOM_ID: rothermel's-surface-fire-rate-of-spread-equation
    :END:

To simulate fire behavior in as similar a way as possible to the US
government-sponsored fire models (e.g., FARSITE, FlamMap, FPA,
BehavePlus), Pyretechnics adopts the surface fire spread and reaction
intensity formulas from Rothermel's 1972 publication "A Mathematical
Model for Predicting Fire Spread in Wildland Fuels", adjusted
according to Albini 1976 Appendix III to match the behavior of
Albini's original FIREMODS library.[fn::Rothermel1972][fn::Albini1976]
This should align with the updated description provided in Patricia
Andrews' 2018 publication "The Rothermel Surface Fire Spread Model and
Associated Developments: A Comprehensive
Explanation".[fn::Andrews2018]

Very briefly, the surface rate of spread of a fire's leading edge $R$
is described by the following formula:

\begin{align}
  R = \frac{I_R \, \xi \, (1 + \phi_W + \phi_S)}{\rho_b \, \epsilon \, Q_{ig}}
\end{align}

where these terms have the meanings shown in Table
[[tab:fire-spread-inputs]].

#+NAME: tab:fire-spread-inputs
#+caption: Inputs to Rothermel's surface fire rate of spread equation
|------------+--------------------------------+-------------------------------|
| Term       | Description                    | Units                         |
|------------+--------------------------------+-------------------------------|
| $R$        | surface fire spread rate       | $\text{ft}/\min$              |
| $I_R$      | reaction intensity             | $\text{Btu}/\text{ft}^2/\min$ |
| $\xi$      | propagating flux ratio         | $\text{unitless}$             |
| $\phi_W$   | wind factor                    | $\text{unitless}$             |
| $\phi_S$   | slope factor                   | $\text{unitless}$             |
| $\rho_b$   | oven-dry fuel bed bulk density | $\text{lb}/\text{ft}^3$       |
| $\epsilon$ | effective heating number       | $\text{unitless}$             |
| $Q_{ig}$   | heat of preignition            | $\text{Btu}/\text{lb}$        |
|------------+--------------------------------+-------------------------------|

*** Surface Fire Spread Rate Functions (No Wind No Slope)
    :PROPERTIES:
    :CUSTOM_ID: surface-fire-spread-rate-functions-(no-wind-no-slope)
    :END:

In this section, Rothermel's surface fire spread rate equation will be
computed without introducing the effects of wind or slope (i.e.,
$\phi_W = \phi_S = 0$). In this case, the only necessary input is a
moisturized fuel model (as created in section [[Applying Fuel Moisture
to a Fuel Model]]). Thus, the functions below will focus on the
no-wind-no-slope term $R_0$ defined as follows:

\begin{align}
  R_0 &= \frac{I_R \, \xi}{\rho_b \, \epsilon \, Q_{ig}} \\
  \nonumber \\
  R &= R_0 \, (1 + \phi_W + \phi_S)
\end{align}

Each term will be defined in its own section, and finally they will be
combined together in a single function that computes $R_0$.

**** Common Intermediate Calculations: $\sigma', \beta, \beta_{op}$
     :PROPERTIES:
     :CUSTOM_ID: common-intermediate-calculations:-$\sigma',-\beta,-\beta_{op}$
     :END:

#+NAME: surface-fire-common-intermediate-calculations
#+begin_src python
@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def __dotp_in_category(x_ij: fclaarr, y_ij: fclaarr) -> fcatarr:
    """
    Util: dot-product between fuel size class vectors, within each fuel category (dead/live).
    """
    return (
        (
            (x_ij[0] * y_ij[0]) +
            (x_ij[1] * y_ij[1]) +
            (x_ij[2] * y_ij[2]) +
            (x_ij[3] * y_ij[3])
        ),
        (
            (x_ij[4] * y_ij[4]) +
            (x_ij[5] * y_ij[5])
        )
    )


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def __dotp_categories(x_i: fcatarr, y_i: fcatarr) -> cy.float:
    return (
        (x_i[0] * y_i[0]) +
        (x_i[1] * y_i[1])
    )


@cy.cfunc
@cy.exceptval(check=False)
def calc_surface_area_to_volume_ratio(f_i: fcatarr, f_ij: fclaarr, sigma: fclaarr) -> cy.float:
    sigma_prime: fcatarr = __dotp_in_category(f_ij, sigma)
    return __dotp_categories(f_i, sigma_prime)


@cy.cfunc
@cy.exceptval(check=False)
def calc_packing_ratio(w_o: fclaarr, rho_p: fclaarr, delta: cy.float) -> cy.float:
    if (delta > 0.0):
        rho_p_inv: fclaarr = ( # TODO: OPTIM pre-compute
            1.0/rho_p[0],
            1.0/rho_p[1],
            1.0/rho_p[2],
            1.0/rho_p[3],
            1.0/rho_p[4],
            1.0/rho_p[5]
        )
        beta: fcatarr = __dotp_in_category(w_o, rho_p_inv)
        return (beta[0] + beta[1]) / delta
    else:
        return 0.0


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def calc_optimum_packing_ratio(sigma_prime: cy.float) -> cy.float:
    return (3.348 * pow(sigma_prime, -0.8189)) if (sigma_prime > 0.0) else 1.0
#+end_src

**** Reaction Intensity: $I_R$
     :PROPERTIES:
     :CUSTOM_ID: reaction-intensity:-$i_r$
     :END:

#+NAME: surface-fire-reaction-intensity
#+begin_src python
@cy.cfunc
@cy.exceptval(check=False)
def calc_mineral_damping_coefficients(f_ij: fclaarr, S_e: fclaarr) -> fcatarr:
    S_e_i: fcatarr = __dotp_in_category(f_ij, S_e)
    (S_e_0, S_e_1) = S_e_i
    return (
        0.174 * pow(S_e_0, -0.19) if (S_e_0 > 0.0) else 1.0,
        0.174 * pow(S_e_1, -0.19) if (S_e_1 > 0.0) else 1.0
    )


@cy.cfunc
@cy.exceptval(check=False)
def __cat_moisture_damping_coefficient(M_f: cy.float, M_x: cy.float) -> cy.float:
    if (M_x > 0.0):
        r_M : cy.float = min(1.0, M_f / M_x)
        r_M2: cy.float = r_M * r_M
        r_M3: cy.float = r_M2 * r_M
        return 1.0 - (2.59 * r_M) + (5.11 * r_M2) - (3.52 * r_M3)
    else:
        return 0.0


@cy.cfunc
@cy.exceptval(check=False)
def calc_moisture_damping_coefficients(f_ij: fclaarr, M_f: fclaarr, M_x: fclaarr) -> fcatarr:
    M_f_i: fcatarr = __dotp_in_category(f_ij, M_f)
    M_x_i: fcatarr = __dotp_in_category(f_ij, M_x)
    return (
        __cat_moisture_damping_coefficient(M_f_i[0], M_x_i[0]),
        __cat_moisture_damping_coefficient(M_f_i[1], M_x_i[1])
    )


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def calc_low_heat_content(f_ij: fclaarr, h: fclaarr) -> fcatarr:
    return __dotp_in_category(f_ij, h)


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def calc_net_fuel_loading(g_ij: fclaarr, w_o: fclaarr, S_T: fclaarr) -> fcatarr:
    return (
        (
            g_ij[0] * w_o[0] * (1.0 - S_T[0]) +
            g_ij[1] * w_o[1] * (1.0 - S_T[1]) +
            g_ij[2] * w_o[2] * (1.0 - S_T[2]) +
            g_ij[3] * w_o[3] * (1.0 - S_T[3])
        ),
        (
            g_ij[4] * w_o[4] * (1.0 - S_T[4]) +
            g_ij[5] * w_o[5] * (1.0 - S_T[5])
        )
    )


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def calc_heat_per_unit_area(eta_S_i: fcatarr, eta_M_i: fcatarr, h_i: fcatarr, W_n_i: fcatarr) -> cy.float:
    return (
        (W_n_i[0] * h_i[0] * eta_M_i[0] * eta_S_i[0]) +
        (W_n_i[1] * h_i[1] * eta_M_i[1] * eta_S_i[1])
    )


@cy.cfunc
@cy.exceptval(check=False)
def calc_optimum_reaction_velocity(sigma_prime: cy.float, beta: cy.float, beta_op: cy.float) -> cy.float:
    # Albini 1976 replaces 1 / (4.774 * (sigma_prime ** 0.1) - 7.27)
    A: cy.float = (133.0 * pow(sigma_prime, -0.7913)) if (sigma_prime > 0.0) else 0.0
    B: cy.float = pow(sigma_prime, 1.5)
    C: cy.float = beta / beta_op
    # Maximum reaction velocity (1/min)
    Gamma_prime_max: cy.float = B / (495.0 + 0.0594 * B)
    # Optimum reaction velocity (1/min)
    return Gamma_prime_max * pow(C, A) * exp(A * (1.0 - C))


@cy.cfunc
@cy.exceptval(check=False)
def calc_reaction_intensity(moisturized_fuel_model: FuelModel,
                            sigma_prime           : cy.float,
                            beta                  : cy.float,
                            beta_op               : cy.float) -> cy.float:
    # Unpack the FuelModel fields
    w_o : fclaarr = moisturized_fuel_model.w_o
    h   : fclaarr = moisturized_fuel_model.h
    S_T : fclaarr = moisturized_fuel_model.S_T
    S_e : fclaarr = moisturized_fuel_model.S_e
    M_x : fclaarr = moisturized_fuel_model.M_x
    M_f : fclaarr = moisturized_fuel_model.M_f
    f_ij: fclaarr = moisturized_fuel_model.f_ij
    g_ij: fclaarr = moisturized_fuel_model.g_ij
    # Derive intermediate quantities
    eta_S_i    : fcatarr  = calc_mineral_damping_coefficients(f_ij, S_e)
    eta_M_i    : fcatarr  = calc_moisture_damping_coefficients(f_ij, M_f, M_x)
    h_i        : fcatarr  = calc_low_heat_content(f_ij, h)                             # (Btu/lb)
    W_n_i      : fcatarr  = calc_net_fuel_loading(g_ij, w_o, S_T)                      # (lb/ft^2)
    Btus       : cy.float = calc_heat_per_unit_area(eta_S_i, eta_M_i, h_i, W_n_i)      # (Btu/ft^2)
    Gamma_prime: cy.float = calc_optimum_reaction_velocity(sigma_prime, beta, beta_op) # (1/min)
    # Calculate reaction intensity
    return Btus * Gamma_prime # (Btu/ft^2/min)
#+end_src

**** Propagating Flux Ratio: $\xi$
     :PROPERTIES:
     :CUSTOM_ID: propagating-flux-ratio:-$\xi$
     :END:

#+NAME: surface-fire-propagating-flux-ratio
#+begin_src python
@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def calc_propagating_flux_ratio(sigma_prime: cy.float, beta: cy.float) -> cy.float:
    return exp((0.792 + 0.681 * sqrt(sigma_prime)) * (beta + 0.1)) / (192.0 + 0.2595 * sigma_prime)
#+end_src

**** Heat Source (No Wind No Slope): $I_R \, \xi$
     :PROPERTIES:
     :CUSTOM_ID: heat-source-(no-wind-no-slope):-$i_r-\,-\xi$
     :END:

#+NAME: surface-fire-heat-source-no-wind-no-slope
#+begin_src python
@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def calc_heat_source(I_R: cy.float, xi: cy.float) -> cy.float:
    return I_R * xi
#+end_src

**** Oven-Dry Fuel Bed Bulk Density: $\rho_b$
     :PROPERTIES:
     :CUSTOM_ID: oven-dry-fuel-bed-bulk-density:-!$\rho_b$
     :END:

#+NAME: surface-fire-oven-dry-fuel-bed-bulk-density
#+begin_src python
@cy.cfunc
@cy.exceptval(check=False)
def calc_ovendry_bulk_density(w_o: fclaarr, delta: cy.float) -> cy.float:
    if (delta > 0.0):
        w_o_sum: cy.float = w_o[0] + w_o[1] + w_o[2] + w_o[3] + w_o[4] + w_o[5]
        return w_o_sum / delta
    else:
        return 0.0
#+end_src

**** Effective Heating Number Distribution: $\epsilon_{ij}$
     :PROPERTIES:
     :CUSTOM_ID: effective-heating-number-distribution:-!$\epsilon_{ij}$
     :END:

#+NAME: surface-fire-effective-heating-number-distribution
#+begin_src python
@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def __sizeclass_heating_number(sigma_i: cy.float) -> cy.float:
    return exp(-138.0 / sigma_i) if (sigma_i > 0.0) else 0.0


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def calc_effective_heating_number_distribution(sigma: fclaarr) -> fclaarr: # OPTIM pre-compute, exp is expensive
    return (
        __sizeclass_heating_number(sigma[0]),
        __sizeclass_heating_number(sigma[1]),
        __sizeclass_heating_number(sigma[2]),
        __sizeclass_heating_number(sigma[3]),
        __sizeclass_heating_number(sigma[4]),
        __sizeclass_heating_number(sigma[5])
    )
#+end_src

**** Heat of Preignition Distribution: $(Q_{ig})_{ij}$
     :PROPERTIES:
     :CUSTOM_ID: heat-of-preignition-distribution:-!$(q_{ig})_{ij}$
     :END:

#+NAME: surface-fire-heat-of-preignition-distribution
#+begin_src python
@cy.cfunc
@cy.exceptval(check=False)
def __sizeclass_heat_of_preignition_distribution(M_f_i: cy.float) -> cy.float:
    pos1: cy.float = cy.cast(cy.float, (M_f_i > 0.0))
    return (250.0 + 1116.0 * M_f_i) * pos1 # Returns 0 unless M_f_i > 0


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def calc_heat_of_preignition_distribution(M_f: fclaarr) -> fclaarr:
    return (
        __sizeclass_heat_of_preignition_distribution(M_f[0]),
        __sizeclass_heat_of_preignition_distribution(M_f[1]),
        __sizeclass_heat_of_preignition_distribution(M_f[2]),
        __sizeclass_heat_of_preignition_distribution(M_f[3]),
        __sizeclass_heat_of_preignition_distribution(M_f[4]),
        __sizeclass_heat_of_preignition_distribution(M_f[5])
    )
#+end_src

**** Heat Sink: $\rho_b \, \epsilon \, Q_{ig}$
     :PROPERTIES:
     :CUSTOM_ID: heat-sink:-$\rho_b-\,-\epsilon-\,-q_{ig}$
     :END:

#+NAME: surface-fire-heat-sink
#+begin_src python
@cy.cfunc
@cy.exceptval(check=False)
def calc_heat_sink(f_i: fcatarr, f_ij: fclaarr, rho_b: cy.float, epsilon_ij: fclaarr, Q_ig_ij: fclaarr) -> cy.float:
    effective_heat_of_preignition_i: fcatarr = (
        (
            (f_ij[0] * epsilon_ij[0] * Q_ig_ij[0]) +
            (f_ij[1] * epsilon_ij[1] * Q_ig_ij[1]) +
            (f_ij[2] * epsilon_ij[2] * Q_ig_ij[2]) +
            (f_ij[3] * epsilon_ij[3] * Q_ig_ij[3])
        ),
        (
            (f_ij[4] * epsilon_ij[4] * Q_ig_ij[4]) +
            (f_ij[5] * epsilon_ij[5] * Q_ig_ij[5])
        )
    )
    effective_heat_of_preignition: cy.float = __dotp_categories(f_i, effective_heat_of_preignition_i)
    return rho_b * effective_heat_of_preignition
#+end_src

**** Spread Rate (No Wind No Slope): $R_0$
     :PROPERTIES:
     :CUSTOM_ID: spread-rate-(no-wind-no-slope):-!$r_0$
     :END:

#+NAME: surface-fire-spread-rate-no-wind-no-slope
#+begin_src python
@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def calc_spread_rate(heat_source: cy.float, heat_sink: cy.float) -> cy.float:
    return heat_source / heat_sink if (heat_sink > 0.0) else 0.0
#+end_src

*** Surface Fire Intensity Functions
    :PROPERTIES:
    :CUSTOM_ID: surface-fire-intensity-functions
    :END:

Using the surface fire spread rate and reaction intensity values, we
can now calculate several surface fire intensity metrics by applying
Anderson's residence time and flame depth formulas, Byram's fireline
intensity and flame length equations, and Andrews & Rothermel's heat
per unit area
equation:[fn::Anderson1969][fn::Byram1959][fn::AndrewsRothermel1982]

\begin{align}
  t_{\text{res}} &= \frac{384}{\sigma'} \\
  \nonumber \\
  D_A &= R_s \, t_{\text{res}} \\
  \nonumber \\
  I_s &= \frac{I_R \, D_A}{60} \\
  \nonumber \\
  L_s &= 0.45 (I_s)^{0.46} \\
  \nonumber \\
  H_s &= I_R \, t_{\text{res}} = 60 \frac{I_s}{R_s} \\
\end{align}

where $\sigma'$ is the weighted sum by size class of the fuel model's
surface area to volume ratio in $\text{ft}^2/\text{ft}^3$,
$t_{\text{res}}$ is the residence time in $\text{minutes}$, $R_s$ is
the surface fire spread rate in $\text{ft}/\min$, $D_A$ is the flame
depth in $\text{ft}$, $I_R$ is the reaction intensity in
$\text{Btu}/\text{ft}^2/\min$, $I_s$ is the fireline intensity in
$\text{Btu}/\text{ft}/\text{s}$, $L_s$ is the flame length in
$\text{ft}$, and $H_s$ is the heat per unit area in
$\text{Btu}/\text{ft}^2$.

#+NAME: surface-fire-intensity-functions
#+begin_src python
@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def calc_residence_time(sigma_prime: cy.float) -> cy.float:
    """
    Returns the residence time (total burning time) of fuel (min) given:
    - sigma_prime :: ft^2/ft^3 (surface area to volume ratio)
    """
    return 384.0 / sigma_prime if (sigma_prime > 0.0) else 0.0


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def calc_flame_depth(spread_rate: cy.float, residence_time: cy.float) -> cy.float:
    """
    Returns the depth, or front-to-back distance, of the actively flaming zone
    of a free-spreading fire (ft) given:
    - spread_rate    :: ft/min (orthogonal to the fireline)
    - residence_time :: min
    """
    return spread_rate * residence_time


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def calc_fireline_intensity(reaction_intensity: cy.float, flame_depth: cy.float) -> cy.float:
    """
    Returns the rate of heat release per unit of fire edge (Btu/ft/s) given:
    - reaction_intensity :: Btu/ft^2/min
    - flame_depth        :: ft
    """
    return (reaction_intensity * flame_depth) / 60.0


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def calc_flame_length(fireline_intensity: cy.float) -> cy.float:
    """
    Returns the average flame length (m) given:
    - fireline_intensity :: kW/m
    """
    return 0.07747042253266703 * pow(fireline_intensity, 0.46)


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def calc_areal_heat_output(spread_rate: cy.float, fireline_intensity: cy.float) -> cy.float:
    """
    Returns the heat per unit area (kJ/m^2) given:
    - spread_rate        :: m/min
    - fireline_intensity :: kW/m
    """
    return 60.0 * fireline_intensity / spread_rate if spread_rate > 0.0 else 0.0
#+end_src

Because of the linear relationship between spread rate, flame depth,
and fireline intensity, once we have calculated the no wind, no slope
fireline intensity, we can simply multiply it by the same combined
wind and slope factor that is applied to the no wind, no slope spread
rate in order to derive the maximum fireline intensity.

Since flame length's relationship to fireline intensity is non-linear,
we will need to wait until after any transformations are applied to
fireline intensity before calculating the associated flame length.

*** Wind and Slope Factor Functions
    :PROPERTIES:
    :CUSTOM_ID: wind-and-slope-factor-functions
    :END:

In order to compute the maximum spread rate, direction, and intensity
of the surface fire front, we will need to incorporate the effects of
wind and slope on the fire. However, we can precompute several
intermediate values and functions needed for this step based solely on
the fuel bed characteristics already available to us with just a
moisturized fuel model (see section [[Applying Fuel Moisture to a Fuel
Model]]).

**** Max Effective Wind Speed: $U_{\text{eff}}^{\max}$
     :PROPERTIES:
     :CUSTOM_ID: max-effective-wind-speed:-!$u_{\text{eff}}^{\max}$
     :END:

The midflame wind speed that would be required to produce the combined
spread rate in a no-slope scenario is termed the effective windspeed
$U_{\text{eff}}$. Following the recommendations given in Appendix III
of Albini 1976, these midflame wind speeds are all limited by the
reaction intensity $I_R$ as follows:[fn::Albini1976]

\begin{align}
  U_{\text{eff}}^{\max} = 0.9 \, I_R
\end{align}

where $I_R$ is the reaction intensity in $\text{Btu}/\text{ft}^2/\min$
and $U_{\text{eff}}^{\max}$ is the maximum effective wind speed in
$\text{ft}/\min$

#+NAME: surface-fire-max-effective-wind-speed
#+begin_src python
@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def calc_max_effective_wind_speed(reaction_intensity: cy.float) -> cy.float:
    return 0.9 * reaction_intensity
#+end_src

**** Slope Factor Function: $\tan(\theta_S) \mapsto \phi_S$
     :PROPERTIES:
     :CUSTOM_ID: slope-factor-function:-$\tan(\theta_s)-\mapsto-\phi_s$
     :END:

#+NAME: surface-fire-slope-factor-function
#+begin_src python
@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def get_phi_S(surface_fire_min: FireBehaviorMin, slope: cy.float) -> cy.float:
    return surface_fire_min._phiS_G * (slope * slope)
#+end_src

**** Wind Factor Function: $U_{\text{mid}} \mapsto \phi_W$
     :PROPERTIES:
     :CUSTOM_ID: wind-factor-function:-$u_{\text{mid}}-\mapsto-\phi_w$
     :END:

#+NAME: surface-fire-wind-factor-function
#+begin_src python
@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def get_phi_W(surface_fire_min: FireBehaviorMin, midflame_wind_speed: cy.float) -> cy.float:
    return surface_fire_min._phiW_scalr * pow(midflame_wind_speed, surface_fire_min._phiW_expnt)
#+end_src

**** Wind Speed Function: $\phi_W \mapsto U_{\text{mid}}$
     :PROPERTIES:
     :CUSTOM_ID: wind-speed-function:-$\phi_w-\mapsto-u_{\text{mid}}$
     :END:

#+NAME: surface-fire-wind-speed-function
#+begin_src python
@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def get_wind_speed(surface_fire_min: FireBehaviorMin, phi_W: cy.float) -> cy.float:
    return surface_fire_min._ws_scalr * pow(phi_W, surface_fire_min._ws_expnt)
#+end_src

*** Surface Fire Behavior Functions (No Wind No Slope)
    :PROPERTIES:
    :CUSTOM_ID: surface-fire-behavior-functions-(no-wind-no-slope)
    :END:

#+NAME: surface-fire-behavior-no-wind-no-slope
#+begin_src python
@cy.cfunc
@cy.exceptval(check=False)
def make_surface_fire_min(base_spread_rate        : cy.float,
                          base_fireline_intensity : cy.float,
                          max_effective_wind_speed: cy.float,
                          B                       : cy.float,
                          C                       : cy.float,
                          F                       : cy.float,
                          beta                    : cy.float) -> FireBehaviorMin:
    _phiS_G: cy.float = 0.0
    if (beta > 0.0):
        _phiS_G = 5.275 * pow(beta, -0.3)

    _phiW_scalr: cy.float = 0.0
    _phiW_expnt: cy.float = 0.0
    if (F > 0.0):
        _phiW_scalr = (C / F) * pow(conv.m_to_ft(1.0), B)
        _phiW_expnt = B

    _ws_scalr: cy.float = 0.0
    _ws_expnt: cy.float = 0.0
    if (B > 0.0):
        B_inverse: cy.float = 1.0 / B
        _ws_scalr = conv.ft_to_m(pow((F / C), B_inverse))
        _ws_expnt = B_inverse

    return FireBehaviorMin(
        base_spread_rate,
        base_fireline_intensity,
        max_effective_wind_speed,
        _phiS_G,
        _phiW_scalr,
        _phiW_expnt,
        _ws_scalr,
        _ws_expnt)


@cy.cfunc
@cy.exceptval(check=False)
def calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model: FuelModel,
                                                spread_rate_adjustment: cy.float = 1.0) -> FireBehaviorMin:
    """
    Given these inputs:
    - moisturized_fuel_model :: FuelModel struct of fuel model and fuel moisture properties
      - delta :: ft                                        (fuel depth)
      - w_o   :: lb/ft^2                                   (ovendry fuel loading)
      - rho_p :: lb/ft^3                                   (ovendry particle density)
      - sigma :: ft^2/ft^3                                 (fuel particle surface-area-to-volume ratio)
      - h     :: Btu/lb                                    (fuel particle low heat content)
      - S_T   :: lb minerals/lb ovendry weight             (fuel particle total mineral content)
      - S_e   :: lb silica-free minerals/lb ovendry weight (fuel particle effective mineral content)
      - M_x   :: lb moisture/lb ovendry weight             (fuel particle moisture of extinction)
      - M_f   :: lb moisture/lb ovendry weight             (fuel particle moisture content)
      - f_ij  :: %                                         (percent load per size class)
      - f_i   :: %                                         (percent load per category)
      - g_ij  :: %                                         (percent load per size class - Albini_1976_FIREMOD, page 20)
    - spread_rate_adjustment :: unitless float (1.0 for no adjustment)

    return a FireBehaviorMin struct containing these keys:
    - base_spread_rate         :: m/min
    - base_fireline_intensity  :: kW/m
    - max_effective_wind_speed :: m/min
    - _phiS_G                  :: intermediate value for computing phi_S (unitless)
    - _phiW_scalr              :: intermediate value for computing phi_W (unitless)
    - _phiW_expnt              :: intermediate value for computing phi_W (unitless)
    - _ws_scalr                :: intermediate value for computing effective_wind_speed (m/min)
    - _ws_expnt                :: intermediate value for computing effective_wind_speed (unitless)
    """
    # Unpack fuel model values
    delta: cy.float = moisturized_fuel_model.delta
    w_o  : fclaarr  = moisturized_fuel_model.w_o
    rho_p: fclaarr  = moisturized_fuel_model.rho_p
    sigma: fclaarr  = moisturized_fuel_model.sigma
    M_f  : fclaarr  = moisturized_fuel_model.M_f
    f_ij : fclaarr  = moisturized_fuel_model.f_ij
    f_i  : fcatarr  = moisturized_fuel_model.f_i
    # Calculate base spread rate (no wind, no slope)
    sigma_prime: cy.float = calc_surface_area_to_volume_ratio(f_i, f_ij, sigma)
    beta       : cy.float = calc_packing_ratio(w_o, rho_p, delta)
    beta_op    : cy.float = calc_optimum_packing_ratio(sigma_prime)
    I_R        : cy.float = calc_reaction_intensity(moisturized_fuel_model, sigma_prime, beta, beta_op) # Btu/ft^2/min
    xi         : cy.float = calc_propagating_flux_ratio(sigma_prime, beta)
    heat_source: cy.float = calc_heat_source(I_R, xi)                             # Btu/ft^2/min
    rho_b      : cy.float = calc_ovendry_bulk_density(w_o, delta)                 # lb/ft^3
    epsilon_ij : fclaarr  = calc_effective_heating_number_distribution(sigma)
    Q_ig_ij    : fclaarr  = calc_heat_of_preignition_distribution(M_f)            # Btu/lb
    heat_sink  : cy.float = calc_heat_sink(f_i, f_ij, rho_b, epsilon_ij, Q_ig_ij) # Btu/ft^3
    R0         : cy.float = calc_spread_rate(heat_source, heat_sink)              # ft/min
    # Calculate base fireline intensity (no wind, no slope)
    t_res: cy.float = calc_residence_time(sigma_prime)  # min
    D_A  : cy.float = calc_flame_depth(R0, t_res)       # ft
    I_s  : cy.float = calc_fireline_intensity(I_R, D_A) # Btu/ft/s
    # Pre-compute values related to wind and slope
    U_eff_max: cy.float = calc_max_effective_wind_speed(I_R) # ft/min
    B        : cy.float = 0.02526 * pow(sigma_prime, 0.54)
    C        : cy.float = 7.47 * exp(-0.133 * pow(sigma_prime, 0.55))
    E        : cy.float = 0.715 * exp(-3.59 * (sigma_prime * 1e-4))
    F        : cy.float = pow((beta / beta_op), E)
    # Return no-wind-no-slope surface fire behavior values
    base_spread_rate        : cy.float = conv.ft_to_m(R0 * spread_rate_adjustment)
    base_fireline_intensity : cy.float = conv.Btu_ft_s_to_kW_m(I_s * spread_rate_adjustment)
    max_effective_wind_speed: cy.float = conv.ft_to_m(U_eff_max)
    return make_surface_fire_min(
        base_spread_rate,
        base_fireline_intensity,
        max_effective_wind_speed,
        B,
        C,
        F,
        beta
    )
#+end_src

*** Midflame Wind Speed
    :PROPERTIES:
    :CUSTOM_ID: midflame-wind-speed
    :END:

Rothermel's formulas all expect a measure of midflame wind speed
$U_{\text{mid}}$. However, wind speed data is often collected at a
height 20 feet (or 10 meters) above either unsheltered ground or a
tree canopy layer if present. To convert this 20-ft wind speed
$U_{20}$ to the required midflame wind speed value, Pyretechnics uses
the wind adjustment factor formula from Albini & Baughman 1979,
parameterized as in BehavePlus, FARSITE, FlamMap, FSPro, and FPA
according to Andrews 2012[fn::Albini1979][fn::Andrews2012].

\begin{align}
  \text{WAF} &= \left\{
    \begin{array}{lr}
      1.83 \ln(\frac{20.0 + 0.36 \text{FBD}}{0.13 \text{FBD}})^{-1} & CC = 0 \\
      0.555 [\sqrt{\text{CH} (\text{CC}/3.0)} \ln(\frac{20 + 0.36 \text{CH}}{0.13 \text{CH}})]^{-1} & CC > 0
    \end{array}
  \right. \\
  \nonumber \\
  U_{\text{mid}} &= U_{20} \, \text{WAF}
\end{align}

where $\text{WAF}$ is the unitless wind adjustment factor,
$\text{FBD}$ is the fuel bed depth in $\text{ft}$, $\text{CH}$ is the
canopy height in $\text{ft}$, and $\text{CC}$ is the canopy cover
fraction $(0-1)$.

#+NAME: midflame-wind-speed
#+begin_src python
@cy.cfunc
@cy.exceptval(check=False)
def calc_wind_adjustment_factor(fuel_bed_depth: cy.float, canopy_height: cy.float, canopy_cover: cy.float) -> cy.float:
    """
    Return the wind adjustment factor (unitless) given these inputs:
    - fuel_bed_depth :: ft
    - canopy_height  :: ft
    - canopy_cover   :: 0-1
    """
    if (canopy_cover > 0.0) and (canopy_height > 0.0):
        # sheltered: equation 2 based on CC and CH, CR=1 (Andrews 2012)
        A: cy.float = sqrt((canopy_cover / 3.0) * canopy_height)
        B: cy.float = log((20.0 + 0.36 * canopy_height) / (0.13 * canopy_height))
        return 0.555 / (A * B)
    elif (fuel_bed_depth > 0.0):
        # unsheltered: equation 6 H_F = H (Andrews 2012)
        A: cy.float = log((20.0 + 0.36 * fuel_bed_depth) / (0.13 * fuel_bed_depth))
        return 1.83 / A # 1.83 truncated from 1.8328795184533409
    else:
        # non-burnable fuel model
        return 0.0


@cy.cfunc
@cy.exceptval(check=False)
def calc_midflame_wind_speed(wind_speed_20ft: cy.float,
                             fuel_bed_depth : cy.float,
                             canopy_height  : cy.float,
                             canopy_cover   : cy.float) -> cy.float:
    """
    Return the midflame wind speed (S) given these inputs:
    - wind_speed_20ft :: S
    - fuel_bed_depth  :: ft
    - canopy_height   :: ft
    - canopy_cover    :: 0-1
    """
    wind_adj_factor: cy.float = calc_wind_adjustment_factor(fuel_bed_depth, canopy_height, canopy_cover)
    return wind_speed_20ft * wind_adj_factor
#+end_src

*** Combining Wind and Slope Vectors
    :PROPERTIES:
    :CUSTOM_ID: combining-wind-and-slope-vectors
    :END:

On flat terrain and in the absence of wind, an idealized surface fire
will spread outward in a circle through homogeneous fuels. On sloped
terrain, a fire will spread more quickly upslope than downslope, and
when wind is present, a fire will spread more quickly in the direction
that the wind is blowing rather than against it. In the presence of
both sloped terrain and wind, the two forces combine to create a new
maximum spread rate and direction for the fire. Together, wind and
slope effects elongate otherwise circular fire perimeters into
ellipses, with the fastest moving edge known as the head fire.

Since Rothermel's original equations for computing the head fire
spread rate assume that the wind direction and upslope direction are
aligned, the effects of cross-slope winds must be taken into effect.
To accomplish this, Pyretechnics implements the vector addition
procedure defined in Rothermel 1983 that combines the wind and slope
vectors to calculate the maximum fire spread direction and
magnitude.[fn::Rothermel1983]

In order to address potential errors related to projecting the
horizontal wind and slope azimuth vectors to and from the
slope-tangential plane, upon which the equations from Rothermel 1983
are defined, we incorporate the three-dimensional vector combination
procedure provided by Waeselynck 2024.[fn::Waeselynck2024]

#+NAME: surface-fire-combine-wind-and-slope-vectors
#+begin_src python
@cy.cfunc
@cy.exceptval(check=False)
def project_wind_and_slope_vectors_3d(wind_speed        : cy.float,
                                      downwind_direction: cy.float,
                                      slope             : cy.float,
                                      upslope_direction : cy.float) -> ProjectedVectors:
    """
    Given these inputs:
    - wind_speed         :: S
    - downwind_direction :: degrees clockwise from North
    - slope              :: rise/run
    - upslope_direction  :: degrees clockwise from North

    return a ProjectedVectors struct containing these keys:
    - wind_vector_3d  :: (x: S, y: S, z: S)
    - slope_vector_3d :: (x, y, z)
    """
    # Convert wind and slope vectors from azimuthal to cartesian coordinates
    wind_vector_2d : vec_xy = conv.azimuthal_to_cartesian(wind_speed, downwind_direction)
    slope_vector_2d: vec_xy = conv.azimuthal_to_cartesian(slope, upslope_direction)
    # Project wind and slope vectors onto the slope-tangential plane
    wind_vector_3d : vec_xyz = vu.to_slope_plane(wind_vector_2d, slope_vector_2d)
    slope_vector_3d: vec_xyz = vu.to_slope_plane(slope_vector_2d, slope_vector_2d)
    return ProjectedVectors(wind_vector_3d, slope_vector_3d)


@cy.cfunc
@cy.exceptval(check=False)
def get_phi_E(wind_vector_3d: vec_xyz, slope_vector_3d: vec_xyz, phi_W: cy.float, phi_S: cy.float) -> vec_xyz:
    # Convert wind and slope vectors to unit vectors on the slope-tangential plane
    w_S: vec_xyz = vu.as_unit_vector_3d(wind_vector_3d)  if phi_W > 0.0 else wind_vector_3d
    u_S: vec_xyz = vu.as_unit_vector_3d(slope_vector_3d) if phi_S > 0.0 else slope_vector_3d
    # Create the 3D slope-tangential phi_W, phi_S, and phi_E vectors
    phi_W_3d: vec_xyz = vu.scale_3d(phi_W, w_S)
    phi_S_3d: vec_xyz = vu.scale_3d(phi_S, u_S)
    phi_E_3d: vec_xyz = vu.add_3d(phi_W_3d, phi_S_3d)
    return phi_E_3d
#+end_src

*** Surface Elliptical Eccentricity
    :PROPERTIES:
    :CUSTOM_ID: surface-elliptical-eccentricity
    :END:

The effective wind speed $U_{\text{eff}}$ is the wind speed that would
be required to produce the same spread rate in flat terrain as that
given by the combination of wind and sloped terrain as described in
section [[Combining Wind and Slope Vectors]].

In order to project the one-dimensional surface fire spread rate
values calculated in earlier sections onto a two-dimensional plane,
$U_{\text{eff}}$ is used to compute the length to width ratio
$\frac{L}{W}$ of an ellipse that approximates the surface fire front.
This length to width ratio is then converted into an eccentricity
measure $E$ of the ellipse using equation 8 from Albini and Chase
1980.[fn::Albini1980]

\begin{align}
  E = \frac{\sqrt{(\frac{L}{W})^2 - 1}}{\frac{L}{W}}
\end{align}

Currently Pyretechnics supports two different methods for computing
the length to width ratio $\frac{L}{W}$:

1. Using equation 9 from Rothermel 1991.[fn::Rothermel1991]

\begin{align}
  \frac{L}{W} = 1 + 0.25 \, U_{\text{eff}}
\end{align}

where $U_{\text{eff}}$ is the effective wind speed in $\text{mph}$.

2. Using the formula implemented in the Missoula Fire Lab's =behave= C++ library[fn::https://github.com/firelab/behave/blob/00b90853182031c9e22e33f22bb0ac497bad9415/src/behave/fireSize.cpp#L93]

\begin{align}
  \frac{L}{W} = \min(8.0, 0.936 e^{(0.1147 U_{\text{eff}})} + 0.461 e^{(-0.0692 U_{\text{eff}})} - 0.397)
\end{align}

where $U_{\text{eff}}$ is the effective wind speed in $\text{mph}$.

#+NAME: surface-fire-eccentricity
#+begin_src python
# TODO: Change model from str to enumerated type and set @cy.exceptval(-1) to @cy.exceptval(check=False)
@cy.cfunc
@cy.exceptval(-1)
def surface_length_to_width_ratio(effective_wind_speed: cy.float, model: str = "behave") -> cy.float:
    """
    Calculate the length_to_width_ratio of the surface fire front given:
    - effective_wind_speed :: m/min (aligned with the slope-tangential plane)
    - model                :: "rothermel" or "behave" (Optional)
    """
    effective_wind_speed_mph = conv.m_min_to_mph(effective_wind_speed)
    # Select formula by model
    if model == "rothermel":
        return 1.0 + 0.25 * effective_wind_speed_mph

    elif model == "behave":
        return min(8.0,
                   0.936 * exp(0.1147 * effective_wind_speed_mph)
                   +
                   0.461 * exp(-0.0692 * effective_wind_speed_mph)
                   -
                   0.397)

    else:
        raise ValueError("Invalid input: model must be 'rothermel' or 'behave'.")


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def surface_fire_eccentricity(length_to_width_ratio: cy.float) -> cy.float:
    """
    Calculate the eccentricity (E) of the surface fire front using eq. 8 from
    Albini and Chase 1980 given:
    - L/W :: (1: circular spread, > 1: elliptical spread)
    """
    return sqrt((length_to_width_ratio * length_to_width_ratio) - 1.0) / length_to_width_ratio
#+end_src

*** Surface Fire Behavior in the Direction of Maximum Spread
    :PROPERTIES:
    :CUSTOM_ID: surface-fire-behavior-in-the-direction-of-maximum-spread
    :END:

This section introduces a function that applies the effects of wind
and slope to the no-wind-no-slope surface fire behavior values
produced in section [[Surface Fire Behavior Functions (No Wind No
Slope)]], in order to compute the maximum surface fire behavior values
associated with a head fire.

A noteworthy decision for users is whether or not to limit the
effective wind speed $U_{\text{eff}}$ in these calculations.

Rothermel 1972 defines a maximum effective wind speed, above which the
predicted spread rate and intensity remains constant. However, a 2013
publication by Andrews et al recommends instead that this wind speed
limit not be imposed, in order to avoid possible spread rate
underprediction.[fn::Rothermel1972][fn::Andrews2013]

In order to support both use cases, the
=calc_surface_fire_behavior_max= function includes an optional
=use_wind_limit= argument that can be used to toggle this limit on or
off.

#+NAME: surface-fire-behavior-max
#+begin_src python
@cy.cfunc
@cy.exceptval(check=False)
def maybe_limit_wind_speed(use_wind_limit  : cy.bint,
                           max_wind_speed  : cy.float,
                           surface_fire_min: FireBehaviorMin,
                           phi_E_magnitude : cy.float) -> tuple[cy.float, cy.float]:
    """
    Given these inputs:
    - use_wind_limit   :: boolean
    - max_wind_speed   :: m/min
    - surface_fire_min :: FireBehaviorMin struct of no-wind-no-slope surface fire behavior values
      - base_spread_rate         :: m/min
      - base_fireline_intensity  :: kW/m
      - max_effective_wind_speed :: m/min
      - _phiS_G                  :: intermediate value for computing phi_S (unitless)
      - _phiW_scalr              :: intermediate value for computing phi_W (unitless)
      - _phiW_expnt              :: intermediate value for computing phi_W (unitless)
      - _ws_scalr                :: intermediate value for computing effective_wind_speed (m/min)
      - _ws_expnt                :: intermediate value for computing effective_wind_speed (unitless)
    - phi_E_magnitude  :: unitless

    return a tuple with these fields:
    - limited_wind_speed :: m/min
    - limited_phi_E      :: unitless
    """
    effective_wind_speed: cy.float = get_wind_speed(surface_fire_min, phi_E_magnitude)
    if (use_wind_limit and effective_wind_speed > max_wind_speed):
        return (
            max_wind_speed,
            get_phi_W(surface_fire_min, max_wind_speed),
        )
    else:
        return (
            effective_wind_speed,
            phi_E_magnitude,
        )


@cy.cfunc
@cy.exceptval(check=False)
def calc_surface_fire_behavior_max(surface_fire_min      : FireBehaviorMin,
                                   midflame_wind_speed   : cy.float,
                                   upwind_direction      : cy.float,
                                   slope                 : cy.float,
                                   aspect                : cy.float,
                                   use_wind_limit        : cy.bint = True,
                                   surface_lw_ratio_model: str = "behave") -> FireBehaviorMax:
    """
    Given these inputs:
    - surface_fire_min       :: FireBehaviorMin struct of no-wind-no-slope surface fire behavior values
      - base_spread_rate         :: m/min
      - base_fireline_intensity  :: kW/m
      - max_effective_wind_speed :: m/min
      - _phiS_G                  :: intermediate value for computing phi_S (unitless)
      - _phiW_scalr              :: intermediate value for computing phi_W (unitless)
      - _phiW_expnt              :: intermediate value for computing phi_W (unitless)
      - _ws_scalr                :: intermediate value for computing effective_wind_speed (m/min)
      - _ws_expnt                :: intermediate value for computing effective_wind_speed (unitless)
    - midflame_wind_speed    :: m/min
    - upwind_direction       :: degrees clockwise from North
    - slope                  :: rise/run
    - aspect                 :: degrees clockwise from North
    - use_wind_limit         :: boolean (Optional)
    - surface_lw_ratio_model :: "rothermel" or "behave" (Optional)

    return a FireBehaviorMax struct containing these keys:
    - max_fire_type          :: 1 (surface)
    - max_spread_rate        :: m/min
    - max_spread_direction   :: (x, y, z) unit vector
    - max_fireline_intensity :: kW/m
    - max_flame_length       :: m
    - length_to_width_ratio  :: unitless (1: circular spread, > 1: elliptical spread)
    - eccentricity           :: unitless (0: circular spread, > 0: elliptical spread)
    - critical_spread_rate   :: m/min
    """
    # Unpack no-wind-no-slope surface fire behavior values
    spread_rate       : cy.float = surface_fire_min.base_spread_rate
    fireline_intensity: cy.float = surface_fire_min.base_fireline_intensity
    max_wind_speed    : cy.float = surface_fire_min.max_effective_wind_speed
    # Reverse the provided wind and slope directions
    downwind_direction: cy.float = conv.opposite_direction(upwind_direction)
    upslope_direction : cy.float = conv.opposite_direction(aspect)
    # Project wind and slope vectors onto the slope-tangential plane
    vectors        : ProjectedVectors = project_wind_and_slope_vectors_3d(midflame_wind_speed,
                                                                          downwind_direction,
                                                                          slope,
                                                                          upslope_direction)
    wind_vector_3d : vec_xyz = vectors.wind_vector_3d  # m/min
    slope_vector_3d: vec_xyz = vectors.slope_vector_3d # rise/run
    # Calculate phi_W and phi_S
    # NOTE: |wind_vector_3d| = slope-aligned midflame wind speed
    phi_W: cy.float = get_phi_W(surface_fire_min, vu.vector_magnitude_3d(wind_vector_3d))
    phi_S: cy.float = get_phi_S(surface_fire_min, slope)
    # Calculate phi_E and the max_spread_direction
    phi_E_3d: vec_xyz  = get_phi_E(wind_vector_3d, slope_vector_3d, phi_W, phi_S)
    phi_E   : cy.float = vu.vector_magnitude_3d(phi_E_3d)
    max_spread_direction: vec_xyz
    if phi_E > 0.0:
        max_spread_direction = vu.as_unit_vector_3d(phi_E_3d)
    elif phi_S > 0.0:
        max_spread_direction = vu.as_unit_vector_3d(slope_vector_3d)
    else:
        max_spread_direction = (0.0, 1.0, 0.0) # default: North
    # Limit effective wind speed to max wind speed if use_wind_limit == True
    (limited_wind_speed, limited_phi_E) = maybe_limit_wind_speed(use_wind_limit,
                                                                 max_wind_speed,
                                                                 surface_fire_min,
                                                                 phi_E)
    # Calculate and return max surface fire behavior values
    max_spread_rate       : cy.float = spread_rate * (1.0 + limited_phi_E)
    max_fireline_intensity: cy.float = fireline_intensity * (1.0 + limited_phi_E)
    length_to_width_ratio : cy.float = surface_length_to_width_ratio(limited_wind_speed, surface_lw_ratio_model)
    return FireBehaviorMax(
        max_fire_type          = 1,
        max_spread_rate        = max_spread_rate,
        max_spread_direction   = max_spread_direction,
        max_fireline_intensity = max_fireline_intensity,
        max_flame_length       = calc_flame_length(max_fireline_intensity),
        length_to_width_ratio  = length_to_width_ratio,
        eccentricity           = surface_fire_eccentricity(length_to_width_ratio),
        critical_spread_rate   = 0.0,
    )
#+end_src

*** Surface Fire Behavior in Any Direction
    :PROPERTIES:
    :CUSTOM_ID: surface-fire-behavior-in-any-direction
    :END:

Once we have calculated the maximum surface fire behavior values
associated with a head fire, we can use the elliptical eccentricity
$E$ to project the maximum spread rate $R_s$ and maximum fireline
intensity $I_s$ to any point along the fire front as follows:

\begin{align}
  \eta &= \frac{1-E}{1-E\cos\omega} \\
  \nonumber \\
  R_s(\omega) &= R_s \, \eta \\
  \nonumber \\
  I_s(\omega) &= I_s \, \eta
\end{align}

where $\omega$ is the angular offset from the direction of maximum
fire spread and $R_s(\omega)$ and $I_s(\omega)$ are the spread rate
and fireline intensity in this direction respectively.

Since the surface fire ellipse is defined on the slope-tangential
plane, we must represent spread directions with three dimensional unit
vectors aligned with this plane rather than with angles. Fortunately,
we can use the relationship between the dot product of two vectors and
the cosine of the angle between them to rewrite the $\eta$ function
above as follows:

\begin{align}
  \eta = \frac{1-E}{1-E(\vec{u_{\max}} \cdot \vec{u_{\omega}})}
\end{align}

where $\vec{u_{\max}}$ is the slope-tangential unit vector in the
direction of maximum spread and $\vec{u_{\omega}}$ is the
slope-tangential unit vector rotated $\omega$ degrees clockwise along
this plane from $\vec{u_{\max}}$.

#+NAME: surface-fire-behavior-in-direction
#+begin_src python
@cy.cfunc
@cy.exceptval(check=False)
def calc_surface_fire_behavior_in_direction(surface_fire_max: FireBehaviorMax,
                                            spread_direction: vec_xyz) -> SpreadBehavior:
    """
    Given these inputs:
    - surface_fire_max     :: FireBehaviorMax struct of max surface fire behavior values
      - max_fire_type          :: 1 (surface)
      - max_spread_rate        :: m/min
      - max_spread_direction   :: (x, y, z) unit vector
      - max_fireline_intensity :: kW/m
      - max_flame_length       :: m
      - length_to_width_ratio  :: unitless (1: circular spread, > 1: elliptical spread)
      - eccentricity           :: unitless (0: circular spread, > 0: elliptical spread)
      - critical_spread_rate   :: m/min
    - spread_direction     :: 3D unit vector on the slope-tangential plane

    return a SpreadBehavior struct containing these keys:
    - dphi_dt            :: phi/min
    - fire_type          :: 1 (surface)
    - spread_rate        :: m/min
    - spread_direction   :: (x, y, z) unit vector
    - fireline_intensity :: kW/m
    - flame_length       :: m
    """
    # Unpack max surface fire behavior values
    max_spread_rate       : cy.float = surface_fire_max.max_spread_rate
    max_spread_direction  : vec_xyz  = surface_fire_max.max_spread_direction
    max_fireline_intensity: cy.float = surface_fire_max.max_fireline_intensity
    eccentricity          : cy.float = surface_fire_max.eccentricity
    # Calculate cos(w), where w is the offset angle between these unit vectors on the slope-tangential plane
    cos_w: cy.float = vu.dot_3d(max_spread_direction, spread_direction)
    # Calculate adjustment due to the offset angle from the max spread direction
    adjustment: cy.float = (1.0 - eccentricity) / (1.0 - eccentricity * cos_w)
    # Update surface fire behavior values by the adjustment value
    fireline_intensity: cy.float = max_fireline_intensity * adjustment
    return SpreadBehavior(
        dphi_dt            = 0.0,
        fire_type          = 1, # surface
        spread_rate        = max_spread_rate * adjustment,
        spread_direction   = spread_direction,
        fireline_intensity = fireline_intensity,
        flame_length       = calc_flame_length(fireline_intensity),
    )
#+end_src

** For Users
   :PROPERTIES:
   :CUSTOM_ID: for-users-surface
   :header-args:python+: :session *examples:pyretechnics.surface_fire*
   :header-args:python+: :results output replace
   :header-args:python+: :exports both
   :END:

In the following sections, we will demonstrate how to calculate the
surface fire behavior values given a fuel model and measurements of
fuel moisture, wind speed, wind direction, slope, and aspect. This
will be done first for the no-wind-no-slope case, followed by the max
spread direction case, and finally in any direction on the sloped
surface using both offset angles from the heading fire direction and
3D vectors specifying absolute directions.

Because wind speed and direction will often be provided from
measurements taken 10m or 20ft above the canopy and may be given in
either cartesion =(x,y)= or azimuthal =(r,azimuth)= coordinates, we
also demonstrate how to convert from cartesian to azimuthal
coordinates, from 10m to 20ft wind speeds, and from 20ft to midflame
wind speeds, given a fuel model and measurements of canopy height and
canopy cover.

See Appendix [[Units Conversion Functions (pyretechnics.conversion)]] for
the full list of available units conversion functions.

See Appendix [[Vector Utility Functions (pyretechnics.vector_utils)]] for
the full list of available vector manipulation functions.

*** How to Calculate the No-Wind-No-Slope Surface Fire Behavior
    :PROPERTIES:
    :CUSTOM_ID: how-to-calculate-the-no-wind-no-slope-surface-fire-behavior
    :END:

#+NAME: compute-surface-fire-behavior-min
#+begin_src python
from pprint import pprint
import pyretechnics.fuel_models as fm
import pyretechnics.surface_fire as sf

# Set input parameters
fuel_model    = fm.fuel_model_table[101] # GR1
fuel_moisture = [
    0.05, # dead_1hr
    0.10, # dead_10hr
    0.15, # dead_100hr
    0.00, # dead_herbaceous (will be set by moisturize for dynamic fuel models)
    0.90, # live_herbaceous
    0.60, # live_woody
]

# Apply fuel moisture to fuel model
moisturized_fuel_model = fm.moisturize(fuel_model, fuel_moisture)

# Calculate no-wind-no-slope surface fire behavior
surface_fire_min = sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model)

# View results
print("No-Wind-No-Slope Surface Fire Behavior for Fuel Model GR1 with Fuel Moisture = "
      + str(moisturized_fuel_model["M_f"]))
pprint({k: surface_fire_min[k] for k in ["base_spread_rate", "base_fireline_intensity", "max_effective_wind_speed"]})
#+end_src

#+NAME: compute-surface-fire-behavior-min-results
#+RESULTS: compute-surface-fire-behavior-min
: No-Wind-No-Slope Surface Fire Behavior for Fuel Model GR1 with Fuel Moisture = [0.05, 0.1, 0.15, 0.05, 0.9, 0.6]
: {'base_fireline_intensity': 1.7899978160858154,
:  'base_spread_rate': 0.12637238204479218,
:  'max_effective_wind_speed': 109.7729263305664}

*** How to Translate the 10m Wind Speed Vector into the Midflame Wind Speed Vector
    :PROPERTIES:
    :CUSTOM_ID: how-to-translate-the-10m-wind-speed-vector-into-the-midflame-wind-speed-vector
    :END:

#+NAME: translate-10m-wind-to-midflame-wind
#+begin_src python
import pyretechnics.conversion as conv
import pyretechnics.fuel_models as fm
import pyretechnics.surface_fire as sf

# Set input parameters
fuel_model       = fm.fuel_model_table[101] # GR1
canopy_height    = 20                       # meters
canopy_cover     = 0.6                      # 0-1
wind_speed_10m   = 20                       # km/hr
upwind_direction = 45.0                     # degrees clockwise from North

# Convert from 10m wind speed to 20ft wind speed
wind_speed_20ft = conv.wind_speed_10m_to_wind_speed_20ft(wind_speed_10m) # km/hr

# Convert from 20ft wind speed to midflame wind speed in m/min
midflame_wind_speed = sf.calc_midflame_wind_speed(conv.km_hr_to_m_min(wind_speed_20ft), # m/min
                                                  fuel_model["delta"],                  # ft
                                                  conv.m_to_ft(canopy_height),          # ft
                                                  canopy_cover)                         # 0-1

# View results
print("Midflame Wind Speed and Direction for 10m Wind Speed = 20 km/hr, Upwind Direction = 45.0\n"
      + " with Fuel Model GR1, Canopy Height = 20m, and Canopy Cover = 60%\n"
      + "- Speed: " + str(midflame_wind_speed) + " (m/min)\n"
      + "- Downwind Direction: " + str(conv.opposite_direction(upwind_direction)) + " (degrees clockwise from North)")
#+end_src

#+NAME: translate-10m-wind-to-midflame-wind-results
#+RESULTS: translate-10m-wind-to-midflame-wind
: Midflame Wind Speed and Direction for 10m Wind Speed = 20 km/hr, Upwind Direction = 45.0
:  with Fuel Model GR1, Canopy Height = 20m, and Canopy Cover = 60%
: - Speed: 27.22428573967944 (m/min)
: - Downwind Direction: 225.0 (degrees clockwise from North)

*** How to Calculate the Surface Fire Behavior in the Direction of Maximum Spread
    :PROPERTIES:
    :CUSTOM_ID: how-to-calculate-the-surface-fire-behavior-in-the-direction-of-maximum-spread
    :END:

#+NAME: compute-surface-fire-behavior-max
#+begin_src python
from pprint import pprint
import pyretechnics.fuel_models as fm
import pyretechnics.surface_fire as sf

# Set input parameters
fuel_model    = fm.fuel_model_table[101] # GR1
fuel_moisture = [
    0.05, # dead_1hr
    0.10, # dead_10hr
    0.15, # dead_100hr
    0.00, # dead_herbaceous (will be set by moisturize for dynamic fuel models)
    0.90, # live_herbaceous
    0.60, # live_woody
]
midflame_wind_speed = 500.0 # m/min
upwind_direction    = 215.0 # degrees clockwise from North
slope               = 0.2   # rise/run
aspect              = 270.0 # degrees clockwise from North

# Apply fuel moisture to fuel model
moisturized_fuel_model = fm.moisturize(fuel_model, fuel_moisture)

# Calculate no-wind-no-slope surface fire behavior
surface_fire_min = sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model)

# Calculate surface fire behavior in the direction of maximum spread with effective wind speed limit
surface_fire_max = sf.calc_surface_fire_behavior_max(surface_fire_min,
                                                     midflame_wind_speed,
                                                     upwind_direction,
                                                     slope,
                                                     aspect)

# View results
print("Surface Fire Behavior Max (Limited) for Fuel Model GR1 with Fuel Moisture = "
      + str(moisturized_fuel_model["M_f"]))
pprint(surface_fire_max)

# Calculate surface fire behavior in the direction of maximum spread without effective wind speed limit
surface_fire_max_unlimited = sf.calc_surface_fire_behavior_max(surface_fire_min,
                                                               midflame_wind_speed,
                                                               upwind_direction,
                                                               slope,
                                                               aspect,
                                                               use_wind_limit=False)

# View results
print("\nSurface Fire Behavior Max (Unlimited) for Fuel Model GR1 with Fuel Moisture = "
      + str(moisturized_fuel_model["M_f"]))
pprint(surface_fire_max_unlimited)
#+end_src

#+NAME: compute-surface-fire-behavior-max-results
#+RESULTS: compute-surface-fire-behavior-max
#+begin_example
Surface Fire Behavior Max (Limited) for Fuel Model GR1 with Fuel Moisture = [0.05, 0.1, 0.15, 0.05, 0.9, 0.6]
{'eccentricity': 0.8693098689345452,
 'length_to_width_ratio': 2.02319598197937,
 'max_fireline_intensity': 32.52824021555232,
 'max_flame_length': 0.384393279547724,
 'max_spread_direction': array([0.57514209, 0.80992591, 0.11502841]),
 'max_spread_rate': 2.2964671592467902}

Surface Fire Behavior Max (Unlimited) for Fuel Model GR1 with Fuel Moisture = [0.05, 0.1, 0.15, 0.05, 0.9, 0.6]
{'eccentricity': 0.9845208635180694,
 'length_to_width_ratio': 5.705566883087158,
 'max_fireline_intensity': 330.52327700735987,
 'max_flame_length': 1.116783188433671,
 'max_spread_direction': array([0.57514209, 0.80992591, 0.11502841]),
 'max_spread_rate': 23.334673071281713}
#+end_example

*** How to Calculate the Surface Fire Behavior in Any Direction
    :PROPERTIES:
    :CUSTOM_ID: how-to-calculate-the-surface-fire-behavior-in-any-direction
    :END:

#+NAME: compute-surface-fire-behavior-in-direction
#+begin_src python
import numpy as np
from pprint import pprint
import pyretechnics.fuel_models as fm
import pyretechnics.surface_fire as sf
import pyretechnics.vector_utils as vu

# Set input parameters
fuel_model    = fm.fuel_model_table[101] # GR1
fuel_moisture = [
    0.05, # dead_1hr
    0.10, # dead_10hr
    0.15, # dead_100hr
    0.00, # dead_herbaceous (will be set by moisturize for dynamic fuel models)
    0.90, # live_herbaceous
    0.60, # live_woody
]
midflame_wind_speed = 500.0 # m/min
upwind_direction    = 215.0 # degrees clockwise from North
slope               = 0.2   # rise/run
aspect              = 270.0 # degrees clockwise from North

# Apply fuel moisture to fuel model
moisturized_fuel_model = fm.moisturize(fuel_model, fuel_moisture)

# Calculate no-wind-no-slope surface fire behavior
surface_fire_min = sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model)

# Calculate surface fire behavior in the direction of maximum spread with effective wind speed limit
surface_fire_max = sf.calc_surface_fire_behavior_max(surface_fire_min,
                                                     midflame_wind_speed,
                                                     upwind_direction,
                                                     slope,
                                                     aspect)

# Calculate surface fire behavior for the heading, flanking, and backing fires
heading_fire_direction  = surface_fire_max["max_spread_direction"]
# FIXME: Change upstream functions to return max_spread_direction as type vec_xyz
#        and change downstream functions to accept spread_direction as type vec_xyz
(dx, dy, dz)            = heading_fire_direction
flanking_fire_direction = np.asarray(vu.rotate_on_sloped_plane((dx, dy, dz), 90.0, slope, aspect))
backing_fire_direction  = np.asarray(vu.rotate_on_sloped_plane((dx, dy, dz), 180.0, slope, aspect))

heading_fire_behavior  = sf.calc_surface_fire_behavior_in_direction(surface_fire_max, heading_fire_direction)
flanking_fire_behavior = sf.calc_surface_fire_behavior_in_direction(surface_fire_max, flanking_fire_direction)
backing_fire_behavior  = sf.calc_surface_fire_behavior_in_direction(surface_fire_max, backing_fire_direction)

# View heading fire results
print("Heading Fire Behavior for Fuel Model GR1 with Fuel Moisture = "
      + str(moisturized_fuel_model["M_f"]))
pprint(heading_fire_behavior)

# View flanking fire results
print("\nFlanking Fire Behavior for Fuel Model GR1 with Fuel Moisture = "
      + str(moisturized_fuel_model["M_f"]))
pprint(flanking_fire_behavior)

# View backing fire results
print("\nBacking Fire Behavior for Fuel Model GR1 with Fuel Moisture = "
      + str(moisturized_fuel_model["M_f"]))
pprint(backing_fire_behavior)
#+end_src

#+NAME: compute-surface-fire-behavior-in-direction-results
#+RESULTS: compute-surface-fire-behavior-in-direction
#+begin_example
Heading Fire Behavior for Fuel Model GR1 with Fuel Moisture = [0.05, 0.1, 0.15, 0.05, 0.9, 0.6]
{'fire_type': 'surface',
 'fireline_intensity': 32.52822719177826,
 'flame_length': 0.38439320875152366,
 'spread_direction': array([0.57514209, 0.80992591, 0.11502841]),
 'spread_rate': 2.2964662397789914}

Flanking Fire Behavior for Fuel Model GR1 with Fuel Moisture = [0.05, 0.1, 0.15, 0.05, 0.9, 0.6]
{'fire_type': 'surface',
 'fireline_intensity': 4.251119786484406,
 'flame_length': 0.15074657797968766,
 'spread_direction': array([ 0.79419774, -0.58653224,  0.15883955]),
 'spread_rate': 0.30012558057223193}

Backing Fire Behavior for Fuel Model GR1 with Fuel Moisture = [0.05, 0.1, 0.15, 0.05, 0.9, 0.6]
{'fire_type': 'surface',
 'fireline_intensity': 2.274165557579764,
 'flame_length': 0.1130509146666419,
 'spread_direction': array([-0.57514215, -0.80992585, -0.11502843]),
 'spread_rate': 0.16055422866605315}
#+end_example

* Crown Fire Equations (pyretechnics.crown_fire)
  :PROPERTIES:
  :CUSTOM_ID: crown-fire-equations-(pyretechnics.crown_fire)
  :END:
** For Developers
   :PROPERTIES:
   :CUSTOM_ID: for-developers-crown
   :header-args:python+: :session *pyretechnics.crown_fire*
   :header-args:python+: :tangle  ../src/pyretechnics/crown_fire.py
   :header-args:python+: :exports code
   :END:

The following sections define functions that calculate the spread rate
and intensity of a fire burning through tree canopy fuels. These
functions combine the surface fire behavior values calculated in
section [[Surface Fire Equations (pyretechnics.surface_fire)]] with
measurements of foliar moisture, dead 1 hour fuel moisture, canopy
cover, canopy height, canopy base height, and canopy bulk density to
determine whether a surface fire will spread into either a passive or
active crown fire. If so, they can then calculate the maximum spread
rate and direction of this crown fire as well as its fireline
intensity and flame length.

*** Module Imports
    :PROPERTIES:
    :CUSTOM_ID: module-imports-crown-fire
    :END:

#+NAME: crown-fire-imports
#+begin_src python
import cython
import cython as cy
if cython.compiled:
    from cython.cimports.libc.math import sqrt, exp, pow
    from cython.cimports.pyretechnics.cy_types import \
        vec_xyz, ProjectedVectors, FireBehaviorMax, SpreadBehavior, CrownSpreadInfo
    import cython.cimports.pyretechnics.conversion as conv
    import cython.cimports.pyretechnics.vector_utils as vu
    import cython.cimports.pyretechnics.surface_fire as sf
else:
    from math import sqrt, exp, pow
    from pyretechnics.py_types import \
        vec_xyz, ProjectedVectors, FireBehaviorMax, SpreadBehavior, CrownSpreadInfo
    import pyretechnics.conversion as conv
    import pyretechnics.vector_utils as vu
    import pyretechnics.surface_fire as sf
#+end_src

*** Crown Fire Initiation
    :PROPERTIES:
    :CUSTOM_ID: crown-fire-initiation
    :END:

In order to incorporate the effects of crown fire behavior,
Pyretechnics includes the crown fire initiation routine from Van
Wagner 1977.[fn::VanWagner1977] According to this approach, we begin
by calculating the /critical fireline intensity/ as follows:

\begin{align}
  H &= 460 + 2600 M^f \\
  \nonumber \\
  I_s^* &= (0.01 \, Z_b \, H)^{1.5}
\end{align}

where $H$ is the heat of ignition for the herbaceous material in the
canopy in $\text{kJ/kg}$, $M^f$ is the foliar moisture content in
$\text{kg moisture/kg ovendry weight}$, $Z_b$ is the canopy base
height in meters, and $I_s^*$ is the critical fireline intensity in
$\text{kW/m}$.

#+NAME: van-wagner-critical-fireline-intensity
#+begin_src python
@cy.cfunc
@cy.exceptval(check=False)
def van_wagner_critical_fireline_intensity(canopy_base_height: cy.float, foliar_moisture: cy.float) -> cy.float:
    """
    Returns the critical fireline intensity (kW/m) given:
    - canopy_base_height :: m
    - foliar_moisture    :: kg moisture/kg ovendry weight

    Constants used:
    460.0 = heat-of-ignition :: kJ/kg
    0.01 = empirical estimate for C in Van Wagner 1977 (eq. 4)
    """
    H: cy.float = 460.0 + 2600.0 * foliar_moisture
    v: cy.float = 0.01 * canopy_base_height * H
    return v * sqrt(v) # NOTE: This is faster than pow(v, 1.5).
#+end_src

If a surface fire is present, the canopy cover is greater than 40%,
and the surface fireline intensity $I_s$ is greater than or equal to
the critical fireline intensity $I_s^*$, then the surface fire
transitions to a crown fire.

#+NAME: van-wagner-crown-fire-initiation
#+begin_src python
@cy.cfunc
@cy.exceptval(check=False)
def van_wagner_crowning_spread_rate(surface_fire_max  : FireBehaviorMax,
                                    canopy_base_height: cy.float,
                                    foliar_moisture   : cy.float) -> cy.float:
    """
    Returns the surface spread rate above which crown fire occurs (m/min) given:
    - surface_fire_max   :: FireBehaviorMax struct
    - canopy_base_height :: m
    - foliar_moisture    :: kg moisture/kg ovendry weight
    """
    surface_max_fireline_intensity: cy.float = surface_fire_max.max_fireline_intensity
    if surface_max_fireline_intensity > 0.0:
        surface_max_spread_rate    : cy.float = surface_fire_max.max_spread_rate
        critical_fireline_intensity: cy.float = van_wagner_critical_fireline_intensity(canopy_base_height,
                                                                                       foliar_moisture)
        return (surface_max_spread_rate * critical_fireline_intensity / surface_max_fireline_intensity)
    else:
        return 0.0


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def van_wagner_crown_fire_initiation(surface_fireline_intensity: cy.float,
                                     canopy_cover              : cy.float,
                                     canopy_base_height        : cy.float,
                                     foliar_moisture           : cy.float) -> cy.bint:
    """
    Returns True if the surface fire transitions to a crown fire or False otherwise given:
    - surface_fireline_intensity :: kW/m
    - canopy_cover               :: 0-1
    - canopy_base_height         :: m
    - foliar_moisture            :: kg moisture/kg ovendry weight
    """
    return (
        surface_fireline_intensity > 0.0
        and
        canopy_cover > 0.4
        and
        surface_fireline_intensity >= van_wagner_critical_fireline_intensity(canopy_base_height, foliar_moisture)
    )
#+end_src

*** Passive and Active Crown Fire Spread Rate Functions
    :PROPERTIES:
    :CUSTOM_ID: passive-and-active-crown-fire-spread-rate-functions
    :END:

If crowning occurs, then the active crown fire spread rate is
calculated from the following formula given in Cruz
2005:[fn::Cruz2005]

\begin{align}
  \text{CROS}_A = 11.02 \, U_{10\text{m}}^{0.90} \, B_m^{0.19} \, e^{-17 \, \text{EFFM}} \\
\end{align}

where $\text{CROS}_A$ is the active crown fire spread rate in
$\text{m}/\min$, $U_{10\text{m}}$ is the 10 meter windspeed in
$\text{km/hr}$, $B_m$ is the canopy bulk density in $\text{kg/m}^3$,
and $\text{EFFM}$ is the estimated fine fuel moisture in $\text{kg moisture/kg ovendry weight}$.

#+NAME: cruz-active-crown-fire-spread-rate
#+begin_src python
@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def cruz_active_crown_fire_spread_rate(wind_speed_10m              : cy.float,
                                       canopy_bulk_density         : cy.float,
                                       estimated_fine_fuel_moisture: cy.float) -> cy.float:
    """
    Returns the active crown fire spread rate (m/min) given:
    - wind_speed_10m                                   :: km/hr
    - canopy_bulk_density                              :: kg/m^3
    - estimated_fine_fuel_moisture (M_f[0] "dead-1hr") :: kg moisture/kg ovendry weight
    """
    return (11.02
            * pow(wind_speed_10m, 0.90)
            * pow(canopy_bulk_density, 0.19)
            * exp(-17.0 * estimated_fine_fuel_moisture))
#+end_src

Next, we need to calculate the /critical spread rate/ from Van Wagner
1977[fn::VanWagner1977] as follows:

\begin{align}
  R^* = \frac{3.0}{B_m}
\end{align}

where $R^*$ is the critical spread rate in $\text{m}/\min$ and $B_m$
is the canopy bulk density in $\text{kg/m}^3$.

#+NAME: van-wagner-critical-spread-rate
#+begin_src python
@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def van_wagner_critical_spread_rate(canopy_bulk_density: cy.float) -> cy.float:
    """
    Returns the critical spread rate (m/min) given:
    - canopy_bulk_density :: kg/m^3
    """
    return 3.0 / canopy_bulk_density
#+end_src

If the active crown fire spread rate $\text{CROS}_A$ is greater than
the critical spread rate $R^*$, then the crown fire will be active,
otherwise passive. In the event of a passive crown fire, its spread
rate is calculated using the following formula from Cruz
2005:[fn::Cruz2005]

\begin{align}
  \text{CROS}_P = \text{CROS}_A \, e^{-\text{CROS}_A / R^*}
\end{align}

where $\text{CROS}_P$ is the passive crown fire spread rate in
$\text{m}/\min$, $\text{CROS}_A$ is the active crown fire spread rate
in $\text{m}/\min$, and $R^*$ is the critical spread rate in
$\text{m}/\min$.

#+NAME: cruz-passive-crown-fire-spread-rate
#+begin_src python
@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def cruz_passive_crown_fire_spread_rate(active_spread_rate: cy.float, critical_spread_rate: cy.float) -> cy.float:
    """
    Returns the passive crown fire spread rate (m/min) given:
    - active_spread_rate   :: m/min
    - critical_spread_rate :: m/min
    """
    return active_spread_rate * exp(-active_spread_rate / critical_spread_rate)
#+end_src

Putting it all together, the following function calculates the
critical spread rate, whether a crown fire will become passive or
active, and its associated passive or active spread rate.

#+NAME: cruz-crown-fire-spread-info
#+begin_src python
@cy.cfunc
@cy.exceptval(check=False)
def cruz_crown_fire_spread_info(wind_speed_10m              : cy.float,
                                canopy_bulk_density         : cy.float,
                                estimated_fine_fuel_moisture: cy.float) -> CrownSpreadInfo:
    """
    Given these inputs:
    - wind_speed_10m                                   :: km/hr
    - canopy_bulk_density                              :: kg/m^3
    - estimated_fine_fuel_moisture (M_f[0] "dead-1hr") :: kg moisture/kg ovendry weight

    return a CrownSpreadInfo struct containing these keys:
    - fire_type            :: 2 (passive_crown) or 3 (active_crown)
    - spread_rate          :: m/min
    - critical_spread_rate :: m/min
    """
    active_spread_rate  : cy.float = cruz_active_crown_fire_spread_rate(wind_speed_10m,
                                                                        canopy_bulk_density,
                                                                        estimated_fine_fuel_moisture) # m/min
    critical_spread_rate: cy.float = van_wagner_critical_spread_rate(canopy_bulk_density) # m/min
    if (active_spread_rate > critical_spread_rate):
        return CrownSpreadInfo(
            fire_type            = 3, # FIXME: NAMED CONSTANT
            spread_rate          = active_spread_rate,
            critical_spread_rate = critical_spread_rate,
        )
    else:
        return CrownSpreadInfo(
            fire_type            = 2, # FIXME: NAMED CONSTANT
            spread_rate          = cruz_passive_crown_fire_spread_rate(active_spread_rate, critical_spread_rate),
            critical_spread_rate = critical_spread_rate,
        )
#+end_src

*** Crown Fire Intensity Functions
    :PROPERTIES:
    :CUSTOM_ID: crown-fire-intensity-functions
    :END:

Once the crown fire spread rate is determined, the crown fireline
intensity may be calculated using the following formula:

\begin{align}
  I_c = \frac{R_c \, B \, (Z - Z_b) \, h}{60}
\end{align}

where $I_c$ is the crown fireline intensity in $\text{Btu/ft/s}$,
$R_c$ is the crown fire spread rate (either $\text{CROS}_A$ or
$\text{CROS}_P$) in $\text{ft}/\min$, $B$ is the canopy bulk density
in $\text{lb/ft}^3$, $Z$ is the canopy height in $\text{ft}$, $Z_b$ is
the canopy base height in $\text{ft}$, and $h$ is the fuel model heat
of combustion (generally 8000 $\text{Btu/lb}$).

Note that $I_c$ is only the fireline intensity generated by the canopy
fuels under the influence of the crown fire spread rate $R_c$.
However, crown fires are typically coupled with the surface fires that
ignited them, and so the combined surface and crown fireline intensity
$I_{s+c}$ is typically the value that should be reported in most
analyses along with the combined surface and crown flame length
$L_{s+c}$. These terms are defined in section [[Combining Surface and
Crown Fire Behavior]].

#+NAME: crown-fireline-intensity
#+begin_src python
# NOTE: heat_of_combustion is h from the fuel models (generally 8000 Btu/lb).
# NOTE: ELMFIRE hard-codes heat_of_combustion to 18000 kJ/kg = 7738.6 Btu/lb.
@cy.cfunc
@cy.exceptval(check=False)
def calc_crown_fireline_intensity(crown_spread_rate  : cy.float,
                                  canopy_bulk_density: cy.float,
                                  canopy_height      : cy.float,
                                  canopy_base_height : cy.float,
                                  heat_of_combustion : cy.float) -> cy.float:
    """
    Returns the crown fireline intensity (Btu/ft/s OR kW/m) given:
    - crown_spread_rate   :: ft/min  OR m/min
    - canopy_bulk_density :: lb/ft^3 OR kg/m^3
    - canopy_height       :: ft      OR m
    - canopy_base_height  :: ft      OR m
    - heat_of_combustion  :: Btu/lb  OR kJ/kg

    (ft/min * lb/ft^3 * ft * Btu/lb)/60 = (Btu/ft/min)/60 = Btu/ft/s
    OR
    (m/min * kg/m^3 * m * kJ/kg)/60 = (kJ/m*min)/60 = kJ/m*s = kW/m
    """
    canopy_height_difference: cy.float = canopy_height - canopy_base_height
    return (crown_spread_rate * canopy_bulk_density * canopy_height_difference * heat_of_combustion) / 60.0
#+end_src

*** Crown Elliptical Eccentricity
    :PROPERTIES:
    :CUSTOM_ID: crown-elliptical-eccentricity
    :END:

As with surface fire spread, the wind speed (this time the 20-ft wind
speed $U_{20}$) is used to compute the length to width ratio
$\frac{L}{W}$ of an ellipse that approximates the crown fire front
using equation 10 from Rothermel 1991.[fn::Rothermel1991] This length
to width ratio is then converted into an eccentricity measure of the
ellipse using equation 8 from Albini and Chase 1980.[fn::Albini1980]
Here are the formulas used:

\begin{align}
  \frac{L}{W} &= 1 + 0.125 \, U_{20} \\
  \nonumber \\
  E &= \frac{\sqrt{(\frac{L}{W})^2 - 1}}{\frac{L}{W}}
\end{align}

where $U_{20}$ is the 20-ft wind speed in $\text{mph}$.

#+NAME: crown-fire-eccentricity
#+begin_src python
# Parameters for the linear model that computes LoW from wind speed.
LoW_intercept       = cy.declare(cy.float, 1.0)
LoW_slope_per_km_hr = cy.declare(cy.float, conv.km_hr_to_mph(0.125)) # The original formula used wind speeds in mph


@cy.cfunc
@cy.exceptval(check=False)
def crown_length_to_width_ratio(wind_speed_10m: cy.float, max_length_to_width_ratio: cy.float = 1e10) -> cy.float:
    """
    Calculate the length_to_width_ratio of the crown fire front using eq. 9 from
    Rothermel 1991 given:
    - wind_speed_10m            :: km/hr (aligned with the slope-tangential plane)
    - max_length_to_width_ratio :: float > 0.0 (Optional)
    """
    # FIXME: Why is wind speed not in SI units???
    length_to_width_ratio: cy.float = LoW_intercept + LoW_slope_per_km_hr * wind_speed_10m
    return min(length_to_width_ratio, max_length_to_width_ratio)


@cy.cfunc
@cy.exceptval(check=False)
def crown_fire_eccentricity(length_to_width_ratio: cy.float) -> cy.float:
    """
    Calculate the eccentricity (E) of the crown fire front using eq. 8 from
    Albini and Chase 1980 given:
    - length_to_width_ratio :: (1: circular spread, > 1: elliptical spread)
    """
    LoW2: cy.float = length_to_width_ratio * length_to_width_ratio
    return sqrt(LoW2 - 1.0) / length_to_width_ratio
#+end_src

*** Crown Fire Behavior in the Direction of Maximum Spread
    :PROPERTIES:
    :CUSTOM_ID: crown-fire-behavior-in-the-direction-of-maximum-spread
    :END:

This section introduces a function that computes all of the crown fire
behavior values described in the previous sections. In order to
accurately compare the crown fire behavior values from this section
with the surface fire behavior values from section [[Surface Fire
Behavior in the Direction of Maximum Spread]], the 10 meter wind vector
must be projected onto the slope-tangential plane (using Waeselynck
2024[fn::Waeselynck2024]) before the crown fire's maximum spread rate
and associated elliptical parameters are calculated. This ensures that
both the surface fire and crown fire ellipses are aligned with the
slope-tangential plane for later comparison in section [[Combining
Surface and Crown Fire Behavior]].

#+NAME: crown-fire-behavior-max
#+begin_src python
@cy.cfunc
@cy.exceptval(check=False)
def calc_crown_fire_behavior_max(canopy_height               : cy.float,
                                 canopy_base_height          : cy.float,
                                 canopy_bulk_density         : cy.float,
                                 heat_of_combustion          : cy.float,
                                 estimated_fine_fuel_moisture: cy.float,
                                 wind_speed_10m              : cy.float,
                                 upwind_direction            : cy.float,
                                 slope                       : cy.float,
                                 aspect                      : cy.float,
                                 crown_max_lw_ratio          : cy.float=1e10) -> FireBehaviorMax:
    """
    Given these inputs:
    - canopy_height                                    :: m
    - canopy_base_height                               :: m
    - canopy_bulk_density                              :: kg/m^3
    - heat_of_combustion                               :: kJ/kg
    - estimated_fine_fuel_moisture (M_f[0] "dead-1hr") :: kg moisture/kg ovendry weight
    - wind_speed_10m                                   :: km/hr
    - upwind_direction                                 :: degrees clockwise from North
    - slope                                            :: rise/run
    - aspect                                           :: degrees clockwise from North
    - crown_max_lw_ratio                               :: float > 0.0 (Optional)

    return a FireBehaviorMax struct containing these keys:
    - max_fire_type          :: 2 (passive_crown) or 3 (active_crown)
    - max_spread_rate        :: m/min
    - max_spread_direction   :: (x, y, z) unit vector
    - max_fireline_intensity :: kW/m
    - max_flame_length       :: m
    - length_to_width_ratio  :: unitless (1: circular spread, > 1: elliptical spread)
    - eccentricity           :: unitless (0: circular spread, > 0: elliptical spread)
    - critical_spread_rate   :: m/min
    """
    # Reverse the provided wind and slope directions
    downwind_direction: cy.float = conv.opposite_direction(upwind_direction)
    upslope_direction : cy.float = conv.opposite_direction(aspect)
    # Project wind and slope vectors onto the slope-tangential plane
    # FIXME: Let's just have these vectors as arguments to the function instead of re-computing them.
    vectors: ProjectedVectors = sf.project_wind_and_slope_vectors_3d(wind_speed_10m, downwind_direction,
                                                                     slope, upslope_direction)
    wind_vector_3d : vec_xyz = vectors.wind_vector_3d  # km/hr
    slope_vector_3d: vec_xyz = vectors.slope_vector_3d # rise/run
    # Determine the max spread direction
    wind_speed_10m_3d: cy.float = vu.vector_magnitude_3d(wind_vector_3d) # km/hr
    max_spread_direction: vec_xyz
    if wind_speed_10m_3d > 0.0:
        max_spread_direction = vu.as_unit_vector_3d(wind_vector_3d)  # unit vector in the 3D downwind direction
    elif slope > 0.0:
        max_spread_direction = vu.as_unit_vector_3d(slope_vector_3d) # unit vector in the 3D upslope direction
    else:
        max_spread_direction = (0.0, 1.0, 0.0)                       # default: North
    # Calculate the crown fire behavior in the max spread direction
    spread_info          : CrownSpreadInfo = cruz_crown_fire_spread_info(wind_speed_10m_3d,
                                                                         canopy_bulk_density,
                                                                         estimated_fine_fuel_moisture)
    spread_rate          : cy.float        = spread_info.spread_rate                           # m/min
    fireline_intensity   : cy.float        = calc_crown_fireline_intensity(spread_rate,
                                                                           canopy_bulk_density,
                                                                           canopy_height,
                                                                           canopy_base_height,
                                                                           heat_of_combustion) # kW/m
    length_to_width_ratio: cy.float        = crown_length_to_width_ratio(wind_speed_10m_3d,
                                                                         crown_max_lw_ratio)   # unitless
    eccentricity         : cy.float        = crown_fire_eccentricity(length_to_width_ratio)    # unitless
    return FireBehaviorMax(
        max_fire_type          = spread_info.fire_type,
        max_spread_rate        = spread_rate,
        max_spread_direction   = max_spread_direction, # unit vector
        max_fireline_intensity = fireline_intensity,
        max_flame_length       = 0.0, # NOTE: max_flame_length is not provided, as in the original unoptimized code.
        length_to_width_ratio  = length_to_width_ratio,
        eccentricity           = eccentricity,
        critical_spread_rate   = spread_info.critical_spread_rate,
    )
#+end_src

*** Crown Fire Behavior in Any Direction
    :PROPERTIES:
    :CUSTOM_ID: crown-fire-behavior-in-any-direction
    :END:

Once we have calculated the maximum crown fire behavior values
associated with a head fire, we can use the elliptical eccentricity
$E$ to project the maximum spread rate $R_c$ and maximum fireline
intensity $I_c$ to any point along the fire front as follows:

\begin{align}
  \eta &= \frac{1-E}{1-E\cos\omega} \\
  \nonumber \\
  R_c(\omega) &= R_c \, \eta \\
  \nonumber \\
  I_c(\omega) &= I_c \, \eta
\end{align}

where $\omega$ is the angular offset from the direction of maximum
fire spread and $R_c(\omega)$ and $I_c(\omega)$ are the spread rate
and fireline intensity in this direction respectively.

Since the crown fire ellipse is defined on the slope-tangential plane,
we must represent spread directions with three dimensional unit
vectors aligned with this plane rather than with angles. Fortunately,
we can use the relationship between the dot product of two vectors and
the cosine of the angle between them to rewrite the $\eta$ function
above as follows:

\begin{align}
  \eta = \frac{1-E}{1-E(\vec{u_{\max}} \cdot \vec{u_{\omega}})}
\end{align}

where $\vec{u_{\max}}$ is the slope-tangential unit vector in the
direction of maximum spread and $\vec{u_{\omega}}$ is the
slope-tangential unit vector rotated $\omega$ degrees clockwise along
this plane from $\vec{u_{\max}}$.

#+NAME: crown-fire-behavior-in-direction
#+begin_src python
@cy.cfunc
@cy.exceptval(check=False)
def calc_crown_fire_behavior_in_direction(crown_fire_max  : FireBehaviorMax,
                                          spread_direction: vec_xyz) -> SpreadBehavior:
    """
    Given these inputs:
    - crown_fire_max     :: a FireBehaviorMax struct of max crown fire behavior values
      - max_fire_type          :: 2 (passive_crown) or 3 (active_crown)
      - max_spread_rate        :: m/min
      - max_spread_direction   :: (x, y, z) unit vector
      - max_fireline_intensity :: kW/m
      - max_flame_length       :: m
      - length_to_width_ratio  :: unitless (1: circular spread, > 1: elliptical spread)
      - eccentricity           :: unitless (0: circular spread, > 0: elliptical spread)
      - critical_spread_rate   :: m/min
    - spread_direction   :: 3D unit vector on the slope-tangential plane

    return a SpreadBehavior struct containing these keys:
    - dphi_dt            :: phi/min
    - fire_type          :: 2 (passive_crown) or 3 (active_crown)
    - spread_rate        :: m/min
    - spread_direction   :: (x, y, z) unit vector
    - fireline_intensity :: kW/m
    - flame_length       :: m
    """
    # Unpack max crown fire behavior values
    max_fire_type         : cy.int   = crown_fire_max.max_fire_type
    max_spread_rate       : cy.float = crown_fire_max.max_spread_rate
    max_spread_direction  : vec_xyz  = crown_fire_max.max_spread_direction
    max_fireline_intensity: cy.float = crown_fire_max.max_fireline_intensity
    eccentricity          : cy.float = crown_fire_max.eccentricity
    critical_spread_rate  : cy.float = crown_fire_max.critical_spread_rate
    # Calculate cos(w), where w is the offset angle between these unit vectors on the slope-tangential plane
    cos_w: cy.float = vu.dot_3d(max_spread_direction, spread_direction)
    # Calculate adjustment due to the offset angle from the max spread direction
    adjustment: cy.float = (1.0 - eccentricity) / (1.0 - eccentricity * cos_w)
    # Adjust the spread rate (possibly switching from an active to passive crown fire)
    spread_rate: cy.float = max_spread_rate * adjustment
    if spread_rate > critical_spread_rate:
        # Max spread rate was active and directional spread rate remains active
        return SpreadBehavior(
            dphi_dt            = 0.0,
            fire_type          = 3, # active_crown
            spread_rate        = spread_rate,
            spread_direction   = spread_direction,
            fireline_intensity = max_fireline_intensity * adjustment,
            flame_length       = 0.0,
        )
    elif max_fire_type == 2: # passive_crown
        # Max spread rate was passive and directional spread rate remains passive
        return SpreadBehavior(
            dphi_dt            = 0.0,
            fire_type          = 2, # passive_crown
            spread_rate        = spread_rate,
            spread_direction   = spread_direction,
            fireline_intensity = max_fireline_intensity * adjustment,
            flame_length       = 0.0,
        )
    else:
        # Max spread rate was active and directional spread rate has become passive
        return SpreadBehavior(
            dphi_dt            = 0.0,
            fire_type          = 2, # passive_crown
            spread_rate        = cruz_passive_crown_fire_spread_rate(spread_rate, critical_spread_rate),
            spread_direction   = spread_direction,
            fireline_intensity = max_fireline_intensity * adjustment,
            flame_length       = 0.0,
        )
#+end_src

*** Combining Surface and Crown Fire Behavior
    :PROPERTIES:
    :CUSTOM_ID: combining-surface-and-crown-fire-behavior
    :END:

When both surface fire and crown fire are present in the same
location, their combined behavior determines the fire type, spread
rate and direction, fireline intensity, and flame length values
associated with this location.

*Note:* Since the surface fire and crown fire each define separate
fire spread ellipses with potentially different maximum spread
directions, their relative spread rates and intensities should only be
compared in a given absolute direction in the slope-tangential plane.
In most applications, this will be the direction normal to the fire
front.

**** Combined Fire Type
     :PROPERTIES:
     :CUSTOM_ID: combined-fire-type
     :END:

The fire type associated with the combined fire is the crown fire
type, either "passive_crown" or "active_crown".

**** Combined Spread Rate and Direction
     :PROPERTIES:
     :CUSTOM_ID: combined-spread-rate-and-direction
     :END:

The combined spread rate $R_{s+c}$ (in $\text{m}/\text{min}$) is
defined to be the maximum of the surface spread rate $R_s$ and the
crown spread rate $R_c$ as follows:

\begin{align}
  R_{s+c} = \max(R_s, R_c)
\end{align}

The combined spread direction is the spread direction associated with
whichever fire front has the fastest spread rate.

**** Combined Fireline Intensity
     :PROPERTIES:
     :CUSTOM_ID: combined-fireline-intensity
     :END:

Combining surface and crown fireline intensities is slightly more
complicated. From section [[Surface Fire Intensity Functions]], we can see
the following relationship between the surface fire spread rate $R_s$
(in $\text{m}/\text{min}$), the surface fireline intensity $I_s$ (in
$\text{kW}/\text{m}$), and the heat per unit area of the burning
surface fuel $H_s$ (in $\text{kJ}/\text{m}^2$), which we here
generalize to calculate the heat per unit area of a crown fire $H_c$
and a combined surface and crown fire $H_{s+c}$:

\begin{align}
  H_s &= 60 \frac{I_s}{R_s} \\
  \nonumber \\
  H_c &= 60 \frac{I_c}{R_c} \\
  \nonumber \\
  H_{s+c} &= 60 \frac{I_{s+c}}{R_{s+c}} \\
\end{align}

When surface and canopy fuels both burn in the same area, their
combined heat per unit area $H_{s+c}$ is their sum:

\begin{align}
  H_{s+c} = H_s + H_c = 60 \left(\frac{I_s}{R_s} + \frac{I_c}{R_c}\right)
\end{align}

Equating the two definitions for $H_{s+c}$ above gives us the
following definition for the combined fireline intensity $I_{s+c}$ (in
$\text{kW}/\text{m}$):

\begin{align}
  I_{s+c} = R_{s+c} \left(\frac{I_s}{R_s} + \frac{I_c}{R_c}\right)
\end{align}

Substituting in the definition of $R_{s+c}$ gives us this piecewise
formula:

\begin{align}
  I_{s+c} &= \left\{
    \begin{array}{lr}
      I_s + I_c \frac{R_s}{R_c} & \text{when}\ R_s > R_c \\
      I_s \frac{R_c}{R_s} + I_c & \text{when}\  R_s < R_c \\
      I_s + I_c & \text{when}\ R_s = R_c \\
    \end{array}
  \right. \\
\end{align}

Some fire behavior models have calculated the combined fireline
intensity by simply adding the surface and crown fireline intensities
together as we do in the $R_s = R_c$ case above. However, that would
misrepresent the physical behavior of the combined fire whenever $R_s
\neq R_c$. For example, when the crown fire makes the fire front
spread faster, then the surface fireline intensity is amplified due to
more surface fuel burning simultaneously (i.e., greater flame depth).
Similarly, if the surface fire outpaces the crown fire, then it can
ignite a longer span of canopy fuels as it progresses, thereby
increasing the flame depth and fireline intensity of the crown fire in
the direction normal to the fire perimeter. The piecewise definition
of $I_{s+c}$ above accounts for this co-amplification behavior.

**** Combined Flame Length
     :PROPERTIES:
     :CUSTOM_ID: combined-flame-length
     :END:

The combined flame length $L_{s+c}$ (in meters) is the flame length of
the combined fireline intensity $I_{s+c}$ (in $\text{kW}/\text{m}$) as
follows:

\begin{align}
  L_{s+c} = 0.07747042253266703 (I_{s+c})^{0.46}
\end{align}

**** Combined Fire Behavior Implementation
     :PROPERTIES:
     :CUSTOM_ID: combined-fire-behavior-implementation
     :END:

#+NAME: combined-fire-behavior
#+begin_src python
@cy.cfunc
@cy.exceptval(check=False)
def calc_combined_fire_behavior(surface_fire_behavior: SpreadBehavior,
                                crown_fire_behavior  : SpreadBehavior) -> SpreadBehavior:
    """
    Given these inputs:
    - surface_fire_behavior :: a SpreadBehavior struct of surface fire behavior values
      - dphi_dt                :: phi/min
      - fire_type              :: 1 (surface)
      - spread_rate            :: m/min
      - spread_direction       :: (x, y, z) unit vector
      - fireline_intensity     :: kW/m
      - flame_length           :: m
    - crown_fire_behavior   :: a SpreadBehavior struct of crown fire behavior values
      - dphi_dt                :: phi/min
      - fire_type              :: 2 (passive_crown) or 3 (active_crown)
      - spread_rate            :: m/min
      - spread_direction       :: (x, y, z) unit vector
      - fireline_intensity     :: kW/m
      - flame_length           :: m

    return a SpreadBehavior struct containing these keys:
    - dphi_dt            :: phi/min
    - fire_type          :: 1 (surface), 2 (passive_crown), or 3 (active_crown)
    - spread_rate        :: m/min
    - spread_direction   :: (x, y, z) unit vector
    - fireline_intensity :: kW/m
    - flame_length       :: m
    """
    # Unpack the surface fire behavior values
    surface_dphi_dt           : cy.float = surface_fire_behavior.dphi_dt            # phi/min
    surface_spread_rate       : cy.float = surface_fire_behavior.spread_rate        # m/min
    surface_spread_direction  : vec_xyz  = surface_fire_behavior.spread_direction   # (x, y, z) unit vector
    surface_fireline_intensity: cy.float = surface_fire_behavior.fireline_intensity # kW/m
    surface_flame_length      : cy.float = surface_fire_behavior.flame_length       # m
    # Unpack the crown fire behavior values
    crown_dphi_dt           : cy.float = crown_fire_behavior.dphi_dt            # phi/min
    crown_fire_type         : cy.int   = crown_fire_behavior.fire_type          # 2 (passive_crown) or 3 (active_crown)
    crown_spread_rate       : cy.float = crown_fire_behavior.spread_rate        # m/min
    crown_spread_direction  : vec_xyz  = crown_fire_behavior.spread_direction   # (x, y, z) unit vector
    crown_fireline_intensity: cy.float = crown_fire_behavior.fireline_intensity # kW/m
    # Select the most quickly changing (i.e., lowest) dphi_dt value
    dphi_dt: cy.float = min(surface_dphi_dt, crown_dphi_dt)
    # Determine whether the surface or crown fire has the fastest spread rate
    if surface_spread_rate == 0.0:
        # Independent crown fire (NOTE: This is probably user error.)
        return crown_fire_behavior
    elif crown_spread_rate == 0.0:
        if crown_fire_type == 2:
            # Passive crown fire
            return SpreadBehavior(
                dphi_dt            = dphi_dt,
                fire_type          = crown_fire_type,
                spread_rate        = surface_spread_rate,
                spread_direction   = surface_spread_direction,
                fireline_intensity = surface_fireline_intensity,
                flame_length       = surface_flame_length,
            )
        else:
            # No crown fire
            return surface_fire_behavior
    elif surface_spread_rate > crown_spread_rate:
        # Surface fire spreads faster
        combined_fireline_intensity: cy.float = (surface_fireline_intensity
                                                 + crown_fireline_intensity * surface_spread_rate / crown_spread_rate)
        return SpreadBehavior(
            dphi_dt            = dphi_dt,
            fire_type          = crown_fire_type,
            spread_rate        = surface_spread_rate,
            spread_direction   = surface_spread_direction,
            fireline_intensity = combined_fireline_intensity,
            flame_length       = sf.calc_flame_length(combined_fireline_intensity),
        )
    else:
        # Crown fire spreads faster
        combined_fireline_intensity: cy.float = (surface_fireline_intensity * crown_spread_rate / surface_spread_rate
                                                 + crown_fireline_intensity)
        return SpreadBehavior(
            dphi_dt            = dphi_dt,
            fire_type          = crown_fire_type,
            spread_rate        = crown_spread_rate,
            spread_direction   = crown_spread_direction,
            fireline_intensity = combined_fireline_intensity,
            flame_length       = sf.calc_flame_length(combined_fireline_intensity),
        )
#+end_src

** For Users
   :PROPERTIES:
   :CUSTOM_ID: for-users-crown
   :header-args:python+: :session *examples:pyretechnics.crown_fire*
   :header-args:python+: :results output replace
   :header-args:python+: :exports both
   :END:

In the following sections, we will demonstrate how to calculate the
crown fire behavior values given a surface fire line intensity and
measurements of foliar moisture, fine fuel moisture, tree canopy
characteristics, wind speed, wind direction, slope, and aspect. This
will be done first for the max spread direction case and then in any
direction on the sloped surface using 3D vectors to specify absolute
directions.

Because wind speed and direction will often be provided from
measurements taken 10m or 20ft above the canopy and may be given in
either cartesion =(x,y)= or azimuthal =(r,azimuth)= coordinates, we
also demonstrate how to convert from cartesian to azimuthal
coordinates and from 10m to 20ft wind speeds.

See Appendix [[Units Conversion Functions (pyretechnics.conversion)]] for
the full list of available units conversion functions.

See Appendix [[Vector Utility Functions (pyretechnics.vector_utils)]] for
the full list of available vector manipulation functions.

*** How to Determine Whether a Surface Fire Transitions to a Crown Fire
    :PROPERTIES:
    :CUSTOM_ID: how-to-determine-whether-a-surface-fire-transitions-to-a-crown-fire
    :END:

#+NAME: check-crown-fire-initiation
#+begin_src python
from pprint import pprint
import pyretechnics.crown_fire as cf

# Set tree canopy characteristics
canopy_cover_low   = 0.3 # 0-1
canopy_cover_high  = 0.8 # 0-1
canopy_base_height = 3.0 # m
foliar_moisture    = 1.0 # kg moisture/kg ovendry weight

# Specify some surface fireline intensity values to check
# These would normally be calculated by the functions in pyretechnics.surface_fire
surface_fireline_intensity_low  = 500.0  # kW/m
surface_fireline_intensity_high = 5000.0 # kW/m

#=================================================================================
# Check for crown fire with canopy_cover_low and surface_fireline_intensity_low
#=================================================================================

print("Low Canopy Cover and Low Surface Fireline Intensity\n" + "=" * 60)

if cf.van_wagner_crown_fire_initiation(surface_fireline_intensity_low,
                                       canopy_cover_low,
                                       canopy_base_height,
                                       foliar_moisture):
    # Crown Fire
    print("\nA crown fire occurs with these input parameters:")
    pprint({
        "surface_fireline_intensity": surface_fireline_intensity_low,
        "canopy_cover"              : canopy_cover_low,
        "canopy_base_height"        : canopy_base_height,
        "foliar_moisture"           : foliar_moisture,
    })
else:
    # Surface Fire
    print("\nA surface fire occurs with these input parameters:")
    pprint({
        "surface_fireline_intensity": surface_fireline_intensity_low,
        "canopy_cover"              : canopy_cover_low,
        "canopy_base_height"        : canopy_base_height,
        "foliar_moisture"           : foliar_moisture,
    })

#=================================================================================
# Check for crown fire with canopy_cover_low and surface_fireline_intensity_high
#=================================================================================

print("\nLow Canopy Cover and High Surface Fireline Intensity\n" + "=" * 60)

if cf.van_wagner_crown_fire_initiation(surface_fireline_intensity_high,
                                       canopy_cover_low,
                                       canopy_base_height,
                                       foliar_moisture):
    # Crown Fire
    print("\nA crown fire occurs with these input parameters:")
    pprint({
        "surface_fireline_intensity": surface_fireline_intensity_high,
        "canopy_cover"              : canopy_cover_low,
        "canopy_base_height"        : canopy_base_height,
        "foliar_moisture"           : foliar_moisture,
    })
else:
    # Surface Fire
    print("\nA surface fire occurs with these input parameters:")
    pprint({
        "surface_fireline_intensity": surface_fireline_intensity_high,
        "canopy_cover"              : canopy_cover_low,
        "canopy_base_height"        : canopy_base_height,
        "foliar_moisture"           : foliar_moisture,
    })

#=================================================================================
# Check for crown fire with canopy_cover_high and surface_fireline_intensity_low
#=================================================================================

print("\nHigh Canopy Cover and Low Surface Fireline Intensity\n" + "=" * 60)

if cf.van_wagner_crown_fire_initiation(surface_fireline_intensity_low,
                                       canopy_cover_high,
                                       canopy_base_height,
                                       foliar_moisture):
    # Crown Fire
    print("\nA crown fire occurs with these input parameters:")
    pprint({
        "surface_fireline_intensity": surface_fireline_intensity_low,
        "canopy_cover"              : canopy_cover_high,
        "canopy_base_height"        : canopy_base_height,
        "foliar_moisture"           : foliar_moisture,
    })
else:
    # Surface Fire
    print("\nA surface fire occurs with these input parameters:")
    pprint({
        "surface_fireline_intensity": surface_fireline_intensity_low,
        "canopy_cover"              : canopy_cover_high,
        "canopy_base_height"        : canopy_base_height,
        "foliar_moisture"           : foliar_moisture,
    })

#=================================================================================
# Check for crown fire with canopy_cover_high and surface_fireline_intensity_high
#=================================================================================

print("\nHigh Canopy Cover and High Surface Fireline Intensity\n" + "=" * 60)

if cf.van_wagner_crown_fire_initiation(surface_fireline_intensity_high,
                                       canopy_cover_high,
                                       canopy_base_height,
                                       foliar_moisture):
    # Crown Fire
    print("\nA crown fire occurs with these input parameters:")
    pprint({
        "surface_fireline_intensity": surface_fireline_intensity_high,
        "canopy_cover"              : canopy_cover_high,
        "canopy_base_height"        : canopy_base_height,
        "foliar_moisture"           : foliar_moisture,
    })
else:
    # Surface Fire
    print("\nA surface fire occurs with these input parameters:")
    pprint({
        "surface_fireline_intensity": surface_fireline_intensity_high,
        "canopy_cover"              : canopy_cover_high,
        "canopy_base_height"        : canopy_base_height,
        "foliar_moisture"           : foliar_moisture,
    })
#+end_src

#+NAME: check-crown-fire-initiation-results
#+RESULTS: check-crown-fire-initiation
#+begin_example
Low Canopy Cover and Low Surface Fireline Intensity
============================================================

A surface fire occurs with these input parameters:
{'canopy_base_height': 3.0,
 'canopy_cover': 0.3,
 'foliar_moisture': 1.0,
 'surface_fireline_intensity': 500.0}

Low Canopy Cover and High Surface Fireline Intensity
============================================================

A surface fire occurs with these input parameters:
{'canopy_base_height': 3.0,
 'canopy_cover': 0.3,
 'foliar_moisture': 1.0,
 'surface_fireline_intensity': 5000.0}

High Canopy Cover and Low Surface Fireline Intensity
============================================================

A surface fire occurs with these input parameters:
{'canopy_base_height': 3.0,
 'canopy_cover': 0.8,
 'foliar_moisture': 1.0,
 'surface_fireline_intensity': 500.0}

High Canopy Cover and High Surface Fireline Intensity
============================================================

A crown fire occurs with these input parameters:
{'canopy_base_height': 3.0,
 'canopy_cover': 0.8,
 'foliar_moisture': 1.0,
 'surface_fireline_intensity': 5000.0}
#+end_example

*** How to Calculate the Crown Fire Behavior in the Direction of Maximum Spread
    :PROPERTIES:
    :CUSTOM_ID: how-to-calculate-the-crown-fire-behavior-in-the-direction-of-maximum-spread
    :END:

#+NAME: compute-crown-fire-behavior-max
#+begin_src python
from pprint import pprint
import pyretechnics.crown_fire as cf

# Set input parameters
canopy_height                = 30.0    # m
canopy_base_height           = 3.0     # m
canopy_bulk_density          = 0.3     # kg/m^3
heat_of_combustion           = 18608.0 # kJ/kg
estimated_fine_fuel_moisture = 0.05    # kg moisture/kg ovendry weight
wind_speed_10m               = 10.0    # km/hr
upwind_direction             = 180.0   # degrees clockwise from North
slope                        = 0.5     # rise/run
aspect_parallel_to_wind      = 180.0   # degrees clockwise from North
aspect_perpendicular_to_wind = 270.0   # degrees clockwise from North

#====================================================================================================
# Calculate crown fire behavior in the direction of maximum spread with slope and wind aligned
#====================================================================================================

crown_fire_max_aligned = cf.calc_crown_fire_behavior_max(canopy_height, canopy_base_height,
                                                         canopy_bulk_density, heat_of_combustion,
                                                         estimated_fine_fuel_moisture,
                                                         wind_speed_10m, upwind_direction,
                                                         slope, aspect_parallel_to_wind)

# View results
print("Crown Fire Behavior Max with Wind and Slope Aligned\n" + "=" * 60)

print("\nInputs:")
pprint({
    "canopy_height"               : canopy_height,
    "canopy_base_height"          : canopy_base_height,
    "canopy_bulk_density"         : canopy_bulk_density,
    "heat_of_combustion"          : heat_of_combustion,
    "estimated_fine_fuel_moisture": estimated_fine_fuel_moisture,
    "wind_speed_10m"              : wind_speed_10m,
    "upwind_direction"            : upwind_direction,
    "slope"                       : slope,
    "aspect"                      : aspect_parallel_to_wind,
})

print("\nOutputs:")
pprint(crown_fire_max_aligned)

#====================================================================================================
# Calculate crown fire behavior in the direction of maximum spread with slope and wind perpendicular
#====================================================================================================

crown_fire_max_perpendicular = cf.calc_crown_fire_behavior_max(canopy_height, canopy_base_height,
                                                               canopy_bulk_density, heat_of_combustion,
                                                               estimated_fine_fuel_moisture,
                                                               wind_speed_10m, upwind_direction,
                                                               slope, aspect_perpendicular_to_wind)

# View results
print("\nCrown Fire Behavior Max with Wind and Slope Perpendicular\n" + "=" * 60)

print("\nInputs:")
pprint({
    "canopy_height"               : canopy_height,
    "canopy_base_height"          : canopy_base_height,
    "canopy_bulk_density"         : canopy_bulk_density,
    "heat_of_combustion"          : heat_of_combustion,
    "estimated_fine_fuel_moisture": estimated_fine_fuel_moisture,
    "wind_speed_10m"              : wind_speed_10m,
    "upwind_direction"            : upwind_direction,
    "slope"                       : slope,
    "aspect"                      : aspect_perpendicular_to_wind,
})

print("\nOutputs:")
pprint(crown_fire_max_perpendicular)
#+end_src

#+NAME: compute-crown-fire-behavior-max-results
#+RESULTS: compute-crown-fire-behavior-max
#+begin_example
Crown Fire Behavior Max with Wind and Slope Aligned
============================================================

Inputs:
{'aspect': 180.0,
 'canopy_base_height': 3.0,
 'canopy_bulk_density': 0.3,
 'canopy_height': 30.0,
 'estimated_fine_fuel_moisture': 0.05,
 'heat_of_combustion': 18608.0,
 'slope': 0.5,
 'upwind_direction': 180.0,
 'wind_speed_10m': 10.0}

Outputs:
{'critical_spread_rate': 10.0,
 'eccentricity': 0.821895863285579,
 'length_to_width_ratio': 1.7555015683174133,
 'max_fire_type': 'active_crown',
 'max_fireline_intensity': 82666.07018304318,
 'max_spread_direction': array([0.        , 0.89442718, 0.44721359]),
 'max_spread_rate': 32.90741942256743}

Crown Fire Behavior Max with Wind and Slope Perpendicular
============================================================

Inputs:
{'aspect': 270.0,
 'canopy_base_height': 3.0,
 'canopy_bulk_density': 0.3,
 'canopy_height': 30.0,
 'estimated_fine_fuel_moisture': 0.05,
 'heat_of_combustion': 18608.0,
 'slope': 0.5,
 'upwind_direction': 180.0,
 'wind_speed_10m': 10.0}

Outputs:
{'critical_spread_rate': 10.0,
 'eccentricity': 0.8024265608222492,
 'length_to_width_ratio': 1.6757411360740662,
 'max_fire_type': 'active_crown',
 'max_fireline_intensity': 74768.3487091958,
 'max_spread_direction': array([ 0.00000000e+00,  1.00000000e+00, -2.18556941e-08]),
 'max_spread_rate': 29.763522144675242}
#+end_example

*** How to Calculate the Crown Fire Behavior in Any Direction
    :PROPERTIES:
    :CUSTOM_ID: how-to-calculate-the-crown-fire-behavior-in-any-direction
    :END:

#+NAME: compute-crown-fire-behavior-in-direction
#+begin_src python
import numpy as np
from pprint import pprint
import pyretechnics.crown_fire as cf
import pyretechnics.vector_utils as vu

# Set input parameters
canopy_height                = 30.0    # m
canopy_base_height           = 3.0     # m
canopy_bulk_density          = 0.3     # kg/m^3
heat_of_combustion           = 18608.0 # kJ/kg
estimated_fine_fuel_moisture = 0.05    # kg moisture/kg ovendry weight
wind_speed_10m               = 10.0    # km/hr
upwind_direction             = 180.0   # degrees clockwise from North
slope                        = 0.5     # rise/run
aspect                       = 225.0   # degrees clockwise from North

#================================================================================================
# Calculate crown fire behavior in the direction of maximum spread
#================================================================================================

crown_fire_max = cf.calc_crown_fire_behavior_max(canopy_height, canopy_base_height,
                                                 canopy_bulk_density, heat_of_combustion,
                                                 estimated_fine_fuel_moisture,
                                                 wind_speed_10m, upwind_direction,
                                                 slope, aspect)

#================================================================================================
# Calculate crown fire behavior for the heading, flanking, and backing fires
#================================================================================================

heading_fire_direction  = crown_fire_max["max_spread_direction"]
# FIXME: Change upstream functions to return max_spread_direction as type vec_xyz
#        and change downstream functions to accept spread_direction as type vec_xyz
(dx, dy, dz)            = heading_fire_direction
flanking_fire_direction = np.asarray(vu.rotate_on_sloped_plane((dx, dy, dz), 90.0, slope, aspect))
backing_fire_direction  = np.asarray(vu.rotate_on_sloped_plane((dx, dy, dz), 180.0, slope, aspect))

heading_fire_behavior  = cf.calc_crown_fire_behavior_in_direction(crown_fire_max, heading_fire_direction)
flanking_fire_behavior = cf.calc_crown_fire_behavior_in_direction(crown_fire_max, flanking_fire_direction)
backing_fire_behavior  = cf.calc_crown_fire_behavior_in_direction(crown_fire_max, backing_fire_direction)

# View heading fire results
print("Heading Fire Behavior\n" + "=" * 60)
pprint(heading_fire_behavior)

# View flanking fire results
print("\nFlanking Fire Behavior\n" + "=" * 60)
pprint(flanking_fire_behavior)

# View backing fire results
print("\nBacking Fire Behavior\n" + "=" * 60)
pprint(backing_fire_behavior)
#+end_src

#+NAME: compute-crown-fire-behavior-in-direction-results
#+RESULTS: compute-crown-fire-behavior-in-direction
#+begin_example
Heading Fire Behavior
============================================================
{'fire_type': 'active_crown',
 'fireline_intensity': 78838.15458910078,
 'spread_direction': array([0.        , 0.94280905, 0.33333334]),
 'spread_rate': 31.383616202151522}

Flanking Fire Behavior
============================================================
{'fire_type': 'passive_crown',
 'fireline_intensity': 14756.204747877806,
 'spread_direction': array([ 0.94868332, -0.1054093 ,  0.2981424 ]),
 'spread_rate': 3.2646179246550817}

Backing Fire Behavior
============================================================
{'fire_type': 'passive_crown',
 'fireline_intensity': 8139.876410946037,
 'spread_direction': array([-8.29365305e-08, -9.42809045e-01, -3.33333373e-01]),
 'spread_rate': 2.3434742608260732}
#+end_example

*** How to Calculate the Combined Surface and Crown Fire Behavior in Any Direction
    :PROPERTIES:
    :CUSTOM_ID: how-to-calculate-the-combined-surface-and-crown-fire-behavior-in-any-direction
    :END:

#+NAME: compute-combined-fire-behavior-in-direction
#+begin_src python
from pprint import pprint
import pyretechnics.conversion as conv
import pyretechnics.crown_fire as cf
import pyretechnics.fuel_models as fm
import pyretechnics.surface_fire as sf
import pyretechnics.vector_utils as vu

#================================================================================================
# Set input parameters
#================================================================================================

# Landscape
fuel_model          = fm.fuel_model_table[101] # GR1
canopy_cover        = 0.6                      # 0-1
canopy_height       = 30.0                     # m
canopy_base_height  = 3.0                      # m
canopy_bulk_density = 0.3                      # kg/m^3
slope               = 0.8                      # rise/run
aspect              = 225.0                    # degrees clockwise from North

# Weather
fuel_moisture    = [
    0.05, # dead_1hr
    0.10, # dead_10hr
    0.15, # dead_100hr
    0.00, # dead_herbaceous (will be set by moisturize for dynamic fuel models)
    0.90, # live_herbaceous
    0.60, # live_woody
]                        # kg moisture/kg ovendry weight
foliar_moisture  = 0.9   # kg moisture/kg ovendry weight
wind_speed_10m   = 30.0  # km/hr
upwind_direction = 180.0 # degrees clockwise from North

# Derived Parameters
fuel_bed_depth               = fuel_model["delta"]                      # ft
heat_of_combustion           = conv.Btu_lb_to_kJ_kg(fuel_model["h"][0]) # kJ/kg
estimated_fine_fuel_moisture = fuel_moisture[0]                         # kg moisture/kg ovendry weight

# Fire Perimeter Normal Vector
fire_perimeter_normal_vector_2d = (1.0, 0.0) # (x,y) unit vector pointing East

#================================================================================================
# Project the 2D fire perimeter normal vector onto the slope-tangential plane
#================================================================================================

upslope_direction               = conv.opposite_direction(aspect)
slope_vector_2d                 = conv.azimuthal_to_cartesian(slope, upslope_direction)
fire_perimeter_normal_vector_3d = vu.as_unit_vector_3d(vu.to_slope_plane(fire_perimeter_normal_vector_2d,
                                                                         slope_vector_2d))

#================================================================================================
# Calculate midflame wind speed
#================================================================================================

# Convert from 10m wind speed to 20ft wind speed
wind_speed_20ft = conv.wind_speed_10m_to_wind_speed_20ft(wind_speed_10m) # km/hr

# Convert 20ft wind speed from km/hr to m/min
wind_speed_20ft_m_min = conv.km_hr_to_m_min(wind_speed_20ft) # m/min

# Convert from 20ft wind speed to midflame wind speed in m/min
midflame_wind_speed = sf.calc_midflame_wind_speed(wind_speed_20ft_m_min,       # m/min
                                                  fuel_bed_depth,              # ft
                                                  conv.m_to_ft(canopy_height), # ft
                                                  canopy_cover)                # 0-1

#================================================================================================
# Calculate surface fire behavior in the direction of maximum spread
#================================================================================================

# Apply fuel moisture to fuel model
moisturized_fuel_model = fm.moisturize(fuel_model, fuel_moisture)

# Calculate no-wind-no-slope surface fire behavior
surface_fire_min = sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model)

# Calculate surface fire behavior in the direction of maximum spread with effective wind speed limit
surface_fire_max = sf.calc_surface_fire_behavior_max(surface_fire_min,
                                                     midflame_wind_speed,
                                                     upwind_direction,
                                                     slope,
                                                     aspect)

#================================================================================================
# Calculate surface fire behavior in the direction normal to the fire perimeter
#================================================================================================

surface_fire_normal = sf.calc_surface_fire_behavior_in_direction(surface_fire_max, fire_perimeter_normal_vector_3d)

#================================================================================================
# Determine whether the surface fire transitions to a crown fire
#================================================================================================

if cf.van_wagner_crown_fire_initiation(surface_fire_normal["fireline_intensity"],
                                       canopy_cover,
                                       canopy_base_height,
                                       foliar_moisture):

    #============================================================================================
    # Calculate crown fire behavior in the direction of maximum spread
    #============================================================================================

    crown_fire_max = cf.calc_crown_fire_behavior_max(canopy_height, canopy_base_height,
                                                     canopy_bulk_density, heat_of_combustion,
                                                     estimated_fine_fuel_moisture,
                                                     wind_speed_10m, upwind_direction,
                                                     slope, aspect)

    #============================================================================================
    # Calculate crown fire behavior in the direction normal to the fire perimeter
    #============================================================================================

    crown_fire_normal = cf.calc_crown_fire_behavior_in_direction(crown_fire_max, fire_perimeter_normal_vector_3d)

    #============================================================================================
    # Calculate combined fire behavior in the direction normal to the fire perimeter
    #============================================================================================

    combined_fire_normal = cf.calc_combined_fire_behavior(surface_fire_normal, crown_fire_normal)

    #============================================================================================
    # Display the combined fire behavior normal to the fire perimeter
    #============================================================================================

    print("Fire Behavior from Combined Surface and Crown Fire\n" + "=" * 60)
    pprint(combined_fire_normal)

else:

    #============================================================================================
    # Display the surface fire behavior normal to the fire perimeter
    #============================================================================================

    print("Fire Behavior from Surface Fire (No Crown Fire Occurred)\n" + "=" * 60)
    pprint(surface_fire_normal)
#+end_src

#+NAME: compute-combined-fire-behavior-in-direction-results
#+RESULTS: compute-combined-fire-behavior-in-direction
: Fire Behavior from Surface Fire (No Crown Fire Occurred)
: ============================================================
: {'fire_type': 'surface',
:  'fireline_intensity': 11.637273243704481,
:  'flame_length': 0.23956727406332143,
:  'spread_direction': array([0.87038827, 0.        , 0.49236599]),
:  'spread_rate': 0.8215819746243512}

* Spot Fire Equations (pyretechnics.spot_fire)
  :PROPERTIES:
  :CUSTOM_ID: spot-fire-equations-(pyretechnics.spot_fire)
  :END:
** For Developers
   :PROPERTIES:
   :CUSTOM_ID: for-developers-spot
   :header-args:python+: :session *pyretechnics.spot_fire*
   :header-args:python+: :tangle  ../src/pyretechnics/spot_fire.py
   :header-args:python+: :exports code
   :END:

Whether a fire is spreading through surface or canopy fuels, it is
possible that small pieces of the burning fuels may be lofted by winds
ahead of the fire front. When these burning firebrands land in
sufficiently dry fuels, they may ignite new fires under the right
conditions. Fires created in this way are called "spot fires" and are
the subject of this chapter. The following sections provide functions
for calculating the probability and rate of firebrand generation from
burning fuels, the lofting distance and direction of these firebrands,
their likelihood of surviving their flight until landing, their
likelihood of igniting spot fires once deposited, and the time to grow
from a spark to a fire capable of spreading on its own.

*** Module Imports
    :PROPERTIES:
    :CUSTOM_ID: module-imports-spot-fire
    :END:

#+NAME: spot-fire-imports
#+begin_src python
import cython
import cython as cy
if cython.compiled:
    from cython.cimports.libc.math import round, sqrt, pow, log, exp, sin, cos
    from cython.cimports.pyretechnics.cy_types import \
        pyidx, vec_xy, coord_yx, coord_tyx, SpreadBehavior, SpotConfig, JumpDistribution
    from cython.cimports.pyretechnics.random import BufferedRandGen
    from cython.cimports.pyretechnics.space_time_cube import ISpaceTimeCube
    import cython.cimports.pyretechnics.conversion as conv
    import cython.cimports.pyretechnics.fuel_models as fm
    import cython.cimports.pyretechnics.surface_fire as sf
else:
    from math import round, sqrt, pow, log, exp, sin, cos
    from pyretechnics.py_types import \
        pyidx, vec_xy, coord_yx, coord_tyx, SpreadBehavior, SpotConfig, JumpDistribution
    from pyretechnics.random import BufferedRandGen
    from pyretechnics.space_time_cube import ISpaceTimeCube
    import pyretechnics.conversion as conv
    import pyretechnics.fuel_models as fm
    import pyretechnics.surface_fire as sf
#+end_src

*** Expected Firebrand Production
    :PROPERTIES:
    :CUSTOM_ID: expected-firebrand-production
    :END:

When surface or canopy fuels burn, they emit a certain amount of heat
$H_C$ (in $\text{kJ}$) before burning out as a function of their fuel
model and moisture values. In this section, we provide a function that
relates this total heat output per cell to the number of firebrands
that our spotting model will cast from that cell when it burns.

From section [[Surface Fire Intensity Functions]], we can see the
following relationship between a fire's spread rate $R$ (in
$\text{m}/\text{min}$), fireline intensity $I$ (in
$\text{kW}/\text{m}$), and heat per unit area $H$ (in
$\text{kJ}/\text{m}^2$):

\begin{align}
  H = 60 \frac{I}{R}
\end{align}

We can calculate the total heat emitted by a cell on a gridded
landscape $H_C$ by multiplying its $H$ value by the slope-adjusted
area of the cell $A_C$ (in $\text{m}^2$) as follows:

\begin{align}
  A_C &= \Delta x \, \Delta y \left[1 + \left(\frac{\partial z}{\partial x}\right)^2 + \left(\frac{\partial z}{\partial y}\right)^2 \right] \\
  \nonumber \\
  H_C &= H \, A_C
\end{align}

where $\Delta x$ is the cell width (in $\text{m}$), $\Delta y$ is the
cell height (in $\text{m}$), and $(\frac{\partial z}{\partial x}$,
$\frac{\partial z}{\partial y})$ is the elevation gradient of the
cell.

A user-provided coefficient $F_H$ ("firebrands_per_unit_heat" in
$\text{firebrands}/\text{kJ}$) is then combined with the total heat
per cell $H_C$ (in $\text{kJ}$) to calculate the number of firebrands
to cast per cell $F_C$:

\begin{align}
  F_C = F_H \, H_C
\end{align}

#+NAME: expected-firebrand-production
#+begin_src python
@cy.cfunc
@cy.exceptval(check=False)
def expected_firebrand_production(fire_behavior           : SpreadBehavior,
                                  elevation_gradient      : vec_xy,
                                  cell_horizontal_area    : cy.float,
                                  firebrands_per_unit_heat: cy.float=1e-6) -> cy.float:
    """
    Return the expected number of firebrands produced by an entire cell when it burns given:
    - fire_behavior            :: a SpreadBehavior struct of surface or crown fire behavior values
      - dphi_dt                   :: phi/min
      - fire_type                 :: 0 (unburned), 1 (surface), 2 (passive_crown), or 3 (active_crown)
      - spread_rate               :: m/min
      - spread_direction          :: (x, y, z) unit vector on the slope-tangential plane
      - fireline_intensity        :: kW/m
      - flame_length              :: m
    - elevation_gradient       :: tuple with these fields
      - dz_dx                     :: rise/run
      - dz_dy                     :: rise/run
    - cell_horizontal_area     :: m^2
    - firebrands_per_unit_heat :: firebrands/kJ
    """
    if fire_behavior.spread_rate == 0.0:
        return 0.0
    else:
        #================================================================================================
        # Calculate the heat output per unit area
        #================================================================================================

        spread_rate         : cy.float = fire_behavior.spread_rate                                  # m/min
        fireline_intensity  : cy.float = fire_behavior.fireline_intensity                           # kW/m
        heat_output_per_area: cy.float = sf.calc_areal_heat_output(spread_rate, fireline_intensity) # kJ/m^2

        #================================================================================================
        # Calculate the slope-adjusted cell area
        #================================================================================================

        (dz_dx, dz_dy)         = elevation_gradient                            # (rise/run, rise/run)
        slope_factor: cy.float = sqrt(1.0 + (dz_dx * dz_dx) + (dz_dy * dz_dy)) # unitless
        cell_area   : cy.float = cell_horizontal_area * slope_factor           # m^2

        #================================================================================================
        # Calculate the expected number of firebrands produced in this cell
        #================================================================================================

        cell_heat_output: cy.float = heat_output_per_area * cell_area            # kJ
        firebrand_count : cy.float = firebrands_per_unit_heat * cell_heat_output # number of firebrands
        return firebrand_count
#+end_src

*** Firebrand Dispersal Model
    :PROPERTIES:
    :CUSTOM_ID: firebrand-dispersal-model
    :END:

The Firebrand Dispersal model describes the distributions of
firebrands relative to the wind direction. The location where the
firebrand lands is represented by the random vector $\vec{\Delta}$
from the location of origin:

\begin{align}
  \vec{\Delta} := \Delta_X.\vec{w} + \Delta_Y.\vec{w}_\perp
\end{align}

in which $\vec{w}, \vec{w}_\perp$ are unit vectors respectively
parallel and perpendicular to the wind direction, and $\Delta_X,
\Delta_Y$ are the random variables for coordinates.

Following Perryman 2012, Sardoy 2008, and Himoto 2005, we model
$\Delta_X$ and $\Delta_Y$ to be independent, with $\Delta_X$ following
a log-normal distribution, and $\Delta_Y$ following a zero-mean normal
distribution, conditional on the fire behavior $\Phi$ at the cell of
origin:[fn::Perryman2012][fn::Sardoy2008][fn::Himoto2005]

\begin{align}
  \ln (\Delta_X / \text{1m}) | \Phi \sim & \text{Normal}(\mu = \mu_X(\Phi), \sigma = \sigma_X(\Phi)) & \\
  \nonumber \\
  \Delta_Y | \Phi \sim & \text{Normal}(\mu = 0, \sigma = \sigma_Y(\Phi)) &
\end{align}

where $\text{Normal}(\mu, \sigma)$ denotes a one-dimensional Gaussian
distribution with mean $\mu$ and standard deviation $\sigma$. Note
that $\mu_X$ and $\sigma_X$ are in log-space, therefore dimensionless.
For the sake of light notation, the conditioning on $\Phi$ will be
implicit from now on, e.g. we will write $\Delta_X$ instead of
$\Delta_X | \Phi$.

Since the results are distance deltas relative to the wind direction,
we must convert this to deltas in our coordinate plane. We can convert
these deltas by using trigonometric functions.

#+NAME: convert-deltas
#+begin_src python
@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def delta_to_grid_dx(cos_wdir: cy.float, sin_wdir: cy.float, delta_x: cy.float, delta_y: cy.float) -> cy.float:
    """
    Computes the grid-aligned x coordinate of the delta vector, given the wind-aligned [ÎX ÎY] coordinates.
    Returns a signed distance (same unit as ÎX and ÎY).

    NOTE:
    - sin_wdir = wdir_x
    - cos_wdir = wdir_perp_x
    """
    return delta_x * sin_wdir + delta_y * cos_wdir


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def delta_to_grid_dy(cos_wdir: cy.float, sin_wdir: cy.float, delta_x: cy.float, delta_y: cy.float) -> cy.float:
    """
    Computes the grid-aligned y coordinate of the delta vector, given the wind-aligned [ÎX ÎY] coordinates.
    Returns a signed distance (same unit as ÎX and ÎY).

    NOTE:
    - cos_wdir = wdir_y
    - sin_wdir = wdir_perp_y
    """
    return delta_x * cos_wdir + delta_y * sin_wdir


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def distance_to_n_cells(distance: cy.float, cell_size: cy.float) -> cy.int:
    """
    Converts a delta expressed as a signed distance to one expressed as a number of grid cells.
    """
    return int(round(distance / cell_size))
#+end_src

*** Resolution of Log-Normal Parameters
    :PROPERTIES:
    :CUSTOM_ID: resolution-of-log-normal-parameters
    :END:

We now need to define the functions $\mu_X(\Phi)$ and
$\sigma_X(\Phi)$. Here we depart from Sardoy 2008[fn::Sardoy2008] and
reproduce the model of ELMFIRE[fn::https://elmfire.io], which models
that dependency using the following relationships between the moments
of the distribution and the fireline intensity $I$ and wind speed $U$:

\begin{align}
  \mathbb{E}[\Delta_X] = & \Delta_1 \left(\frac{I}{\text{1 kW/m}}\right)^{e_I} \left(\frac{U}{\text{1 m/s}}\right)^{e_U} & \\
  \nonumber \\
  \text{Var}[\Delta_X] = & r_\frac{V}{E} \mathbb{E}[\Delta_X] &
\end{align}

in which $\Delta_1, e_I, e_U, r_\frac{V}{E}$ are configured by the
keys shown in table [[tab:spotting-elmfire-params]].

#+NAME: tab:spotting-elmfire-params
#+CAPTION: Spotting parameters for the downwind distribution per the ELMFIRE model
|-----------------+------+------------------------------------------+------------------------------|
| Parameter       | Unit | Description                              | Configuration Key            |
|-----------------+------+------------------------------------------+------------------------------|
| $\Delta_1$      | m    | Mean landing distance in unit conditions | downwind_distance_mean       |
| $e_I$           | -    | Fireline intensity exponent              | fireline_intensity_exponent  |
| $e_U$           | -    | Wind speed exponent                      | wind_speed_exponent          |
| $r_\frac{V}{E}$ | m    | Variance-over-Mean ratio                 | downwind_variance_mean_ratio |
|-----------------+------+------------------------------------------+------------------------------|

*Note:* One potential way in which this model can misbehave is that
the variance is proportional to the expected value, and therefore the
coefficient of variation is driven to zero as the expected value goes
to infinity, making the distribution less and less dispersed around
its mean. This means that, in high-wind/high-intensity conditions, all
the firebrands will tend to land at approximately the same (large)
distance, following a narrow near-normal distribution.

From the above moments, $\mu_X$ and $\sigma_X$ can be obtained using
the properties of the log-normal distribution:

\begin{align}
  \sigma_X^2 = & \ln \left(1 + \frac{\text{Var}[\Delta_X]}{\mathbb{E}[\Delta_X]^2}\right) & \\
  \nonumber \\
  \mu_X = & \ln \frac{\mathbb{E}[\Delta_X]^2}{\sqrt{\text{Var}[\Delta_X] + \mathbb{E}[\Delta_X]^2}} &
\end{align}

#+NAME: resolve-spotting-lognormal-elmfire
#+begin_src python
@cy.cfunc
@cy.exceptval(check=False)
def resolve_exp_delta_x(spot_config: SpotConfig, fireline_intensity: cy.float, wind_speed_20ft: cy.float) -> cy.float:
    """
    Computes the expected value E[ÎX] (in meters) of the downwind spotting distance ÎX given:
    - spot_config        :: a SpotConfig struct of spotting parameters
      - random_seed                  :: seed for a numpy.random.Generator object
      - firebrands_per_unit_heat     :: firebrands/kJ
      - downwind_distance_mean       :: meters
      - fireline_intensity_exponent  :: downwind_distance_mean multiplier [I^fireline_intensity_exponent]
      - wind_speed_exponent          :: downwind_distance_mean multiplier [U^wind_speed_exponent]
      - downwind_variance_mean_ratio :: meters^2 / meter [downwind_variance_mean_ratio = Var(X) / E(X)]
      - crosswind_distance_stdev     :: meters
      - decay_distance               :: meters
    - fireline_intensity :: kW/m
    - wind_speed_20ft    :: m/s
    """
    downwind_distance_mean     : cy.float = spot_config.downwind_distance_mean
    fireline_intensity_exponent: cy.float = spot_config.fireline_intensity_exponent
    wind_speed_exponent        : cy.float = spot_config.wind_speed_exponent
    return (downwind_distance_mean
            * pow(fireline_intensity, fireline_intensity_exponent)
            * pow(wind_speed_20ft, wind_speed_exponent))


@cy.cfunc
@cy.exceptval(check=False)
def resolve_var_delta_x(spot_config: SpotConfig, exp_delta_x: cy.float) -> cy.float:
    """
    Computes the variance Var[ÎX] (in m^2) of the downwind spotting distance ÎX given:
    - spot_config :: a SpotConfig struct of spotting parameters
      - random_seed                  :: seed for a numpy.random.Generator object
      - firebrands_per_unit_heat     :: firebrands/kJ
      - downwind_distance_mean       :: meters
      - fireline_intensity_exponent  :: downwind_distance_mean multiplier [I^fireline_intensity_exponent]
      - wind_speed_exponent          :: downwind_distance_mean multiplier [U^wind_speed_exponent]
      - downwind_variance_mean_ratio :: meters^2 / meter [downwind_variance_mean_ratio = Var(X) / E(X)]
      - crosswind_distance_stdev     :: meters
      - decay_distance               :: meters
    - exp_delta_x :: meters (E[ÎX])
    """
    downwind_variance_mean_ratio: cy.float = spot_config.downwind_variance_mean_ratio
    return downwind_variance_mean_ratio * exp_delta_x


@cy.cfunc
@cy.exceptval(check=False)
def lognormal_mu_from_moments(mean: cy.float, variance: cy.float) -> cy.float:
    """
    TODO: Add docstring
    """
    m2: cy.float = mean * mean
    return log(m2 / sqrt(m2 + variance))


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def lognormal_sigma_from_moments(mean: cy.float, variance: cy.float) -> cy.float:
    """
    TODO: Add docstring
    """
    return sqrt(log(1.0 + variance / (mean * mean)))


@cy.cfunc
@cy.exceptval(check=False)
def resolve_lognormal_params(spot_config       : SpotConfig,
                             fireline_intensity: cy.float,
                             wind_speed_20ft   : cy.float) -> tuple[cy.float, cy.float]:
    """
    TODO: Add docstring
    """
    exp_delta_x         : cy.float = resolve_exp_delta_x(spot_config, fireline_intensity, wind_speed_20ft)
    var_delta_x         : cy.float = resolve_var_delta_x(spot_config, exp_delta_x)
    prob_lognormal_mu   : cy.float = lognormal_mu_from_moments(exp_delta_x, var_delta_x)
    prob_lognormal_sigma: cy.float = lognormal_sigma_from_moments(exp_delta_x, var_delta_x)
    return (prob_lognormal_mu, prob_lognormal_sigma)
#+end_src

*** Wind-Perpendicular Dispersal
    :PROPERTIES:
    :CUSTOM_ID: wind-perpendicular-dispersal
    :END:

For $\sigma_Y$, we either let the user specify an explicit value with
key *crosswind_distance_stdev* (in meters), which makes it equivalent
to the model of Perryman 2012[fn::Perryman2012], or we default to
deriving them from equation (28) of Himoto 2005[fn::Himoto2005], which
is equivalent to:

\begin{align}
  \sigma_Y = 0.92 D = 0.92 \frac{0.47}{0.88^2}\frac{\text{Var}[\Delta_X]}{\mathbb{E}[\Delta_X]}
\end{align}

$\text{Var}[\Delta_X]$ and $\mathbb{E}[\Delta_X]$ can be calculated
from the properties of the log-normal distribution:

\begin{align}
  \mathbb{E}[\Delta_X] = \text{1m} \times \exp \left(\mu_X + \frac{1}{2}\sigma_X^2 \right) \\
  \nonumber \\
  \text{Var}[\Delta_X] = \mathbb{E}[\Delta_X]^2 \left(e^{\sigma_X^2} - 1\right)
\end{align}

Combining the above equations and applying some algebra yields a
formula for $\sigma_Y$:

\begin{align}
  \sigma_Y = 0.92 D = \text{1m} \times 0.5584 \times e^{\mu_X} \times e^{\frac{1}{2}\sigma_X^2} \left(e^{\frac{1}{2}\sigma_X^2} - 1\right) \left(e^{\frac{1}{2}\sigma_X^2} + 1\right)
\end{align}

Typical values are shown in table [[tab:himoto2005-example-values]].

#+NAME: tab:himoto2005-example-values
#+CAPTION: Typical values for $\vec{\Delta}$ distribution characteristics derived from Himoto2005
|-------+-----------------------+------------+---------------------------------|
| $B^*$ | $\text{CV}[\Delta_X]$ | $\sigma_X$ | $\sigma_Y/\mathbb{E}[\Delta_X]$ |
|-------+-----------------------+------------+---------------------------------|
|    20 |                   69% |       0.72 |                            0.27 |
|    50 |                   51% |       0.64 |                            0.14 |
|   100 |                   40% |       0.58 |                            0.09 |
|   150 |                   35% |       0.55 |                            0.07 |
|   200 |                   32% |       0.53 |                            0.06 |
|-------+-----------------------+------------+---------------------------------|

See section [[How to Estimate Typical Ranges for the $\vec{\Delta}$
Distribution Characteristics]] for more information on how these values
were obtained.

*CAUTION:* (FIXME REVIEW) We have found the above formula to be
problematic when applied to the parameters values found in Sardoy
2008[fn::Sardoy2008] because it tends to yield nonsensical $\sigma_Y >
\mathbb{E}[\Delta_X]$. In fact, it can be seen that $\sigma_Y > s
\mathbb{E}[\Delta_X]$ if and only if $\sigma_X > \sqrt{\ln \left(1 +
\frac{.88^2}{.92 \times .47} s \right)}$, in particular $\sigma_X >
1.013$ for $s = 1$, which is unfortunately the case with the range of
$\sigma_X$ values in Sardoy 2008[fn::Sardoy2008]. This reflects a
divergence between Himoto 2005[fn::Himoto2005] and Sardoy
2008[fn::Sardoy2008], the latter allowing for more dispersed
$\Delta_X$ distributions (higher coefficient of variation
$\text{Var}[\Delta_X]^{\frac{1}{2}}/\mathbb{E}[\Delta_X] =
\sqrt{e^{\sigma_X^2} - 1}$), whereas the former typically predicts a
low coefficient of variation, as is perceptible in figure 6 of Himoto
2005[fn::Himoto2005]. Figure 10 of Sardoy 2008[fn::Sardoy2008]
suggests coefficients of variation ranging from 95% to 210%, whereas
Figure 6 of Himoto 2005[fn::Himoto2005] suggests coefficients of
variation ranging from 30% to 70%. For this reason, we *strongly
recommend to supply $\sigma_Y$ directly* through the configuration key
*crosswind_distance_stdev*.

*** Sampling Firebrand Casting Distances
    :PROPERTIES:
    :CUSTOM_ID: sampling-firebrand-casting-distances
    :END:

Having computed the $\mu_X$, $\sigma_X$ and $\sigma_Y$ parameters, it
remains to draw values of $\Delta_X$ and $\Delta_Y$ by sampling from
log-normal and normal distributions. This can be done by sampling from
a standard normal distribution, then transforming by affine and
exponential functions:

#+NAME: sardoy-firebrand-dispersal
#+begin_src python
@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def sample_normal(rng: BufferedRandGen, mu: cy.float, sd: cy.float) -> cy.float:
    """
    Returns sample from normal/gaussian distribution given mu and sd.
    """
    return mu + sd * rng.next_normal()


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def sample_lognormal(rng: BufferedRandGen, mu: cy.float, sd: cy.float) -> cy.float:
    """
    Returns sample from log-normal distribution given mu and sd.
    """
    return exp(sample_normal(rng, mu, sd))


# When will we have the default sigma_Y > E[ÎX]?
# It can be seen that this nonsensical situation
# happens iff sigma_X exceeds the following number:
#
# sqrt(log(1.0 + (0.88 ** 2.0) / (0.92 * 0.47))
#
# => 1.0131023746492023
sigma_y_scalar_m = cy.declare(cy.double, 0.92 * 0.47 / (0.88 * 0.88))


@cy.cfunc
@cy.exceptval(check=False)
def himoto_resolve_default_sigma_y_from_lognormal_params(mu_x: cy.float, sigma_x: cy.float) -> cy.float:
    es2h      : cy.float = exp((sigma_x * sigma_x) / 2.0)
    avg_deltax: cy.float = exp(mu_x) * es2h
    return sigma_y_scalar_m * avg_deltax * (es2h + 1.0) * (es2h - 1.0) # meters


@cy.cfunc
@cy.exceptval(check=False)
def himoto_resolve_default_sigma_y(spot_config       : SpotConfig,
                                   fireline_intensity: cy.float,
                                   wind_speed_20ft   : cy.float) -> cy.float:
    ln_params: tuple[cy.float, cy.float] = resolve_lognormal_params(spot_config, fireline_intensity, wind_speed_20ft)
    mu_x     : cy.float                  = ln_params[0] # dimensionless (log-space)
    sigma_x  : cy.float                  = ln_params[1] # dimensionless (log-space)
    return himoto_resolve_default_sigma_y_from_lognormal_params(mu_x, sigma_x) # meters


@cy.cfunc
@cy.exceptval(check=False)
def resolve_crosswind_distance_stdev(spot_config       : SpotConfig,
                                     fireline_intensity: cy.float,
                                     wind_speed_20ft   : cy.float) -> cy.float:
    crosswind_distance_stdev: cy.float = spot_config.crosswind_distance_stdev
    if crosswind_distance_stdev != 0.0:
        return crosswind_distance_stdev # meters
    else:
        return himoto_resolve_default_sigma_y(spot_config, fireline_intensity, wind_speed_20ft) # meters


@cy.cfunc
@cy.exceptval(check=False)
def resolve_JumpDistribution(spot_config       : SpotConfig,
                             fireline_intensity: cy.float,
                             wind_speed_20ft   : cy.float) -> JumpDistribution:
    ln_params: tuple[cy.float, cy.float] = resolve_lognormal_params(spot_config, fireline_intensity, wind_speed_20ft)
    # Initialize a new JumpDistribution
    return JumpDistribution(
        mu_x    = ln_params[0], # dimensionless (log-space)
        sigma_x = ln_params[1], # dimensionless (log-space)
        sigma_y = resolve_crosswind_distance_stdev(spot_config, fireline_intensity, wind_speed_20ft), # meters
    )


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def sample_downwind_jump(jd: JumpDistribution, random_generator: BufferedRandGen) -> cy.float:
    return sample_lognormal(random_generator, jd.mu_x, jd.sigma_x)


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def sample_crosswind_jump(jd: JumpDistribution, random_generator: BufferedRandGen) -> cy.float:
    return sample_normal(random_generator, 0.0, jd.sigma_y)
#+end_src

*** Spotting Probability and Number of Firebrands
    :PROPERTIES:
    :CUSTOM_ID: spotting-probability-and-number-of-firebrands
    :END:

Whether or not a cell emits firebrands is determined by a spotting
probability. Pyretechnics lets users configure separate spotting
probabilities for crown fires (*crown_fire_spotting_percent*) and for
surface fires under certain conditions
(*surface_fire_spotting_percent*). Note that these configuration keys
have misleading names (the values must be between 0 and 1).

Surface fire spotting can only happen when the fireline intensity
exceeds a certain threshold (configured with
*critical_fireline_intensity*). Both that threshold and the spotting
probability can be configured per fuel model.

If spotting occurs at a cell, the number of firebrands is randomly
drawn from a Poisson distribution, the mean of which is configured
with key *num_firebrands*. As such, non-integer values are allowed for
*num_firebrands*. The use of a Poisson distribution can help make the
behavior robust to changes in simulation resolution. That being said,
note that *num_firebrands* and/or the spotting probabilities will need
to be adjusted if you change the simulation resolution, the essential
invariant being the average number of firebrands per unit area. What's
more, it may be sensible to set the spotting probability to 1 and
compensate with a low Poisson mean.

*** Spot Ignition Model
    :PROPERTIES:
    :CUSTOM_ID: spot-ignition-model
    :END:

The Spot Ignition model describes the probability of a spot ignition
as well as when the spot ignition should occur. Perryman 2012 uses the
method described in Schroeder 1969 but adjusts the result to take into
account the distance a firebrand lands from the source tree (using
Albini 1979) and the number of firebrands that land in a cell (using
Stauffer
2008).[fn::Perryman2012][fn::Schroeder1969][fn::Albini1979][fn::Stauffer2008]

\begin{align}
  P(I)_l = P(I)\exp(-\lambda_s l) \\
  \nonumber \\
  P(I)_l^{FB} = 1 - (1 - P(I)_l)^{n_b}
\end{align}

where $\lambda_s$ is a positive number representing the decay
constant, $l$ is the firebrand's landing distance away from the source
cell. $P(I)_l$ is the probability of spot ignition taking into
consideration $l$. $P(I)_l^{FB}$ is the probability of spot fire
ignition taking into consideration $n_b$, the number of firebrands
landing in a cell.

We observe that the second formula is equivalent to a model where the
firebrands are i.i.d causes of ignition (this is consistent with the
goal of making the model insensitive to grid resolution). Therefore,
Pyretechnics will simply draw an independent Bernoulli trial for each
firebrand rather than apply the above formula.

The first formula simply says that the per-firebrand probability
decays exponentially with distance (i.e. adding $1/\lambda_s$ to the
distance divides the probability by $e$, or equivalently $l \mapsto
P(I)_l$ has derivative $\lambda_s P(I)_l$). Yet another way to say
this is that, if $\lambda_s = \text{0.005 m}^{-1}$, then each added
meter decreases $P(I)_l$ by 0.5%.

#+NAME: firebrand-ignition-probability
#+begin_src python
@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def firebrand_flight_survival_probability(spotting_distance: cy.float, decay_distance: cy.float) -> cy.float:
    """
    Returns the probability that a firebrand will survive its flight (Perryman 2012) given:
    - spotting_distance :: meters (d)
    - decay_distance    :: meters (1/lambda)

    P(Survival) = exp(-d * lambda)
    """
    return exp(-spotting_distance / decay_distance)


@cy.cfunc
@cy.exceptval(check=False)
def heat_of_preignition(temperature: cy.float, fine_fuel_moisture: cy.float) -> cy.float:
    """
    Returns heat of preignition given:
    - temperature        :: degrees Celsius
    - fine_fuel_moisture :: 0-1

    Q_ig = 144.512 - 0.266 * T_o - 0.00058 * (T_o)^2 - T_o * M + 18.54 * (1 - exp(-15.1 * M)) + 640 * M (eq. 10)
    """
    T_o: cy.float = temperature
    M  : cy.float = fine_fuel_moisture
    # Heat required to reach ignition temperature
    Q_a: cy.float = 144.512 - 0.266 * T_o - 0.00058 * (T_o * T_o)
    # Heat required to raise moisture to the boiling point
    Q_b: cy.float = -T_o * M
    # Heat of desorption
    Q_c: cy.float = 18.54 * (1.0 - exp(-15.1 * M))
    # Heat required to vaporize moisture
    Q_d: cy.float = 640.0 * M
    return Q_a + Q_b + Q_c + Q_d


@cy.cfunc
@cy.exceptval(check=False)
def schroeder_ignition_probability(temperature: cy.float, fine_fuel_moisture: cy.float) -> cy.float:
    """
    Returns the probability of spot fire ignition (Schroeder 1969) given:
    - temperature        :: degrees Celsius
    - fine_fuel_moisture :: 0-1

    X           = (400 - Q_ig) / 10
    P(Ignition) = (0.000048 * X^4.3) / 50 (pg. 15)
    """
    Q_ig      : cy.float = heat_of_preignition(temperature, fine_fuel_moisture)
    X         : cy.float = max(0.0, 400.0 - Q_ig) * 0.1
    P_Ignition: cy.float = 0.000048 * pow(X, 4.3) * 0.02
    return min(P_Ignition, 1.0)
#+end_src

A firebrand will cause an unburned cell to transition to a burned
state if the cell receives at least one firebrand and the cell's
probability of ignition as calculated by the above equations is
greater than a randomly generated uniform number.

*** Time to Spot Ignition
    :PROPERTIES:
    :CUSTOM_ID: time-to-spot-ignition
    :END:

# FIXME: Simplify the text in this section based on the following observation:
#
# We see that $t_v$ will only be a few seconds for high flamelengths,
# and a few minutes for small ones, amounting to insignificant
# contributions compared to the $t_I = 20 \text{min}$ term, which will
# dominate the time to ignition. Given that $t_I$ is only a ballpark
# guess, this questions the relevance of computing $t_v$ at all.

Once a cell has been determined to ignite, then the time until
ignition is calculated. The time until ignition is a sum of three time
intervals: the amount of time required for the firebrand to reach its
maximum vertical height $t_v$, the amount of time required for the
firebrand to descend from the maximum vertical height to the forest
floor $t_g$, and the amount of time required for a spot fire to ignite
and build up to the steady-state $t_I$. Perryman
2012[fn::Perryman2012] assumes $t_v$ and $t_g$ to be equal and used
the formula from Albini 1979[fn::Albini1979spot] to calculate it.
$t_I$ is also assumed to be 20 min as used in McAlpine
1991[fn::McAlpine1991].

By Albini 1979[fn::Albini1979spot], the time $t_v$ for a firebrand to
reach height $z$ when the flame length is $z_F$ is given by:

\begin{align}
  t_v &= \frac{2 z_F}{w_F} \left(1.2 + \frac{a}{3} \left[ \left(\frac{b + (z/z_F)}{a}\right)^\frac{3}{2} - 1 \right] \right) & \\
  \nonumber \\
  w_F &= 2.3 \text{ m/s} \sqrt{\frac{z_F}{1 \text{ m}}} & \\
  \nonumber \\
  a   &= 5.963 & \\
  \nonumber \\
  b   &=  a - 1.4 & \\
\end{align}

In the notation of Albini 1979[fn::Albini1979spot], we would have $t_v
= \frac{2 z_F}{w_F}(t_T - t_o)$.

Albini 1979[fn::Albini1979spot] also provides a formula - (D44) - for
the maximum height $z_\text{max}$ that a firebrand can reach while
still glowing when it hits the ground, as a function of the firebrand
diameter $D$ in a cylinder model:

\begin{align}
  z_\text{max} = D \times 0.39 \times 10^5
\end{align}

To estimate firebrand travel time, Pyretechnics makes the assumption
that each firebrand will reach $z_\text{max}$, where $z_\text{max}$ is
computed for $D = 3\text{mm}$, yielding $z_\text{max} = 117 \text{m}$.

To make the above formulas more tangible, observe that when the flame
length is small enough that $z_F \ll z_\text{max}$, the above formulas
simplify into the following approximation:

\begin{align}
  t_v \underset{z_F \ll z_\text{max}}{\approx} \frac{2}{3 \sqrt{a}} \frac{\sqrt{z_\text{max} \times 1Â \text{m}}}{2.3 \text{m/s}}\frac{z_\text{max}}{z_F}
\end{align}

Plugging in Pyretechnics' choice of $z_\text{max} = 117 \text{m}$
yields:

\begin{align}
  t_v \underset{z_F \ll z_\text{max}}{\approx} 1.28 \text{s} \times \frac{117 \text{m}}{z_F}
\end{align}

In other words, in the limit of small-enough flame lengths, the
firebrand is assumed to elevate at a constant vertical speed
$(z_F/1.28 \text{s})$ which is proportional to the flame length, until
it reaches $z_\text{max} = 117 \text{m}$. For example, if the flame
length is 1.17m (100x smaller than $z_\text{max}$), $t_v$ is about
128s.

#+NAME: firebrands-time-of-ignition
#+begin_src python
# FIXME: unused
@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def albini_firebrand_maximum_height(firebrand_diameter: cy.float) -> cy.float:
    return 0.39e5 * firebrand_diameter


@cy.cfunc
@cy.exceptval(check=False)
def albini_t_max(flame_length: cy.float) -> cy.float:
    """
    Returns the time of spot ignition using Albini1979spot in minutes given:
    - flame_length :: meters [z_F]

    a           = 5.963                                                             (D33)
    b           = a - 1.4                                                           (D34)
    D           = 0.003
    z           = 0.39 * D * 10^5
    w_F         = 2.3 * z_F^0.5                                                     (A58)
    t_c         = 1
    t_o         = t_c / (2 * z_F / w_F)
    travel_time = t_1 + t_2 + t_3 = 1.2 + (a / 3) * (((b + (z/z_F)) / a)^3/2 - 1)   (D43)
    """
    a        : cy.float = 5.963  # dimensionless constant from (D33)
    b        : cy.float = 4.563  # dimensionless constant from (D34)
    z        : cy.float = 117.0  # maximum altitude of firebrands in meters [derived for (D44) in (Albini1979spot)]
    z_F      : cy.float = flame_length                      # m
    w_F      : cy.float = 2.3 * sqrt(flame_length)          # m/s
    charact_t: cy.float = conv.sec_to_min(2.0 * z_F / w_F)  # min
    # The following dimensionless factor is equal to t_T - t_o, with t_T defined by (D43) in Albini1979spot.
    u          : cy.float = (b + z / z_F) / a
    u3_2       : cy.float = u * sqrt(u) # Faster than ** 1.5
    travel_time: cy.float = 1.2 + (a / 3.0) * (u3_2 - 1.0)
    return charact_t * travel_time


# FIXME: What is t_max still doing here? I thought we decided to neglect the flight time! (Val)
@cy.cfunc
@cy.exceptval(check=False)
def spot_ignition_time(time_of_arrival: cy.float, flame_length: cy.float) -> cy.float:
    """
    Returns the time of spot ignition using Albini 1979 and Perryman 2012 in minutes given:
    - time_of_arrival :: minutes
    - flame_length    :: meters

    t_spot = time_of_arrival + (2 * t_max) + t_ss
    """
    t_max         : cy.float = albini_t_max(flame_length)
    t_steady_state: cy.float = 20.0 # period of building up to steady state from ignition (min)
    return time_of_arrival + 2.0 * t_max + t_steady_state
#+end_src

*** Spreading Firebrands
    :PROPERTIES:
    :CUSTOM_ID: spreading-firebrands
    :END:

Once the locations, ignition probabilities, and times of ignition have
been calculated for each of the firebrands, a tuple of
*(spot_ignition_time, ignition_locations)* are returned, to be
processed in the fire spread algorithm (see section [[Fire Spread
Algorithm (ELMFIRE): Eulerian Level Set Method
(pyretechnics.eulerian_level_set)]]), where *spot_ignition_time* is
the ignition time of the spot fire in minutes, and
*ignition_locations* is a list of *(y,x)* grid coordinates in which
spot fires will be ignited.


#+NAME: spread-firebrands
#+begin_src python
@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def is_in_bounds(y: pyidx, x: pyidx, rows: pyidx, cols: pyidx) -> cy.bint:
    """
    Returns True if the grid coordinate (y,x) lies within the bounds [0,rows) by [0,cols).
    """
    return (y >= 0) and (x >= 0) and (y < rows) and (x < cols)


@cy.cfunc
@cy.exceptval(check=False)
def is_burnable_cell(fuel_model_cube: ISpaceTimeCube, t: pyidx, y: pyidx, x: pyidx) -> cy.bint:
    """
    Returns True if the space-time coordinate (t,y,x) contains a burnable fuel model.
    """
    fuel_model_number: cy.int = cy.cast(cy.int, fuel_model_cube.get(t,y,x))
    return fm.is_burnable_fuel_model_number(fuel_model_number)


@cy.cfunc
@cy.exceptval(check=False)
def cast_firebrand(rng                        : BufferedRandGen,
                   fuel_model_cube            : ISpaceTimeCube,
                   temperature_cube           : ISpaceTimeCube,
                   fuel_moisture_dead_1hr_cube: ISpaceTimeCube,
                   fire_type_matrix           : cy.uchar[:,::1],
                   rows                       : pyidx,
                   cols                       : pyidx,
                   cell_height                : cy.float,
                   cell_width                 : cy.float,
                   source_t                   : pyidx,
                   source_y                   : pyidx,
                   source_x                   : pyidx,
                   decay_distance             : cy.float,
                   cos_wdir                   : cy.float,
                   sin_wdir                   : cy.float,
                   jd                         : JumpDistribution) -> coord_yx:
    """
    Draws a random [ÎX, ÎY] pair of signed distances (in meters) from
    the supplied cell, representing the coordinates of the spotting jump in the directions
    parallel and perpendicular to the wind. ÎX will typically be positive (downwind),
    and positive ÎY means to the right of the downwind direction.

    NOTE: If the random draw yields no spot ignition, the source cell coordinates will be returned.
          Calling code should check for that.
    """
    #=======================================================================================
    # Determine where the firebrand will land
    #=======================================================================================

    delta_y: cy.float = sample_crosswind_jump(jd, rng)                         # meters
    delta_x: cy.float = sample_downwind_jump(jd, rng)                          # meters
    grid_dy: cy.float = delta_to_grid_dy(cos_wdir, sin_wdir, delta_x, delta_y) # meters
    grid_dx: cy.float = delta_to_grid_dx(cos_wdir, sin_wdir, delta_x, delta_y) # meters
    # NOTE: It would cause a bug to type the following as pyidx.
    target_y: cy.int = source_y + distance_to_n_cells(grid_dy, cell_height)
    target_x: cy.int = source_x + distance_to_n_cells(grid_dx, cell_width)

    #=======================================================================================
    # Determine whether the firebrand will start a fire or fizzle out
    #=======================================================================================

    if is_in_bounds(target_y, target_x, rows, cols) and fire_type_matrix[target_y,target_x] == 0:
        # Firebrand landed on the grid in an unburned cell
        # Calculate the probability that the firebrand survived its flight and landed while still burning
        spotting_distance          : cy.float = sqrt(grid_dx * grid_dx + grid_dy * grid_dy) # meters
        flight_survival_probability: cy.float = firebrand_flight_survival_probability(spotting_distance,
                                                                                      decay_distance)

        # Roll the dice
        uniform_sample: cy.float = rng.next_uniform()

        if (uniform_sample <= flight_survival_probability
            and is_burnable_cell(fuel_model_cube, source_t, target_y, target_x)):
            # Firebrand landed in a cell with a burnable fuel model, so calculate its ignition probability
            temperature         : cy.float = temperature_cube.get(source_t, target_y, target_x) # degrees Celsius
            fine_fuel_moisture  : cy.float = fuel_moisture_dead_1hr_cube.get(source_t, target_y, target_x) # %
            ignition_probability: cy.float = schroeder_ignition_probability(temperature, fine_fuel_moisture)

            if uniform_sample <= flight_survival_probability * ignition_probability:
                # Firebrand ignited the target cell, so return its coordinates for later processing
                return (target_y, target_x)
    # This code is only reached if the spotting ignition fails.
    # For efficiency, the source cell is used as a sentinel value for a failed spot ignition.
    return (source_y, source_x)


@cy.cfunc
def spread_firebrands(fuel_model_cube            : ISpaceTimeCube,
                      temperature_cube           : ISpaceTimeCube,
                      fuel_moisture_dead_1hr_cube: ISpaceTimeCube,
                      fire_type_matrix           : cy.uchar[:,::1],
                      sim_area_bounds            : coord_yx,
                      cell_height                : cy.float,
                      cell_width                 : cy.float,
                      space_time_coordinate      : coord_tyx,
                      wind_speed_10m             : cy.float, # km/hr (for shame!)
                      upwind_direction           : cy.float, # degrees
                      fireline_intensity         : cy.float,
                      flame_length               : cy.float,
                      time_of_arrival            : cy.float,
                      random_generator           : BufferedRandGen,
                      num_firebrands             : cy.long,
                      spot_config                : SpotConfig) -> object: # tuple[float, set]|None
    """
    Given these inputs:
    - fuel_model_cube             :: (Lazy)SpaceTimeCube (integer index in fm.fuel_model_table)
    - temperature_cube            :: (Lazy)SpaceTimeCube (degrees Celsius)
    - fuel_moisture_dead_1hr_cube :: (Lazy)SpaceTimeCube (kg moisture/kg ovendry weight)
    - fire_type_matrix            :: 2D byte array (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)
    - sim_area_bounds             :: tuple with these fields
      - rows                         :: number of rows on the simulation grid
      - cols                         :: number of columns on the simulation grid
    - cell_height                 :: meters
    - cell_width                  :: meters
    - space_time_coordinate       :: (t,y,x) coordinate in which the source cell burns
    - upwind_direction            :: degrees clockwise from North
    - wind_speed_10m              :: km/hr
    - fireline_intensity          :: kW/m
    - flame_length                :: m
    - time_of_arrival             :: min
    - random_generator            :: BufferedRandGen
    - num_firebrands              :: number of firebrands to emit from the space_time_coordinate
    - spot_config                 :: SpotConfig struct of spotting parameters
      - downwind_distance_mean       :: meters
      - fireline_intensity_exponent  :: downwind_distance_mean multiplier [I^fireline_intensity_exponent]
      - wind_speed_exponent          :: downwind_distance_mean multiplier [U^wind_speed_exponent]
      - downwind_variance_mean_ratio :: meters^2 / meter [downwind_variance_mean_ratio = Var(X) / E(X)]
      - crosswind_distance_stdev     :: meters
      - decay_distance               :: meters

    casts num_firebrands from the space_time_coordinate into grid cells in the space-time cube, filters out
    all of the firebrands that fizzle out in either burnable or non-burnable fuels, and returns any that ignite
    new spot fires in a tuple with these fields:

    - ignition_time :: minutes
    - ignited_cells :: set of (y,x) grid coordinates
    """
    #=======================================================================================
    # Ensure that the source cell is casting firebrands
    #=======================================================================================

    if num_firebrands > 0:

        #=======================================================================================
        # Ensure that there is wind to transport the firebrands
        #=======================================================================================

        if wind_speed_10m > 0.0:

            #=======================================================================================
            # Unpack all firebrand-related features of the source cell
            #=======================================================================================

            # TODO: OPTIM Get rid of trigonometry here if possible by having callers pass vectors.
            (rows, cols)                          = sim_area_bounds
            (t, y, x)                             = space_time_coordinate
            decay_distance     : cy.float         = spot_config.decay_distance
            downwind_direction : cy.float         = conv.deg_to_rad(conv.opposite_direction(upwind_direction))
            cos_wdir           : cy.float         = cos(downwind_direction)
            sin_wdir           : cy.float         = sin(downwind_direction)
            wind_speed_20ft    : cy.float         = conv.wind_speed_10m_to_wind_speed_20ft(wind_speed_10m) # km/hr
            wind_speed_20ft_mps: cy.float         = conv.km_hr_to_mps(wind_speed_20ft)                     # m/s
            jd                 : JumpDistribution = resolve_JumpDistribution(spot_config,
                                                                             fireline_intensity,
                                                                             wind_speed_20ft_mps)

            #=======================================================================================
            # Cast each firebrand and accumulate any ignited cells
            #=======================================================================================

            # FIXME: A set is slow, so use a list instead. Collisions can happen with other source cells anyway.
            ignited_cells: set = set()
            i: cy.long
            for i in range(num_firebrands):
                ignited_cell: coord_yx = cast_firebrand(random_generator,
                                                        fuel_model_cube,
                                                        temperature_cube,
                                                        fuel_moisture_dead_1hr_cube,
                                                        fire_type_matrix,
                                                        rows,
                                                        cols,
                                                        cell_height,
                                                        cell_width,
                                                        t,
                                                        y,
                                                        x,
                                                        decay_distance,
                                                        cos_wdir,
                                                        sin_wdir,
                                                        jd)
                if (ignited_cell[0] != y) or (ignited_cell[1] != x):
                    ignited_cells.add(ignited_cell)

            #=======================================================================================
            # Return any cells ignited by firebrands along with their time of ignition
            #=======================================================================================

            if len(ignited_cells) > 0:
                ignition_time: cy.float = spot_ignition_time(time_of_arrival, flame_length) # minutes
                return (ignition_time, ignited_cells)
#+end_src

** For Users
   :PROPERTIES:
   :CUSTOM_ID: for-users-spot
   :header-args:python+: :session *examples:pyretechnics.spot_fire*
   :header-args:python+: :results output replace
   :header-args:python+: :exports both
   :END:

*** How to Estimate the Areal Heat Output for All Surface Fuel Models
    :PROPERTIES:
    :CUSTOM_ID: how-to-estimate-the-areal-heat-output-for-all-surface-fuel-models
    :END:

#+NAME: estimate-areal-heat-output
#+begin_src python
import matplotlib.pyplot as plt
import numpy as np
from pprint import pprint
import pyretechnics.fuel_models as fm
import pyretechnics.surface_fire as sf

def calc_areal_heat_output_from_fuel_model(moisturized_fuel_model):
    fire_behavior      = sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model)
    spread_rate        = fire_behavior["base_spread_rate"]            # m/min
    fireline_intensity = fire_behavior["base_fireline_intensity"]     # kW/m
    return sf.calc_areal_heat_output(spread_rate, fireline_intensity) # kJ/m^2

def save_areal_heat_output_as_histogram(areal_heat_output, moisture_category):
    plt.hist(areal_heat_output[moisture_category],
             range=(0, 60000),
             bins=12,
             density=True,
             histtype="bar",
             color="darkred",
             edgecolor="black")
    plt.title("Areal Heat Output for All Surface Fuel Models - " + str.capitalize(moisture_category) + " Conditions")
    plt.xlabel("Areal Heat Output (kJ/m^2)")
    plt.ylabel("Probability Density")
    plt.savefig("pics/fm_areal_heat_output_" + moisture_category + ".png")
    plt.close("all")

fuel_moisture_dry = [
    0.025, # dead_1hr
    0.050, # dead_10hr
    0.075, # dead_100hr
    0.00, # dead_herbaceous (will be set by moisturize for dynamic fuel models)
    0.45, # live_herbaceous
    0.30, # live_woody
]

fuel_moisture_mod = [
    0.05, # dead_1hr
    0.10, # dead_10hr
    0.15, # dead_100hr
    0.00, # dead_herbaceous (will be set by moisturize for dynamic fuel models)
    0.90, # live_herbaceous
    0.60, # live_woody
]

fuel_moisture_wet = [
    0.10, # dead_1hr
    0.20, # dead_10hr
    0.30, # dead_100hr
    0.00, # dead_herbaceous (will be set by moisturize for dynamic fuel models)
    1.80, # live_herbaceous
    1.20, # live_woody
]

areal_heat_output = {
    "dry": [calc_areal_heat_output_from_fuel_model(fm.moisturize(v, fuel_moisture_dry))
            for v in fm.fuel_model_table.values()],
    "mod": [calc_areal_heat_output_from_fuel_model(fm.moisturize(v, fuel_moisture_mod))
            for v in fm.fuel_model_table.values()],
    "wet": [calc_areal_heat_output_from_fuel_model(fm.moisturize(v, fuel_moisture_wet))
            for v in fm.fuel_model_table.values()],
}

for moisture_category in ["dry", "mod", "wet"]:
    save_areal_heat_output_as_histogram(areal_heat_output, moisture_category)

print("Median Areal Heat Output (kJ/m^2) for All Surface Fuel Models\n" + "=" * 80)
pprint({
    "dry": np.median(areal_heat_output["dry"]),
    "mod": np.median(areal_heat_output["mod"]),
    "wet": np.median(areal_heat_output["wet"]),
})

print("\nMean Areal Heat Output (kJ/m^2) for All Surface Fuel Models\n" + "=" * 80)
pprint({
    "dry": np.mean(areal_heat_output["dry"]),
    "mod": np.mean(areal_heat_output["mod"]),
    "wet": np.mean(areal_heat_output["wet"]),
})

print("\nMax Areal Heat Output (kJ/m^2) for All Surface Fuel Models\n" + "=" * 80)
pprint({
    "dry": np.max(areal_heat_output["dry"]),
    "mod": np.max(areal_heat_output["mod"]),
    "wet": np.max(areal_heat_output["wet"]),
})
#+end_src

#+NAME: run-estimate-areal-heat-output
#+RESULTS: estimate-areal-heat-output
#+begin_example
Median Areal Heat Output (kJ/m^2) for All Surface Fuel Models
================================================================================
{'dry': 9517.751889162279, 'mod': 7050.1670422893385, 'wet': 3533.8201824045955}

Mean Areal Heat Output (kJ/m^2) for All Surface Fuel Models
================================================================================
{'dry': 14270.339217272918,
 'mod': 10954.330808704475,
 'wet': 5705.4111616613945}

Max Areal Heat Output (kJ/m^2) for All Surface Fuel Models
================================================================================
{'dry': 54285.275558317175, 'mod': 45108.6289738327, 'wet': 32325.037970995523}
#+end_example

#+NAME: areal-heat-output-all-fm-dry
#+caption: Areal Heat Output for All Surface Fuel Models - Dry Conditions
file:pics/fm_areal_heat_output_dry.png

#+NAME: areal-heat-output-all-fm-mod
#+caption: Areal Heat Output for All Surface Fuel Models - Mod Conditions
file:pics/fm_areal_heat_output_mod.png

#+NAME: areal-heat-output-all-fm-wet
#+caption: Areal Heat Output for All Surface Fuel Models - Wet Conditions
file:pics/fm_areal_heat_output_wet.png

*** How to Estimate the Number of Firebrands Cast per Burned Cell
    :PROPERTIES:
    :CUSTOM_ID: how-to-estimate-the-number-of-firebrands-cast-per-burned-cell
    :END:

Several spotting parameters can be adjusted by the user:

#+NAME: tab:spotting-parameters
#+caption: User adjustable spotting parameters
|------------------------------+----------------------------------------+------------------------------------------------------------------------|
| Parameter                    | Units                                  | Description                                                            |
|------------------------------+----------------------------------------+------------------------------------------------------------------------|
| random_seed                  | $\text{integer}$ or $\text{Generator}$ | seed for a numpy.random.Generator object                               |
| firebrands_per_unit_heat     | $\text{firebrands}/\text{kJ}$          | number of firebrands to emit per kilojoule                             |
| downwind_distance_mean       | $\text{m}$                             | normal distribution mean underpinning lognormal distribution           |
| fireline_intensity_exponent  | $\text{-}$                             | downwind_distance_mean multiplier [I^fireline_intensity_exponent]      |
| wind_speed_exponent          | $\text{-}$                             | downwind_distance_mean multiplier [U^wind_speed_exponent]              |
| downwind_variance_mean_ratio | $\text{m}^2/\text{m}$                  | normal distribution variance divided by expected value [Var(X) / E(X)] |
| crosswind_distance_stdev     | $\text{m}$                             | crosswind normal distribution standard deviation (mean = 0)            |
| decay_distance               | $\text{m}$                             | spotting distance at which ignition probability is divided by $e$      |
|------------------------------+----------------------------------------+------------------------------------------------------------------------|

In this section, we will look at *firebrands_per_unit_heat* and
*decay_distance* specifically as they have the most direct bearing on
the number of firebrands produced from each burning cell as well as
how many of these will ignite new spot fires rather than fizzle out.

From section [[How to Estimate the Areal Heat Output for All Surface
Fuel Models]], we can see that heat outputs across all surface fuel
models under moderately dry conditions range from about 0-45,000
$\text{kJ}/\text{m}^2$.

Here, we will calculate some representative ignition probabilities and
expected spot fire counts per burning cell given the following input
variable ranges:

- *heat output per area*: 0-45,000 $\text{kJ}/\text{m}^2$
- *heat per firebrand*: 500,000-2,000,000 $\text{kJ}/\text{firebrand}$
- *spotting distance from burning cell*: 30-900 meters (e.g., 1-30 cells @ 30m resolution)
- *decay distance*: 30-900 meters (e.g., 1-30 cells @ 30m resolution)
- *temperature at target cell*: 20-40 degrees Celsius
- *fine fuel moisture at target cell*: 5-20%

In this example, we will assume a flat landscape (no slope) with 30
meter resolution grid cells. This gives us a cell area of 900 $\text{m}^2$.

#+NAME: estimate-spot-fire-ignition-probability
#+begin_src python
from pprint import pprint
import pyretechnics.spot_fire as spot


cell_area = 900 # m^2


firebrand_counts = sorted([heat_output_per_area * cell_area * firebrands_per_unit_heat
                           for heat_output_per_area in range(0, 45001, 5000)
                           for firebrands_per_unit_heat in map(lambda x: 1/x, range(int(5e5), int(2e6)+1, int(5e5)))])


distance_penalties = sorted([spot.firebrand_flight_survival_probability(spotting_distance, decay_distance)
                             for spotting_distance in range(30, 901, 30)
                             for decay_distance in range(30, 901, 30)])


schroeder_probs = sorted([spot.schroeder_ignition_probability(temperature, moisture / 100)
                          for temperature in range(20, 41, 5)
                          for moisture in range(5, 21, 5)])


ignition_probs = sorted([dp * sp
                         for dp in distance_penalties
                         for sp in schroeder_probs])


spot_fire_counts = sorted([fb * ip
                           for fb in firebrand_counts
                           for ip in ignition_probs])


def percentile_indices(coll):
    """
    Return the 0th, 25th, 50th, 75th, and 100th percentile indices for coll.
    """
    max_index = len(coll) - 1
    return map(lambda p: (p, int(p * max_index)),
               [0.0, 0.25, 0.5, 0.75, 1.0])


firebrand_count_percs = {int(100 * p_v[0]): firebrand_counts[p_v[1]]
                         for p_v in percentile_indices(firebrand_counts)}


distance_penalty_percs = {int(100 * p_v[0]): distance_penalties[p_v[1]]
                          for p_v in percentile_indices(distance_penalties)}


schroeder_prob_percs = {int(100 * p_v[0]): schroeder_probs[p_v[1]]
                        for p_v in percentile_indices(schroeder_probs)}


ignition_prob_percs = {int(100 * p_v[0]): ignition_probs[p_v[1]]
                       for p_v in percentile_indices(ignition_probs)}


spot_fire_count_percs = {int(100 * p_v[0]): spot_fire_counts[p_v[1]]
                         for p_v in percentile_indices(spot_fire_counts)}


pprint({
    "firebrand_count_percentiles"               : firebrand_count_percs,
    "flight_distance_penalty_percentiles"       : distance_penalty_percs,
    "schroeder_ignition_probability_percentiles": schroeder_prob_percs,
    "spot_ignition_probability_percentiles"     : ignition_prob_percs,
    "spot_fire_count_percentiles"               : spot_fire_count_percs,
}, sort_dicts=False)
#+end_src

#+NAME: estimate-spot-fire-ignition-probability-results
#+RESULTS: estimate-spot-fire-ignition-probability
#+begin_example
{'firebrand_count_percentiles': {0: 0.0,
                                 25: 6.75,
                                 50: 15.75,
                                 75: 27.0,
                                 100: 81.0},
 'flight_distance_penalty_percentiles': {0: 9.357622968840175e-14,
                                         25: 0.1353352832366127,
                                         50: 0.36787944117144233,
                                         75: 0.5961628688829711,
                                         100: 0.9672161004820059},
 'schroeder_ignition_probability_percentiles': {0: 0.0410643084416302,
                                                25: 0.05806152126033939,
                                                50: 0.1462606114856146,
                                                75: 0.32092711244047045,
                                                100: 0.6532412198970651},
 'spot_ignition_probability_percentiles': {0: 3.842643158729363e-15,
                                           25: 0.016675322729050666,
                                           50: 0.05110365673058294,
                                           75: 0.1456615550998886,
                                           100: 0.6318254253829478},
 'spot_fire_count_percentiles': {0: 0.0,
                                 25: 0.09538065053197298,
                                 50: 0.6628202779508812,
                                 75: 2.3768372423970905,
                                 100: 51.17785945601877}}
#+end_example

We can see that depending on the surface fuel model and weather
conditions at the cells receiving firebrands, we can get anywhere from
0-51 spot fires ignited by one burning cell per timestep using the
ranges for *firebrands_per_unit_heat* and *decay_distance* provided
above.

*** How to Estimate Typical Ranges for the $\vec{\Delta}$ Distribution Characteristics
    :PROPERTIES:
    :CUSTOM_ID: how-to-estimate-typical-ranges-for-the-$\vec{\delta}$-distribution-characteristics
    :END:

#+NAME: himoto-typical-ranges
#+begin_src python :results table raw
from math import sqrt, log

def himoto_eq_28_values(B_star):
    # NOTE: The following value for D seems absurdly low, and so does
    # the predicted E[ÎX]. I suspect a typo in the Himoto2005 paper.
    D                  = 0.08
    std_delta_x_over_D = 0.88 * (B_star ** (1.0 / 3.0))
    exp_delta_x_over_D = 0.47 * (B_star ** (2.0 / 3.0))
    cv_delta_x         = std_delta_x_over_D / exp_delta_x_over_D
    sigma_x            = sqrt(log(1.0 + cv_delta_x))
    exp_delta_x        = exp_delta_x_over_D * D
    mu_x               = log(exp_delta_x) - (sigma_x ** 2.0) / 2.0
    sigma_y            = D * 0.92
    return {
        "$B^*$"                             : B_star,
        "$\\text{CV}[\\Delta_X]$"           : "{:.0f}%".format(100.0 * cv_delta_x),
        "$\\sigma_X$"                       : "{:.2f}".format(sigma_x),
        "$\\sigma_Y/\\mathbb{E}[\\Delta_X]$": "{:.2f}".format(sigma_y / exp_delta_x),
        # NOTE the following ended up being nonsensical:
        # "E[ÎX] (m)" exp_delta_x
        # "Î¼_X"       mu_x
    }

himoto_typical_ranges = [himoto_eq_28_values(B_star) for B_star in [20, 50, 100, 150, 200]]
table_header          = list(himoto_typical_ranges[0].keys())
table_rows            = [list(d.values()) for d in himoto_typical_ranges]

print([table_header, *table_rows])
#+end_src

#+NAME: run-himoto-typical-ranges
#+RESULTS: himoto-typical-ranges
| $B^*$ | $\text{CV}[\Delta_X]$ | $\sigma_X$ | $\sigma_Y/\mathbb{E}[\Delta_X]$ |
|    20 |                   69% |       0.72 |                            0.27 |
|    50 |                   51% |       0.64 |                            0.14 |
|   100 |                   40% |       0.58 |                            0.09 |
|   150 |                   35% |       0.55 |                            0.07 |
|   200 |                   32% |       0.53 |                            0.06 |

* Burning Cells on a Grid (pyretechnics.burn_cells)
  :PROPERTIES:
  :CUSTOM_ID: burning-cells-on-a-grid-(pyretechnics.burn_cells)
  :END:
** For Developers
   :PROPERTIES:
   :CUSTOM_ID: for-developers-burn-cells
   :header-args:python+: :session *pyretechnics.burn_cells*
   :header-args:python+: :tangle  ../src/pyretechnics/burn_cells.py
   :header-args:python+: :exports code
   :END:

This module provides convenience functions that apply the fuel model
and moisture definitions from section [[Fuel Model and Moisture
Definitions (pyretechnics.fuel_models)]], surface fire equations from
section [[Surface Fire Equations (pyretechnics.surface_fire)]], and crown
fire equations from section [[Crown Fire Equations
(pyretechnics.crown_fire)]] to cells within a space-time cube, returning
their combined surface and crown fire behavior.

*** Module Imports
    :PROPERTIES:
    :CUSTOM_ID: module-imports-burn-cells
    :END:

#+NAME: burn-cells-imports
#+begin_src python
import cython
import cython as cy
import numpy as np
if cython.compiled:
    from cython.cimports.pyretechnics.cy_types import \
        pyidx, vec_xy, vec_xyz, coord_tyx, fclaarr, FuelModel, FireBehaviorMin, FireBehaviorMax, SpreadBehavior
    from cython.cimports.pyretechnics.space_time_cube import ISpaceTimeCube, to_positive_index_range
    import cython.cimports.pyretechnics.conversion as conv
    import cython.cimports.pyretechnics.vector_utils as vu
    import cython.cimports.pyretechnics.fuel_models as fm
    import cython.cimports.pyretechnics.surface_fire as sf
    import cython.cimports.pyretechnics.crown_fire as cf
else:
    from pyretechnics.py_types import \
        pyidx, vec_xy, vec_xyz, coord_tyx, fclaarr, FuelModel, FireBehaviorMin, FireBehaviorMax, SpreadBehavior
    from pyretechnics.space_time_cube import ISpaceTimeCube, to_positive_index_range
    import pyretechnics.conversion as conv
    import pyretechnics.vector_utils as vu
    import pyretechnics.fuel_models as fm
    import pyretechnics.surface_fire as sf
    import pyretechnics.crown_fire as cf
#+end_src

*** Burn Cell as a Head Fire
    :PROPERTIES:
    :CUSTOM_ID: burn-cell-as-a-head-fire
    :END:

Sometimes the goal of a fire behavior analysis is to determine the
most extreme behavior to be expected, given static measurements of
surface fuels, tree canopy characteristics, topography, wind, and
moisture. The following function computes the maximum surface fire
behavior and checks to see whether its maximum surface fireline
intensity causes a crown fire. If so, the maximum crown fire behavior
is computed and combined with the maximum surface fire behavior as per
section [[Combining Surface and Crown Fire Behavior]]. If not, the maximum
surface fire behavior is returned.

#+NAME: burn-cell-as-head-fire
#+begin_src python
@cy.cfunc
@cy.inline
def SpreadBehavior_to_dict(sb: SpreadBehavior) -> dict:
    return {
        "fire_type"         : sb.fire_type,
        "spread_rate"       : sb.spread_rate,
        "spread_direction"  : sb.spread_direction,
        "fireline_intensity": sb.fireline_intensity,
        "flame_length"      : sb.flame_length,
    }


@cy.ccall
def burn_cell_as_head_fire(space_time_cubes      : dict[str, ISpaceTimeCube],
                           space_time_coordinate : coord_tyx,
                           use_wind_limit        : cy.bint = True,
                           surface_lw_ratio_model: str = "behave",
                           crown_max_lw_ratio    : cy.float = 1e10) -> dict:
    """
    Given these inputs:
    - space_time_cubes             :: dictionary of (Lazy)SpaceTimeCube objects with these cell types
      - slope                         :: rise/run
      - aspect                        :: degrees clockwise from North
      - fuel_model                    :: integer index in fm.fuel_model_table
      - canopy_cover                  :: 0-1
      - canopy_height                 :: m
      - canopy_base_height            :: m
      - canopy_bulk_density           :: kg/m^3
      - wind_speed_10m                :: km/hr
      - upwind_direction              :: degrees clockwise from North
      - fuel_moisture_dead_1hr        :: kg moisture/kg ovendry weight
      - fuel_moisture_dead_10hr       :: kg moisture/kg ovendry weight
      - fuel_moisture_dead_100hr      :: kg moisture/kg ovendry weight
      - fuel_moisture_live_herbaceous :: kg moisture/kg ovendry weight
      - fuel_moisture_live_woody      :: kg moisture/kg ovendry weight
      - foliar_moisture               :: kg moisture/kg ovendry weight
      - fuel_spread_adjustment        :: float >= 0.0 (Optional: defaults to 1.0)
      - weather_spread_adjustment     :: float >= 0.0 (Optional: defaults to 1.0)
    - space_time_coordinate        :: (t,y,x)
    - use_wind_limit               :: boolean (Optional)
    - surface_lw_ratio_model       :: "rothermel" or "behave" (Optional)
    - crown_max_lw_ratio           :: float > 0.0 (Optional)

    return a dictionary with these fire behavior values for the space-time coordinate (t,y,x):
    - fire_type          :: 0 (unburned), 1 (surface), 2 (passive_crown), or 3 (active_crown)
    - spread_rate        :: m/min
    - spread_direction   :: (x, y, z) unit vector on the slope-tangential plane
    - fireline_intensity :: kW/m
    - flame_length       :: m
    """
    #================================================================================================
    # Destructure the space_time_coordinate
    #================================================================================================

    (t, y, x) = space_time_coordinate

    #================================================================================================
    # Unpack the space_time_cubes dictionary
    #================================================================================================

    # Topography, Fuel Model, and Vegetation
    slope              : cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["slope"]).get(t, y, x)
    aspect             : cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["aspect"]).get(t, y, x)
    fuel_model_number  : cy.int   = cy.cast(cy.int, cy.cast(ISpaceTimeCube, space_time_cubes["fuel_model"]).get(t, y, x))
    canopy_cover       : cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["canopy_cover"]).get(t, y, x)
    canopy_height      : cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["canopy_height"]).get(t, y, x)
    canopy_base_height : cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["canopy_base_height"]).get(t, y, x)
    canopy_bulk_density: cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["canopy_bulk_density"]).get(t, y, x)

    # Wind, Surface Moisture, and Foliar Moisture
    wind_speed_10m               : cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["wind_speed_10m"]).get(t, y, x)
    upwind_direction             : cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["upwind_direction"]).get(t, y, x)
    fuel_moisture_dead_1hr       : cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["fuel_moisture_dead_1hr"]).get(t, y, x)
    fuel_moisture_dead_10hr      : cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["fuel_moisture_dead_10hr"]).get(t, y, x)
    fuel_moisture_dead_100hr     : cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["fuel_moisture_dead_100hr"]).get(t, y, x)
    fuel_moisture_live_herbaceous: cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["fuel_moisture_live_herbaceous"]).get(t, y, x)
    fuel_moisture_live_woody     : cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["fuel_moisture_live_woody"]).get(t, y, x)
    foliar_moisture              : cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["foliar_moisture"]).get(t, y, x)

    # Spread Rate Adjustments (Optional)
    fuel_spread_adjustment   : cy.float = (cy.cast(ISpaceTimeCube, space_time_cubes["fuel_spread_adjustment"]).get(t, y, x)
                                           if "fuel_spread_adjustment" in space_time_cubes
                                           else 1.0)                                         # float >= 0.0
    weather_spread_adjustment: cy.float = (cy.cast(ISpaceTimeCube, space_time_cubes["weather_spread_adjustment"]).get(t, y, x)
                                           if "weather_spread_adjustment" in space_time_cubes
                                           else 1.0)                                         # float >= 0.0
    spread_rate_adjustment   : cy.float = fuel_spread_adjustment * weather_spread_adjustment # float >= 0.0

    #================================================================================================
    # Check whether cell is burnable
    #================================================================================================

    fuel_model      : FuelModel
    maybe_fuel_model: FuelModel|None = fm.fuel_model_table.get(fuel_model_number)

    if maybe_fuel_model:
        fuel_model = maybe_fuel_model

    if (maybe_fuel_model is None or not(fuel_model.burnable)):
        # Encountered unknown or non-burnable fuel model

        #================================================================================================
        # Create a 3D unit vector pointing upslope on the slope-tangential plane
        #================================================================================================

        upslope_direction: cy.float = conv.opposite_direction(aspect)
        slope_vector_2d  : vec_xy   = conv.azimuthal_to_cartesian(slope, upslope_direction)
        slope_vector_3d  : vec_xyz  = vu.to_slope_plane(slope_vector_2d, slope_vector_2d)
        default_direction: vec_xyz  = (0.0, 1.0, 0.0) # default: North
        spread_direction : vec_xyz  = vu.as_unit_vector_3d(slope_vector_3d) if slope > 0.0 else default_direction

        #============================================================================================
        # Return zero surface fire behavior
        #============================================================================================

        return {
            "fire_type"         : 0, # unburned
            "spread_rate"       : 0.0,
            "spread_direction"  : spread_direction,
            "fireline_intensity": 0.0,
            "flame_length"      : 0.0,
        }

    else:
        # Encountered burnable fuel model

        #============================================================================================
        # Compute derived parameters
        #============================================================================================

        fuel_moisture               : fclaarr  = (fuel_moisture_dead_1hr,
                                                  fuel_moisture_dead_10hr,
                                                  fuel_moisture_dead_100hr,
                                                  0.0, # fuel_moisture_dead_herbaceous
                                                  fuel_moisture_live_herbaceous,
                                                  fuel_moisture_live_woody) # kg moisture/kg ovendry weight
        fuel_bed_depth              : cy.float = fuel_model.delta                      # ft
        heat_of_combustion          : cy.float = conv.Btu_lb_to_kJ_kg(fuel_model.h[0]) # kJ/kg
        estimated_fine_fuel_moisture: cy.float = fuel_moisture_dead_1hr                # kg moisture/kg ovendry weight

        #============================================================================================
        # Calculate midflame wind speed
        #============================================================================================

        # Convert from 10m wind speed to 20ft wind speed
        wind_speed_20ft: cy.float = conv.wind_speed_10m_to_wind_speed_20ft(wind_speed_10m) # km/hr

        # Convert 20ft wind speed from km/hr to m/min
        wind_speed_20ft_m_min: cy.float = conv.km_hr_to_m_min(wind_speed_20ft) # m/min

        # Convert from 20ft wind speed to midflame wind speed in m/min
        midflame_wind_speed: cy.float = sf.calc_midflame_wind_speed(wind_speed_20ft_m_min,       # m/min
                                                                    fuel_bed_depth,              # ft
                                                                    conv.m_to_ft(canopy_height), # ft
                                                                    canopy_cover)                # 0-1

        #============================================================================================
        # Calculate surface fire behavior in the direction of maximum spread
        #============================================================================================

        # Apply fuel moisture to fuel model
        moisturized_fuel_model: FuelModel = fm.moisturize(fuel_model, fuel_moisture)

        # TODO: Memoize calc_surface_fire_behavior_no_wind_no_slope
        # Calculate no-wind-no-slope surface fire behavior
        surface_fire_min: FireBehaviorMin = sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model,
                                                                                           spread_rate_adjustment)

        # Calculate surface fire behavior in the direction of maximum spread
        surface_fire_max: FireBehaviorMax = sf.calc_surface_fire_behavior_max(surface_fire_min,
                                                                              midflame_wind_speed,
                                                                              upwind_direction,
                                                                              slope,
                                                                              aspect,
                                                                              use_wind_limit,
                                                                              surface_lw_ratio_model)

        # Simplify the surface fire behavior fields for future combination with the crown fire behavior values
        spread_direction       : vec_xyz        = surface_fire_max.max_spread_direction
        surface_fire_max_simple: SpreadBehavior = sf.calc_surface_fire_behavior_in_direction(surface_fire_max,
                                                                                             spread_direction)

        #============================================================================================
        # Determine whether the surface fire transitions to a crown fire
        #============================================================================================

        if cf.van_wagner_crown_fire_initiation(surface_fire_max_simple.fireline_intensity,
                                               canopy_cover,
                                               canopy_base_height,
                                               foliar_moisture):

            #========================================================================================
            # Calculate crown fire behavior in the direction of maximum spread
            #========================================================================================

            # Calculate crown fire behavior in the direction of maximum spread
            crown_fire_max: FireBehaviorMax = cf.calc_crown_fire_behavior_max(canopy_height, canopy_base_height,
                                                                              canopy_bulk_density, heat_of_combustion,
                                                                              estimated_fine_fuel_moisture,
                                                                              wind_speed_10m, upwind_direction,
                                                                              slope, aspect, crown_max_lw_ratio)

            # Simplify the crown fire behavior fields for future combination with the surface fire behavior values
            spread_direction     : vec_xyz        = crown_fire_max.max_spread_direction
            crown_fire_max_simple: SpreadBehavior = cf.calc_crown_fire_behavior_in_direction(crown_fire_max,
                                                                                             spread_direction)

            #========================================================================================
            # Calculate combined fire behavior in the direction of maximum spread
            #========================================================================================

            combined_fire_max: SpreadBehavior = cf.calc_combined_fire_behavior(surface_fire_max_simple,
                                                                               crown_fire_max_simple)

            #========================================================================================
            # Return the combined fire behavior in the direction of maximum spread
            #========================================================================================

            return SpreadBehavior_to_dict(combined_fire_max)

        else:

            #========================================================================================
            # Return the surface fire behavior in the direction of maximum spread
            #========================================================================================

            return SpreadBehavior_to_dict(surface_fire_max_simple)


# TODO: Make a more efficient version that avoids space_time_cubes dictionary lookups for each cell
@cy.ccall
def burn_all_cells_as_head_fire(space_time_cubes      : dict[str, ISpaceTimeCube],
                                t                     : pyidx,
                                y_range               : tuple[pyidx, pyidx]|None = None,
                                x_range               : tuple[pyidx, pyidx]|None = None,
                                use_wind_limit        : cy.bint = True,
                                surface_lw_ratio_model: str = "behave",
                                crown_max_lw_ratio    : cy.float = 1e10) -> dict:
    """
    Given these inputs:
    - space_time_cubes             :: dictionary of (Lazy)SpaceTimeCube objects with these cell types
      - slope                         :: rise/run
      - aspect                        :: degrees clockwise from North
      - fuel_model                    :: integer index in fm.fuel_model_table
      - canopy_cover                  :: 0-1
      - canopy_height                 :: m
      - canopy_base_height            :: m
      - canopy_bulk_density           :: kg/m^3
      - wind_speed_10m                :: km/hr
      - upwind_direction              :: degrees clockwise from North
      - fuel_moisture_dead_1hr        :: kg moisture/kg ovendry weight
      - fuel_moisture_dead_10hr       :: kg moisture/kg ovendry weight
      - fuel_moisture_dead_100hr      :: kg moisture/kg ovendry weight
      - fuel_moisture_live_herbaceous :: kg moisture/kg ovendry weight
      - fuel_moisture_live_woody      :: kg moisture/kg ovendry weight
      - foliar_moisture               :: kg moisture/kg ovendry weight
      - fuel_spread_adjustment        :: float >= 0.0 (Optional: defaults to 1.0)
      - weather_spread_adjustment     :: float >= 0.0 (Optional: defaults to 1.0)
    - t                            :: temporal integer index into the ISpaceTimeCube objects
    - y_range                      :: (min_y, max_y) spatial integer index into the ISpaceTimeCube objects (Optional)
    - x_range                      :: (min_x, max_x) spatial integer index into the ISpaceTimeCube objects (Optional)
    - use_wind_limit               :: boolean (Optional)
    - surface_lw_ratio_model       :: "rothermel" or "behave" (Optional)
    - crown_max_lw_ratio           :: float > 0.0 (Optional)

    return a dictionary with these keys:
    - fire_type          :: 2D byte array (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)
    - spread_rate        :: 2D float array (m/min)
    - spread_direction   :: 2D float array (degrees clockwise from North)
    - fireline_intensity :: 2D float array (kW/m)
    - flame_length       :: 2D float array (m)
    """
    slope_cube  : ISpaceTimeCube      = cy.cast(ISpaceTimeCube, space_time_cubes["slope"])
    bands       : pyidx               = slope_cube.shape[0]
    rows        : pyidx               = slope_cube.shape[1]
    cols        : pyidx               = slope_cube.shape[2]
    grid_shape  : tuple[int, int]     = (rows, cols)
    y_range_real: tuple[pyidx, pyidx] = to_positive_index_range(y_range, rows)
    x_range_real: tuple[pyidx, pyidx] = to_positive_index_range(x_range, cols)
    min_y       : pyidx               = y_range_real[0]
    max_y       : pyidx               = y_range_real[1]
    min_x       : pyidx               = x_range_real[0]
    max_x       : pyidx               = x_range_real[1]

    if not(0 <= t < bands):
        raise ValueError("The t value is out of range of the space_time_cubes.")

    if not(0 <= min_y < max_y <= rows):
        raise ValueError("The y_range values are out of range of the space_time_cubes.")

    if not(0 <= min_x < max_x <= rows):
        raise ValueError("The x_range values are out of range of the space_time_cubes.")

    fire_type_matrix          : np.ndarray      = np.zeros(grid_shape, dtype="uint8")
    spread_rate_matrix        : np.ndarray      = np.zeros(grid_shape, dtype="float32")
    spread_direction_matrix   : np.ndarray      = np.zeros(grid_shape, dtype="float32")
    fireline_intensity_matrix : np.ndarray      = np.zeros(grid_shape, dtype="float32")
    flame_length_matrix       : np.ndarray      = np.zeros(grid_shape, dtype="float32")
    fire_type_memview         : cy.uchar[:,::1] = fire_type_matrix
    spread_rate_memview       : cy.float[:,::1] = spread_rate_matrix
    spread_direction_memview  : cy.float[:,::1] = spread_direction_matrix
    fireline_intensity_memview: cy.float[:,::1] = fireline_intensity_matrix
    flame_length_memview      : cy.float[:,::1] = flame_length_matrix

    y                    : pyidx
    x                    : pyidx
    space_time_coordinate: coord_tyx
    for y in range(min_y, max_y):
        for x in range(min_x, max_x):
            space_time_coordinate          = (t, y, x)
            spread_behavior                = burn_cell_as_head_fire(space_time_cubes,
                                                                    space_time_coordinate,
                                                                    use_wind_limit,
                                                                    surface_lw_ratio_model,
                                                                    crown_max_lw_ratio)
            fire_type_memview[y,x]          = spread_behavior["fire_type"]
            spread_rate_memview[y,x]        = spread_behavior["spread_rate"]
            spread_direction_memview[y,x]   = vu.spread_direction_vector_to_angle(spread_behavior["spread_direction"])
            fireline_intensity_memview[y,x] = spread_behavior["fireline_intensity"]
            flame_length_memview[y,x]       = spread_behavior["flame_length"]

    return {
        "fire_type"         : fire_type_matrix,
        "spread_rate"       : spread_rate_matrix,
        "spread_direction"  : spread_direction_matrix,
        "fireline_intensity": fireline_intensity_matrix,
        "flame_length"      : flame_length_matrix,
    }
#+end_src

*** Burn Cell in Any Direction
    :PROPERTIES:
    :CUSTOM_ID: burn-cell-in-any-direction
    :END:

When the goal of a fire behavior analysis is to evolve a burn scar
from its point of ignition into a generally conical shape in
space-time, then it is necessary to evaluate the combined surface and
crown fire behavior in the direction normal to the fire front. In
order to facilitate this calculation, the following function takes an
azimuth (degrees clockwise from North), meant to represent the spatial
direction in which the fire front is spreading from a given grid cell.
It first projects this 2D direction onto the local slope-tangential
plane and computes the surface fire behavior in this direction. If a
crown fire occurs, the crown fire behavior is also calculated in the
azimuth direction, and the combined surface and crown fire behavior
(as per section [[Combining Surface and Crown Fire Behavior]]) is
returned. If no crown fire occurs, the surface fire behavior in the
azimuth direction is returned.

#+NAME: burn-cell-toward-azimuth
#+begin_src python
@cy.ccall
def burn_cell_toward_azimuth(space_time_cubes      : dict[str, ISpaceTimeCube],
                             space_time_coordinate : coord_tyx,
                             azimuth               : cy.float,
                             use_wind_limit        : cy.bint = True,
                             surface_lw_ratio_model: str = "behave",
                             crown_max_lw_ratio    : cy.float = 1e10) -> dict:
    """
    Given these inputs:
    - space_time_cubes             :: dictionary of (Lazy)SpaceTimeCube objects with these cell types
      - slope                         :: rise/run
      - aspect                        :: degrees clockwise from North
      - fuel_model                    :: integer index in fm.fuel_model_table
      - canopy_cover                  :: 0-1
      - canopy_height                 :: m
      - canopy_base_height            :: m
      - canopy_bulk_density           :: kg/m^3
      - wind_speed_10m                :: km/hr
      - upwind_direction              :: degrees clockwise from North
      - fuel_moisture_dead_1hr        :: kg moisture/kg ovendry weight
      - fuel_moisture_dead_10hr       :: kg moisture/kg ovendry weight
      - fuel_moisture_dead_100hr      :: kg moisture/kg ovendry weight
      - fuel_moisture_live_herbaceous :: kg moisture/kg ovendry weight
      - fuel_moisture_live_woody      :: kg moisture/kg ovendry weight
      - foliar_moisture               :: kg moisture/kg ovendry weight
      - fuel_spread_adjustment        :: float >= 0.0 (Optional: defaults to 1.0)
      - weather_spread_adjustment     :: float >= 0.0 (Optional: defaults to 1.0)
    - space_time_coordinate        :: (t,y,x)
    - azimuth                      :: degrees clockwise from North on the horizontal plane
    - use_wind_limit               :: boolean (Optional)
    - surface_lw_ratio_model       :: "rothermel" or "behave" (Optional)
    - crown_max_lw_ratio           :: float > 0.0 (Optional)

    return a dictionary with these fire behavior values for the space-time coordinate (t,y,x):
    - fire_type          :: 0 (unburned), 1 (surface), 2 (passive_crown), or 3 (active_crown)
    - spread_rate        :: m/min
    - spread_direction   :: (x, y, z) unit vector on the slope-tangential plane
    - fireline_intensity :: kW/m
    - flame_length       :: m
    """
    #================================================================================================
    # Destructure the space_time_coordinate
    #================================================================================================

    (t, y, x) = space_time_coordinate

    #================================================================================================
    # Unpack the space_time_cubes dictionary
    #================================================================================================

    # Topography, Fuel Model, and Vegetation
    slope              : cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["slope"]).get(t, y, x)
    aspect             : cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["aspect"]).get(t, y, x)
    fuel_model_number  : cy.int   = cy.cast(cy.int, cy.cast(ISpaceTimeCube, space_time_cubes["fuel_model"]).get(t, y, x))
    canopy_cover       : cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["canopy_cover"]).get(t, y, x)
    canopy_height      : cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["canopy_height"]).get(t, y, x)
    canopy_base_height : cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["canopy_base_height"]).get(t, y, x)
    canopy_bulk_density: cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["canopy_bulk_density"]).get(t, y, x)

    # Wind, Surface Moisture, and Foliar Moisture
    wind_speed_10m               : cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["wind_speed_10m"]).get(t, y, x)
    upwind_direction             : cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["upwind_direction"]).get(t, y, x)
    fuel_moisture_dead_1hr       : cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["fuel_moisture_dead_1hr"]).get(t, y, x)
    fuel_moisture_dead_10hr      : cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["fuel_moisture_dead_10hr"]).get(t, y, x)
    fuel_moisture_dead_100hr     : cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["fuel_moisture_dead_100hr"]).get(t, y, x)
    fuel_moisture_live_herbaceous: cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["fuel_moisture_live_herbaceous"]).get(t, y, x)
    fuel_moisture_live_woody     : cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["fuel_moisture_live_woody"]).get(t, y, x)
    foliar_moisture              : cy.float = cy.cast(ISpaceTimeCube, space_time_cubes["foliar_moisture"]).get(t, y, x)

    # Spread Rate Adjustments (Optional)
    fuel_spread_adjustment   : cy.float = (cy.cast(ISpaceTimeCube, space_time_cubes["fuel_spread_adjustment"]).get(t, y, x)
                                           if "fuel_spread_adjustment" in space_time_cubes
                                           else 1.0)                                         # float >= 0.0
    weather_spread_adjustment: cy.float = (cy.cast(ISpaceTimeCube, space_time_cubes["weather_spread_adjustment"]).get(t, y, x)
                                           if "weather_spread_adjustment" in space_time_cubes
                                           else 1.0)                                         # float >= 0.0
    spread_rate_adjustment   : cy.float = fuel_spread_adjustment * weather_spread_adjustment # float >= 0.0

    #================================================================================================
    # Project a 2D unit vector pointing toward the azimuth onto the slope-tangential plane
    #================================================================================================

    upslope_direction: cy.float = conv.opposite_direction(aspect)
    slope_vector_2d  : vec_xy   = conv.azimuthal_to_cartesian(slope, upslope_direction)
    azimuth_vector_2d: vec_xy   = conv.azimuthal_to_cartesian(1.0, azimuth)
    spread_direction : vec_xyz  = vu.as_unit_vector_3d(vu.to_slope_plane(azimuth_vector_2d, slope_vector_2d))

    #================================================================================================
    # Check whether cell is burnable
    #================================================================================================

    fuel_model      : FuelModel
    maybe_fuel_model: FuelModel|None = fm.fuel_model_table.get(fuel_model_number)

    if maybe_fuel_model:
        fuel_model = maybe_fuel_model

    if (maybe_fuel_model is None or not(fuel_model.burnable)):
        # Encountered unknown or non-burnable fuel model

        #============================================================================================
        # Return zero surface fire behavior in the direction of the azimuth vector
        #============================================================================================

        return {
            "fire_type"         : 0, # unburned
            "spread_rate"       : 0.0,
            "spread_direction"  : spread_direction,
            "fireline_intensity": 0.0,
            "flame_length"      : 0.0,
        }

    else:
        # Encountered burnable fuel model

        #============================================================================================
        # Compute derived parameters
        #============================================================================================

        fuel_moisture               : fclaarr  = (fuel_moisture_dead_1hr,
                                                  fuel_moisture_dead_10hr,
                                                  fuel_moisture_dead_100hr,
                                                  0.0, # fuel_moisture_dead_herbaceous
                                                  fuel_moisture_live_herbaceous,
                                                  fuel_moisture_live_woody) # kg moisture/kg ovendry weight
        fuel_bed_depth              : cy.float = fuel_model.delta                      # ft
        heat_of_combustion          : cy.float = conv.Btu_lb_to_kJ_kg(fuel_model.h[0]) # kJ/kg
        estimated_fine_fuel_moisture: cy.float = fuel_moisture_dead_1hr                # kg moisture/kg ovendry weight

        #============================================================================================
        # Calculate midflame wind speed
        #============================================================================================

        # Convert from 10m wind speed to 20ft wind speed
        wind_speed_20ft: cy.float = conv.wind_speed_10m_to_wind_speed_20ft(wind_speed_10m) # km/hr

        # Convert 20ft wind speed from km/hr to m/min
        wind_speed_20ft_m_min: cy.float = conv.km_hr_to_m_min(wind_speed_20ft) # m/min

        # Convert from 20ft wind speed to midflame wind speed in m/min
        midflame_wind_speed: cy.float = sf.calc_midflame_wind_speed(wind_speed_20ft_m_min,       # m/min
                                                                    fuel_bed_depth,              # ft
                                                                    conv.m_to_ft(canopy_height), # ft
                                                                    canopy_cover)                # 0-1

        #============================================================================================
        # Calculate surface fire behavior in the direction of maximum spread
        #============================================================================================

        # Apply fuel moisture to fuel model
        moisturized_fuel_model: FuelModel = fm.moisturize(fuel_model, fuel_moisture)

        # TODO: Memoize calc_surface_fire_behavior_no_wind_no_slope
        # Calculate no-wind-no-slope surface fire behavior
        surface_fire_min: FireBehaviorMin = sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model,
                                                                                           spread_rate_adjustment)

        # Calculate surface fire behavior in the direction of maximum spread
        surface_fire_max: FireBehaviorMax = sf.calc_surface_fire_behavior_max(surface_fire_min,
                                                                              midflame_wind_speed,
                                                                              upwind_direction,
                                                                              slope,
                                                                              aspect,
                                                                              use_wind_limit,
                                                                              surface_lw_ratio_model)

        #============================================================================================
        # Calculate surface fire behavior in the direction of the azimuth vector
        #============================================================================================

        surface_fire_azimuth: SpreadBehavior = sf.calc_surface_fire_behavior_in_direction(surface_fire_max,
                                                                                          spread_direction)

        #============================================================================================
        # Determine whether the surface fire transitions to a crown fire
        #============================================================================================

        if cf.van_wagner_crown_fire_initiation(surface_fire_azimuth.fireline_intensity,
                                               canopy_cover,
                                               canopy_base_height,
                                               foliar_moisture):

            #========================================================================================
            # Calculate crown fire behavior in the direction of maximum spread
            #========================================================================================

            crown_fire_max: FireBehaviorMax = cf.calc_crown_fire_behavior_max(canopy_height, canopy_base_height,
                                                                              canopy_bulk_density, heat_of_combustion,
                                                                              estimated_fine_fuel_moisture,
                                                                              wind_speed_10m, upwind_direction,
                                                                              slope, aspect, crown_max_lw_ratio)

            #========================================================================================
            # Calculate crown fire behavior in the direction of the azimuth vector
            #========================================================================================

            crown_fire_azimuth: SpreadBehavior = cf.calc_crown_fire_behavior_in_direction(crown_fire_max,
                                                                                          spread_direction)

            #========================================================================================
            # Calculate combined fire behavior in the direction of the azimuth vector
            #========================================================================================

            combined_fire_azimuth: SpreadBehavior = cf.calc_combined_fire_behavior(surface_fire_azimuth,
                                                                                   crown_fire_azimuth)

            #========================================================================================
            # Return the combined fire behavior in the direction of the azimuth vector
            #========================================================================================

            return SpreadBehavior_to_dict(combined_fire_azimuth)

        else:

            #========================================================================================
            # Return the surface fire behavior in the direction of the azimuth vector
            #========================================================================================

            return SpreadBehavior_to_dict(surface_fire_azimuth)


# TODO: Make a more efficient version that avoids space_time_cubes dictionary lookups for each cell
@cy.ccall
def burn_all_cells_toward_azimuth(space_time_cubes      : dict[str, ISpaceTimeCube],
                                  azimuth               : cy.float,
                                  t                     : pyidx,
                                  y_range               : tuple[pyidx, pyidx]|None = None,
                                  x_range               : tuple[pyidx, pyidx]|None = None,
                                  use_wind_limit        : cy.bint = True,
                                  surface_lw_ratio_model: str = "behave",
                                  crown_max_lw_ratio    : cy.float = 1e10) -> dict:
    """
    Given these inputs:
    - space_time_cubes             :: dictionary of (Lazy)SpaceTimeCube objects with these cell types
      - slope                         :: rise/run
      - aspect                        :: degrees clockwise from North
      - fuel_model                    :: integer index in fm.fuel_model_table
      - canopy_cover                  :: 0-1
      - canopy_height                 :: m
      - canopy_base_height            :: m
      - canopy_bulk_density           :: kg/m^3
      - wind_speed_10m                :: km/hr
      - upwind_direction              :: degrees clockwise from North
      - fuel_moisture_dead_1hr        :: kg moisture/kg ovendry weight
      - fuel_moisture_dead_10hr       :: kg moisture/kg ovendry weight
      - fuel_moisture_dead_100hr      :: kg moisture/kg ovendry weight
      - fuel_moisture_live_herbaceous :: kg moisture/kg ovendry weight
      - fuel_moisture_live_woody      :: kg moisture/kg ovendry weight
      - foliar_moisture               :: kg moisture/kg ovendry weight
      - fuel_spread_adjustment        :: float >= 0.0 (Optional: defaults to 1.0)
      - weather_spread_adjustment     :: float >= 0.0 (Optional: defaults to 1.0)
    - azimuth                      :: degrees clockwise from North on the horizontal plane
    - t                            :: temporal integer index into the ISpaceTimeCube objects
    - y_range                      :: (min_y, max_y) spatial integer index into the ISpaceTimeCube objects (Optional)
    - x_range                      :: (min_x, max_x) spatial integer index into the ISpaceTimeCube objects (Optional)
    - use_wind_limit               :: boolean (Optional)
    - surface_lw_ratio_model       :: "rothermel" or "behave" (Optional)
    - crown_max_lw_ratio           :: float > 0.0 (Optional)

    return a dictionary with these keys:
    - fire_type          :: 2D byte array (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)
    - spread_rate        :: 2D float array (m/min)
    - spread_direction   :: 2D float array (degrees clockwise from North)
    - fireline_intensity :: 2D float array (kW/m)
    - flame_length       :: 2D float array (m)
    """
    slope_cube  : ISpaceTimeCube      = cy.cast(ISpaceTimeCube, space_time_cubes["slope"])
    bands       : pyidx               = slope_cube.shape[0]
    rows        : pyidx               = slope_cube.shape[1]
    cols        : pyidx               = slope_cube.shape[2]
    grid_shape  : tuple[int, int]     = (rows, cols)
    y_range_real: tuple[pyidx, pyidx] = to_positive_index_range(y_range, rows)
    x_range_real: tuple[pyidx, pyidx] = to_positive_index_range(x_range, cols)
    min_y       : pyidx               = y_range_real[0]
    max_y       : pyidx               = y_range_real[1]
    min_x       : pyidx               = x_range_real[0]
    max_x       : pyidx               = x_range_real[1]

    if not(0 <= t < bands):
        raise ValueError("The t value is out of range of the space_time_cubes.")

    if not(0 <= min_y < max_y <= rows):
        raise ValueError("The y_range values are out of range of the space_time_cubes.")

    if not(0 <= min_x < max_x <= rows):
        raise ValueError("The x_range values are out of range of the space_time_cubes.")

    fire_type_matrix          : np.ndarray      = np.zeros(grid_shape, dtype="uint8")
    spread_rate_matrix        : np.ndarray      = np.zeros(grid_shape, dtype="float32")
    spread_direction_matrix   : np.ndarray      = np.zeros(grid_shape, dtype="float32")
    fireline_intensity_matrix : np.ndarray      = np.zeros(grid_shape, dtype="float32")
    flame_length_matrix       : np.ndarray      = np.zeros(grid_shape, dtype="float32")
    fire_type_memview         : cy.uchar[:,::1] = fire_type_matrix
    spread_rate_memview       : cy.float[:,::1] = spread_rate_matrix
    spread_direction_memview  : cy.float[:,::1] = spread_direction_matrix
    fireline_intensity_memview: cy.float[:,::1] = fireline_intensity_matrix
    flame_length_memview      : cy.float[:,::1] = flame_length_matrix

    y                    : pyidx
    x                    : pyidx
    space_time_coordinate: coord_tyx
    for y in range(min_y, max_y):
        for x in range(min_x, max_x):
            space_time_coordinate          = (t, y, x)
            spread_behavior                = burn_cell_toward_azimuth(space_time_cubes,
                                                                      space_time_coordinate,
                                                                      azimuth,
                                                                      use_wind_limit,
                                                                      surface_lw_ratio_model,
                                                                      crown_max_lw_ratio)
            fire_type_memview[y,x]          = spread_behavior["fire_type"]
            spread_rate_memview[y,x]        = spread_behavior["spread_rate"]
            spread_direction_memview[y,x]   = vu.spread_direction_vector_to_angle(spread_behavior["spread_direction"])
            fireline_intensity_memview[y,x] = spread_behavior["fireline_intensity"]
            flame_length_memview[y,x]       = spread_behavior["flame_length"]

    return {
        "fire_type"         : fire_type_matrix,
        "spread_rate"       : spread_rate_matrix,
        "spread_direction"  : spread_direction_matrix,
        "fireline_intensity": fireline_intensity_matrix,
        "flame_length"      : flame_length_matrix,
    }
#+end_src

** For Users
   :PROPERTIES:
   :CUSTOM_ID: for-users-burn-cells
   :header-args:python+: :session *examples:pyretechnics.burn_cells*
   :header-args:python+: :results output replace
   :header-args:python+: :exports both
   :END:

In the following sections, we will demonstrate how to calculate the
combined surface and crown fire behavior first in the direction of
maximum spread and then in any direction.

*** How to Burn a Cell as a Head Fire
    :PROPERTIES:
    :CUSTOM_ID: how-to-burn-a-cell-as-a-head-fire
    :END:

#+NAME: run-burn-cell-as-head-fire
#+begin_src python
from pprint import pprint
import pyretechnics.burn_cells as bc
from pyretechnics.space_time_cube import SpaceTimeCube

#============================================================================================
# Specify the SpaceTimeCube dimensions
#============================================================================================

cube_shape = (
    240,  # bands: 10 days @ 1 hour/band
    1000, # rows:  30 km @ 30 meters/row
    1000, # cols:  30 km @ 30 meters/col
)

#============================================================================================
# Create an input dictionary of SpaceTimeCubes (using constant data for this example)
#============================================================================================

space_time_cubes = {
    "slope"                        : SpaceTimeCube(cube_shape, 0.8),   # rise/run
    "aspect"                       : SpaceTimeCube(cube_shape, 225.0), # degrees clockwise from North
    "fuel_model"                   : SpaceTimeCube(cube_shape, 101),   # integer index in fm.fuel_model_table
    "canopy_cover"                 : SpaceTimeCube(cube_shape, 0.6),   # 0-1
    "canopy_height"                : SpaceTimeCube(cube_shape, 30.0),  # m
    "canopy_base_height"           : SpaceTimeCube(cube_shape, 3.0),   # m
    "canopy_bulk_density"          : SpaceTimeCube(cube_shape, 0.3),   # kg/m^3
    "wind_speed_10m"               : SpaceTimeCube(cube_shape, 30.0),  # km/hr
    "upwind_direction"             : SpaceTimeCube(cube_shape, 180.0), # degrees clockwise from North
    "fuel_moisture_dead_1hr"       : SpaceTimeCube(cube_shape, 0.05),  # kg moisture/kg ovendry weight
    "fuel_moisture_dead_10hr"      : SpaceTimeCube(cube_shape, 0.10),  # kg moisture/kg ovendry weight
    "fuel_moisture_dead_100hr"     : SpaceTimeCube(cube_shape, 0.15),  # kg moisture/kg ovendry weight
    "fuel_moisture_live_herbaceous": SpaceTimeCube(cube_shape, 0.90),  # kg moisture/kg ovendry weight
    "fuel_moisture_live_woody"     : SpaceTimeCube(cube_shape, 0.60),  # kg moisture/kg ovendry weight
    "foliar_moisture"              : SpaceTimeCube(cube_shape, 0.90),  # kg moisture/kg ovendry weight
    "fuel_spread_adjustment"       : SpaceTimeCube(cube_shape, 1.0),   # float >= 0.0 (Optional: defaults to 1.0)
    "weather_spread_adjustment"    : SpaceTimeCube(cube_shape, 1.0),   # float >= 0.0 (Optional: defaults to 1.0)
}

#============================================================================================
# Specify a space-time coordinate (t,y,x) within the extent of the SpaceTimeCube dimensions
#============================================================================================

space_time_coordinate = (24, 100, 100)

#============================================================================================
# Calculate combined fire behavior in the direction of maximum spread (with wind limit)
#============================================================================================

combined_behavior_limited = bc.burn_cell_as_head_fire(space_time_cubes, space_time_coordinate)

#============================================================================================
# Calculate combined fire behavior in the direction of maximum spread (without wind limit)
#============================================================================================

combined_behavior_unlimited = bc.burn_cell_as_head_fire(space_time_cubes, space_time_coordinate,
                                                        use_wind_limit=False)

#============================================================================================
# Display combined fire behavior in the direction of maximum spread (with wind limit)
#============================================================================================

print("Fire Behavior from Combined Surface and Crown Fire (with Wind Limit) at Coordinate "
      + str(space_time_coordinate) + "\n" + "=" * 100)
pprint(combined_behavior_limited)

#============================================================================================
# Display combined fire behavior in the direction of maximum spread (without wind limit)
#============================================================================================

print("\nFire Behavior from Combined Surface and Crown Fire (without Wind Limit) at Coordinate "
      + str(space_time_coordinate) + "\n" + "=" * 100)
pprint(combined_behavior_unlimited)
#+end_src

#+NAME: run-burn-cell-as-head-fire-results
#+RESULTS: run-burn-cell-as-head-fire
#+begin_example
Fire Behavior from Combined Surface and Crown Fire (with Wind Limit) at Coordinate (24, 100, 100)
====================================================================================================
{'fire_type': 'surface',
 'fireline_intensity': 32.528250853562525,
 'flame_length': 0.38439333737509035,
 'spread_direction': array([0.48686895, 0.61304247, 0.62220383]),
 'spread_rate': 2.2964679102816112}

Fire Behavior from Combined Surface and Crown Fire (without Wind Limit) at Coordinate (24, 100, 100)
====================================================================================================
{'fire_type': 'surface',
 'fireline_intensity': 50.61292548195906,
 'flame_length': 0.47108164985334633,
 'spread_direction': array([0.48686895, 0.61304247, 0.62220383]),
 'spread_rate': 3.5732311503021905}
#+end_example

*** How to Burn a Cell in Any Direction
    :PROPERTIES:
    :CUSTOM_ID: how-to-burn-a-cell-in-any-direction
    :END:

#+NAME: run-burn-cell-toward-azimuth
#+begin_src python
from pprint import pprint
import pyretechnics.burn_cells as bc
from pyretechnics.space_time_cube import SpaceTimeCube

#============================================================================================
# Specify the SpaceTimeCube dimensions
#============================================================================================

cube_shape = (
    240,  # bands: 10 days @ 1 hour/band
    1000, # rows:  30 km @ 30 meters/row
    1000, # cols:  30 km @ 30 meters/col
)

#============================================================================================
# Create an input dictionary of SpaceTimeCubes (using constant data for this example)
#============================================================================================

space_time_cubes = {
    "slope"                        : SpaceTimeCube(cube_shape, 0.8),   # rise/run
    "aspect"                       : SpaceTimeCube(cube_shape, 225.0), # degrees clockwise from North
    "fuel_model"                   : SpaceTimeCube(cube_shape, 101),   # integer index in fm.fuel_model_table
    "canopy_cover"                 : SpaceTimeCube(cube_shape, 0.6),   # 0-1
    "canopy_height"                : SpaceTimeCube(cube_shape, 30.0),  # m
    "canopy_base_height"           : SpaceTimeCube(cube_shape, 3.0),   # m
    "canopy_bulk_density"          : SpaceTimeCube(cube_shape, 0.3),   # kg/m^3
    "wind_speed_10m"               : SpaceTimeCube(cube_shape, 30.0),  # km/hr
    "upwind_direction"             : SpaceTimeCube(cube_shape, 180.0), # degrees clockwise from North
    "fuel_moisture_dead_1hr"       : SpaceTimeCube(cube_shape, 0.05),  # kg moisture/kg ovendry weight
    "fuel_moisture_dead_10hr"      : SpaceTimeCube(cube_shape, 0.10),  # kg moisture/kg ovendry weight
    "fuel_moisture_dead_100hr"     : SpaceTimeCube(cube_shape, 0.15),  # kg moisture/kg ovendry weight
    "fuel_moisture_live_herbaceous": SpaceTimeCube(cube_shape, 0.90),  # kg moisture/kg ovendry weight
    "fuel_moisture_live_woody"     : SpaceTimeCube(cube_shape, 0.60),  # kg moisture/kg ovendry weight
    "foliar_moisture"              : SpaceTimeCube(cube_shape, 0.90),  # kg moisture/kg ovendry weight
    "fuel_spread_adjustment"       : SpaceTimeCube(cube_shape, 1.0),   # float >= 0.0 (Optional: defaults to 1.0)
    "weather_spread_adjustment"    : SpaceTimeCube(cube_shape, 1.0),   # float >= 0.0 (Optional: defaults to 1.0)
}

#============================================================================================
# Specify a space-time coordinate (t,y,x) within the extent of the SpaceTimeCube dimensions
#============================================================================================

space_time_coordinate = (24, 100, 100)

#============================================================================================
# Specify an azimuth to spread the fire towards
#============================================================================================

spread_azimuth = 90.0 # degrees clockwise from North on the horizontal plane

#============================================================================================
# Calculate combined fire behavior in the direction of the azimuth (with wind limit)
#============================================================================================

combined_behavior_limited = bc.burn_cell_toward_azimuth(space_time_cubes, space_time_coordinate, spread_azimuth)

#============================================================================================
# Calculate combined fire behavior in the direction of the azimuth (without wind limit)
#============================================================================================

combined_behavior_unlimited = bc.burn_cell_toward_azimuth(space_time_cubes, space_time_coordinate, spread_azimuth,
                                                          use_wind_limit=False)

#============================================================================================
# Display combined fire behavior in the direction of the azimuth (with wind limit)
#============================================================================================

print("Fire Behavior from Combined Surface and Crown Fire (with Wind Limit) at Coordinate "
      + str(space_time_coordinate) + "\n" + "=" * 100)
pprint(combined_behavior_limited)

#============================================================================================
# Display combined fire behavior in the direction of the azimuth (without wind limit)
#============================================================================================

print("\nFire Behavior from Combined Surface and Crown Fire (without Wind Limit) at Coordinate "
      + str(space_time_coordinate) + "\n" + "=" * 100)
pprint(combined_behavior_unlimited)
#+end_src

#+NAME: run-burn-cell-toward-azimuth-results
#+RESULTS: run-burn-cell-toward-azimuth
#+begin_example
Fire Behavior from Combined Surface and Crown Fire (with Wind Limit) at Coordinate (24, 100, 100)
====================================================================================================
{'fire_type': 'surface',
 'fireline_intensity': 11.637272597794672,
 'flame_length': 0.23956726794677918,
 'spread_direction': array([ 8.70388269e-01, -3.80458793e-08,  4.92365986e-01]),
 'spread_rate': 0.8215819290236468}

Fire Behavior from Combined Surface and Crown Fire (without Wind Limit) at Coordinate (24, 100, 100)
====================================================================================================
{'fire_type': 'surface',
 'fireline_intensity': 13.89820197455359,
 'flame_length': 0.2599542303459697,
 'spread_direction': array([ 8.70388269e-01, -3.80458793e-08,  4.92365986e-01]),
 'spread_rate': 0.9812016941476362}
#+end_example

* Fire Spread Algorithm (ELMFIRE): Eulerian Level Set Method (pyretechnics.eulerian_level_set)
  :PROPERTIES:
  :CUSTOM_ID: fire-spread-algorithm:-eulerian-level-set-method-(pyretechnics.eulerian_level_set)
  :END:
** For Developers
   :PROPERTIES:
   :CUSTOM_ID: for-developers-fire-spread
   :header-args:python+: :session *pyretechnics.eulerian_level_set*
   :header-args:python+: :tangle  ../src/pyretechnics/eulerian_level_set.py
   :header-args:python+: :exports code
   :END:

In order to simulate the spread of a fire from a starting point or
perimeter, we will need to implement a model that projects the
one-dimensional spread and intensity equations presented in sections
[[Surface Fire Equations (pyretechnics.surface_fire)]] and [[Crown Fire
Equations (pyretechnics.crown_fire)]] into the three-dimensional
space-time cube introduced in section [[Data Model]].

This section introduces the equations used in the Eulerian level set
method of fire spread, operationalized in Chris Lautenberger's ELMFIRE
model[fn::https://elmfire.io].

*** Module Imports
    :PROPERTIES:
    :CUSTOM_ID: module-imports-eulerian-level-set
    :END:

#+NAME: eulerian-level-set-imports
#+begin_src python
import cython
import cython as cy
import numpy as np
from sortedcontainers import SortedDict
if cython.compiled:
    from cython.cimports.libc.stdlib import malloc, realloc, free
    from cython.cimports.libc.math import pi, floor, sqrt, pow, atan
    from cython.cimports.pyretechnics.cy_types import pyidx, vec_xy, vec_xyz, coord_yx, coord_tyx, \
        fclaarr, FuelModel, FireBehaviorMin, FireBehaviorMax, SpreadBehavior, SpotConfig, \
        PartialedEllWavelet, CellInputs, EllipticalInfo, Pass1CellOutput
    from cython.cimports.pyretechnics.random import BufferedRandGen
    from cython.cimports.pyretechnics.space_time_cube import ISpaceTimeCube
    import cython.cimports.pyretechnics.conversion as conv
    import cython.cimports.pyretechnics.vector_utils as vu
    import cython.cimports.pyretechnics.fuel_models as fm
    import cython.cimports.pyretechnics.surface_fire as sf
    import cython.cimports.pyretechnics.crown_fire as cf
    import cython.cimports.pyretechnics.spot_fire as spot
    import cython.cimports.pyretechnics.narrow_band_tracking as nbt
else:
    # TODO: Create equivalent Python functions for malloc, realloc, free
    from math import pi, floor, sqrt, pow, atan
    from pyretechnics.py_types import pyidx, vec_xy, vec_xyz, coord_yx, coord_tyx, \
        fclaarr, FuelModel, FireBehaviorMin, FireBehaviorMax, SpreadBehavior, SpotConfig, \
        PartialedEllWavelet, CellInputs, EllipticalInfo, Pass1CellOutput
    from pyretechnics.random import BufferedRandGen
    from pyretechnics.space_time_cube import ISpaceTimeCube
    import pyretechnics.conversion as conv
    import pyretechnics.vector_utils as vu
    import pyretechnics.fuel_models as fm
    import pyretechnics.surface_fire as sf
    import pyretechnics.crown_fire as cf
    import pyretechnics.spot_fire as spot
    import pyretechnics.narrow_band_tracking as nbt
#+end_src

*** The $\phi$ Field
    :PROPERTIES:
    :CUSTOM_ID: the-$\phi$-field
    :END:

In this model, a continuous field called $\phi$ fills the simulation
space and is used to track the progression of the fire front through
space and time. Within Pyretechnics, the $\phi$ field is discretized
into grid cells and initialized with the following values:

- -1 for cells that have already been burned and are inside the fire perimeter
- 1 for cells that have not been burned and are outside the fire perimeter

If a fire is being simulated starting from an actively burning
perimeter, the $\phi$ grid cells indicate the initially burning region.
If a point fire is being simulated, then a single $\phi$ cell will be
set to -1 and the remaining cells will have the value 1.

*** Fire Front Normal Vector
    :PROPERTIES:
    :CUSTOM_ID: fire-front-normal-vector
    :END:

In this fire spread algorithm, the fire front only propagates normal
to itself. Given a $\phi$ raster, we can calculate the normal vector to
the $\phi$ field by using the following formula:

\begin{align}
  \hat{n} &= n_x\hat{i} + n_y\hat{j} = \frac{1}{|\nabla\phi|}\left(\frac{\partial \phi}{\partial x}\hat{i} + \frac{\partial \phi}{\partial y}\hat{j}\right) \\
  \nonumber \\
  |\nabla\phi| &= \sqrt{\left(\frac{\partial \phi}{\partial x}\right)^2 + \left(\frac{\partial \phi}{\partial y}\right)^2}
\end{align}

We begin by approximating the spatial gradients of the $\phi$ field with
node-centered central differences, represented by the values in the
$\phi$ raster's grid cells.

\begin{align}
  \left(\frac{\partial \phi}{\partial x}\right)_{i,j} &\approx \frac{\phi_{i+1,j} - \phi_{i-1,j}}{2 \Delta x} \\
  \nonumber \\
  \left(\frac{\partial \phi}{\partial y}\right)_{i,j} &\approx \frac{\phi_{i,j+1} - \phi_{i,j-1}}{2 \Delta y}
\end{align}

#+NAME: phi-field-spatial-gradients-approx
#+begin_src python
# NOTE: No longer used in tight loops.
@cy.cfunc
@cy.exceptval(check=False)
def calc_dphi_dx_approx(phi_matrix: cy.float[:,::1], dx: cy.float, x: pyidx, y: pyidx) -> cy.float:
    """
    Calculate the spatial gradient of `phi_matrix` in the x (west->east)
    direction at grid cell (x,y) given the cell width `dx`.
    """
    east_x: pyidx = x + 1
    west_x: pyidx = x - 1
    return (phi_matrix[2+y][2+east_x] - phi_matrix[2+y][2+west_x]) / (2.0 * dx)


# NOTE: No longer used in tight loops.
@cy.cfunc
@cy.exceptval(check=False)
def calc_dphi_dy_approx(phi_matrix: cy.float[:,::1], dy: cy.float, x: pyidx, y: pyidx) -> cy.float:
    """
    Calculate the spatial gradient of `phi_matrix` in the y (south->north)
    direction at grid cell (x,y) given the cell height `dy`.
    """
    north_y: pyidx = y + 1
    south_y: pyidx = y - 1
    return (phi_matrix[2+north_y][2+x] - phi_matrix[2+south_y][2+x]) / (2.0 * dy)


# NOTE: No longer used in tight loops.
@cy.cfunc
@cy.exceptval(check=False)
def calc_phi_gradient_approx(phi_matrix: cy.float[:,::1], dx: cy.float, dy: cy.float, x: pyidx, y: pyidx) -> vec_xy:
    """
    Calculate the spatial gradient of `phi_matrix` at grid cell (x,y)
    given the cell width `dx` and the cell height `dy`.
    """
    dphi_dx: cy.float = calc_dphi_dx_approx(phi_matrix, dx, x, y)
    dphi_dy: cy.float = calc_dphi_dy_approx(phi_matrix, dy, x, y)
    return (dphi_dx, dphi_dy)
#+end_src

We can now combine these spatial gradients with the magnitude of the
gradient of the $\phi$ field at any location on the grid to compute
the fire front normal vector as follows:

#+NAME: phi-field-normal-vector
#+begin_src python
# TODO: Remove unused function
@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def calc_phi_normal_vector(phi_matrix: cy.float[:,::1], dx: cy.float, dy: cy.float, x: pyidx, y: pyidx) -> vec_xy:
    """
    Calculate the phi field normal vector in the x and y dimensions.

    - n_x: eastward component of the unit normal vector
    - n_y: northward component of the unit normal vector
    """
    return vu.as_unit_vector_2d(calc_phi_gradient_approx(phi_matrix, dx, dy, x, y)) # (n_x, n_y)
#+end_src

Next, we can use the following geometrical relations to calculate the
angle $\theta_n$ (measured clockwise from North) to which the normal
vector points:

\begin{equation}
  \theta_n =
  \begin{cases}
    \frac{1}{2}\pi - \tan^{-1}(\frac{n_y}{n_x}) & \text{for}\ n_x > 0 & \text{and}\ n_y \geq 0 \\
    \frac{1}{2}\pi + \tan^{-1}(\frac{|n_y|}{n_x}) & \text{for}\ n_x > 0 & \text{and}\ n_y < 0 \\
    \frac{3}{2}\pi + \tan^{-1}(\frac{n_y}{|n_x|}) & \text{for}\ n_x < 0 & \text{and}\ n_y \geq 0 \\
    \frac{3}{2}\pi - \tan^{-1}(\frac{n_y}{n_x}) & \text{for}\ n_x < 0 & \text{and}\ n_y < 0 \\
    0 & \text{for}\ n_x = 0 & \text{and}\ n_y \geq 0 \\
    \pi & \text{for}\ n_x = 0 & \text{and}\ n_y < 0
  \end{cases}
\end{equation}

#+NAME: phi-field-normal-vector-angle
#+begin_src python
# TODO: Remove unused function
@cy.cfunc
@cy.exceptval(check=False)
def calc_phi_normal_azimuth(phi_normal_vector: vec_xy) -> cy.float:
    """
    Calculate the angle (measured in degrees clockwise from North)
    to which the phi field's normal vector points.
    """
    (n_x, n_y) = phi_normal_vector
    angle: cy.float
    if n_x > 0.0:
        if n_y >= 0.0:
            angle = 0.5 * pi - atan(n_y / n_x)
        elif n_y < 0.0:
            angle = 0.5 * pi + atan(abs(n_y) / n_x)
    elif n_x < 0.0:
        if n_y >= 0.0:
            angle = 1.5 * pi + atan(n_y / abs(n_x))
        elif n_y < 0.0:
            angle = 1.5 * pi - atan(n_y / n_x)
    else:
        if n_y >= 0.0:
            angle = 0.0
        elif n_y < 0.0:
            angle = pi
    return conv.rad_to_deg(angle)
#+end_src

Now that we can compute the fire front normal vector, we can find the
spread rate in this direction by combining this vector with the
maximum spread rate vector and elliptical eccentricity values
calculated for each grid cell, using the approaches described in
sections [[Surface Fire Equations (pyretechnics.surface_fire)]] and [[Crown
Fire Equations (pyretechnics.crown_fire)]].

We will refer to the spread rate vector normal to the fire front in
the following sections as $U$ with spatial components $U_x$ and $U_y$.

*** Numerical Solution of the $\phi$ Field Equation
    :PROPERTIES:
    :CUSTOM_ID: numerical-solution-of-the-$\phi$-field-equation
    :END:

In order to evolve the $\phi$ field through time and space, we must
solve the following hyperbolic differential equation for the scalar
variable $\phi$.

\begin{align}
  \frac{\partial \phi}{\partial t} + U_x \frac{\partial \phi}{\partial x} + U_y \frac{\partial \phi}{\partial y} = 0
\end{align}

This is accomplished after applying a flux limiter to the convective
terms, in order to ensure solution monotonicity and prevent spurious
oscillations that can be induced in its absence.

First, we define the parameter $r$ and the Superbee flux limiter
$B(r)$ as follows:

\begin{align}
  r &= \frac{\delta\phi_{\text{up}}}{\delta\phi_{\text{loc}}} \\
  \nonumber \\
  B(r) &= \max(0, \min(2r, 1), \min(r, 2))
\end{align}

#+NAME: superbee-flux-limiter
#+begin_src python
@cy.cfunc
@cy.exceptval(check=False)
def half_superbee_dphi_up(dphi_up: cy.float, dphi_loc: cy.float) -> cy.float:
    """
    Logically like calc_superbee_flux_limiter() but returns a result multiplied by (0.5 * dphi_loc).

    NOTE: This is more numerically stable than calc_superbee_flux_limiter().
    """
    s_loc             : cy.float = 1.0 if dphi_loc >= 0.0 else -1.0
    are_opposite_signs: cy.bint  = (s_loc * dphi_up) <= 0.0
    if are_opposite_signs:
        return 0.0
    a_up : cy.float = abs(dphi_up)
    a_loc: cy.float = abs(dphi_loc)
    return s_loc * max(min(a_up / 2.0, a_loc),
                       min(a_up, a_loc / 2.0))
#+end_src

To compute the inputs to this function, we build up the partial
derivatives of the $\phi$ field in terms of "east", "west", "north",
and "south" values as follows:

\begin{align}
  \frac{\partial \phi}{\partial x} &\approx \frac{\phi_{\text{east}} - \phi_{\text{west}}}{\Delta x} \\
  \nonumber \\
  \frac{\partial \phi}{\partial y} &\approx \frac{\phi_{\text{north}} - \phi_{\text{south}}}{\Delta y}
\end{align}

#+NAME: phi-field-spatial-gradients
#+begin_src python
@cy.cfunc
@cy.exceptval(check=False)
def calc_dphi_flim_x(p00: cy.float, pw2: cy.float, pw1: cy.float, pe1: cy.float, pe2: cy.float) -> cy.float:
    dphi_up : cy.float
    dphi_loc: cy.float
    phi_east: cy.float
    phi_west: cy.float

    dphi_loc = pe1 - p00
    if pe1 >= pw1:
        dphi_up  = p00 - pw1
        phi_east = p00 + half_superbee_dphi_up(dphi_up, dphi_loc)
    else:
        dphi_up  = pe2 - pe1
        phi_east = pe1 - half_superbee_dphi_up(dphi_up, dphi_loc)

    dphi_loc = pw1 - p00
    if pe1 >= pw1:
        dphi_up  = pw2 - pw1
        phi_west = pw1 - half_superbee_dphi_up(dphi_up, dphi_loc)
    else:
        dphi_up  = p00 - pe1
        phi_west = p00 + half_superbee_dphi_up(dphi_up, dphi_loc)
    return (phi_east - phi_west)


# NOTE: This is actually the same function as the previous one. But
#       who knows, maybe we get a performance gain by differentiating
#       code sites.
@cy.cfunc
@cy.exceptval(check=False)
def calc_dphi_flim_y(p00: cy.float, ps2: cy.float, ps1: cy.float, pn1: cy.float, pn2: cy.float) -> cy.float:
    dphi_up  : cy.float
    dphi_loc : cy.float
    phi_north: cy.float
    phi_south: cy.float

    dphi_loc = pn1 - p00
    if pn1 >= ps1:
        dphi_up   = p00 - ps1
        phi_north = p00 + half_superbee_dphi_up(dphi_up, dphi_loc)
    else:
        dphi_up   = pn2 - pn1
        phi_north = pn1 - half_superbee_dphi_up(dphi_up, dphi_loc)

    dphi_loc = ps1 - p00
    if pn1 >= ps1:
        dphi_up   = ps2 - ps1
        phi_south = ps1 - half_superbee_dphi_up(dphi_up, dphi_loc)
    else:
        dphi_up   = p00 - pn1
        phi_south = p00 + half_superbee_dphi_up(dphi_up, dphi_loc)

    return (phi_north - phi_south)
#+end_src

For the east face:

\begin{align}
  \delta\phi_{\text{loc}} &= \phi_{i+1,j} - \phi{i,j} \\
  \nonumber \\
  \delta\phi_{\text{up}} &= \begin{cases}
                              \phi_{i,j} - \phi_{i-1,j} & \text{for}\ u_{x,i,j} \ge 0 \\
                              \phi_{i+2,j} - \phi_{i+1,j} & \text{for}\ u_{x,i,j} < 0
                            \end{cases} \\
  \nonumber \\
  \phi_{\text{east}} &= \begin{cases}
                          \phi_{i,j} + \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{x,i,j} \ge 0 \\
                          \phi_{i+1,j} - \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{x,i,j} < 0
                        \end{cases}
\end{align}

For the west face:

\begin{align}
  \delta\phi_{\text{loc}} &= \phi_{i-1,j} - \phi{i,j} \\
  \nonumber \\
  \delta\phi_{\text{up}} &= \begin{cases}
                              \phi_{i-2,j} - \phi_{i-1,j} & \text{for}\ u_{x,i,j} \ge 0 \\
                              \phi_{i,j} - \phi_{i+1,j} & \text{for}\ u_{x,i,j} < 0
                            \end{cases} \\
  \nonumber \\
  \phi_{\text{west}} &= \begin{cases}
                          \phi_{i-1,j} - \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{x,i,j} \ge 0 \\
                          \phi_{i,j} + \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{x,i,j} < 0
                        \end{cases}
\end{align}

For the north face:

\begin{align}
  \delta\phi_{\text{loc}} &= \phi_{i,j+1} - \phi{i,j} \\
  \nonumber \\
  \delta\phi_{\text{up}} &= \begin{cases}
                              \phi_{i,j} - \phi_{i,j-1} & \text{for}\ u_{y,i,j} \ge 0 \\
                              \phi_{i,j+2} - \phi_{i,j+1} & \text{for}\ u_{y,i,j} < 0
                            \end{cases} \\
  \nonumber \\
  \phi_{\text{north}} &= \begin{cases}
                           \phi_{i,j} + \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{y,i,j} \ge 0 \\
                           \phi_{i,j+1} - \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{y,i,j} < 0
                         \end{cases}
\end{align}

For the south face:

\begin{align}
  \delta\phi_{\text{loc}} &= \phi_{i,j-1} - \phi{i,j} \\
  \nonumber \\
  \delta\phi_{\text{up}} &= \begin{cases}
                              \phi_{i,j-2} - \phi_{i,j-1} & \text{for}\ u_{y,i,j} \ge 0 \\
                              \phi_{i,j} - \phi_{i,j+1} & \text{for}\ u_{y,i,j} < 0
                            \end{cases} \\
  \nonumber \\
  \phi_{\text{south}} &= \begin{cases}
                           \phi_{i,j-1} - \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{y,i,j} \ge 0 \\
                           \phi_{i,j} + \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{y,i,j} < 0
                         \end{cases}
\end{align}

Once the various spatial partial derivatives have been calculated, we
can march the $\phi$ field solution forward in time using a second
order Runge Kutta method as follows:

\begin{align}
  \phi^* &= \phi^t - \Delta t \left(U_x \frac{\phi^t_{\text{east}} - \phi^t_{\text{west}}}{\Delta x} + U_y \frac{\phi^t_{\text{north}} - \phi^t_{\text{south}}}{\Delta y} \right) \\
  \nonumber \\
  \phi^{t + \Delta t} &= \frac{1}{2}\phi^t + \frac{1}{2} \left( \phi^* - \Delta t \left(U_x \frac{\phi^*_{\text{east}} - \phi^*_{\text{west}}}{\Delta x} + U_y \frac{\phi^*_{\text{north}} - \phi^*_{\text{south}}}{\Delta y} \right) \right)
\end{align}

In the above equations, timestep ($\Delta t$) is constrained by the
Courant-Friedrichs-Lewy (CFL) condition. The location of the fire
perimeter is determined by interpolation of the $\phi$ field as the
level set corresponding to $\phi = 0$.

*** Calculate the Surface/Crown Fireline Normal Behavior
    :PROPERTIES:
    :CUSTOM_ID: calculate-the-surface/crown-fireline-normal-behavior
    :END:

Since the fire front only propagates normal to itself in this fire
spread algorithm, we need a method to translate the surface and/or
crown fire behavior associated with a heading fire into the surface
and/or crown fire behavior normal to the fire front. This process is
illustrated below.

#+NAME: calc-fireline-normal-behavior
#+begin_src python
# TODO: Move these to a shared module and use throughout the literate program
# NOTE: It would be better to use a cython enum here, but that's not supported in pure python syntax.
fire_type_unburned      = cy.declare(cy.int, 0)
fire_type_surface       = cy.declare(cy.int, 1)
fire_type_crown_passive = cy.declare(cy.int, 2)
fire_type_crown_active  = cy.declare(cy.int, 3)


# TODO: Move this to pyretechnics.vector_utils and use throughout the literate program
@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def calc_elevation_gradient(slope: cy.float, aspect: cy.float) -> vec_xy:
    """
    Returns the elevation gradient (dz_dx: rise/run, dz_dy: rise/run) given:
    - slope  :: rise/run
    - aspect :: degrees clockwise from North
    """
    return conv.azimuthal_to_cartesian(slope, conv.opposite_direction(aspect))


@cy.cfunc
@cy.exceptval(check=False)
def calc_phi_gradient_on_slope(phi_gradient_xy: vec_xy, elevation_gradient: vec_xy) -> vec_xyz:
    """
    Returns the gradient of phi projected onto the slope-tangential plane as a 3D (x,y,z) vector (in phi/m) given:
    - phi_gradient_xy    :: (dphi_dx: phi/m, dphi_dy: phi/m) 2D vector on the horizontal plane
    - elevation_gradient :: (dz_dx: rise/run, dz_dy: rise/run)
    """
    (dphi_dx, dphi_dy)        = phi_gradient_xy
    phi_gradient_xyz: vec_xyz = (dphi_dx, dphi_dy, 0.0)
    if vu.vector_magnitude_2d(elevation_gradient) == 0.0:
        return phi_gradient_xyz
    else:
        slope_normal_vector: vec_xyz  = vu.get_slope_normal_vector(elevation_gradient) # (x,y,z) unit vector
        phi_slope_agreement: cy.float = vu.dot_3d(phi_gradient_xyz, slope_normal_vector)
        dphi_dx_on_slope   : cy.float = phi_gradient_xyz[0] - phi_slope_agreement * slope_normal_vector[0]
        dphi_dy_on_slope   : cy.float = phi_gradient_xyz[1] - phi_slope_agreement * slope_normal_vector[1]
        dphi_dz_on_slope   : cy.float = phi_gradient_xyz[2] - phi_slope_agreement * slope_normal_vector[2]
        return (dphi_dx_on_slope, dphi_dy_on_slope, dphi_dz_on_slope)


# FIXME: Do I switch to cruz_passive_crown_fire_spread_rate() if the normal_spread_rate < critical_spread_rate?
#        Did I do this correctly in calc_crown_fire_behavior_in_direction?
@cy.cfunc
@cy.exceptval(check=False)
def calc_fireline_normal_behavior(fire_behavior_max: FireBehaviorMax, phi_gradient_xyz: vec_xyz) -> SpreadBehavior:
    """
    Given these inputs:
    - fire_behavior_max  :: FireBehaviorMax struct of max surface or crown fire behavior values
      - max_fire_type          :: 0 (unburned), 1 (surface), 2 (passive_crown), or 3 (active_crown)
      - max_spread_rate        :: m/min
      - max_spread_direction   :: (x, y, z) unit vector
      - max_fireline_intensity :: kW/m
      - max_flame_length       :: m
      - length_to_width_ratio  :: unitless (1: circular spread, > 1: elliptical spread)
      - eccentricity           :: unitless (0: circular spread, > 0: elliptical spread)
      - critical_spread_rate   :: m/min (Required for crown fires only)
    - phi_gradient_xyz   :: (dphi_dx: phi/m, dphi_dy: phi/m, dphi_dz: phi/m) 3D vector on the slope-tangential plane

    return a SpreadBehavior struct containing these keys:
    - dphi_dt            :: phi/min (on the slope-tangential plane)
    - fire_type          :: 0 (unburned), 1 (surface), 2 (passive_crown), or 3 (active_crown)
    - spread_rate        :: m/min
    - spread_direction   :: (x, y, z) unit vector
    - fireline_intensity :: kW/m
    - flame_length       :: m

    NOTE: This function should work for surface or crown fires interchangeably.
    """
    #================================================================================================
    # Calculate the magnitude of the phi gradient
    #================================================================================================

    phi_magnitude: cy.float = vu.vector_magnitude_3d(phi_gradient_xyz) # phi/m

    #================================================================================================
    # Check whether cell is on the fire perimeter and burning
    #================================================================================================

    if (phi_magnitude == 0.0 or fire_behavior_max.max_spread_rate == 0.0):
        # This location is not on the fire perimeter and/or is not burning

        #================================================================================================
        # Set the spread direction to the phi gradient direction, max spread direction, upslope, or North
        #================================================================================================

        spread_direction: vec_xyz = (vu.scale_3d(1.0 / phi_magnitude, phi_gradient_xyz)
                                     if phi_magnitude > 0.0
                                     else fire_behavior_max.max_spread_direction)

        #============================================================================================
        # Return zero surface/crown fire behavior
        #============================================================================================

        return SpreadBehavior(
            dphi_dt            = 0.0,
            fire_type          = fire_type_unburned,
            spread_rate        = 0.0,
            spread_direction   = spread_direction,
            fireline_intensity = 0.0,
            flame_length       = 0.0,
        )

    else:
        # This location is on the fire perimeter and is burning

        #============================================================================================
        # Unpack the fire_behavior_max struct
        #============================================================================================

        heading_fire_type         : cy.int   = fire_behavior_max.max_fire_type
        heading_spread_rate       : cy.float = fire_behavior_max.max_spread_rate        # m/min
        heading_spread_direction  : vec_xyz  = fire_behavior_max.max_spread_direction   # (x,y,z) unit vector
        heading_spread_vector     : vec_xyz  = vu.scale_3d(heading_spread_rate,
                                                           heading_spread_direction)    # (x,y,z) m/min vector
        heading_fireline_intensity: cy.float = fire_behavior_max.max_fireline_intensity # kW/m
        length_to_width_ratio     : cy.float = fire_behavior_max.length_to_width_ratio  # unitless
        eccentricity              : cy.float = fire_behavior_max.eccentricity           # unitless
        critical_spread_rate      : cy.float = fire_behavior_max.critical_spread_rate   # m/min

        #============================================================================================
        # Calculate the backing and flanking fire spread rates
        #============================================================================================

        backing_adjustment  : cy.float = (1.0 - eccentricity) / (1.0 + eccentricity)  # unitless
        backing_spread_rate : cy.float = heading_spread_rate * backing_adjustment     # m/min
        flanking_spread_rate: cy.float = ((heading_spread_rate + backing_spread_rate)
                                          / (2.0 * length_to_width_ratio))            # m/min

        #============================================================================================
        # Calculate dphi/dt
        #============================================================================================

        A      : cy.float = (heading_spread_rate - backing_spread_rate) / (2.0 * heading_spread_rate) # unitless
        B      : cy.float = vu.dot_3d(heading_spread_vector, phi_gradient_xyz)                        # phi/min
        C      : cy.float = flanking_spread_rate / heading_spread_rate                                # unitless
        D      : cy.float = pow((heading_spread_rate * phi_magnitude), 2.0)                           # (phi/min)^2
        E      : cy.float = ((length_to_width_ratio * length_to_width_ratio) - 1.0) * (B * B)         # (phi/min)^2
        dphi_dt: cy.float = -(A * B + C * sqrt(D + E))                                                # phi/min

        #============================================================================================
        # Calculate fire behavior normal to the fire perimeter
        #============================================================================================

        normal_spread_rate       : cy.float = -dphi_dt / phi_magnitude                        # m/min
        normal_spread_direction  : vec_xyz  = vu.as_unit_vector_3d(phi_gradient_xyz)          # (x,y,z) unit vector
        normal_adjustment        : cy.float = normal_spread_rate / heading_spread_rate        # unitless
        normal_fireline_intensity: cy.float = heading_fireline_intensity * normal_adjustment  # kW/m
        normal_flame_length      : cy.float = sf.calc_flame_length(normal_fireline_intensity) # m
        normal_fire_type         : cy.int   = (fire_type_surface if heading_fire_type == fire_type_surface
                                               else fire_type_crown_active if normal_spread_rate > critical_spread_rate
                                               else fire_type_crown_passive)

        #========================================================================================
        # Return the surface/crown fire behavior normal to the fire perimeter
        #========================================================================================

        return SpreadBehavior(
            dphi_dt            = dphi_dt,                   # phi/min
            fire_type          = normal_fire_type,          # surface, passive_crown, or active_crown
            spread_rate        = normal_spread_rate,        # m/min
            spread_direction   = normal_spread_direction,   # (x,y,z) unit vector
            fireline_intensity = normal_fireline_intensity, # kW/m
            flame_length       = normal_flame_length,       # m
        )
#+end_src

*** Burn Cell Normal to the Fire Perimeter
    :PROPERTIES:
    :CUSTOM_ID: burn-cell-normal-to-the-fire-perimeter
    :END:

When the goal of a fire behavior analysis is to evolve a burn scar
from its point of ignition into a generally conical shape in
space-time, then it is necessary to evaluate the combined surface and
crown fire behavior in the direction normal to the fire front. In
order to facilitate this calculation, the following function uses the
horizontal $\phi$ gradient, which denotes the maximum rate of change
in the $\phi$ field at each grid cell in the horizontal (spatial)
plane. This 2D vector is first projected onto the 3D local
slope-tangential plane and used to compute the surface fire behavior
in this direction. If a crown fire occurs, the crown fire behavior is
also calculated in the direction of the 3D $\phi$ gradient, and the
combined surface and crown fire behavior (as per section [[Combining
Surface and Crown Fire Behavior]]) is returned. If no crown fire occurs,
the surface fire behavior in the direction of the 3D $\phi$ gradient
is returned.

#+NAME: burn-cell-toward-phi-gradient
#+begin_src python
# TODO: Turn this into a struct once its methods have been removed
@cy.cclass
class SpreadInputs:
    """
    A fast-access data structure for reading inputs in performance-critical code.
    """
    rows                         : pyidx
    cols                         : pyidx
    band_duration                : cy.float # minutes
    cell_height                  : cy.float # meters
    cell_width                   : cy.float # meters
    slope                        : ISpaceTimeCube
    aspect                       : ISpaceTimeCube
    fuel_model                   : ISpaceTimeCube
    canopy_cover                 : ISpaceTimeCube
    canopy_height                : ISpaceTimeCube
    canopy_base_height           : ISpaceTimeCube
    canopy_bulk_density          : ISpaceTimeCube
    wind_speed_10m               : ISpaceTimeCube
    upwind_direction             : ISpaceTimeCube
    fuel_moisture_dead_1hr       : ISpaceTimeCube
    fuel_moisture_dead_10hr      : ISpaceTimeCube
    fuel_moisture_dead_100hr     : ISpaceTimeCube
    fuel_moisture_live_herbaceous: ISpaceTimeCube
    fuel_moisture_live_woody     : ISpaceTimeCube
    foliar_moisture              : ISpaceTimeCube
    temperature                  : ISpaceTimeCube
    fuel_spread_adjustment       : ISpaceTimeCube
    weather_spread_adjustment    : ISpaceTimeCube
    fuel_model_cache             : cy.pointer(FuelModel)


    def __cinit__(self,
                  cube_resolution              : tuple[cy.float, cy.float, cy.float],
                  slope                        : ISpaceTimeCube,
                  aspect                       : ISpaceTimeCube,
                  fuel_model                   : ISpaceTimeCube,
                  canopy_cover                 : ISpaceTimeCube,
                  canopy_height                : ISpaceTimeCube,
                  canopy_base_height           : ISpaceTimeCube,
                  canopy_bulk_density          : ISpaceTimeCube,
                  wind_speed_10m               : ISpaceTimeCube,
                  upwind_direction             : ISpaceTimeCube,
                  fuel_moisture_dead_1hr       : ISpaceTimeCube,
                  fuel_moisture_dead_10hr      : ISpaceTimeCube,
                  fuel_moisture_dead_100hr     : ISpaceTimeCube,
                  fuel_moisture_live_herbaceous: ISpaceTimeCube,
                  fuel_moisture_live_woody     : ISpaceTimeCube,
                  foliar_moisture              : ISpaceTimeCube,
                  temperature                  : ISpaceTimeCube,
                  fuel_spread_adjustment       : ISpaceTimeCube,
                  weather_spread_adjustment    : ISpaceTimeCube) -> cy.void:
        (_bands, rows, cols)               = slope.shape
        self.rows                          = rows
        self.cols                          = cols
        self.band_duration                 = cube_resolution[0]
        self.cell_height                   = cube_resolution[1]
        self.cell_width                    = cube_resolution[2]
        self.slope                         = slope
        self.aspect                        = aspect
        self.fuel_model                    = fuel_model
        self.canopy_cover                  = canopy_cover
        self.canopy_height                 = canopy_height
        self.canopy_base_height            = canopy_base_height
        self.canopy_bulk_density           = canopy_bulk_density
        self.wind_speed_10m                = wind_speed_10m
        self.upwind_direction              = upwind_direction
        self.fuel_moisture_dead_1hr        = fuel_moisture_dead_1hr
        self.fuel_moisture_dead_10hr       = fuel_moisture_dead_10hr
        self.fuel_moisture_dead_100hr      = fuel_moisture_dead_100hr
        self.fuel_moisture_live_herbaceous = fuel_moisture_live_herbaceous
        self.fuel_moisture_live_woody      = fuel_moisture_live_woody
        self.foliar_moisture               = foliar_moisture
        self.temperature                   = temperature
        self.fuel_spread_adjustment        = fuel_spread_adjustment
        self.weather_spread_adjustment     = weather_spread_adjustment
        self.__init_fuel_models()


    # TODO: Move this code to fuel_models.py
    @cy.cfunc
    def __init_fuel_models(self: SpreadInputs) -> cy.void:
        # Allocate an empty FuelModel array in memory
        fuel_model_cache: cy.pointer(FuelModel) = cy.cast(cy.pointer(FuelModel),
                                                          malloc(300 * cy.sizeof(FuelModel)))
        # Verify that it was created
        if not fuel_model_cache:
            # Something went wrong with malloc
            raise MemoryError()
        else:
            # Copy FuelModels from fm.fuel_model_table into fuel_model_cache
            fuel_model: FuelModel
            for fuel_model in fm.fuel_model_table.values():
                fuel_model_cache[fuel_model.number] = fuel_model
            # Save fuel_model_cache in the SpreadInputs object
            self.fuel_model_cache = fuel_model_cache


    # TODO: Inline this code at its call sites
    @cy.cfunc
    @cy.inline
    @cy.exceptval(check=False)
    def get_fm_struct(self: SpreadInputs, fm_number: pyidx) -> FuelModel:
        return self.fuel_model_cache[fm_number]


    def __dealloc__(self: SpreadInputs) -> cy.void:
        free(self.fuel_model_cache) # no-op if self.fuel_model_cache is NULL


# TODO: Inline this code at its call sites
@cy.cfunc
@cy.inline
def make_SpreadInputs(cube_resolution: tuple[cy.float, cy.float, cy.float], space_time_cubes: dict) -> SpreadInputs:
    return SpreadInputs(cube_resolution,
                        space_time_cubes["slope"],
                        space_time_cubes["aspect"],
                        space_time_cubes["fuel_model"],
                        space_time_cubes["canopy_cover"],
                        space_time_cubes["canopy_height"],
                        space_time_cubes["canopy_base_height"],
                        space_time_cubes["canopy_bulk_density"],
                        space_time_cubes["wind_speed_10m"],
                        space_time_cubes["upwind_direction"],
                        space_time_cubes["fuel_moisture_dead_1hr"],
                        space_time_cubes["fuel_moisture_dead_10hr"],
                        space_time_cubes["fuel_moisture_dead_100hr"],
                        space_time_cubes["fuel_moisture_live_herbaceous"],
                        space_time_cubes["fuel_moisture_live_woody"],
                        space_time_cubes["foliar_moisture"],
                        space_time_cubes.get("temperature"),
                        space_time_cubes.get("fuel_spread_adjustment"),
                        space_time_cubes.get("weather_spread_adjustment"))


@cy.cfunc
@cy.exceptval(check=False)
def lookup_cell_inputs(spread_inputs: SpreadInputs, space_time_coordinate: coord_tyx) -> CellInputs:
    """
    Reads the inputs for a given cell from the space-time cubes, returning a `CellInputs` struct.
    """
    # Unpack the space_time_coordinate
    t: pyidx = space_time_coordinate[0]
    y: pyidx = space_time_coordinate[1]
    x: pyidx = space_time_coordinate[2]

    # Topography, Fuel Model, and Vegetation
    slope              : cy.float = spread_inputs.slope.get(t, y, x)               # rise/run
    aspect             : cy.float = spread_inputs.aspect.get(t, y, x)              # degrees clockwise from North
    fuel_model_number  : cy.float = spread_inputs.fuel_model.get(t, y, x)          # integer index in fm.fuel_model_table
    canopy_cover       : cy.float = spread_inputs.canopy_cover.get(t, y, x)        # 0-1
    canopy_height      : cy.float = spread_inputs.canopy_height.get(t, y, x)       # m
    canopy_base_height : cy.float = spread_inputs.canopy_base_height.get(t, y, x)  # m
    canopy_bulk_density: cy.float = spread_inputs.canopy_bulk_density.get(t, y, x) # kg/m^3

    # Wind, Surface Moisture, and Foliar Moisture
    wind_speed_10m               : cy.float = spread_inputs.wind_speed_10m.get(t, y, x)                # km/hr
    upwind_direction             : cy.float = spread_inputs.upwind_direction.get(t, y, x)              # degrees clockwise from North
    fuel_moisture_dead_1hr       : cy.float = spread_inputs.fuel_moisture_dead_1hr.get(t, y, x)        # kg moisture/kg ovendry weight
    fuel_moisture_dead_10hr      : cy.float = spread_inputs.fuel_moisture_dead_10hr.get(t, y, x)       # kg moisture/kg ovendry weight
    fuel_moisture_dead_100hr     : cy.float = spread_inputs.fuel_moisture_dead_100hr.get(t, y, x)      # kg moisture/kg ovendry weight
    fuel_moisture_live_herbaceous: cy.float = spread_inputs.fuel_moisture_live_herbaceous.get(t, y, x) # kg moisture/kg ovendry weight
    fuel_moisture_live_woody     : cy.float = spread_inputs.fuel_moisture_live_woody.get(t, y, x)      # kg moisture/kg ovendry weight
    foliar_moisture              : cy.float = spread_inputs.foliar_moisture.get(t, y, x)               # kg moisture/kg ovendry weight

    # Spread Rate Adjustments (Optional)
    fuel_spread_adjustment   : cy.float = (spread_inputs.fuel_spread_adjustment.get(t, y, x)
                                           if spread_inputs.fuel_spread_adjustment is not None
                                           else 1.0)                                         # float >= 0.0
    weather_spread_adjustment: cy.float = (spread_inputs.weather_spread_adjustment.get(t, y, x)
                                           if spread_inputs.weather_spread_adjustment is not None
                                           else 1.0)                                         # float >= 0.0

    # Pack values into a CellInputs struct and return
    return CellInputs(
        slope                         = slope,
        aspect                        = aspect,
        fuel_model_number             = fuel_model_number,
        canopy_cover                  = canopy_cover,
        canopy_height                 = canopy_height,
        canopy_base_height            = canopy_base_height,
        canopy_bulk_density           = canopy_bulk_density,
        wind_speed_10m                = wind_speed_10m,
        upwind_direction              = upwind_direction,
        fuel_moisture_dead_1hr        = fuel_moisture_dead_1hr,
        fuel_moisture_dead_10hr       = fuel_moisture_dead_10hr,
        fuel_moisture_dead_100hr      = fuel_moisture_dead_100hr,
        fuel_moisture_live_herbaceous = fuel_moisture_live_herbaceous,
        fuel_moisture_live_woody      = fuel_moisture_live_woody,
        foliar_moisture               = foliar_moisture,
        fuel_spread_adjustment        = fuel_spread_adjustment,
        weather_spread_adjustment     = weather_spread_adjustment,
    )


# NOTE: We're only going through these annoying calculations because
# we are required to return a spread_direction unit vector, which is
# of questionable value.
#
# IMPROVEMENT: We wouldn't have to go through this trouble if we simply
# returned a Cartesian speed vector instead, which would play more
# nicely with the rest of the code.
@cy.cfunc
@cy.exceptval(check=False)
def unburned_SpreadBehavior(elevation_gradient: vec_xy, phi_gradient_xyz: vec_xyz) -> SpreadBehavior:
    # Create a 3D unit vector pointing...
    spread_direction: vec_xyz
    if (phi_gradient_xyz[0] != 0.0 and phi_gradient_xyz[1] != 0.0 and phi_gradient_xyz[2] != 0.0):
        # ...in the direction of the spatial phi gradient
        spread_direction = vu.as_unit_vector_3d(phi_gradient_xyz)
    elif (elevation_gradient[0] != 0.0 and elevation_gradient[1] != 0.0):
        # ...upslope on the slope-tangential plane
        slope_vector_3d: vec_xyz = vu.to_slope_plane(elevation_gradient, elevation_gradient)
        spread_direction         = vu.as_unit_vector_3d(slope_vector_3d)
    else:
        # ...to the North
        spread_direction = (0.0, 1.0, 0.0)

    # Return zero surface fire behavior
    return SpreadBehavior(
        dphi_dt            = 0.0,
        fire_type          = fire_type_unburned,
        spread_rate        = 0.0,
        spread_direction   = spread_direction,
        fireline_intensity = 0.0,
        flame_length       = 0.0,
    )
#+end_src

*** Identify Cells Near the Fire Perimeter ($\phi = 0$)
    :PROPERTIES:
    :CUSTOM_ID: identify-cells-near-the-fire-perimeter-($\phi-=-0$)
    :END:
**** A proposed algorithm for narrow band tracking
     :PROPERTIES:
     :CUSTOM_ID: a-proposed-algorithm-for-narrow-band-tracking
     :END:
***** Problem statement
      :PROPERTIES:
      :CUSTOM_ID: problem-statement
      :END:

To make the level-set method efficient, an important optimization
consists of updating only those cells in a narrow band around the fire
front (e.g., within a width of 3 cells). This way fire behavior gets
computed (and $\phi$ gets updated) only on a sparse subset of the
landscape at each timestep.

***** Definitions
      :PROPERTIES:
      :CUSTOM_ID: definitions
      :END:

At a given time step:

1. a _frontier_ cell is a cell that has a neighbor of opposite $\phi$
   sign.

2. a _tracked_ cell is a cell for which we will compute the fire
   behavior and update the $\phi$ field.

***** Suggested algorithm
      :PROPERTIES:
      :CUSTOM_ID: suggested-algorithm
      :END:

- Detecting Frontier Cells :: iterate through cell pairs (N/S, E/W),
  computing the products of their $\phi$ values and match when these
  are negative.

- Invariant :: at each time step, the set of tracked cells is the set
  of cells within 3 cells of a frontier cell using the Chebyshev
  distance.

- State :: we maintain a "reference counting" map, mapping each
  tracked cell to the number of frontier cells to which it is near
  (_near_ means "within 3 cells" using the Chebyshev distance). In
  particular, the keyset of this map is the set of tracked cells.

- Iteration :: at the end of timestep $t$, we know the values of
  $\phi(t)$ and $\phi(t+\Delta t)$ for all tracked cells. We now must
  compute the new set of tracked cells, which involves updating the
  reference-counting map. We do so by taking the following steps:

  1. Scan the set of tracked cells, and compute two subsets of them:
     (A) those that have become frontier cells and (B) those that are
     no longer frontier cells.

  2. For each cell in A (new frontier cell), list the cells near it,
     and increment their tracking counter by 1.

  3. For each cell in B (no longer a frontier cell), list the cells
     near it, and decrement their tracking counter by 1. Upon reaching
     0, remove the map entry.

# TODO: What's an efficient data structure for implementing the
#       reference-counting map? If Python/Cython can provide an
#       efficient primitive map implementation, then use that.
#       Otherwise, a 2D array might be a reasonable start, with the
#       downside of not being sparse, which means that iterating over
#       its keys ends up being $O(n^2)$. If that becomes a problem in
#       practice, then we'll have to implement some sort of sparse
#       data structure (I envision a hierarchy of 2D arrays with
#       exponentially increasing resolution, representing a tree-like
#       data structure).

#+NAME: phi-field-perimeter-tracking
#+begin_src python
@cy.cfunc
@cy.inline
def encode_cell_index(y: pyidx, x: pyidx) -> object: # ulong
    """
    Encodes a (y, x) tuple into a single Python integer object.
    This enables a more efficient memory layout than a tuple of Python integers.
    """
    return (cy.cast(cy.ulong, y) << 32) + cy.cast(cy.ulong, x)


@cy.cfunc
@cy.exceptval(check=False)
def decode_cell_index(encoded_cell_index: object) -> coord_yx:
    cell_index: cy.ulong = encoded_cell_index
    y         : pyidx    = cell_index >> 32
    x         : pyidx    = cy.cast(cy.uint, cell_index) # NOTE: faster than (cell_index & 0xFFFFFFFF)
    return (y, x)


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def opposite_phi_signs(phi_matrix: cy.float[:,::1], y1: pyidx, x1: pyidx, y2: pyidx, x2: pyidx) -> cy.bint:
    """
    Return True if the phi values at cells (x1,y1) and (x2,y2) have opposite signs.

    NOTE: phi_matrix has a 2 cell buffer on all 4 sides, so we have to add (2,2) to each cell index.
    """
    return phi_matrix[2+y1, 2+x1] * phi_matrix[2+y2, 2+x2] < 0.0


# TODO: Pass a 2D fuel_model_array instead for speed
@cy.cfunc
@cy.exceptval(check=False)
def is_frontier_cell(phi_matrix     : cy.float[:,::1],
                     fuel_model_cube: ISpaceTimeCube,
                     t              : pyidx,
                     y              : pyidx,
                     x              : pyidx) -> cy.bint:
    # Compare (north, south, east, west) neighboring cell pairs for opposite phi signs
    north_y: pyidx = y+1
    south_y: pyidx = y-1
    east_x : pyidx = x+1
    west_x : pyidx = x-1
    return ((
        # Check north
        opposite_phi_signs(phi_matrix, y, x, north_y, x) and spot.is_burnable_cell(fuel_model_cube, t, north_y, x)
    ) or (
        # Check south
        opposite_phi_signs(phi_matrix, y, x, south_y, x) and spot.is_burnable_cell(fuel_model_cube, t, south_y, x)
    ) or (
        # Check east
        opposite_phi_signs(phi_matrix, y, x, y, east_x) and spot.is_burnable_cell(fuel_model_cube, t, y, east_x)
    ) or (
        # Check west
        opposite_phi_signs(phi_matrix, y, x, y, west_x) and spot.is_burnable_cell(fuel_model_cube, t, y, west_x)
    )) and (
        # Is this cell burnable?
        spot.is_burnable_cell(fuel_model_cube, t, y, x)
    )


# TODO: Is it faster to build up a list or a set?
@cy.cfunc
def identify_all_frontier_cells(phi_matrix     : cy.float[:,::1],
                                fuel_model_cube: ISpaceTimeCube,
                                t              : pyidx,
                                rows           : pyidx,
                                cols           : pyidx) -> set:
    """
    TODO: Add docstring
    """
    frontier_cells: set = set()
    y             : pyidx
    x             : pyidx
    for y in range(rows):
        for x in range(cols):
            if is_frontier_cell(phi_matrix, fuel_model_cube, t, y, x):
                frontier_cells.add(encode_cell_index(y, x))
    return frontier_cells


@cy.cfunc
def identify_tracked_cells(frontier_cells: set,
                           buffer_width  : pyidx,
                           rows          : pyidx,
                           cols          : pyidx) -> nbt.NarrowBandTracker:
    """
    TODO: Add docstring
    """
    tracked_cells     : nbt.NarrowBandTracker = nbt.new_NarrowBandTracker(rows, cols)
    encoded_cell_index: object
    y                 : pyidx
    x                 : pyidx
    for encoded_cell_index in frontier_cells:
        (y, x) = decode_cell_index(encoded_cell_index)
        nbt.inc_square_around(tracked_cells, y, x, buffer_width)
    return tracked_cells
#+end_src

*** Spread Phi Field
    :PROPERTIES:
    :CUSTOM_ID: spread-phi-field
    :END:

# TODO: Include Val's proof for late integration of the limited and unlimited phi gradients in dphi/dt.

$\hat{\nabla} \varphi \cdot U = (\hat{\nabla} \varphi \cdot \frac{\ddot{\nabla} \varphi}{|\ddot{\nabla} \varphi|}) (\frac{\ddot{\nabla} \varphi}{|\ddot{\nabla} \varphi|}\cdot U) = (\hat{\nabla} \varphi \cdot \frac{\ddot{\nabla} \varphi}{|\ddot{\nabla} \varphi|^2}) (\ddot{\nabla} \varphi \cdot U)$

Compute dt at each timestep using the Courant-Friedrichs Lewy condition simplified to the one-dimensional case by computing `UMAX`:
https://en.wikipedia.org/wiki/Courant%E2%80%93Friedrichs%E2%80%93Lewy_condition

Here's how to do the correct computation for the $U_x$ and $U_y$ horizontal spread rates used in the CFL calculation.

Denote $\bar{U} := (\bar{U}_x, \bar{U}_y)$ the horizontal vector that we need for the CFL. This vector is defined as being front-normal in the horizontal plane, with magnitude $|\bar{U}| = - \frac{d \varphi}{dt}/|\nabla \varphi|$. It follows that its coordinates can be obtained as:

$ \bar{U}_x = - \frac{d \varphi}{dt} \frac{1}{|\nabla \varphi|^2}  \frac{\partial \varphi}{\partial x}$

... and similarly for $\bar{U}_y$. The spatial gradient is not flux-limited.

#+NAME: spread-phi-field
#+begin_src python
# TODO: OPTIM We might want to pass in the CellInputs and avoid looking up the SpreadInputs again here.
@cy.cfunc
@cy.exceptval(check=False)
def spot_from_burned_cell(spread_inputs   : SpreadInputs,
                          fire_type_matrix: cy.uchar[:,::1],
                          y               : pyidx,
                          x               : pyidx,
                          fire_behavior   : SpreadBehavior,
                          time_of_arrival : cy.float,
                          random_generator: BufferedRandGen,
                          spot_config     : SpotConfig,
                          spot_ignitions  : SortedDict[float, set]) -> cy.void:
    """
    Schedules the future spot ignitions following from burning the given cell.
    Mutates `spot_ignitions` (and `random_generator`).
    """
    t_cast                  : pyidx    = int(time_of_arrival // spread_inputs.band_duration)
    slope                   : cy.float = spread_inputs.slope.get(t_cast, y, x)
    aspect                  : cy.float = spread_inputs.aspect.get(t_cast, y, x)
    elevation_gradient      : vec_xy   = calc_elevation_gradient(slope, aspect)
    cell_height             : cy.float = spread_inputs.cell_height
    cell_width              : cy.float = spread_inputs.cell_width
    cell_horizontal_area    : cy.float = cell_height * cell_width
    expected_firebrand_count: cy.float = spot.expected_firebrand_production(fire_behavior,
                                                                            elevation_gradient,
                                                                            cell_horizontal_area,
                                                                            spot_config.firebrands_per_unit_heat)
    num_firebrands          : cy.long  = random_generator.next_poisson(expected_firebrand_count)
    if num_firebrands > 0:
        wind_speed_10m  : cy.float               = spread_inputs.wind_speed_10m.get(t_cast, y, x)
        upwind_direction: cy.float               = spread_inputs.upwind_direction.get(t_cast, y, x)
        new_ignitions   : tuple[float, set]|None = spot.spread_firebrands(spread_inputs.fuel_model,
                                                                          spread_inputs.temperature,
                                                                          spread_inputs.fuel_moisture_dead_1hr,
                                                                          fire_type_matrix,
                                                                          (spread_inputs.rows,
                                                                           spread_inputs.cols),
                                                                          cell_height,
                                                                          cell_width,
                                                                          (t_cast, y, x),
                                                                          wind_speed_10m,
                                                                          upwind_direction,
                                                                          fire_behavior.fireline_intensity,
                                                                          fire_behavior.flame_length,
                                                                          time_of_arrival,
                                                                          random_generator,
                                                                          num_firebrands,
                                                                          spot_config)
        if new_ignitions:
            ignition_time           : float    = new_ignitions[0]
            ignited_cells           : set      = new_ignitions[1]
            concurrent_ignited_cells: set|None = spot_ignitions.get(ignition_time)
            if concurrent_ignited_cells:
                spot_ignitions[ignition_time] = set.union(ignited_cells, concurrent_ignited_cells)
            else:
                spot_ignitions[ignition_time] = ignited_cells


@cy.cfunc
@cy.exceptval(check=False)
def calc_phi_magnitude_xyz_2(phi_gradient_xy   : vec_xy,
                             elevation_gradient: vec_xy) -> cy.float:
    """
    Calculates the squared magnitude of the 3D slope-tangential phi gradient given:
    - phi_gradient_xy    :: (dphi_dx: phi/m, dphi_dy: phi/m) 2D vector on the horizontal plane
    - elevation_gradient :: (dz_dx: rise/run, dz_dy: rise/run)
    """
    (dz_dx, dz_dy)     = elevation_gradient
    (dphi_dx, dphi_dy) = phi_gradient_xy
    dphi_dz: cy.float  = vu.dot_2d(phi_gradient_xy, elevation_gradient)
    return (dphi_dx * dphi_dx + dphi_dy * dphi_dy - dphi_dz * dphi_dz / (1.0 + dz_dx * dz_dx + dz_dy * dz_dy))


# TODO: Is it faster if we save this as a top-level constant?
@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def zero_partialed_wavelet() -> PartialedEllWavelet:
    return PartialedEllWavelet(
        Vh_3d = (0.0, 0.0, 0.0),
        ewc_A = 0.0,
        ewc_B = 0.0,
        ewc_C = 0.0,
    )


@cy.cfunc
@cy.exceptval(check=False)
def prepare_partialed_wavelet(heading_spread_vector: vec_xyz,
                              flanking_spread_rate : cy.float,
                              backing_spread_rate  : cy.float) -> PartialedEllWavelet:
    """
    Partially evaluates the elliptical wavelet calculation given:
    - heading_spread_vector :: (x: m/min, y: m/min, z: m/min)
    - flanking_spread_rate  :: m/min
    - backing_spread_rate   :: m/min

    The returned data is meant to be passed to function `dphi_dt_from_partialed_wavelet()`.

    NOTE: Accepting the (flanking_spread_rate, backing_spread_rate) pair is more robust than just eccentricity
          (or equivalently length_to_width_ratio) because not all fire models use elliptical wavelets
          that grow around their focus. For example, ELMFIRE defaults to something else.
    """
    heading_spread_rate: cy.float = vu.vector_magnitude_3d(heading_spread_vector)
    if heading_spread_rate > 0.0:
        heading_spread_rate_inv: cy.float = 1.0 / heading_spread_rate
        length_to_width_ratio  : cy.float = (heading_spread_rate + backing_spread_rate) / (2.0 * flanking_spread_rate)
        return PartialedEllWavelet(
            Vh_3d = heading_spread_vector,
            ewc_A = -0.5 * (heading_spread_rate - backing_spread_rate) * heading_spread_rate_inv,
            ewc_B = -(flanking_spread_rate * heading_spread_rate_inv),
            ewc_C = (length_to_width_ratio * length_to_width_ratio - 1.0),
        )
    else:
        return zero_partialed_wavelet()


@cy.cfunc
@cy.exceptval(check=False)
def wavelet_from_FireBehaviorMax(fire_behavior_max: FireBehaviorMax) -> PartialedEllWavelet:
    heading_spread_rate: cy.float = fire_behavior_max.max_spread_rate # m/min
    if heading_spread_rate > 0.0:
        heading_spread_direction: vec_xyz  = fire_behavior_max.max_spread_direction      # (x,y,z) unit vector
        heading_spread_vector   : vec_xyz  = vu.scale_3d(heading_spread_rate,
                                                         heading_spread_direction)       # (x,y,z) m/min vector
        length_to_width_ratio   : cy.float = fire_behavior_max.length_to_width_ratio     # unitless
        eccentricity            : cy.float = fire_behavior_max.eccentricity              # unitless
        backing_adjustment      : cy.float = (1.0 - eccentricity) / (1.0 + eccentricity) # unitless
        backing_spread_rate     : cy.float = heading_spread_rate * backing_adjustment    # m/min
        flanking_spread_rate    : cy.float = ((heading_spread_rate + backing_spread_rate)
                                              / (2.0 * length_to_width_ratio))           # m/min
        return prepare_partialed_wavelet(heading_spread_vector, flanking_spread_rate, backing_spread_rate)
    else:
        return zero_partialed_wavelet()


# TODO: Change local variable names
@cy.cfunc
@cy.exceptval(check=False)
def dphi_dt_from_partialed_wavelet(wavelet            : PartialedEllWavelet,
                                   phi_gradient_xy    : vec_xy,
                                   phi_magnitude_xyz_2: cy.float) -> cy.float:
    """
    Calculates the dphi/dt (a negative number in phi/min) of one elliptical wavelet given:
    - wavelet             :: PartialedEllWavelet struct
      - Vh_3d                :: (m/min, m/min, m/min)
      - ewc_A                :: unitless
      - ewc_B                :: unitless
      - ewc_C                :: unitless
    - phi_gradient_xy     :: (dphi_dx: phi/m, dphi_dy: phi/m) 2D vector on the horizontal plane
    - phi_magnitude_xyz_2 :: (phi/m)^2 squared magnitude of the 3D slope-tangential phi gradient
    """
    # Unpack vectors
    (Vx, Vy, Vz)       = wavelet.Vh_3d
    (dphi_dx, dphi_dy) = phi_gradient_xy
    # Compute intermediate values
    Vh2    : cy.float = (Vx * Vx + Vy * Vy + Vz * Vz) # NOTE: Pre-computing this doesn't appear to make it faster.
    delta  : cy.float = (Vx * dphi_dx + Vy * dphi_dy) # dot-product between Vh_3d and slope-tangential phi gradient
    # Compute dphi_dt
    return (
        wavelet.ewc_A * delta +
        wavelet.ewc_B * sqrt(
            Vh2 * phi_magnitude_xyz_2 +
            wavelet.ewc_C * (delta * delta)
        )
    )


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def phi_aware_crowning_check(phi_magnitude_xyz_2 : cy.float,
                             surface_dphi_dt     : cy.float,
                             crowning_spread_rate: cy.float) -> cy.bint:
    """
    Logically equivalent to: (surface_spread_rate > crowning_spread_rate)
    but faster to compute and robust to zero phi gradient.
    """
    return (surface_dphi_dt * surface_dphi_dt) > (crowning_spread_rate * crowning_spread_rate * phi_magnitude_xyz_2)


# NOTE: Changing this function to accept a pointer to an EllipticalInfo did not yield appreciable performance gains.
@cy.cfunc
@cy.exceptval(check=False)
def dphi_dt_from_ellipses(ellipses: EllipticalInfo, phi_gradient_xy: vec_xy) -> cy.float:
    """
    Calculates the dphi/dt (a negative number in phi/min) of the combined surface and crown elliptical wavelets.

    NOTE: The reason for computing and returning only dphi/dt is efficiency.
          Nothing else is needed in the front-propagating tight loop that iterates over tracked cells.
    """
    phi_magnitude_xyz_2: cy.float = calc_phi_magnitude_xyz_2(phi_gradient_xy, ellipses.elevation_gradient)
    surface_dphi_dt    : cy.float = dphi_dt_from_partialed_wavelet(ellipses.surface_wavelet,
                                                                   phi_gradient_xy,
                                                                   phi_magnitude_xyz_2)
    if phi_aware_crowning_check(phi_magnitude_xyz_2, surface_dphi_dt, ellipses.crowning_spread_rate):
        crown_dphi_dt: cy.float = dphi_dt_from_partialed_wavelet(ellipses.crown_wavelet,
                                                                 phi_gradient_xy,
                                                                 phi_magnitude_xyz_2)
        return min(surface_dphi_dt, crown_dphi_dt) # NOTE: dphi_dt <= 0
    else:
        return surface_dphi_dt


# TODO: Rename this constant
p_CellInputs = cy.declare(pyidx, 17) # the number of input columns


@cy.cclass
class TrackedCellsArrays:
    """
    Arrays used as on-heap supporting data structures during spread, which:
    - provide an efficient memory layout for the data involved in the Runge-Kutta passes
    - should be read-only up to the number of tracked cells
    - have a greater length in order to implement dynamic resizing

    NOTE: The *_refreshed timestamps indicate when the data was last updated for each column.

    NOTE: The motivation for cube_cache being an array of floats and not of structs
          is to enable more generic processing when reading inputs.
    """
    _array_length    : pyidx                       # power of 2, doubles each time there is a dynamic resizing
    num_tracked_cells: pyidx
    cube_cache       : cy.float[:,::1]             # shape: (_array_length, p_CellInputs)
    phi_cache        : cy.float[:,::1]             # shape: (_array_length, 9)
    sfmin_cache      : cy.pointer(FireBehaviorMin) # array of structs, caching the FireBehaviorMin for each tracked cell
    ellipse_cache    : cy.pointer(EllipticalInfo)  # array of structs (needs to be iterated over very efficiently)
    pass1_cache      : cy.pointer(Pass1CellOutput) # per-cell data produced by the 1st Runge-Kutta pass
    time_refreshed   : cy.float[17]                # an exact instant in minutes
    t_refreshed      : pyidx[17]                   # a rounded index into the space-time cubes


    def __cinit__(self,
                  time_refreshed_init: cy.float,
                  t_refreshed_init   : pyidx,
                  array_length       : pyidx = 256) -> cy.void:
        self._array_length     = array_length
        self.num_tracked_cells = 0
        self.cube_cache        = np.zeros((array_length, p_CellInputs), dtype=np.float32)
        self.phi_cache         = np.zeros((array_length, 9), dtype=np.float32)
        self.sfmin_cache       = cy.cast(cy.pointer(FireBehaviorMin),
                                         malloc(array_length * cy.sizeof(FireBehaviorMin)))
        self.ellipse_cache     = cy.cast(cy.pointer(EllipticalInfo),
                                         malloc(array_length * cy.sizeof(EllipticalInfo)))
        self.pass1_cache       = cy.cast(cy.pointer(Pass1CellOutput),
                                         malloc(array_length * cy.sizeof(Pass1CellOutput)))
        # Verify that all arrays were created
        if not (self.sfmin_cache and self.ellipse_cache and self.pass1_cache):
            # Something went wrong with malloc
            raise MemoryError()
        # Set all values in the time_refreshed and t_refreshed arrays to the passed in values
        k: pyidx
        for k in range(17):
            self.time_refreshed[k] = time_refreshed_init
            self.t_refreshed[k]    = t_refreshed_init


    @cy.cfunc
    def reset_size(self: TrackedCellsArrays, num_tracked_cells: pyidx) -> cy.void:
        """
        Ensures that this can hold at least `num_tracked_cells`, resizing the internal arrays if necessary.
        Also updates `self.num_tracked_cells`.
        This can erase any data present in this object, so callers must make sure this information is no longer needed.
        """
        array_length: pyidx = self._array_length
        if num_tracked_cells > array_length:
            # Calculate an array_length >= num_tracked_cells
            while num_tracked_cells > array_length:
                array_length *= 2
            # Dynamically resize all internal arrays
            cube_cache   : cy.float[:,::1]             = np.zeros((array_length, p_CellInputs), dtype=np.float32)
            phi_cache    : cy.float[:,::1]             = np.zeros((array_length, 9), dtype=np.float32)
            sfmin_cache  : cy.pointer(FireBehaviorMin) = cy.cast(cy.pointer(FireBehaviorMin),
                                                                 realloc(self.sfmin_cache,
                                                                         array_length * cy.sizeof(FireBehaviorMin)))
            ellipse_cache: cy.pointer(EllipticalInfo)  = cy.cast(cy.pointer(EllipticalInfo),
                                                                 realloc(self.ellipse_cache,
                                                                         array_length * cy.sizeof(EllipticalInfo)))
            pass1_cache  : cy.pointer(Pass1CellOutput) = cy.cast(cy.pointer(Pass1CellOutput),
                                                                 realloc(self.pass1_cache,
                                                                         array_length * cy.sizeof(Pass1CellOutput)))
            # Verify that all arrays were created
            if not (sfmin_cache and ellipse_cache and pass1_cache):
                # Something went wrong with malloc
                raise MemoryError()
            else:
                self._array_length = array_length
                self.cube_cache    = cube_cache
                self.phi_cache     = phi_cache
                self.sfmin_cache   = sfmin_cache
                self.ellipse_cache = ellipse_cache
                self.pass1_cache   = pass1_cache
        # Update num_tracked_cells
        self.num_tracked_cells = num_tracked_cells


    def __dealloc__(self: TrackedCellsArrays) -> cy.void:
        free(self.sfmin_cache)
        free(self.ellipse_cache)
        free(self.pass1_cache)


@cy.cfunc
@cy.exceptval(check=False)
def collect_phi_cache(phi_matrix: cy.float[:,::1], tca: TrackedCellsArrays) -> cy.void:
    """
    Iterates over the tracked cells and stores their phi values in a cache.
    For each tracked cell, stores a row of 9 values in `tca.phi_cache`,
    corresponding to the 'cross' of cells required to compute flux-limited gradients.
    Reads from `phi_matrix` and mutates `tca.phi_cache`.
    """
    phi_cache    : cy.float[:,::1]            = tca.phi_cache
    ellipse_cache: cy.pointer(EllipticalInfo) = tca.ellipse_cache
    i            : pyidx
    y            : pyidx
    x            : pyidx
    for i in range(tca.num_tracked_cells):
        (y, x)          = ellipse_cache[i].cell_index
        phi_cache[i, 0] = phi_matrix[2+y  , 2+x]
        phi_cache[i, 1] = phi_matrix[2+y  , 2+x-2]
        phi_cache[i, 2] = phi_matrix[2+y  , 2+x-1]
        phi_cache[i, 3] = phi_matrix[2+y  , 2+x+1]
        phi_cache[i, 4] = phi_matrix[2+y  , 2+x+2]
        phi_cache[i, 5] = phi_matrix[2+y-2, 2+x]
        phi_cache[i, 6] = phi_matrix[2+y-1, 2+x]
        phi_cache[i, 7] = phi_matrix[2+y+1, 2+x]
        phi_cache[i, 8] = phi_matrix[2+y+2, 2+x]


@cy.cfunc
@cy.exceptval(check=False)
def compare_cell_indexes(c0: coord_yx, c1: coord_yx) -> cy.int:
    """
    Lexicographic comparison of (y, x) coordinates. Returns -1, 0, or 1.
    """
    (y0, x0) = c0
    (y1, x1) = c1
    if y0 < y1:
        return -1
    elif y0 > y1:
        return 1
    # Now we know both have the same y
    elif x0 < x1:
        return -1
    elif x0 > x1:
        return 1
    else:
        return 0


# TODO: OPTIM Maybe we want to use a native array directly instead of a MemoryView.
@cy.cfunc
@cy.exceptval(check=False)
def copy_tracked_cell_data(i_old  : pyidx,
                           tca_old: TrackedCellsArrays,
                           i_new  : pyidx,
                           tca_new: TrackedCellsArrays) -> cy.void:
    # Copy cube_cache
    # NOTE: Unrolling this loop made the code 2x faster.
    tca_new.cube_cache[i_new,  0] = tca_old.cube_cache[i_old,  0]
    tca_new.cube_cache[i_new,  1] = tca_old.cube_cache[i_old,  1]
    tca_new.cube_cache[i_new,  2] = tca_old.cube_cache[i_old,  2]
    tca_new.cube_cache[i_new,  3] = tca_old.cube_cache[i_old,  3]
    tca_new.cube_cache[i_new,  4] = tca_old.cube_cache[i_old,  4]
    tca_new.cube_cache[i_new,  5] = tca_old.cube_cache[i_old,  5]
    tca_new.cube_cache[i_new,  6] = tca_old.cube_cache[i_old,  6]
    tca_new.cube_cache[i_new,  7] = tca_old.cube_cache[i_old,  7]
    tca_new.cube_cache[i_new,  8] = tca_old.cube_cache[i_old,  8]
    tca_new.cube_cache[i_new,  9] = tca_old.cube_cache[i_old,  9]
    tca_new.cube_cache[i_new, 10] = tca_old.cube_cache[i_old, 10]
    tca_new.cube_cache[i_new, 11] = tca_old.cube_cache[i_old, 11]
    tca_new.cube_cache[i_new, 12] = tca_old.cube_cache[i_old, 12]
    tca_new.cube_cache[i_new, 13] = tca_old.cube_cache[i_old, 13]
    tca_new.cube_cache[i_new, 14] = tca_old.cube_cache[i_old, 14]
    tca_new.cube_cache[i_new, 15] = tca_old.cube_cache[i_old, 15]
    tca_new.cube_cache[i_new, 16] = tca_old.cube_cache[i_old, 16]
    # Copy sfmin_cache and ellipse_cache
    # NOTE: tca_old.pass1_cache does not need to be copied over given how it will get used.
    tca_new.sfmin_cache[i_new]   = tca_old.sfmin_cache[i_old]
    tca_new.ellipse_cache[i_new] = tca_old.ellipse_cache[i_old]


# TODO: Is it faster if we save this as a top-level constant?
@cy.cfunc
@cy.inline
def inputs_name_list() -> list[str]:
    return [
        "slope",
        "aspect",
        "fuel_model",
        "canopy_cover",
        "canopy_height",
        "canopy_base_height",
        "canopy_bulk_density",
        "wind_speed_10m",
        "upwind_direction",
        "fuel_moisture_dead_1hr",
        "fuel_moisture_dead_10hr",
        "fuel_moisture_dead_100hr",
        "fuel_moisture_live_herbaceous",
        "fuel_moisture_live_woody",
        "foliar_moisture",
        "fuel_spread_adjustment",
        "weather_spread_adjustment",
    ]


@cy.cclass
class FireBehaviorSettings:
    """
    A fast-access data structure for fire behavior parameters
    to reduce the number of arguments being passed around.
    """
    max_cells_per_timestep: cy.float # CFL condition
    buffer_width          : pyidx
    use_wind_limit        : cy.bint
    surface_lw_ratio_model: str
    crown_max_lw_ratio    : cy.float
    spot_config           : dict
    cube_refresh_rates    : cy.float[17] # (min^-1) the rate at which each input column needs to be refreshed


    def __init__(self,
                 max_cells_per_timestep: float|None = 0.4,
                 buffer_width          : int|None   = 3,
                 use_wind_limit        : bool|None  = True,
                 surface_lw_ratio_model: str|None   = "behave",
                 crown_max_lw_ratio    : float|None = 1e10,
                 spot_config           : dict|None  = None,
                 cube_refresh_rates    : dict|None  = {}) -> cy.void:
        self.max_cells_per_timestep = max_cells_per_timestep
        self.buffer_width           = buffer_width
        self.use_wind_limit         = use_wind_limit
        self.surface_lw_ratio_model = surface_lw_ratio_model
        self.crown_max_lw_ratio     = crown_max_lw_ratio
        if spot_config:
            self.spot_config = SpotConfig(
                random_seed                  = spot_config.get("random_seed"),
                firebrands_per_unit_heat     = spot_config.get("firebrands_per_unit_heat", 5e-11),
                downwind_distance_mean       = spot_config.get("downwind_distance_mean", 11.7),
                fireline_intensity_exponent  = spot_config.get("fireline_intensity_exponent"),
                wind_speed_exponent          = spot_config.get("wind_speed_exponent"),
                downwind_variance_mean_ratio = spot_config.get("downwind_variance_mean_ratio"),
                crosswind_distance_stdev     = spot_config.get("crosswind_distance_stdev", 10.0),
                decay_distance               = spot_config.get("decay_distance", 500.0),
            )
        inputs_names: list = inputs_name_list()
        for k in range(17):
            self.cube_refresh_rates[k] = cube_refresh_rates[inputs_names[k]]


@cy.cfunc
@cy.exceptval(check=False)
def load_cube_cache_for_cell(spread_inputs   : SpreadInputs,
                             cell_index      : coord_yx,
                             tca             : TrackedCellsArrays,
                             i               : pyidx) -> cy.void: # NOTE: Maybe return the CellInputs struct instead?
    """
    Reads variables from input ISpaceTimeCubes and saves them by mutating `tca.cube_cache`.
    """
    (y, x)                      = cell_index
    tr        : pyidx[17]       = tca.t_refreshed
    cube_cache: cy.float[:,::1] = tca.cube_cache

    # Topography, Fuel Model, and Vegetation
    cube_cache[i,  0] = spread_inputs.slope.get(tr[0], y, x)               # rise/run
    cube_cache[i,  1] = spread_inputs.aspect.get(tr[1], y, x)              # degrees clockwise from North
    cube_cache[i,  2] = spread_inputs.fuel_model.get(tr[2], y, x)          # integer index in fm.fuel_model_table
    cube_cache[i,  3] = spread_inputs.canopy_cover.get(tr[3], y, x)        # 0-1
    cube_cache[i,  4] = spread_inputs.canopy_height.get(tr[4], y, x)       # m
    cube_cache[i,  5] = spread_inputs.canopy_base_height.get(tr[5], y, x)  # m
    cube_cache[i,  6] = spread_inputs.canopy_bulk_density.get(tr[6], y, x) # kg/m^3

    # Wind, Surface Moisture, and Foliar Moisture
    cube_cache[i,  7] = spread_inputs.wind_speed_10m.get(tr[7], y, x)                 # km/hr
    cube_cache[i,  8] = spread_inputs.upwind_direction.get(tr[8], y, x)               # degrees clockwise from North
    cube_cache[i,  9] = spread_inputs.fuel_moisture_dead_1hr.get(tr[9], y, x)         # kg moisture/kg ovendry weight
    cube_cache[i, 10] = spread_inputs.fuel_moisture_dead_10hr.get(tr[10], y, x)       # kg moisture/kg ovendry weight
    cube_cache[i, 11] = spread_inputs.fuel_moisture_dead_100hr.get(tr[11], y, x)      # kg moisture/kg ovendry weight
    cube_cache[i, 12] = spread_inputs.fuel_moisture_live_herbaceous.get(tr[12], y, x) # kg moisture/kg ovendry weight
    cube_cache[i, 13] = spread_inputs.fuel_moisture_live_woody.get(tr[13], y, x)      # kg moisture/kg ovendry weight
    cube_cache[i, 14] = spread_inputs.foliar_moisture.get(tr[14], y, x)               # kg moisture/kg ovendry weight

    # Spread Rate Adjustments (Optional)
    cube_cache[i, 15] = (spread_inputs.fuel_spread_adjustment.get(tr[15], y, x)
                         if spread_inputs.fuel_spread_adjustment is not None
                         else 1.0)                                                       # float >= 0.0
    cube_cache[i, 16] = (spread_inputs.weather_spread_adjustment.get(tr[16], y, x)
                         if spread_inputs.weather_spread_adjustment is not None
                         else 1.0)                                                       # float >= 0.0


@cy.cfunc
@cy.inline
def list_float_input_cubes(spread_inputs: SpreadInputs) -> list[ISpaceTimeCube]:
    return [
        spread_inputs.slope,
        spread_inputs.aspect,
        spread_inputs.fuel_model,
        spread_inputs.canopy_cover,
        spread_inputs.canopy_height,
        spread_inputs.canopy_base_height,
        spread_inputs.canopy_bulk_density,
        spread_inputs.wind_speed_10m,
        spread_inputs.upwind_direction,
        spread_inputs.fuel_moisture_dead_1hr,
        spread_inputs.fuel_moisture_dead_10hr,
        spread_inputs.fuel_moisture_dead_100hr,
        spread_inputs.fuel_moisture_live_herbaceous,
        spread_inputs.fuel_moisture_live_woody,
        spread_inputs.foliar_moisture,
        spread_inputs.fuel_spread_adjustment,
        spread_inputs.weather_spread_adjustment,
    ]


@cy.cfunc
def default_cube_refresh_rates(band_duration: cy.float) -> dict:
    refresh_rate: cy.float = 1.0 / band_duration
    return {
        # Non-weather inputs default to a refresh rate of 0.0 (never refreshed).
        "slope"              : 0.0,
        "aspect"             : 0.0,
        "fuel_model"         : 0.0,
        "canopy_cover"       : 0.0,
        "canopy_height"      : 0.0,
        "canopy_base_height" : 0.0,
        "canopy_bulk_density": 0.0,
        # Weather inputs default to have the same refresh rate as the base resolution of inputs.
        "wind_speed_10m"               : refresh_rate,
        "upwind_direction"             : refresh_rate,
        "fuel_moisture_dead_1hr"       : refresh_rate,
        "fuel_moisture_dead_10hr"      : refresh_rate,
        "fuel_moisture_dead_100hr"     : refresh_rate,
        "fuel_moisture_live_herbaceous": refresh_rate,
        "fuel_moisture_live_woody"     : refresh_rate,
        "foliar_moisture"              : refresh_rate,
        "fuel_spread_adjustment"       : refresh_rate,
        "weather_spread_adjustment"    : refresh_rate,
    }


recompute_levels_list: list = [
    100, # slope
    100, # aspect
    100, # fuel_model
    100, # canopy_cover
    100, # canopy_height
    100, # canopy_base_height
    100, # canopy_bulk_density
     10, # wind_speed_10m
     10, # upwind_direction
    100, # fuel_moisture_dead_1hr
    100, # fuel_moisture_dead_10hr
    100, # fuel_moisture_dead_100hr
    100, # fuel_moisture_live_herbaceous
    100, # fuel_moisture_live_woody
    100, # foliar_moisture
    100, # fuel_spread_adjustment
    100  # weather_spread_adjustment
]


# TODO: Make this more efficient by replacing the list with an array of integers.
@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def recompute_level_for_input(input_k: pyidx) -> cy.uint:
    return recompute_levels_list[input_k]


@cy.cfunc
@cy.exceptval(check=False)
def refresh_inputs_if_needed(spread_inputs: SpreadInputs,
                             fb_opts      : FireBehaviorSettings,
                             tca          : TrackedCellsArrays,
                             present_time : cy.float) -> cy.uint:
    """
    Refreshes the data input columns and refresh timestamps if needed.
    Mutates `tca` and returns an integer indicating which downstream computations need to be recomputed.
    """
    stc_list       : list[ISpaceTimeCube]|None = None
    recompute_level: cy.uint                   = 0
    k              : pyidx
    for k in range(p_CellInputs):
        refresh_rate: cy.float = fb_opts.cube_refresh_rates[k]
        # Check whether ISpaceTimeCube k needs to be refreshed
        if refresh_rate * (present_time - tca.time_refreshed[k]) > 1.0:
            # Retrieve the stc_list only the first time a ISpaceTimeCube needs to be refreshed
            stc_list = list_float_input_cubes(spread_inputs) if (stc_list is None) else stc_list
            # Extract ISpaceTimeCube k
            space_time_cube: ISpaceTimeCube = stc_list[k]
            # Calculate and store the new time_refreshed and t_refreshed values
            #
            # NOTE: The refresh time is always an integer multiple of
            #       the refresh interval. We might want to change this.
            refresh_interval  : cy.float = 1.0 / refresh_rate
            time_refreshed_new: cy.float = (present_time // refresh_interval) * refresh_interval
            t_refreshed_new   : pyidx    = int(floor(time_refreshed_new / spread_inputs.band_duration))
            tca.time_refreshed[k]        = time_refreshed_new
            tca.t_refreshed[k]           = t_refreshed_new
            # Update the cube_cache array with the latest ISpaceTimeCube values for all tracked cells
            cube_cache: cy.float[:,::1] = tca.cube_cache
            i         : pyidx
            y         : pyidx
            x         : pyidx
            for i in range(tca.num_tracked_cells):
                (y, x)           = tca.ellipse_cache[i].cell_index
                cube_cache[i][k] = space_time_cube.get(t_refreshed_new, y, x)
            # Reset the recompute_level
            recompute_level = max(recompute_level, recompute_level_for_input(k))
    return recompute_level


@cy.cfunc
@cy.exceptval(check=False)
def load_saved_CellInputs(cube_cache: cy.float[:,::1], i: pyidx) -> CellInputs:
    """
    Loads the CellInputs struct by reading the data saved in the the cube_cache array.
    """
    # Topography, Fuel Model, and Vegetation
    slope              : cy.float = cube_cache[i, 0] # rise/run
    aspect             : cy.float = cube_cache[i, 1] # degrees clockwise from North
    fuel_model_number  : cy.float = cube_cache[i, 2] # integer index in fm.fuel_model_table
    canopy_cover       : cy.float = cube_cache[i, 3] # 0-1
    canopy_height      : cy.float = cube_cache[i, 4] # m
    canopy_base_height : cy.float = cube_cache[i, 5] # m
    canopy_bulk_density: cy.float = cube_cache[i, 6] # kg/m^3

    # Wind, Surface Moisture, and Foliar Moisture
    wind_speed_10m               : cy.float = cube_cache[i, 7]  # km/hr
    upwind_direction             : cy.float = cube_cache[i, 8]  # degrees clockwise from North
    fuel_moisture_dead_1hr       : cy.float = cube_cache[i, 9]  # kg moisture/kg ovendry weight
    fuel_moisture_dead_10hr      : cy.float = cube_cache[i, 10] # kg moisture/kg ovendry weight
    fuel_moisture_dead_100hr     : cy.float = cube_cache[i, 11] # kg moisture/kg ovendry weight
    fuel_moisture_live_herbaceous: cy.float = cube_cache[i, 12] # kg moisture/kg ovendry weight
    fuel_moisture_live_woody     : cy.float = cube_cache[i, 13] # kg moisture/kg ovendry weight
    foliar_moisture              : cy.float = cube_cache[i, 14] # kg moisture/kg ovendry weight

    # Spread Rate Adjustments (Optional)
    fuel_spread_adjustment   : cy.float = cube_cache[i, 15] # float >= 0.0
    weather_spread_adjustment: cy.float = cube_cache[i, 16] # float >= 0.0

    return CellInputs(
        slope                         = slope,
        aspect                        = aspect,
        fuel_model_number             = fuel_model_number,
        canopy_cover                  = canopy_cover,
        canopy_height                 = canopy_height,
        canopy_base_height            = canopy_base_height,
        canopy_bulk_density           = canopy_bulk_density,
        wind_speed_10m                = wind_speed_10m,
        upwind_direction              = upwind_direction,
        fuel_moisture_dead_1hr        = fuel_moisture_dead_1hr,
        fuel_moisture_dead_10hr       = fuel_moisture_dead_10hr,
        fuel_moisture_dead_100hr      = fuel_moisture_dead_100hr,
        fuel_moisture_live_herbaceous = fuel_moisture_live_herbaceous,
        fuel_moisture_live_woody      = fuel_moisture_live_woody,
        foliar_moisture               = foliar_moisture,
        fuel_spread_adjustment        = fuel_spread_adjustment,
        weather_spread_adjustment     = weather_spread_adjustment,
    )


@cy.cfunc
@cy.exceptval(check=False)
def resolve_surface_no_wind_no_slope_behavior(cell_inputs: CellInputs, fuel_model: FuelModel) -> FireBehaviorMin:
    """
    Computes the no-wind/no-slope surface fire behavior for a single cell.
    """
    # Pack surface fuel moisture values into a tuple
    M_f: fclaarr = (cell_inputs.fuel_moisture_dead_1hr,
                    cell_inputs.fuel_moisture_dead_10hr,
                    cell_inputs.fuel_moisture_dead_100hr,
                    0.0, # fuel_moisture_dead_herbaceous
                    cell_inputs.fuel_moisture_live_herbaceous,
                    cell_inputs.fuel_moisture_live_woody)

    # Apply fuel moisture to fuel model
    moisturized_fuel_model: FuelModel = fm.moisturize(fuel_model, M_f)

    # Combine the fuel and weather spread rate adjustments
    spread_rate_adjustment: cy.float = cell_inputs.fuel_spread_adjustment * cell_inputs.weather_spread_adjustment

    # Calculate the no-wind/no-slope surface fire behavior
    return sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model, spread_rate_adjustment)


@cy.cfunc
@cy.exceptval(check=False)
def resolve_surface_max_behavior(fb_opts         : FireBehaviorSettings,
                                 cell_inputs     : CellInputs,
                                 fuel_model      : FuelModel,
                                 surface_fire_min: FireBehaviorMin) -> FireBehaviorMax:
    # Convert from 10m wind speed to 20ft wind speed
    wind_speed_20ft: cy.float = conv.wind_speed_10m_to_wind_speed_20ft(cell_inputs.wind_speed_10m) # km/hr

    # Convert 20ft wind speed from km/hr to m/min
    wind_speed_20ft_m_min: cy.float = conv.km_hr_to_m_min(wind_speed_20ft) # m/min

    # Convert from 20ft wind speed to midflame wind speed in m/min
    midflame_wind_speed: cy.float = sf.calc_midflame_wind_speed(wind_speed_20ft_m_min,                   # m/min
                                                                fuel_model.delta,                        # ft
                                                                conv.m_to_ft(cell_inputs.canopy_height), # ft
                                                                cell_inputs.canopy_cover)                # 0-1

    # Calculate surface fire behavior in the direction of maximum spread
    return sf.calc_surface_fire_behavior_max(surface_fire_min,
                                             midflame_wind_speed,
                                             cell_inputs.upwind_direction,
                                             cell_inputs.slope,
                                             cell_inputs.aspect,
                                             fb_opts.use_wind_limit,
                                             fb_opts.surface_lw_ratio_model)


# TODO: OPTIM Use elevation_gradient to avoid some polar-to-cartesian conversion.
@cy.cfunc
@cy.exceptval(check=False)
def resolve_crown_max_behavior(fb_opts    : FireBehaviorSettings,
                               cell_inputs: CellInputs,
                               fuel_model : FuelModel) -> FireBehaviorMax:
    # Extract intermediate values
    heat_of_combustion          : cy.float = conv.Btu_lb_to_kJ_kg(fuel_model.h[0]) # kJ/kg
    estimated_fine_fuel_moisture: cy.float = cell_inputs.fuel_moisture_dead_1hr    # kg moisture/kg ovendry weight

    # Calculate crown fire behavior in the direction of maximum spread
    return cf.calc_crown_fire_behavior_max(cell_inputs.canopy_height,
                                           cell_inputs.canopy_base_height,
                                           cell_inputs.canopy_bulk_density,
                                           heat_of_combustion,
                                           estimated_fine_fuel_moisture,
                                           cell_inputs.wind_speed_10m,
                                           cell_inputs.upwind_direction,
                                           cell_inputs.slope,
                                           cell_inputs.aspect,
                                           fb_opts.crown_max_lw_ratio)


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def resolve_crowning_spread_rate(cell_inputs: CellInputs, surface_fire_max: FireBehaviorMax) -> cy.float:
    """
    Computes the surface spread rate at which crown fire occurs.
    """
    return cf.van_wagner_crowning_spread_rate(surface_fire_max,
                                              cell_inputs.canopy_base_height,
                                              cell_inputs.foliar_moisture)


@cy.cfunc
@cy.exceptval(check=False)
def resolve_cell_elliptical_info(fb_opts         : FireBehaviorSettings,
                                 cell_index      : coord_yx,
                                 cell_inputs     : CellInputs,
                                 fuel_model      : FuelModel,
                                 surface_fire_min: FireBehaviorMin) -> EllipticalInfo:
    # Calculate the cell's elevation gradient
    elevation_gradient: vec_xy = calc_elevation_gradient(cell_inputs.slope, cell_inputs.aspect)

    # Calculate the surface_wavelet, crown_wavelet, and crowning_spread_rate
    surface_wavelet     : PartialedEllWavelet
    crown_wavelet       : PartialedEllWavelet
    crowning_spread_rate: cy.float
    if not fuel_model.burnable:
        surface_wavelet      = zero_partialed_wavelet()
        crown_wavelet        = zero_partialed_wavelet()
        crowning_spread_rate = 1234.5 # arbitrary positive value - this threshold will never be reached.
    else:
        surface_fire_max: FireBehaviorMax = resolve_surface_max_behavior(fb_opts,
                                                                         cell_inputs,
                                                                         fuel_model,
                                                                         surface_fire_min)
        crown_fire_max  : FireBehaviorMax = resolve_crown_max_behavior(fb_opts, cell_inputs, fuel_model)
        surface_wavelet                   = wavelet_from_FireBehaviorMax(surface_fire_max)
        crown_wavelet                     = wavelet_from_FireBehaviorMax(crown_fire_max)
        crowning_spread_rate              = resolve_crowning_spread_rate(cell_inputs, surface_fire_max)

    # Build the EllipticalInfo struct
    return EllipticalInfo(
        cell_index           = cell_index,
        elevation_gradient   = elevation_gradient,
        surface_wavelet      = surface_wavelet,
        crown_wavelet        = crown_wavelet,
        crowning_spread_rate = crowning_spread_rate,
    )


@cy.cfunc
@cy.exceptval(check=False)
def refresh_caches_from_inputs_if_needed(spread_inputs: SpreadInputs,
                                         fb_opts      : FireBehaviorSettings,
                                         tca          : TrackedCellsArrays,
                                         present_time : cy.float) -> cy.void:
    """
    If required by the refresh rates, refresh inputs and recompute the necessary downstream calcs
    for each tracked cell, such as the elliptical info and the no-wind/no-slope surface fire behavior.
    Mutates `tca`.
    """
    # Update the cached cell inputs from the spread_inputs
    recompute_level  : cy.uint         = refresh_inputs_if_needed(spread_inputs, fb_opts, tca, present_time)
    cube_cache       : cy.float[:,::1] = tca.cube_cache
    cell_inputs      : CellInputs
    fuel_model_number: pyidx
    fuel_model       : FuelModel
    i                : pyidx
    if recompute_level >= 10:
        for i in range(tca.num_tracked_cells):
            # Load the cached cell inputs from the spread_inputs
            cell_inputs = load_saved_CellInputs(cube_cache, i)
            # Load the fuel model
            fuel_model_number = cy.cast(pyidx, cell_inputs.fuel_model_number)
            fuel_model        = spread_inputs.get_fm_struct(fuel_model_number)
            # Recalculate the no-wind/no-slope surface fire behavior for all tracked cells if recompute_level >= 100
            if recompute_level >= 100:
                tca.sfmin_cache[i] = resolve_surface_no_wind_no_slope_behavior(cell_inputs, fuel_model)
            # Recalculate the surface_wavelet, crown_wavelet, and crowning_spread_rate for all tracked cells
            tca.ellipse_cache[i] = resolve_cell_elliptical_info(fb_opts,
                                                                tca.ellipse_cache[i].cell_index,
                                                                cell_inputs,
                                                                fuel_model,
                                                                tca.sfmin_cache[i])


@cy.cfunc
@cy.exceptval(check=False)
def resolve_combined_spread_behavior(spread_inputs        : SpreadInputs,
                                     fb_opts              : FireBehaviorSettings,
                                     space_time_coordinate: coord_tyx,
                                     phi_gradient_xy      : vec_xy) -> SpreadBehavior:
    """
    Similar to resolve_cell_elliptical_info, but does a more exhaustive computation
    and returns a SpreadBehavior struct.
    """
    # Project phi_gradient_xy onto the slope-tangential plane as a 3D (x,y,z) vector
    cell_inputs       : CellInputs = lookup_cell_inputs(spread_inputs, space_time_coordinate)
    elevation_gradient: vec_xy     = calc_elevation_gradient(cell_inputs.slope, cell_inputs.aspect)
    phi_gradient_xyz  : vec_xyz    = calc_phi_gradient_on_slope(phi_gradient_xy, elevation_gradient)
    phi_magnitude     : cy.float   = vu.vector_magnitude_3d(phi_gradient_xyz)
    # Load the fuel model
    fuel_model_number: pyidx     = cy.cast(pyidx, cell_inputs.fuel_model_number)
    fuel_model       : FuelModel = spread_inputs.get_fm_struct(fuel_model_number)
    if phi_magnitude == 0.0 or not fuel_model.burnable:
        # This location is not on the fire perimeter and/or is not burnable
        return unburned_SpreadBehavior(elevation_gradient, phi_gradient_xyz)
    else:
        # This location is on the fire perimeter and is burnable
        surface_fire_min   : FireBehaviorMin = resolve_surface_no_wind_no_slope_behavior(cell_inputs, fuel_model)
        surface_fire_max   : FireBehaviorMax = resolve_surface_max_behavior(fb_opts,
                                                                            cell_inputs,
                                                                            fuel_model,
                                                                            surface_fire_min)
        surface_fire_normal: SpreadBehavior  = calc_fireline_normal_behavior(surface_fire_max, phi_gradient_xyz)
        # Check whether a crown fire occurs
        crowning_spread_rate: cy.float = resolve_crowning_spread_rate(cell_inputs, surface_fire_max)
        if (surface_fire_normal.spread_rate <= crowning_spread_rate):
            return surface_fire_normal
        else:
            crown_fire_max      : FireBehaviorMax = resolve_crown_max_behavior(fb_opts, cell_inputs, fuel_model)
            crown_fire_normal   : SpreadBehavior  = calc_fireline_normal_behavior(crown_fire_max, phi_gradient_xyz)
            combined_fire_normal: SpreadBehavior  = cf.calc_combined_fire_behavior(surface_fire_normal,
                                                                                   crown_fire_normal)
            return combined_fire_normal


@cy.cfunc
@cy.exceptval(check=False)
def load_tracked_cell_data(spread_inputs: SpreadInputs,
                           fb_opts      : FireBehaviorSettings,
                           cell_index   : coord_yx,
                           tca          : TrackedCellsArrays,
                           i            : pyidx) -> cy.void:
    # Read data from spread_inputs and save it in tca.cube_cache
    load_cube_cache_for_cell(spread_inputs, cell_index, tca, i)
    # Load the cached cell inputs from the spread_inputs
    cell_inputs: CellInputs = load_saved_CellInputs(tca.cube_cache, i)
    # Load the fuel model
    fuel_model_number: pyidx     = cy.cast(pyidx, cell_inputs.fuel_model_number)
    fuel_model       : FuelModel = spread_inputs.get_fm_struct(fuel_model_number)
    # Recalculate the no-wind/no-slope surface fire behavior
    surface_fire_min: FireBehaviorMin = resolve_surface_no_wind_no_slope_behavior(cell_inputs, fuel_model)
    tca.sfmin_cache[i]                = surface_fire_min
    # Recalculate the surface_wavelet, crown_wavelet, and crowning_spread_rate
    tca.ellipse_cache[i] = resolve_cell_elliptical_info(fb_opts, cell_index, cell_inputs, fuel_model, surface_fire_min)


@cy.cfunc
@cy.exceptval(check=False)
def sync_tracked_cells_arrays(spread_inputs: SpreadInputs,
                              fb_opts      : FireBehaviorSettings,
                              tracked_cells: nbt.NarrowBandTracker,
                              tca_old      : TrackedCellsArrays,
                              tca_new      : TrackedCellsArrays) -> cy.void:
    """
    Mutates `tca_new` so that it covers the same set of cells as `tracked_cells`,
    copying data from `tca_old` where possible, and otherwise loading new data from `spread_inputs`.
    """
    # Copy time_refreshed and t_refreshed arrays from tca_old to tca_new
    tca_new.reset_size(tracked_cells.num_tracked_cells)
    tca_new.time_refreshed = tca_old.time_refreshed
    tca_new.t_refreshed    = tca_old.t_refreshed
    # Set up loop variables
    cell_old     : coord_yx = (0, 0)
    cell_new     : coord_yx
    i_old        : pyidx    = 0
    i_new        : pyidx    = 0
    exhausted_old: cy.bint  = i_old >= tca_old.num_tracked_cells
    if not(exhausted_old):
        cell_old = tca_old.ellipse_cache[i_old].cell_index
    # NOTE: This loop uses the fact that tca_old is sorted consistently with compare_cell_indexes().
    ys_list: list = tracked_cells.ys_list
    if ys_list is not None:
        s: SortedDict
        for s in ys_list:
            if s is not None:
                segment: nbt.CellsCountSegment
                for segment in s.values():
                    k: pyidx
                    y: pyidx = segment.y
                    segment_counts: cy.ushort[16] = segment.counts
                    for k in range(16):
                        if (segment_counts[k] > 0):
                            # NOTE: The `for` and `if` code above is essentially just looping over the tracked cells.
                            #       This is ugly but faster than using an Iterator pattern.
                            x: pyidx = segment.x0 + k
                            cell_new = (y, x)
                            while not(exhausted_old) and compare_cell_indexes(cell_old, cell_new) < 0:
                                # cell_old is no longer tracked: just move forward.
                                i_old        += 1
                                exhausted_old = i_old >= tca_old.num_tracked_cells
                                if not(exhausted_old):
                                    cell_old = tca_old.ellipse_cache[i_old].cell_index
                            if not(exhausted_old) and (compare_cell_indexes(cell_old, cell_new) == 0):
                                # cell_new was already tracked: copy the data.
                                copy_tracked_cell_data(i_old, tca_old, i_new, tca_new)
                            else:
                                # cell_new was not in tca_old
                                load_tracked_cell_data(spread_inputs, fb_opts, cell_new, tca_new, i_new)
                            i_new += 1


@cy.cfunc
@cy.exceptval(check=False)
def runge_kutta_pass1(max_cells_per_timestep: cy.float,
                      dy                    : cy.float,
                      dx                    : cy.float,
                      max_timestep          : cy.float,
                      tca                   : TrackedCellsArrays) -> cy.float:
    """
    1st Runge-Kutta loop over elliptical dimensions, which:
    1. Resolves dt from the CFL condition
    2. Saves a Pass1CellOutput struct for each cell

    Returns the resolved `dt` and mutates `tca.pass1_cache`.
    Reads only `tca.ellipse_cache`.
    """
    ellipse_cache: cy.pointer[EllipticalInfo]  = tca.ellipse_cache
    pass1_cache  : cy.pointer[Pass1CellOutput] = tca.pass1_cache
    # The following will be useful to compute dt based on the CFL constraint.
    # It is more convenient to first compute dt_inv, the reciprocal of dt, and then
    # dt_inv = 0 represents an infinite dt. We will later enforce that dt <= max_timestep.
    dt_inv: cy.float = 0.0
    C_dx  : cy.float = max_cells_per_timestep * dx
    C_dy  : cy.float = max_cells_per_timestep * dy
    # Now looping over tracked cells:
    phi_cache: cy.float[:,::1] = tca.phi_cache
    dx_inv   : cy.float        = 1.0 / dx
    dy_inv   : cy.float        = 1.0 / dy
    for i in range(tca.num_tracked_cells):
        ellipses  : EllipticalInfo = ellipse_cache[i]
        cell_index: coord_yx       = ellipses.cell_index
        # Calculate the non-flux-limited spatial phi gradient
        dphi_dx           : cy.float = (phi_cache[i, 3] - phi_cache[i, 2]) * dx_inv / 2.0
        dphi_dy           : cy.float = (phi_cache[i, 7] - phi_cache[i, 6]) * dy_inv / 2.0
        phi_gradient_xy   : vec_xy   = (dphi_dx, dphi_dy)
        dphi_norm2        : cy.float = (dphi_dx * dphi_dx) + (dphi_dy * dphi_dy)
        dphi_dt_flim_pass1: cy.float
        if dphi_norm2 > 0.0: # Most common case
            # Calculate the flux-limited spatial phi gradient
            dphi_dx_flim: cy.float = dx_inv * calc_dphi_flim_x(phi_cache[i, 0],
                                                               phi_cache[i, 1],
                                                               phi_cache[i, 2],
                                                               phi_cache[i, 3],
                                                               phi_cache[i, 4])
            dphi_dy_flim: cy.float = dy_inv * calc_dphi_flim_y(phi_cache[i, 0],
                                                               phi_cache[i, 5],
                                                               phi_cache[i, 6],
                                                               phi_cache[i, 7],
                                                               phi_cache[i, 8])
            # Calculate the flux-limited temporal phi gradient
            dphi_dt           : cy.float = dphi_dt_from_ellipses(ellipses, phi_gradient_xy)
            dphi_dt_correction: cy.float = (dphi_dx * dphi_dx_flim + dphi_dy * dphi_dy_flim) / dphi_norm2
            dphi_dt_flim_pass1           = (dphi_dt * dphi_dt_correction)
            # Checking the CFL condition and updating dt_inv if needed (which will be rare).
            # The code is written in this way to be fast, but it's not trivial that it's correct; proof below.
            # The CFL constraint is defined as the requirement that |Ux*dt| <= C*dx and |Uy*dt| <= C*dy,
            # in which U := (Ux, Uy) is the front-normal spread rate vector in the horizontal plane,
            # and C := max_cells_per_timestep.
            # Recall that we could express U as follows: U: vec_xy = scale_2d(-dphi_dt/dphi_norm2, dphi),
            # which follows from the facts that dphi_dt = -dot2d(U, dphi) and that U is by definition
            # positively proportional to dphi.
            # In particular, Ux = -dphi_dx * dphi_dt / dphi_norm2.
            # Our constraint (from Ux) thus becomes:
            # |dt * dphi_dx * dphi_dt / dphi_norm2| <= C * dx
            # Recalling that dt_inv := 1/dt and rearranging yields:
            # dt_inv * (C * dx) * dphi_norm2 >= |dphi_dx * dphi_dt|
            if (dt_inv * (dphi_norm2 * C_dx) < abs(dphi_dt * dphi_dx)): # dt is too large given Ux
                dt_inv = abs(dphi_dt * dphi_dx) / (dphi_norm2 * C_dx)
            # And similarly for Uy:
            if (dt_inv * (dphi_norm2 * C_dy) < abs(dphi_dt * dphi_dy)): # dt is too large given Uy
                dt_inv = abs(dphi_dt * dphi_dy) / (dphi_norm2 * C_dy)
        else:
            dphi_dt_flim_pass1 = 0.0
        # Store the old and new phi values for each cell in pass1_cache
        pass1_cache[i] = Pass1CellOutput(
            cell_index      = cell_index,
            phi_gradient_xy = phi_gradient_xy,
            dphi_dt_flim    = dphi_dt_flim_pass1,
            phi_old         = phi_cache[i, 0],
        )
    # Calculate the CFL-constrained timestep dt
    dt_inv       = max(dt_inv, 1.0 / max_timestep) # (dt <= max_timestep) iff (dt_inv >= 1/max_timestep)
    dt: cy.float = 1.0 / dt_inv
    return dt


@cy.cfunc
@cy.exceptval(check=False)
def update_phi_star(tca            : TrackedCellsArrays,
                    dt             : cy.float,
                    phi_star_matrix: cy.float[:,::1]) -> cy.void:
    """
    Mutates phi_star_matrix, by using the dt and dphi/dt computed in the 1st Runge-Kutta pass.
    To be called between Runge-Kutta passes.
    """
    pass1_cache: cy.pointer[Pass1CellOutput] = tca.pass1_cache
    i          : pyidx
    for i in range(tca.num_tracked_cells):
        pass1output: Pass1CellOutput = pass1_cache[i]
        cell_index : coord_yx        = pass1output.cell_index
        y          : pyidx           = cell_index[0]
        x          : pyidx           = cell_index[1]
        phi_star_matrix[2+y, 2+x]    = pass1output.phi_old + (dt * pass1output.dphi_dt_flim)


# NOTE: Using an Extension Type here instead of a struct because it's
#       convenient to store in Python data structures like lists and dicts.
@cy.cclass
class BurnedCellInfo:
    """
    This data structure simply records information about a burned cell.
    """
    cell_index     : coord_yx
    time_of_arrival: cy.float
    phi_gradient_xy: vec_xy
    from_spotting  : cy.bint # whether spotting is what caused the cell to ignite


@cy.cfunc
def new_BurnedCellInfo(cell_index     : coord_yx,
                       time_of_arrival: cy.float,
                       phi_gradient_xy: vec_xy,
                       from_spotting  : cy.bint) -> BurnedCellInfo:
    ret: BurnedCellInfo = BurnedCellInfo()
    ret.cell_index      = cell_index
    ret.time_of_arrival = time_of_arrival
    ret.phi_gradient_xy = phi_gradient_xy
    ret.from_spotting   = from_spotting
    return ret


@cy.cfunc
def runge_kutta_pass2(dy                : cy.float,
                      dx                : cy.float,
                      start_time        : cy.float,
                      dt                : cy.float,
                      tca               : TrackedCellsArrays,
                      phi_matrix        : cy.float[:,::1]) -> list[BurnedCellInfo]:
    """
    2nd Runge-Kutta loop, which:
    1. Updates phi_matrix
    2. Identifies cells that have just burned and returns them in a list
    Reads from `tca` and `phi_star_cache`, and mutates `phi_matrix`.
    """
    dx_inv        : cy.float                    = 1.0 / dx
    dy_inv        : cy.float                    = 1.0 / dy
    ellipse_cache : cy.pointer[EllipticalInfo]  = tca.ellipse_cache
    pass1_cache   : cy.pointer[Pass1CellOutput] = tca.pass1_cache
    phi_star_cache: cy.float[:,::1]             = tca.phi_cache
    burned_cells  : list[BurnedCellInfo]        = []
    i             : pyidx
    for i in range(tca.num_tracked_cells):
        ellipses  : EllipticalInfo = ellipse_cache[i]
        cell_index: coord_yx       = ellipses.cell_index
        y         : pyidx          = cell_index[0]
        x         : pyidx          = cell_index[1]
        # Calculate the non-flux-limited spatial phi gradient
        dphi_dx           : cy.float = (phi_star_cache[i, 3] - phi_star_cache[i, 2]) * dx_inv / 2.0
        dphi_dy           : cy.float = (phi_star_cache[i, 7] - phi_star_cache[i, 6]) * dy_inv / 2.0
        phi_gradient_xy   : vec_xy   = (dphi_dx, dphi_dy)
        dphi_norm2        : cy.float = (dphi_dx * dphi_dx) + (dphi_dy * dphi_dy)
        dphi_dt_flim_pass2: cy.float
        if dphi_norm2 > 0.0: # Most common case
            # Calculate the flux-limited spatial phi gradient
            dphi_dx_flim: cy.float = dx_inv * calc_dphi_flim_x(phi_star_cache[i, 0],
                                                               phi_star_cache[i, 1],
                                                               phi_star_cache[i, 2],
                                                               phi_star_cache[i, 3],
                                                               phi_star_cache[i, 4])
            dphi_dy_flim: cy.float = dy_inv * calc_dphi_flim_y(phi_star_cache[i, 0],
                                                               phi_star_cache[i, 5],
                                                               phi_star_cache[i, 6],
                                                               phi_star_cache[i, 7],
                                                               phi_star_cache[i, 8])
            # Calculate the flux-limited temporal phi gradient
            dphi_dt           : cy.float = dphi_dt_from_ellipses(ellipses, phi_gradient_xy)
            dphi_dt_correction: cy.float = (dphi_dx * dphi_dx_flim + dphi_dy * dphi_dy_flim) / dphi_norm2
            dphi_dt_flim_pass2           = (dphi_dt * dphi_dt_correction)
        else:
            dphi_dt_flim_pass2 = 0.0
        # Combine the flux-limited temporal phi gradients from both Runge-Kutta passes
        dphi_dt_flim_pass1: cy.float = pass1_cache[i].dphi_dt_flim
        phi_old           : cy.float = pass1_cache[i].phi_old
        phi_new           : cy.float = phi_old + 0.5 * (dphi_dt_flim_pass1 + dphi_dt_flim_pass2) * dt
        phi_matrix[2+y, 2+x]         = phi_new
        # Check whether this cell has just burned, and add it to the burned_cells list if so.
        # NOTE: Phi can only ever decrease, and cells with negative phi are on fire.
        #       Therefore, if phi_old and phi_new are of opposite signs, the cell has just burned.
        if (phi_old * phi_new) < 0.0:
            time_of_arrival: cy.float = start_time + dt * phi_old / (phi_old - phi_new)
            # FIXME: Here we set phi_gradient_xy to be the phi gradient from the 1st pass.
            #        However, to be consistent with the time_of_arrival, we might want to
            #        average this with the phi_gradient_xy from the 2nd pass.
            burned_cells.append(
                new_BurnedCellInfo(cell_index      = cell_index,
                                   time_of_arrival = time_of_arrival,
                                   phi_gradient_xy = pass1_cache[i].phi_gradient_xy,
                                   from_spotting   = False)
            )
    return burned_cells


# TODO: Pass output_matrices as a struct
@cy.cfunc
@cy.exceptval(check=False)
def process_burned_cells(spread_inputs   : SpreadInputs,
                         fb_opts         : FireBehaviorSettings,
                         output_matrices : dict,
                         spot_ignitions  : SortedDict[float, set],
                         random_generator: BufferedRandGen,
                         burned_cells    : list[BurnedCellInfo]) -> cy.void:
    # Unpack output_matrices
    fire_type_matrix         : cy.uchar[:,::1] = output_matrices["fire_type"]
    spread_rate_matrix       : cy.float[:,::1] = output_matrices["spread_rate"]
    spread_direction_matrix  : cy.float[:,::1] = output_matrices["spread_direction"]
    fireline_intensity_matrix: cy.float[:,::1] = output_matrices["fireline_intensity"]
    flame_length_matrix      : cy.float[:,::1] = output_matrices["flame_length"]
    time_of_arrival_matrix   : cy.float[:,::1] = output_matrices["time_of_arrival"]

    # Save the burned_cells fire behavior values in output_matrices
    burned_cell: BurnedCellInfo
    for burned_cell in burned_cells:
        # Determine the current space_time_coordinate
        time_of_arrival      : cy.float  = burned_cell.time_of_arrival
        cell_index           : coord_yx  = burned_cell.cell_index
        t                    : pyidx     = int(time_of_arrival // spread_inputs.band_duration)
        (y, x)                           = cell_index
        space_time_coordinate: coord_tyx = (t, y, x)
        # Re-compute the spread behavior. It's OK to re-compute it because a cell burning is a relatively rare event.
        fire_behavior: SpreadBehavior = resolve_combined_spread_behavior(spread_inputs,
                                                                         fb_opts,
                                                                         space_time_coordinate,
                                                                         burned_cell.phi_gradient_xy)
        # Write to output_matrices
        fire_type_matrix[y, x]          = fire_behavior.fire_type
        spread_rate_matrix[y, x]        = fire_behavior.spread_rate
        spread_direction_matrix[y, x]   = vu.spread_direction_vector_to_angle(fire_behavior.spread_direction)
        fireline_intensity_matrix[y, x] = fire_behavior.fireline_intensity
        flame_length_matrix[y, x]       = fire_behavior.flame_length
        time_of_arrival_matrix[y, x]    = time_of_arrival

        # Cast firebrands and update spot_ignitions
        if fb_opts.spot_config:
            spot_from_burned_cell(spread_inputs,
                                  fire_type_matrix,
                                  y,
                                  x,
                                  fire_behavior,
                                  time_of_arrival,
                                  random_generator,
                                  fb_opts.spot_config,
                                  spot_ignitions)


@cy.cfunc
@cy.exceptval(check=False)
def reset_phi_star(tca               : TrackedCellsArrays,
                   spot_ignited_cells: list[BurnedCellInfo],
                   phi_star_matrix   : cy.float[:,::1],
                   phi_matrix        : cy.float[:,::1]) -> cy.void:
    """
    Efficiently updates `phi_star_matrix` to match `phi_matrix`,
    by copying only the values of cells where phi has changed.
    Mutates `phi_star_matrix`, reading from `tca.pass1_cache`, `spot_ignited_cells`, and `phi_matrix`.
    """
    y: pyidx
    x: pyidx
    i: pyidx
    # First copy phi values from the tracked cells
    for i in range(tca.num_tracked_cells):
        (y, x)                    = tca.pass1_cache[i].cell_index
        phi_star_matrix[2+y, 2+x] = phi_matrix[2+y, 2+x]
    # Then copy phi values from any spot-ignited cells
    burned_cell: BurnedCellInfo
    for burned_cell in spot_ignited_cells:
        (y, x)                    = burned_cell.cell_index
        phi_star_matrix[2+y, 2+x] = phi_matrix[2+y, 2+x]


# TODO: Pass output_matrices as a struct
@cy.cfunc
def ignite_from_spotting(spot_ignitions : SortedDict[float, set],
                         output_matrices: dict,
                         stop_time      : cy.float) -> list[BurnedCellInfo]:
    """
    Resolves the cells to be ignited by spotting in the current time step,
    returning them as a list of (y, x) tuples, and mutates `output_matrices` accordingly.
    """
    ignited_cells: list[BurnedCellInfo] = []
    if len(spot_ignitions) > 0:
        phi_matrix            : cy.float[:,::1] = output_matrices["phi"]
        time_of_arrival_matrix: cy.float[:,::1] = output_matrices["time_of_arrival"]
        ignition_time         : cy.float
        maybe_ignited_cells   : set
        cell_index            : coord_yx
        # https://grantjenks.com/docs/sortedcontainers/sorteddict.html
        n : pyidx = spot_ignitions.bisect_left(stop_time) # number of ignition_time values smaller than stop_time
        _i: pyidx
        for _i in range(n):
            # Remove and return the smallest ignition_time
            (ignition_time, maybe_ignited_cells) = spot_ignitions.popitem(index=0)
            for cell_index in maybe_ignited_cells:
                y: pyidx = cell_index[0]
                x: pyidx = cell_index[1]
                if phi_matrix[2+y, 2+x] > 0.0: # Not burned yet
                    phi_matrix[2+y, 2+x]        = -1.0
                    time_of_arrival_matrix[y,x] = ignition_time # FIXME: REVIEW Should I use stop_time instead?
                    ignited_cells.append(new_BurnedCellInfo(
                        cell_index      = cell_index,
                        time_of_arrival = ignition_time,
                        phi_gradient_xy = (0.0, 0.0),
                        from_spotting   = True
                    ))
                    # FIXME: I need to calculate and store the fire_behavior values for these cells
    return ignited_cells


@cy.cfunc
@cy.exceptval(check=False)
def route_cell_to_diff(frontier_cells_old: set,
                       frontier_additions: set,
                       frontier_removals : set,
                       phi_matrix        : cy.float[:,::1],
                       fuel_model_cube   : ISpaceTimeCube,
                       t                 : pyidx,
                       y                 : pyidx,
                       x                 : pyidx) -> cy.void:
    """
    Determines whether the cell `(y, x)` was just added or removed from the frontier cells,
    mutating the sets `frontier_additions` and `frontier_removals` accordingly.
    Idempotent.
    """
    encoded_cell_index: object = encode_cell_index(y, x)
    if is_frontier_cell(phi_matrix, fuel_model_cube, t, y, x):
        if not (encoded_cell_index in frontier_cells_old):
            frontier_additions.add(encoded_cell_index)
    else:
        if (encoded_cell_index in frontier_cells_old):
            frontier_removals.add(encoded_cell_index)


@cy.cfunc
def diff_frontier_cells(frontier_cells_old  : set,
                        spread_ignited_cells: list[BurnedCellInfo],
                        spot_ignited_cells  : list[BurnedCellInfo],
                        phi_matrix          : cy.float[:,::1],
                        fuel_model_cube     : ISpaceTimeCube,
                        t                   : pyidx) -> tuple[set, set]:
    """
    Computes the bi-directional set difference between the old frontier cells and the new frontier cells,
    based on newly burned cells. Returns a `(cells_added, cells_dropped)` tuple of sets, containing cell indices
    encoded by `encode_cell_index`.
    """
    frontier_additions: set = set()
    frontier_removals : set = set()
    ignited_cells     : list[BurnedCellInfo]
    # NOTE: We accept two lists below instead of one to avoid paying the cost of concatenating them.
    for ignited_cells in [spread_ignited_cells, spot_ignited_cells]:
        burned_cell: BurnedCellInfo
        y          : pyidx
        x          : pyidx
        for burned_cell in ignited_cells:
            (y, x) = burned_cell.cell_index
            # NOTE: Only in the neighborhood of a burned cell can there be changes to frontier cells membership.
            # FIXME: Should we be checking the diagonal directions as well?
            route_cell_to_diff(frontier_cells_old,
                               frontier_additions,
                               frontier_removals,
                               phi_matrix,
                               fuel_model_cube,
                               t,
                               y,
                               x)
            route_cell_to_diff(frontier_cells_old,
                               frontier_additions,
                               frontier_removals,
                               phi_matrix,
                               fuel_model_cube,
                               t,
                               y-1,
                               x)
            route_cell_to_diff(frontier_cells_old,
                               frontier_additions,
                               frontier_removals,
                               phi_matrix,
                               fuel_model_cube,
                               t,
                               y+1,
                               x)
            route_cell_to_diff(frontier_cells_old,
                               frontier_additions,
                               frontier_removals,
                               phi_matrix,
                               fuel_model_cube,
                               t,
                               y,
                               x-1)
            route_cell_to_diff(frontier_cells_old,
                               frontier_additions,
                               frontier_removals,
                               phi_matrix,
                               fuel_model_cube,
                               t,
                               y,
                               x+1)
    return (frontier_additions, frontier_removals)


@cy.cfunc
def apply_frontier_diff(frontier_cells_old: set, frontier_additions: set, frontier_removals: set) -> set:
    frontier_cells_new: set = frontier_cells_old.copy()
    encoded_cell_index: object
    for encoded_cell_index in frontier_additions:
        frontier_cells_new.add(encoded_cell_index)
    for encoded_cell_index in frontier_removals:
        frontier_cells_new.discard(encoded_cell_index)
    return frontier_cells_new


@cy.cfunc
def update_tracked_cells_with_frontier_diff(tracked_cells         : nbt.NarrowBandTracker,
                                            frontier_cells_added  : set,
                                            frontier_cells_dropped: set,
                                            buffer_width          : pyidx) -> nbt.NarrowBandTracker:
    """
    TODO: Add docstring
    """
    # Increment reference counters for all cells within buffer_width of the added frontier cells
    encoded_cell_index: object
    y                 : pyidx
    x                 : pyidx
    for encoded_cell_index in frontier_cells_added:
        (y, x) = decode_cell_index(encoded_cell_index)
        nbt.inc_square_around(tracked_cells, y, x, buffer_width)
    # Decrement reference counters for all cells within buffer_width of the dropped frontier cells
    for encoded_cell_index in frontier_cells_dropped:
        (y, x) = decode_cell_index(encoded_cell_index)
        nbt.dec_square_around(tracked_cells, y, x, buffer_width)
    # Return updated tracked cells
    return tracked_cells


# TODO: Turn sim_state and output_matrices into structs
@cy.cfunc
def spread_one_timestep(sim_state    : dict,
                        spread_inputs: SpreadInputs,
                        fb_opts      : FireBehaviorSettings,
                        max_timestep : cy.float) -> dict:
    """
    Spreads the fire for one iteration using the eulerian level-set method, returning an updated `sim_state`.
    """
    # Unpack sim_state
    start_time      : cy.float               = sim_state["simulation_time"]
    output_matrices : dict                   = sim_state["output_matrices"]
    phi_matrix      : cy.float[:,::1]        = output_matrices["phi"]
    phi_star_matrix : cy.float[:,::1]        = output_matrices["phi_star"]
    frontier_cells  : set                    = sim_state["frontier_cells"] # TODO: OPTIM Use a binary array instead?
    tracked_cells   : nbt.NarrowBandTracker  = sim_state["tracked_cells"]
    tca             : TrackedCellsArrays     = sim_state["_tracked_cells_arrays"]
    tca_old         : TrackedCellsArrays     = sim_state["_tracked_cells_arrays_old"]
    spot_ignitions  : SortedDict[float, set] = sim_state["spot_ignitions"]
    random_generator: BufferedRandGen        = sim_state["random_generator"]

    # Insert missing tracked cells
    sync_tracked_cells_arrays(spread_inputs, fb_opts, tracked_cells, tca_old, tca)
    refresh_caches_from_inputs_if_needed(spread_inputs, fb_opts, tca, start_time)
    collect_phi_cache(phi_matrix, tca)

    # Perform the first Runge-Kutta pass and save the calculated timestep dt
    dt       : cy.float = runge_kutta_pass1(fb_opts.max_cells_per_timestep,
                                            spread_inputs.cell_height,
                                            spread_inputs.cell_width,
                                            max_timestep,
                                            tca)
    stop_time: cy.float = start_time + dt

    # Now that dt is known, update phi_star_matrix
    update_phi_star(tca, dt, phi_star_matrix)
    collect_phi_cache(phi_star_matrix, tca)

    # Perform the second Runge-Kutta pass and save the newly burned cells
    burned_cells: list[BurnedCellInfo] = runge_kutta_pass2(spread_inputs.cell_height,
                                                           spread_inputs.cell_width,
                                                           start_time,
                                                           dt,
                                                           tca,
                                                           phi_matrix)

    # Process side-effects of the burned cells (outputs, etc.)
    process_burned_cells(spread_inputs, fb_opts, output_matrices, spot_ignitions, random_generator, burned_cells)
    # TODO: REVIEW It is a questionable choice to call this function AFTER process_burned_cells.
    #       It may be more sensible to ignite the spotting cells first and then to process them all.
    spot_ignited_cells: list[BurnedCellInfo] = ignite_from_spotting(spot_ignitions, output_matrices, stop_time)

    # Save the new phi_matrix values in phi_star_matrix
    reset_phi_star(tca, spot_ignited_cells, phi_star_matrix, phi_matrix)

    # Update the sets of frontier cells and tracked cells based on the updated phi matrix
    frontier_diff     : tuple[set, set]       = diff_frontier_cells(frontier_cells,
                                                                    burned_cells,
                                                                    spot_ignited_cells,
                                                                    phi_matrix,
                                                                    spread_inputs.fuel_model,
                                                                    int(stop_time // spread_inputs.band_duration))
    frontier_additions: set                   = frontier_diff[0]
    frontier_removals : set                   = frontier_diff[1]
    frontier_cells_new: set                   = apply_frontier_diff(frontier_cells,
                                                                    frontier_additions,
                                                                    frontier_removals)
    tracked_cells_new : nbt.NarrowBandTracker = update_tracked_cells_with_frontier_diff(tracked_cells,
                                                                                        frontier_additions,
                                                                                        frontier_removals,
                                                                                        fb_opts.buffer_width)

    # Return the updated world state
    # NOTE: We are intentionally swapping the tracked_cells_arrays
    return {
        "simulation_time"          : stop_time,
        "output_matrices"          : output_matrices,
        "frontier_cells"           : frontier_cells_new,
        "tracked_cells"            : tracked_cells_new,
        "_tracked_cells_arrays"    : tca_old,
        "_tracked_cells_arrays_old": tca,
        "spot_ignitions"           : spot_ignitions,
        "random_generator"         : random_generator,
    }


@cy.cfunc
def check_space_time_cubes(space_time_cubes: dict, spot_config: dict|None = None) -> cy.void:
    # Define the provided, required, and optional keys for space_time_cubes
    provided_cubes: set = set(space_time_cubes.keys())
    required_cubes: set = {
        "slope",
        "aspect",
        "fuel_model",
        "canopy_cover",
        "canopy_height",
        "canopy_base_height",
        "canopy_bulk_density",
        "wind_speed_10m",
        "upwind_direction",
        "fuel_moisture_dead_1hr",
        "fuel_moisture_dead_10hr",
        "fuel_moisture_dead_100hr",
        "fuel_moisture_live_herbaceous",
        "fuel_moisture_live_woody",
        "foliar_moisture",
    } | ({"temperature"} if spot_config else set())
    optional_cubes: set = {
        "fuel_spread_adjustment",
        "weather_spread_adjustment",
    } | ({"temperature"} if spot_config is None else set())

    # Ensure that all required_cubes are present in provided_cubes
    if not provided_cubes.issuperset(required_cubes):
        raise ValueError("The space_time_cubes dictionary is missing these required keys: "
                         + str(required_cubes.difference(provided_cubes)))

    # Ensure that only required_cubes and optional_cubes are present in provided_cubes
    if not (required_cubes | optional_cubes).issuperset(provided_cubes):
        raise ValueError("The space_time_cubes dictionary contains these unused keys: "
                         + str(provided_cubes.difference((required_cubes | optional_cubes))))

    # Ensure that all space_time_cubes values are ISpaceTimeCube objects
    cube: object
    for cube in space_time_cubes.values():
        if not(isinstance(cube, ISpaceTimeCube)):
            raise ValueError("All values in the space_time_cubes dictionary must be ISpaceTimeCube "
                             + "objects. See pyretechnics.space_time_cube for more information.")


@cy.cfunc
def check_output_matrices(output_matrices: dict) -> cy.void:
    # Define the provided, required, and optional keys for output_matrices
    provided_matrices: set = set(output_matrices.keys())
    required_matrices: set = {
        "phi",
        "fire_type",
        "spread_rate",
        "spread_direction",
        "fireline_intensity",
        "flame_length",
        "time_of_arrival",
    }
    optional_matrices: set = set() # NOTE: Leaving this here in case we add some later

    # Ensure that all required_matrices are present in provided_matrices
    if not provided_matrices.issuperset(required_matrices):
        raise ValueError("The output_matrices dictionary is missing these required keys: "
                         + str(required_matrices.difference(provided_matrices)))

    # Ensure that only required_matrices and optional_matrices are present in provided_matrices
    if not (required_matrices | optional_matrices).issuperset(provided_matrices):
        raise ValueError("The output_matrices dictionary contains these unused keys: "
                         + str(provided_matrices.difference((required_matrices | optional_matrices))))

    # Ensure that all output_matrices values are 2D Numpy arrays
    matrix: object
    for matrix in output_matrices.values():
        if not(isinstance(matrix, np.ndarray) and np.ndim(matrix) == 2):
            raise ValueError("All values in the output_matrices dictionary must be 2D Numpy arrays.")


@cy.cfunc
def check_dimensions_and_resolutions(space_time_cubes: dict,
                                     output_matrices : dict,
                                     bands           : pyidx,
                                     rows            : pyidx,
                                     cols            : pyidx,
                                     band_duration   : cy.float,
                                     cell_height     : cy.float,
                                     cell_width      : cy.float) -> cy.void:
    # Ensure that all space_time_cubes have the same cube shape
    cube: ISpaceTimeCube
    for cube in space_time_cubes.values():
        if cube.shape != (bands, rows, cols):
            raise ValueError("The space_time_cubes must all share the same cube shape.")

    # Ensure that space_time_cubes and output_matrices have the same cube shape
    label : str
    matrix: np.ndarray
    for (label, matrix) in output_matrices.items():
        if label == "phi":
            if matrix.shape != (rows + 4, cols + 4):
                raise ValueError("The phi matrix must be padded by 2 rows and 2 columns "
                                 + "compared to the simulation dimensions.")
        else:
            if matrix.shape != (rows, cols):
                raise ValueError("The space_time_cubes and output_matrices must share the same "
                                 + "number of rows and columns.")

    # Ensure that all cube resolution values are positive
    if band_duration <= 0.0 or cell_height <= 0.0 or cell_width <= 0.0:
        raise ValueError("The cube_resolution tuple may only contain positive values.")


@cy.cfunc
def check_start_and_stop_times(start_time   : cy.float,
                               max_stop_time: cy.float,
                               cube_duration: cy.float,
                               max_duration : float|None = None) -> cy.void:
    # Ensure that start_time exists within the temporal bounds of the space_time_cubes
    if not(0.0 <= start_time < cube_duration):
        raise ValueError("The start_time falls outside of the temporal bounds of the space_time_cubes.")

    # Ensure that max_duration is positive if provided
    if max_duration and max_duration <= 0.0:
        raise ValueError("The max_duration must be a positive value if provided.")

    # Ensure that the max_stop_time does not exceed the cube_duration
    if max_stop_time > cube_duration:
        raise ValueError("The start_time + max_duration exceeds the temporal bounds of the space_time_cubes.")


@cy.ccall
def spread_fire_with_phi_field(space_time_cubes      : dict[str, ISpaceTimeCube],
                               output_matrices       : dict[str, np.ndarray],
                               cube_resolution       : tuple[cy.float, cy.float, cy.float],
                               start_time            : cy.float,
                               max_duration          : float|None             = None,
                               max_cells_per_timestep: cy.float               = 0.4,
                               buffer_width          : pyidx                  = 3,
                               use_wind_limit        : cy.bint                = True,
                               surface_lw_ratio_model: str                    = "behave",
                               crown_max_lw_ratio    : cy.float               = 1e10,
                               spot_ignitions        : dict[float, set]       = {},
                               spot_config           : dict[str, object]|None = None,
                               cube_refresh_rates    : dict[str, float]       = {}) -> dict[str, object]:
    """
    Given these inputs:
    - space_time_cubes             :: dictionary of ISpaceTimeCube objects with these cell types
      - slope                         :: rise/run
      - aspect                        :: degrees clockwise from North
      - fuel_model                    :: integer index in fm.fuel_model_table
      - canopy_cover                  :: 0-1
      - canopy_height                 :: m
      - canopy_base_height            :: m
      - canopy_bulk_density           :: kg/m^3
      - temperature                   :: degrees Celsius (Optional: needed for spotting)
      - wind_speed_10m                :: km/hr
      - upwind_direction              :: degrees clockwise from North
      - fuel_moisture_dead_1hr        :: kg moisture/kg ovendry weight
      - fuel_moisture_dead_10hr       :: kg moisture/kg ovendry weight
      - fuel_moisture_dead_100hr      :: kg moisture/kg ovendry weight
      - fuel_moisture_live_herbaceous :: kg moisture/kg ovendry weight
      - fuel_moisture_live_woody      :: kg moisture/kg ovendry weight
      - foliar_moisture               :: kg moisture/kg ovendry weight
      - fuel_spread_adjustment        :: float >= 0.0 (Optional: defaults to 1.0)
      - weather_spread_adjustment     :: float >= 0.0 (Optional: defaults to 1.0)
    - output_matrices              :: dictionary of 2D Numpy arrays whose spatial dimensions match the space_time_cubes
      - phi                           :: 2D float array of values in [-1,1]
      - fire_type                     :: 2D byte array (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)
      - spread_rate                   :: 2D float array (m/min)
      - spread_direction              :: 2D float array (degrees clockwise from North)
      - fireline_intensity            :: 2D float array (kW/m)
      - flame_length                  :: 2D float array (m)
      - time_of_arrival               :: 2D float array (min)
    - cube_resolution              :: tuple with these fields
      - band_duration                 :: minutes
      - cell_height                   :: meters
      - cell_width                    :: meters
    - start_time                   :: minutes (from the start of the space_time_cube's temporal origin)
    - max_duration                 :: minutes (Optional)
    - max_cells_per_timestep       :: max number of cells the fire front can travel in one timestep (Optional)
    - buffer_width                 :: Chebyshev distance from frontier cells to include in tracked cells (Optional)
    - use_wind_limit               :: boolean (Optional)
    - surface_lw_ratio_model       :: "rothermel" or "behave" (Optional)
    - crown_max_lw_ratio           :: float > 0.0 (Optional)
    - spot_ignitions               :: dictionary of (ignition_time -> ignited_cells) (Optional: needed for spotting)
    - spot_config                  :: dictionary of spotting parameters (Optional: needed for spotting)
      - random_seed                   :: seed for a numpy.random.Generator object
      - firebrands_per_unit_heat      :: firebrands/kJ
      - downwind_distance_mean        :: meters
      - fireline_intensity_exponent   :: downwind_distance_mean multiplier [I^fireline_intensity_exponent]
      - wind_speed_exponent           :: downwind_distance_mean multiplier [U^wind_speed_exponent]
      - downwind_variance_mean_ratio  :: meters^2 / meter [downwind_variance_mean_ratio = Var(X) / E(X)]
      - crosswind_distance_stdev      :: meters
      - decay_distance                :: meters
    - cube_refresh_rates           :: dictionary from input name to refresh rate in 1/min (Optional).
                                      0 means never refresh. Weather inputs default to 1/band_duration,
                                      whereas non-weather inputs default to 0.

    return a dictionary with these keys:
    - stop_time            :: minutes
    - stop_condition       :: "max duration reached", "zero-length timestep", or "no burnable cells"
    - output_matrices      :: dictionary of 2D Numpy arrays whose spatial dimensions match the space_time_cubes
      - phi                   :: 2D float array of values in [-1,1]
      - fire_type             :: 2D byte array (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)
      - spread_rate           :: 2D float array (m/min)
      - spread_direction      :: 2D float array (degrees clockwise from North)
      - fireline_intensity    :: 2D float array (kW/m)
      - flame_length          :: 2D float array (m)
      - time_of_arrival       :: 2D float array (min)
    - spot_ignitions       :: dictionary of (ignition_time -> ignited_cells) (only included when spotting is used)
    - random_generator     :: BufferedRandGen object (only included when spotting is used)
    """
    # Verify the contents of space_time_cubes
    check_space_time_cubes(space_time_cubes, spot_config)

    # Verify the contents of output_matrices
    check_output_matrices(output_matrices)

    # Extract simulation dimensions
    fuel_model_cube: ISpaceTimeCube             = space_time_cubes["fuel_model"]
    cube_shape     : tuple[pyidx, pyidx, pyidx] = fuel_model_cube.shape
    bands          : pyidx                      = cube_shape[0]
    rows           : pyidx                      = cube_shape[1]
    cols           : pyidx                      = cube_shape[2]

    # Extract simulation resolutions
    band_duration: cy.float = cube_resolution[0]
    cell_height  : cy.float = cube_resolution[1]
    cell_width   : cy.float = cube_resolution[2]

    # Verify the simulation dimensions and resolutions
    check_dimensions_and_resolutions(space_time_cubes,
                                     output_matrices,
                                     bands,
                                     rows,
                                     cols,
                                     band_duration,
                                     cell_height,
                                     cell_width)

    # Calculate the cube duration and max stop time
    cube_duration: cy.float = bands * band_duration
    max_stop_time: cy.float = start_time + max_duration if max_duration else cube_duration

    # Verify simulation start and stop times
    check_start_and_stop_times(start_time, max_stop_time, cube_duration, max_duration)

    # Identify the sets of frontier cells and tracked cells based on the phi matrix
    start_t       : pyidx                 = int(start_time // band_duration)
    phi_matrix    : cy.float[:,::1]       = output_matrices["phi"]
    frontier_cells: set                   = identify_all_frontier_cells(phi_matrix,
                                                                        fuel_model_cube,
                                                                        start_t,
                                                                        rows,
                                                                        cols)
    tracked_cells : nbt.NarrowBandTracker = identify_tracked_cells(frontier_cells, buffer_width, rows, cols)

    # Make a copy of the phi matrix to use for intermediate calculations in each timestep
    output_matrices["phi_star"] = np.copy(phi_matrix)

    # Create a BufferedRandGen object to produce random samples if spot_config is provided
    random_generator: BufferedRandGen|None = None
    if spot_config:
        random_generator = BufferedRandGen(np.random.default_rng(seed=spot_config.get("random_seed")))

    # FIXME: Change this name without a collision
    # Prepare the SpreadInputs struct
    spread_inputs: SpreadInputs = make_SpreadInputs(cube_resolution, space_time_cubes)

    # Prepare the FireBehaviorSettings struct
    fb_opts: FireBehaviorSettings = FireBehaviorSettings(
        max_cells_per_timestep = max_cells_per_timestep,
        buffer_width           = buffer_width,
        use_wind_limit         = use_wind_limit,
        surface_lw_ratio_model = surface_lw_ratio_model,
        crown_max_lw_ratio     = crown_max_lw_ratio,
        spot_config            = spot_config,
        cube_refresh_rates     = {**default_cube_refresh_rates(band_duration), **cube_refresh_rates},
    )

    # Prepare the sim_state dictionary
    # NOTE: We are intentionally swapping the tracked_cells_arrays.
    #       It's OK not to be in sync - spread_one_timestep will solve this.
    sim_state: dict  = {
        "simulation_time"          : start_time,
        "output_matrices"          : output_matrices,
        "frontier_cells"           : frontier_cells,
        "tracked_cells"            : tracked_cells,
        "_tracked_cells_arrays"    : TrackedCellsArrays(start_time, start_t),
        "_tracked_cells_arrays_old": TrackedCellsArrays(start_time, start_t),
        "spot_ignitions"           : SortedDict(spot_ignitions), # Convert spot_ignitions into a SortedDict
        "random_generator"         : random_generator,
    }

    # FIXME: I don't think the "no burnable cells" condition can ever be met currently.
    # Spread the fire until an exit condition is reached
    remaining_time_in_simulation: cy.float = max_stop_time - start_time
    early_exit_threshold        : cy.float = 1.0 / 60.0 # 1 second
    while((remaining_time_in_simulation > early_exit_threshold)       # 1. There is still time left in the simulation
          and (nbt.nonempty_tracked_cells(tracked_cells)              # 2. There are burning cells on the grid
               or len(sim_state["spot_ignitions"]) > 0)):             # 3. There are embers waiting to catch fire on the grid
        # Spread fire one timestep
        sim_state                    = spread_one_timestep(sim_state,
                                                           spread_inputs,
                                                           fb_opts,
                                                           remaining_time_in_simulation)
        remaining_time_in_simulation = max_stop_time - sim_state["simulation_time"]

    # Determine the stop_condition
    stop_condition: str = ("max duration reached"
                           if remaining_time_in_simulation <= early_exit_threshold
                           else "no burnable cells")

    # FIXME: REVIEW Perhaps phi_star would be better off in sim_state
    # Remove the temporary copy of the phi matrix from output_matrices
    sim_state["output_matrices"].pop("phi_star")

    # Return the final simulation results
    return {
        "stop_time"        : sim_state["simulation_time"],
        "stop_condition"   : stop_condition,
        "output_matrices"  : sim_state["output_matrices"],
        "num_tracked_cells": tracked_cells.num_tracked_cells,
    } | ({
        "spot_ignitions"  : sim_state["spot_ignitions"],
        "random_generator": sim_state["random_generator"],
    } if spot_config else {})
#+end_src

** For Users
   :PROPERTIES:
   :CUSTOM_ID: for-users-fire-spread
   :header-args:python+: :session *examples:pyretechnics.eulerian_level_set*
   :header-args:python+: :results output replace
   :header-args:python+: :exports both
   :END:

*** How to Spread a Fire from a Point Ignition
    :PROPERTIES:
    :CUSTOM_ID: how-to-spread-a-fire-from-a-point-ignition
    :END:

**** Configure and Run the Fire Spread Simulation
     :PROPERTIES:
     :CUSTOM_ID: configure-and-run-the-fire-spread-simulation
     :END:

#+NAME: run-spread-fire-with-phi-field
#+begin_src python :results silent :tangle ../prof/spread_fire.py
import numpy as np
import pyretechnics.eulerian_level_set as els
from pyretechnics.space_time_cube import SpaceTimeCube
import time

#============================================================================================
# Specify the SpaceTimeCube dimensions
#============================================================================================

cube_shape = (
    75, # bands: 10 days @ 1 hour/band
    5000, # rows:  3 km @ 30 meters/row
    5000, # cols:  3 km @ 30 meters/col
)

grid_shape = cube_shape[1:]

#============================================================================================
# Specify the SpaceTimeCube resolution
#============================================================================================

cube_resolution = (
    60, # band_duration: minutes
    30, # cell_height:   meters
    30, # cell_width:    meters
)

#============================================================================================
# Create an input dictionary of SpaceTimeCubes (using constant data for this example)
#============================================================================================

def arr2d(value):
    return np.full(grid_shape, value)

def arr3d(value):
    (b, r, c) = cube_shape
    return np.full((b, r//10, c//10) , value)

space_time_cubes = {
    "slope"                        : SpaceTimeCube(cube_shape, arr2d(0.8)),   # rise/run
    "aspect"                       : SpaceTimeCube(cube_shape, arr2d(225.0)), # degrees clockwise from North
    # Fuel model 185: (TL5) high-load conifer litter
    "fuel_model"                   : SpaceTimeCube(cube_shape, arr2d(185)),   # integer index in fm.fuel_model_table
    "canopy_cover"                 : SpaceTimeCube(cube_shape, arr2d(0.7)),   # 0-1
    "canopy_height"                : SpaceTimeCube(cube_shape, arr2d(10.0)),  # m
    "canopy_base_height"           : SpaceTimeCube(cube_shape, arr2d(0.5)),   # m
    "canopy_bulk_density"          : SpaceTimeCube(cube_shape, arr2d(0.3)),   # kg/m^3
    "wind_speed_10m"               : SpaceTimeCube(cube_shape, arr3d(10.0)),  # km/hr
    "upwind_direction"             : SpaceTimeCube(cube_shape, arr3d(180.0)), # degrees clockwise from North
    "fuel_moisture_dead_1hr"       : SpaceTimeCube(cube_shape, arr3d(0.03)),  # kg moisture/kg ovendry weight
    "fuel_moisture_dead_10hr"      : SpaceTimeCube(cube_shape, arr3d(0.04)),  # kg moisture/kg ovendry weight
    "fuel_moisture_dead_100hr"     : SpaceTimeCube(cube_shape, arr3d(0.05)),  # kg moisture/kg ovendry weight
    "fuel_moisture_live_herbaceous": SpaceTimeCube(cube_shape, arr3d(0.90)),  # kg moisture/kg ovendry weight
    "fuel_moisture_live_woody"     : SpaceTimeCube(cube_shape, arr3d(0.60)),  # kg moisture/kg ovendry weight
    "foliar_moisture"              : SpaceTimeCube(cube_shape, arr3d(0.70)),  # kg moisture/kg ovendry weight
    "temperature"                  : SpaceTimeCube(cube_shape, 30.0),  # degrees Celsius
    "fuel_spread_adjustment"       : SpaceTimeCube(cube_shape, arr2d(1.0)),   # float >= 0.0 (Optional: defaults to 1.0)
    "weather_spread_adjustment"    : SpaceTimeCube(cube_shape, arr3d(1.0)),   # float >= 0.0 (Optional: defaults to 1.0)
}

cube_refresh_rates = {
    "wind_speed_10m"               : 1.0 / 15.0,
    "upwind_direction"             : 1.0 / 15.0,
    
    "fuel_moisture_dead_1hr"       : 1.0 / 30.0,
    
    "temperature"                  : 1.0 / 30.0,
    "fuel_spread_adjustment"       : 0.0,
    "weather_spread_adjustment"    : 1.0 / 30.0,
}

#============================================================================================
# Create an output dictionary of 2D Numpy arrays
#============================================================================================

output_matrices = {
    "phi"               : np.ones((grid_shape[0] + 4, grid_shape[1] + 4), dtype="float32"),       # 2D float array of values in [-1,1] # FIXME NOTE padding the phi raster to avoid the cost of checking bounds.
    "fire_type"         : np.zeros(grid_shape, dtype="uint8"),        # 2D byte array (0-3)
    "spread_rate"       : np.zeros(grid_shape, dtype="float32"),      # 2D float array (m/min)
    "spread_direction"  : np.zeros(grid_shape, dtype="float32"),      # 2D float array (degrees clockwise from North)
    "fireline_intensity": np.zeros(grid_shape, dtype="float32"),      # 2D float array (kW/m)
    "flame_length"      : np.zeros(grid_shape, dtype="float32"),      # 2D float array (m)
    "time_of_arrival"   : np.full(grid_shape, -1.0, dtype="float32"), # 2D float array (min)
}

#============================================================================================
# Set the start time, max duration, and initially ignited cell
#============================================================================================

# Day 2 @ 10:30am
start_time = 2070  # minutes

# 8 hours
max_duration = 480 # minutes
max_duration = 60*24*0.5 # minutes

# Burn initially ignited cell into the phi matrix by setting it to -1.0
output_matrices["phi"][2+500,2+500] = -1.0

#============================================================================================
# Spread fire from the start time for the max duration
#============================================================================================

spot_config = {
    "random_seed"                 : 1234567890,
    "firebrands_per_unit_heat"    : 1e-9,       # firebrands/kJ
    "downwind_distance_mean"      : 10.0,       # meters
    "fireline_intensity_exponent" : 0.3,        # downwind_distance_mean multiplier [I^fireline_intensity_exponent]
    "wind_speed_exponent"         : 0.55,       # downwind_distance_mean multiplier [U^wind_speed_exponent]
    "downwind_variance_mean_ratio": 425.0,      # meters^2 / meter [downwind_variance_mean_ratio = Var(X) / E(X)]
    "crosswind_distance_stdev"    : 100.0,      # meters
    "decay_distance"              : 200.0,      # meters
}


runtime_start       = time.perf_counter()
fire_spread_results = els.spread_fire_with_phi_field(space_time_cubes,
                                                     output_matrices,
                                                     cube_resolution,
                                                     start_time,
                                                     max_duration,
                                                     spot_config=spot_config,
                                                     cube_refresh_rates=cube_refresh_rates)
runtime_stop        = time.perf_counter()

stop_time           = fire_spread_results["stop_time"]         # minutes
stop_condition      = fire_spread_results["stop_condition"]    # "max duration reached" or "no burnable cells"
output_matrices     = fire_spread_results["output_matrices"]   # updated 2D arrays (mutated from inputs)
num_tracked_cells   = fire_spread_results["num_tracked_cells"] # cell count

#============================================================================================
# Print out the acres burned, total runtime, and runtime per burned cell
#============================================================================================

num_burned_cells        = np.count_nonzero(output_matrices["fire_type"]) # cells
acres_burned            = num_burned_cells / 4.5                         # acres
simulation_runtime      = runtime_stop - runtime_start                   # seconds
runtime_per_burned_cell = 1000.0 * simulation_runtime / num_burned_cells # ms/cell


ftype = output_matrices["fire_type"]

def empirical_LoW(ftype):
    """
    Estimates the length/width ratio (elliptical shape) by computing the empirical covariance matrix of the burned coordinates,
    and using its eigenvalues.
    """
    burned_yx = np.argwhere(ftype > 0)
    c = np.cov(burned_yx.astype(float), rowvar=False)
    eig = np.linalg.eig(c)
    v1, v2 = eig[0] # eigenvalues
    return np.sqrt(v1 / v2)



num_crowned = np.count_nonzero(ftype > 1)
print(f"Tracked Cells: {num_tracked_cells}")
print(f"Crowning Fraction: {num_crowned / num_burned_cells}")
print(f"Empirical Length/Width Ratio: {empirical_LoW(ftype)}")

print("Acres Burned: " + str(acres_burned))
print("Total Runtime: " + str(simulation_runtime) + " seconds")
print("Runtime Per Burned Cell: " + str(runtime_per_burned_cell) + " ms/cell")
Mha_per_cell = 0.09e-6
ms_per_hr = 3.6e6
print(f"Areal Throughput: {(ms_per_hr*Mha_per_cell/runtime_per_burned_cell):.2f} Mha/(CPU.hr)")
#+end_src

**** Display Summary Statistics of the Output Matrices
     :PROPERTIES:
     :CUSTOM_ID: display-summary-statistics-of-the-output-matrices
     :END:

#+NAME: run-spread-fire-with-phi-field-stats
#+begin_src python
import numpy as np
from pprint import pprint

#============================================================================================
# Display summary statistics of our fire spread results
#============================================================================================

# Used as a filter in get_array_stats below
burned_cells = output_matrices["fire_type"] > 0

def get_array_stats(array, use_burn_scar_mask=True):
    array_values_to_analyze = array[burned_cells] if use_burn_scar_mask else array
    if len(array_values_to_analyze) > 0:
        return {
            "Min"  : np.min(array_values_to_analyze),
            "Max"  : np.max(array_values_to_analyze),
            "Mean" : np.mean(array_values_to_analyze),
            "Stdev": np.std(array_values_to_analyze),
        }
    else:
        return {
            "Min"  : "No Data",
            "Max"  : "No Data",
            "Mean" : "No Data",
            "Stdev": "No Data",
        }

print("Fire Behavior from Day 2 @ 10:30am - Day 2 @ 6:30pm Spreading from Coordinate (50,50)\n" + "=" * 100)

print("Stop Time: " + str(stop_time) + " (minutes)")
print("Stop Condition: " + stop_condition)

print("\nPhi (phi <= 0: burned, phi > 0: unburned")
pprint(get_array_stats(output_matrices["phi"], use_burn_scar_mask=False), sort_dicts=False)

print("\nFire Type (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)")
pprint(get_array_stats(output_matrices["fire_type"]), sort_dicts=False)

print("\nSpread Rate (m/min)")
pprint(get_array_stats(output_matrices["spread_rate"]), sort_dicts=False)

print("\nSpread Direction (degrees clockwise from North)")
pprint(get_array_stats(output_matrices["spread_direction"]), sort_dicts=False)

print("\nFireline Intensity (kW/m)")
pprint(get_array_stats(output_matrices["fireline_intensity"]), sort_dicts=False)

print("\nFlame Length (meters)")
pprint(get_array_stats(output_matrices["flame_length"]), sort_dicts=False)

print("\nTime of Arrival (minutes)")
pprint(get_array_stats(output_matrices["time_of_arrival"]), sort_dicts=False)
#+end_src

#+NAME: run-spread-fire-with-phi-field-stats-results
#+RESULTS: run-spread-fire-with-phi-field-stats
#+begin_example
Fire Behavior from Day 2 @ 10:30am - Day 2 @ 6:30pm Spreading from Coordinate (50,50)
====================================================================================================
Stop Time: 2550.0 (minutes)
Stop Condition: max duration reached

Phi (phi <= 0: burned, phi > 0: unburned
{'Min': -0.9256893, 'Max': 1.0, 'Mean': 0.9060591, 'Stdev': 0.3892009}

Fire Type (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)
{'Min': 1, 'Max': 1, 'Mean': 1.0, 'Stdev': 0.0}

Spread Rate (m/min)
{'Min': 0.16077116, 'Max': 2.2964668, 'Mean': 1.2116479, 'Stdev': 0.6341628}

Spread Direction (degrees clockwise from North)
{'Min': 0.658666, 'Max': 359.69885, 'Mean': 191.40175, 'Stdev': 117.9331}

Fireline Intensity (kW/m)
{'Min': 2.2772384, 'Max': 32.528233, 'Mean': 17.16235, 'Stdev': 8.982579}

Flame Length (meters)
{'Min': 0.11312115, 'Max': 0.38439324, 'Mean': 0.27523616, 'Stdev': 0.07356826}

Time of Arrival (minutes)
{'Min': 2081.8516, 'Max': 2548.1523, 'Mean': 2385.591, 'Stdev': 116.83735}
#+end_example

**** Create Images of the Output Matrices
     :PROPERTIES:
     :CUSTOM_ID: create-images-of-the-output-matrices
     :END:

#+NAME: run-spread-fire-with-phi-field-images
#+begin_src python :results silent
import matplotlib.pyplot as plt
import numpy as np


def save_matrix_as_heatmap(matrix, colors, units, title, filename, vmin=None, vmax=None, ticks=None):
    image    = plt.imshow(matrix, origin="lower", cmap=colors, vmin=vmin, vmax=vmax)
    colorbar = plt.colorbar(image, orientation="vertical", ticks=ticks)
    colorbar.set_label(units)
    plt.title(title)
    plt.savefig(filename)
    plt.close("all")


def save_matrix_as_contours(matrix, title, filename, levels=None):
    fig, ax = plt.subplots()
    cs      = ax.contour(matrix, levels=levels)
    ax.clabel(cs, inline=True, fontsize=10)
    ax.set_aspect('equal', 'box')
    ax.set_title(title)
    plt.savefig(filename)
    plt.close("all")


# See https://matplotlib.org/stable/gallery/color/colormap_reference.html for the available options for "colors"
heatmap_configs = [
    {
        "matrix"  : output_matrices["phi"],
        "colors"  : "plasma",
        "units"   : "phi <= 0: burned, phi > 0: unburned",
        "title"   : "Phi",
        "filename": "pics/els_phi.png",
    },
    {
        "matrix"  : output_matrices["fire_type"],
        "colors"  : "viridis",
        "units"   : "0=unburned, 1=surface, 2=passive_crown, 3=active_crown",
        "title"   : "Fire Type",
        "filename": "pics/els_fire_type.png",
        "vmin"    : 0,
        "vmax"    : 3,
        "ticks"   : [0,1,2,3],
    },
    {
        "matrix"  : output_matrices["spread_rate"],
        "colors"  : "hot",
        "units"   : "m/min",
        "title"   : "Spread Rate",
        "filename": "pics/els_spread_rate.png",
    },
    {
        "matrix"  : output_matrices["spread_direction"],
        "colors"  : "viridis",
        "units"   : "degrees clockwise from North",
        "title"   : "Spread Direction",
        "filename": "pics/els_spread_direction.png",
        "vmin"    : 0,
        "vmax"    : 360,
        "ticks"   : [0,45,90,135,180,225,270,315,360]
    },
    {
        "matrix"  : output_matrices["fireline_intensity"],
        "colors"  : "hot",
        "units"   : "kW/m",
        "title"   : "Fireline Intensity",
        "filename": "pics/els_fireline_intensity.png",
    },
    {
        "matrix"  : output_matrices["flame_length"],
        "colors"  : "hot",
        "units"   : "meters",
        "title"   : "Flame Length",
        "filename": "pics/els_flame_length.png",
    },
]


contour_configs = [
    {
        "matrix"  : output_matrices["time_of_arrival"],
        "title"   : "Time of Arrival",
        "filename": "pics/els_time_of_arrival.png",
        "levels"  : int(start_time) + np.asarray(range(0, int(max_duration) + 1, 60)),
    },
]


for heatmap_config in heatmap_configs:
    save_matrix_as_heatmap(**heatmap_config)


for contour_config in contour_configs:
    save_matrix_as_contours(**contour_config)
#+end_src

#+NAME: fire-behavior-matplotlib-heatmaps
#+caption: Fire behavior attributes after 8 hours of spread
|--------------------------------------+------------------------------------|
| file:pics/els_phi.png                | file:pics/els_fire_type.png        |
| file:pics/els_spread_rate.png        | file:pics/els_spread_direction.png |
| file:pics/els_fireline_intensity.png | file:pics/els_flame_length.png     |
|--------------------------------------+------------------------------------|

#+NAME: time-of-arrival-matplotlib-countours
#+caption: Time of arrival with hourly perimeters
file:pics/els_time_of_arrival.png

*** How to Spread a Fire from a Point Ignition with Spotting Enabled
    :PROPERTIES:
    :CUSTOM_ID: how-to-spread-a-fire-from-a-point-ignition-with-spotting-enabled
    :END:

**** Configure and Run the Fire Spread Simulation with Spotting Enabled
     :PROPERTIES:
     :CUSTOM_ID: configure-and-run-the-fire-spread-simulation-with-spotting-enabled
     :END:

#+NAME: run-spread-fire-with-phi-field-with-spotting
#+begin_src python :results silent
import numpy as np
import pyretechnics.eulerian_level_set as els
from pyretechnics.space_time_cube import SpaceTimeCube
import time

#============================================================================================
# Specify the SpaceTimeCube dimensions
#============================================================================================

cube_shape = (
    240, # bands: 10 days @ 1 hour/band
    100, # rows:  3 km @ 30 meters/row
    100, # cols:  3 km @ 30 meters/col
)

grid_shape = cube_shape[1:]

#============================================================================================
# Specify the SpaceTimeCube resolution
#============================================================================================

cube_resolution = (
    60, # band_duration: minutes
    30, # cell_height:   meters
    30, # cell_width:    meters
)

#============================================================================================
# Create an input dictionary of SpaceTimeCubes (using constant data for this example)
#============================================================================================

space_time_cubes = {
    "slope"                        : SpaceTimeCube(cube_shape, 0.8),   # rise/run
    "aspect"                       : SpaceTimeCube(cube_shape, 225.0), # degrees clockwise from North
    "fuel_model"                   : SpaceTimeCube(cube_shape, 101),   # integer index in fm.fuel_model_table
    "canopy_cover"                 : SpaceTimeCube(cube_shape, 0.6),   # 0-1
    "canopy_height"                : SpaceTimeCube(cube_shape, 30.0),  # m
    "canopy_base_height"           : SpaceTimeCube(cube_shape, 3.0),   # m
    "canopy_bulk_density"          : SpaceTimeCube(cube_shape, 0.3),   # kg/m^3
    "temperature"                  : SpaceTimeCube(cube_shape, 30.0),  # degrees Celsius
    "wind_speed_10m"               : SpaceTimeCube(cube_shape, 30.0),  # km/hr
    "upwind_direction"             : SpaceTimeCube(cube_shape, 180.0), # degrees clockwise from North
    "fuel_moisture_dead_1hr"       : SpaceTimeCube(cube_shape, 0.05),  # kg moisture/kg ovendry weight
    "fuel_moisture_dead_10hr"      : SpaceTimeCube(cube_shape, 0.10),  # kg moisture/kg ovendry weight
    "fuel_moisture_dead_100hr"     : SpaceTimeCube(cube_shape, 0.15),  # kg moisture/kg ovendry weight
    "fuel_moisture_live_herbaceous": SpaceTimeCube(cube_shape, 0.90),  # kg moisture/kg ovendry weight
    "fuel_moisture_live_woody"     : SpaceTimeCube(cube_shape, 0.60),  # kg moisture/kg ovendry weight
    "foliar_moisture"              : SpaceTimeCube(cube_shape, 0.90),  # kg moisture/kg ovendry weight
    "fuel_spread_adjustment"       : SpaceTimeCube(cube_shape, 1.0),   # float >= 0.0 (Optional: defaults to 1.0)
    "weather_spread_adjustment"    : SpaceTimeCube(cube_shape, 1.0),   # float >= 0.0 (Optional: defaults to 1.0)
}

#============================================================================================
# Create an output dictionary of 2D Numpy arrays
#============================================================================================

output_matrices = {
    "phi"               : np.ones(grid_shape, dtype="float32"),       # 2D float array of values in [-1,1]
    "fire_type"         : np.zeros(grid_shape, dtype="uint8"),        # 2D byte array (0-3)
    "spread_rate"       : np.zeros(grid_shape, dtype="float32"),      # 2D float array (m/min)
    "spread_direction"  : np.zeros(grid_shape, dtype="float32"),      # 2D float array (degrees clockwise from North)
    "fireline_intensity": np.zeros(grid_shape, dtype="float32"),      # 2D float array (kW/m)
    "flame_length"      : np.zeros(grid_shape, dtype="float32"),      # 2D float array (m)
    "time_of_arrival"   : np.full(grid_shape, -1.0, dtype="float32"), # 2D float array (min)
    "firebrand_count"   : np.zeros(grid_shape, dtype="int32"),        # 2D integer array (number of firebrands)
}

#============================================================================================
# Set the start time, max duration, and initially ignited cell
#============================================================================================

# Day 2 @ 10:30am
start_time = 2070  # minutes

# 8 hours
max_duration = 480 # minutes

# Burn initially ignited cell into the phi matrix by setting it to -1.0
output_matrices["phi"][50,50] = -1.0

#============================================================================================
# Specify the spotting parameters
#============================================================================================

spot_config = {
    "random_seed"                 : 1234567890,
    "firebrands_per_unit_heat"    : 1e-6,       # firebrands/kJ
    "downwind_distance_mean"      : 10.0,       # meters
    "fireline_intensity_exponent" : 0.3,        # downwind_distance_mean multiplier [I^fireline_intensity_exponent]
    "wind_speed_exponent"         : 0.55,       # downwind_distance_mean multiplier [U^wind_speed_exponent]
    "downwind_variance_mean_ratio": 425.0,      # meters^2 / meter [downwind_variance_mean_ratio = Var(X) / E(X)]
    "crosswind_distance_stdev"    : 100.0,      # meters
    "decay_distance"              : 200.0,      # meters
}

#============================================================================================
# Spread fire from the start time for the max duration
#============================================================================================

runtime_start       = time.perf_counter()
fire_spread_results = els.spread_fire_with_phi_field(space_time_cubes, output_matrices, cube_resolution,
                                                     start_time, max_duration, spot_ignitions={},
                                                     spot_config=spot_config)
runtime_stop        = time.perf_counter()

stop_time        = fire_spread_results["stop_time"]                  # minutes
stop_condition   = fire_spread_results["stop_condition"]             # "max duration reached" or "no burnable cells"
output_matrices  = fire_spread_results["output_matrices"]            # updated 2D arrays (mutated from inputs)
spot_ignitions   = fire_spread_results.get("spot_ignitions", {})     # remaining firebrands on the landscape
random_generator = fire_spread_results.get("random_generator", None) # numpy.random.Generator object

#============================================================================================
# Print out the acres burned, total runtime, and runtime per burned cell
#============================================================================================

num_burned_cells        = np.count_nonzero(output_matrices["fire_type"]) # cells
acres_burned            = num_burned_cells / 4.5                         # acres
simulation_runtime      = runtime_stop - runtime_start                   # seconds
runtime_per_burned_cell = 1000.0 * simulation_runtime / num_burned_cells # ms/cell

print("Acres Burned: " + str(acres_burned))
print("Total Runtime: " + str(simulation_runtime) + " seconds")
print("Runtime per Burned Cell: " + str(runtime_per_burned_cell) + " ms/cell")
#+end_src

**** Display Summary Statistics of the Output Matrices and Spot Ignitions
     :PROPERTIES:
     :CUSTOM_ID: display-summary-statistics-of-the-output-matrices-and-spot-ignitions
     :END:

#+NAME: run-spread-fire-with-phi-field-with-spotting-stats
#+begin_src python
import numpy as np
from pprint import pprint

#============================================================================================
# Display summary statistics of our fire spread results
#============================================================================================

# Used as a filter in get_array_stats below
burned_cells = output_matrices["fire_type"] > 0

def get_array_stats(array, use_burn_scar_mask=True):
    array_values_to_analyze = array[burned_cells] if use_burn_scar_mask else array
    if len(array_values_to_analyze) > 0:
        return {
            "Min"  : np.min(array_values_to_analyze),
            "Max"  : np.max(array_values_to_analyze),
            "Mean" : np.mean(array_values_to_analyze),
            "Stdev": np.std(array_values_to_analyze),
        }
    else:
        return {
            "Min"  : "No Data",
            "Max"  : "No Data",
            "Mean" : "No Data",
            "Stdev": "No Data",
        }

print("Fire Behavior from Day 2 @ 10:30am - Day 2 @ 6:30pm Spreading from Coordinate (50,50)\n" + "=" * 100)

print("Stop Time: " + str(stop_time) + " (minutes)")
print("Stop Condition: " + stop_condition)

print("\nPhi (phi <= 0: burned, phi > 0: unburned")
pprint(get_array_stats(output_matrices["phi"], use_burn_scar_mask=False), sort_dicts=False)

print("\nFire Type (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)")
pprint(get_array_stats(output_matrices["fire_type"]), sort_dicts=False)

print("\nSpread Rate (m/min)")
pprint(get_array_stats(output_matrices["spread_rate"]), sort_dicts=False)

print("\nSpread Direction (degrees clockwise from North)")
pprint(get_array_stats(output_matrices["spread_direction"]), sort_dicts=False)

print("\nFireline Intensity (kW/m)")
pprint(get_array_stats(output_matrices["fireline_intensity"]), sort_dicts=False)

print("\nFlame Length (meters)")
pprint(get_array_stats(output_matrices["flame_length"]), sort_dicts=False)

print("\nTime of Arrival (minutes)")
pprint(get_array_stats(output_matrices["time_of_arrival"]), sort_dicts=False)

firebrand_count_matrix = output_matrices.get("firebrand_count")
if isinstance(firebrand_count_matrix, np.ndarray):
    print("\nFirebrand Count (number of firebrands)")
    pprint(get_array_stats(firebrand_count_matrix, use_burn_scar_mask=False), sort_dicts=False)
    print("\nTotal Firebrands on Grid: " + str(np.sum(firebrand_count_matrix)))

print("\nFuture Spot Ignitions:")
pprint(spot_ignitions)
#+end_src

#+NAME: run-spread-fire-with-phi-field-with-spotting-stats-results
#+RESULTS: run-spread-fire-with-phi-field-with-spotting-stats
#+begin_example
Fire Behavior from Day 2 @ 10:30am - Day 2 @ 6:30pm Spreading from Coordinate (50,50)
====================================================================================================
Stop Time: 2550.0 (minutes)
Stop Condition: max duration reached

Phi (phi <= 0: burned, phi > 0: unburned
{'Min': -0.9967122, 'Max': 1.0, 'Mean': 0.7720047, 'Stdev': 0.5722504}

Fire Type (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)
{'Min': 1, 'Max': 1, 'Mean': 1.0, 'Stdev': 0.0}

Spread Rate (m/min)
{'Min': 0.16055717, 'Max': 2.2964664, 'Mean': 1.3839706, 'Stdev': 0.6849228}

Spread Direction (degrees clockwise from North)
{'Min': 0.015500054, 'Max': 359.82297, 'Mean': 179.89368, 'Stdev': 127.714645}

Fireline Intensity (kW/m)
{'Min': 2.274207, 'Max': 32.52823, 'Mean': 19.60321, 'Stdev': 9.701569}

Flame Length (meters)
{'Min': 0.11305186, 'Max': 0.38439322, 'Mean': 0.29242113, 'Stdev': 0.079029635}

Time of Arrival (minutes)
{'Min': 2081.8516, 'Max': 2549.8735, 'Mean': 2406.4568, 'Stdev': 106.72756}

Firebrand Count (number of firebrands)
{'Min': 0, 'Max': 4, 'Mean': 0.0743, 'Stdev': 0.32307817939316175}

Total Firebrands on Grid: 743

Future Spot Ignitions:
{2551.197586000257: {(78, 75)},
 2551.4126499292092: {(79, 54), (80, 60)},
 2551.856804638606: {(82, 36)},
 2553.2429458344905: {(73, 50)},
 2553.503079371683: {(82, 42)},
 2553.670617042156: {(88, 50)},
 2554.83807664013: {(78, 64)},
 2555.525101157285: {(78, 60), (78, 58)},
 2556.2804247854724: {(80, 74)},
 2556.956798222929: {(79, 80), (78, 75)},
 2557.195619307969: {(72, 52), (75, 51)},
 2560.051319507768: {(82, 76)},
 2560.0546776037436: {(75, 81)},
 2562.2242880384597: {(78, 53)},
 2563.013039281081: {(60, 78)},
 2563.863116389773: {(81, 38)},
 2566.6678273977955: {(82, 40)},
 2567.2125614511942: {(78, 77)},
 2567.3587638733025: {(83, 69)},
 2569.330376022855: {(79, 77)},
 2570.921652617251: {(83, 43), (83, 36)},
 2573.7323031261817: {(92, 51)},
 2574.6585895680705: {(53, 44)},
 2574.794226434831: {(85, 72)},
 2575.851040433648: {(81, 65), (80, 63)},
 2576.9250365965636: {(90, 38)},
 2576.970322423062: {(78, 60), (80, 63)},
 2581.2574393261707: {(73, 78)},
 2583.2559022370483: {(84, 31)},
 2583.5325256200385: {(84, 54)},
 2583.757301741892: {(70, 84)},
 2591.9147157633897: {(66, 34), (71, 40)},
 2592.883811071109: {(64, 36)},
 2603.1103976938066: {(80, 55)},
 2613.4410783216385: {(61, 37)}}
#+end_example

**** Create Images of the Output Matrices with Spotting Enabled
     :PROPERTIES:
     :CUSTOM_ID: create-images-of-the-output-matrices-with-spotting-enabled
     :END:

#+NAME: run-spread-fire-with-phi-field-with-spotting-images
#+begin_src python :results silent
import matplotlib.pyplot as plt
import numpy as np


def save_matrix_as_heatmap(matrix, colors, units, title, filename, vmin=None, vmax=None, ticks=None):
    image    = plt.imshow(matrix, origin="lower", cmap=colors, vmin=vmin, vmax=vmax)
    colorbar = plt.colorbar(image, orientation="vertical", ticks=ticks)
    colorbar.set_label(units)
    plt.title(title)
    plt.savefig(filename)
    plt.close("all")


def save_matrix_as_contours(matrix, title, filename, levels=None):
    fig, ax = plt.subplots()
    cs      = ax.contour(matrix, levels=levels)
    ax.clabel(cs, inline=True, fontsize=10)
    ax.set_aspect('equal', 'box')
    ax.set_title(title)
    plt.savefig(filename)
    plt.close("all")


# See https://matplotlib.org/stable/gallery/color/colormap_reference.html for the available options for "colors"
heatmap_configs = [
    {
        "matrix"  : output_matrices["phi"],
        "colors"  : "plasma",
        "units"   : "phi <= 0: burned, phi > 0: unburned",
        "title"   : "Phi",
        "filename": "pics/els_spot_phi.png",
    },
    {
        "matrix"  : output_matrices["fire_type"],
        "colors"  : "viridis",
        "units"   : "0=unburned, 1=surface, 2=passive_crown, 3=active_crown",
        "title"   : "Fire Type",
        "filename": "pics/els_spot_fire_type.png",
        "vmin"    : 0,
        "vmax"    : 3,
        "ticks"   : [0,1,2,3],
    },
    {
        "matrix"  : output_matrices["spread_rate"],
        "colors"  : "hot",
        "units"   : "m/min",
        "title"   : "Spread Rate",
        "filename": "pics/els_spot_spread_rate.png",
    },
    {
        "matrix"  : output_matrices["spread_direction"],
        "colors"  : "viridis",
        "units"   : "degrees clockwise from North",
        "title"   : "Spread Direction",
        "filename": "pics/els_spot_spread_direction.png",
        "vmin"    : 0,
        "vmax"    : 360,
        "ticks"   : [0,45,90,135,180,225,270,315,360]
    },
    {
        "matrix"  : output_matrices["fireline_intensity"],
        "colors"  : "hot",
        "units"   : "kW/m",
        "title"   : "Fireline Intensity",
        "filename": "pics/els_spot_fireline_intensity.png",
    },
    {
        "matrix"  : output_matrices["flame_length"],
        "colors"  : "hot",
        "units"   : "meters",
        "title"   : "Flame Length",
        "filename": "pics/els_spot_flame_length.png",
    },
]


firebrand_count_matrix = output_matrices.get("firebrand_count")
if isinstance(firebrand_count_matrix, np.ndarray):
    heatmap_configs.append(
        {
            "matrix"  : firebrand_count_matrix,
            "colors"  : "hot",
            "units"   : "number of firebrands",
            "title"   : "Firebrand Count",
            "filename": "pics/els_spot_firebrand_count.png",
        }
    )


contour_configs = [
    {
        "matrix"  : output_matrices["time_of_arrival"],
        "title"   : "Time of Arrival",
        "filename": "pics/els_spot_time_of_arrival.png",
        "levels"  : int(start_time) + np.asarray(range(0, int(max_duration) + 1, 60)),
    },
]


for heatmap_config in heatmap_configs:
    save_matrix_as_heatmap(**heatmap_config)


for contour_config in contour_configs:
    save_matrix_as_contours(**contour_config)
#+end_src

#+NAME: spot-fire-behavior-matplotlib-heatmaps
#+caption: Fire behavior attributes after 8 hours of spread with spotting enabled
|-------------------------------------------+-----------------------------------------|
| file:pics/els_spot_phi.png                | file:pics/els_spot_fire_type.png        |
| file:pics/els_spot_spread_rate.png        | file:pics/els_spot_spread_direction.png |
| file:pics/els_spot_fireline_intensity.png | file:pics/els_spot_flame_length.png     |
|-------------------------------------------+-----------------------------------------|

#+NAME: spot-firebrand-count-matplotlib-heatmap
#+caption: Firebrand count with spotting enabled (NOTE: This is not the same as ember exposure.)
file:pics/els_spot_firebrand_count.png

#+NAME: spot-time-of-arrival-matplotlib-countours
#+caption: Time of arrival with hourly perimeters with spotting enabled
file:pics/els_spot_time_of_arrival.png

*** How to Spread a Fire, Pause, Fork, and Continue
    :PROPERTIES:
    :CUSTOM_ID: how-to-spread-a-fire,-pause,-fork,-and-continue
    :END:

**** Configure and Run the Initial Fire Spread Simulation
     :PROPERTIES:
     :CUSTOM_ID: configure-and-run-the-initial-fire-spread-simulation
     :END:

#+NAME: run-spread-fire-with-phi-field-initial
#+begin_src python :results silent
import numpy as np
import pyretechnics.eulerian_level_set as els
from pyretechnics.space_time_cube import SpaceTimeCube
import time

#============================================================================================
# Specify the SpaceTimeCube dimensions
#============================================================================================

cube_shape = (
    240, # bands: 10 days @ 1 hour/band
    100, # rows:  3 km @ 30 meters/row
    100, # cols:  3 km @ 30 meters/col
)

grid_shape = cube_shape[1:]

#============================================================================================
# Specify the SpaceTimeCube resolution
#============================================================================================

cube_resolution = (
    60, # band_duration: minutes
    30, # cell_height:   meters
    30, # cell_width:    meters
)

#============================================================================================
# Create an input dictionary of SpaceTimeCubes (using constant data for this example)
#============================================================================================

space_time_cubes = {
    "slope"                        : SpaceTimeCube(cube_shape, 0.8),   # rise/run
    "aspect"                       : SpaceTimeCube(cube_shape, 225.0), # degrees clockwise from North
    "fuel_model"                   : SpaceTimeCube(cube_shape, 101),   # integer index in fm.fuel_model_table
    "canopy_cover"                 : SpaceTimeCube(cube_shape, 0.6),   # 0-1
    "canopy_height"                : SpaceTimeCube(cube_shape, 30.0),  # m
    "canopy_base_height"           : SpaceTimeCube(cube_shape, 3.0),   # m
    "canopy_bulk_density"          : SpaceTimeCube(cube_shape, 0.3),   # kg/m^3
    "wind_speed_10m"               : SpaceTimeCube(cube_shape, 30.0),  # km/hr
    "upwind_direction"             : SpaceTimeCube(cube_shape, 180.0), # degrees clockwise from North
    "fuel_moisture_dead_1hr"       : SpaceTimeCube(cube_shape, 0.05),  # kg moisture/kg ovendry weight
    "fuel_moisture_dead_10hr"      : SpaceTimeCube(cube_shape, 0.10),  # kg moisture/kg ovendry weight
    "fuel_moisture_dead_100hr"     : SpaceTimeCube(cube_shape, 0.15),  # kg moisture/kg ovendry weight
    "fuel_moisture_live_herbaceous": SpaceTimeCube(cube_shape, 0.90),  # kg moisture/kg ovendry weight
    "fuel_moisture_live_woody"     : SpaceTimeCube(cube_shape, 0.60),  # kg moisture/kg ovendry weight
    "foliar_moisture"              : SpaceTimeCube(cube_shape, 0.90),  # kg moisture/kg ovendry weight
    "fuel_spread_adjustment"       : SpaceTimeCube(cube_shape, 1.0),   # float >= 0.0 (Optional: defaults to 1.0)
    "weather_spread_adjustment"    : SpaceTimeCube(cube_shape, 1.0),   # float >= 0.0 (Optional: defaults to 1.0)
}

#============================================================================================
# Create an output dictionary of 2D Numpy arrays
#============================================================================================

output_matrices = {
    "phi"               : np.ones(grid_shape, dtype="float32"),       # 2D float array of values in [-1,1]
    "fire_type"         : np.zeros(grid_shape, dtype="uint8"),        # 2D byte array (0-3)
    "spread_rate"       : np.zeros(grid_shape, dtype="float32"),      # 2D float array (m/min)
    "spread_direction"  : np.zeros(grid_shape, dtype="float32"),      # 2D float array (degrees clockwise from North)
    "fireline_intensity": np.zeros(grid_shape, dtype="float32"),      # 2D float array (kW/m)
    "flame_length"      : np.zeros(grid_shape, dtype="float32"),      # 2D float array (m)
    "time_of_arrival"   : np.full(grid_shape, -1.0, dtype="float32"), # 2D float array (min)
}

#============================================================================================
# Set the start time, max duration, and initially ignited cell
#============================================================================================

# Day 2 @ 10:30am
start_time = 2070  # minutes

# 8 hours
max_duration = 480 # minutes

# Burn initially ignited cell into the phi matrix by setting it to -1.0
output_matrices["phi"][50,50] = -1.0

#============================================================================================
# Spread fire from the start time for the max duration
#============================================================================================

runtime_start         = time.perf_counter()
fire_spread_results_8 = els.spread_fire_with_phi_field(space_time_cubes, output_matrices, cube_resolution,
                                                       start_time, max_duration)
runtime_stop          = time.perf_counter()

stop_time       = fire_spread_results_8["stop_time"]       # minutes
stop_condition  = fire_spread_results_8["stop_condition"]  # "max duration reached" or "no burnable cells"
output_matrices = fire_spread_results_8["output_matrices"] # updated 2D arrays (mutated from inputs)

#============================================================================================
# Print out the acres burned, total runtime, and runtime per burned cell
#============================================================================================

num_burned_cells        = np.count_nonzero(output_matrices["fire_type"]) # cells
acres_burned            = num_burned_cells / 4.5                         # acres
simulation_runtime      = runtime_stop - runtime_start                   # seconds
runtime_per_burned_cell = 1000.0 * simulation_runtime / num_burned_cells # ms/cell

print("Acres Burned: " + str(acres_burned))
print("Total Runtime: " + str(simulation_runtime) + " seconds")
print("Runtime per Burned Cell: " + str(runtime_per_burned_cell) + " ms/cell")
#+end_src

**** Fork and Run Two Fire Spread Scenarios
     :PROPERTIES:
     :CUSTOM_ID: fork-and-run-two-fire-spread-scenarios
     :END:

#+NAME: run-spread-fire-with-phi-field-forked
#+begin_src python :results silent
#============================================================================================
# Fork the simulation by creating a copy of the space_time_cubes and output_matrices
#============================================================================================

def copy_matrices(matrix_dict):
    return {k: np.copy(matrix_dict[k]) for k in matrix_dict}

space_time_cubes_fork = space_time_cubes.copy()

output_matrices_fork = copy_matrices(output_matrices)

#============================================================================================
# Add a non-burnable fire-break to the forked space_time_cubes fuel model
#============================================================================================

# Extract 2D array of fuel_model values at the cube's spatial dimensions (100 x 100)
fuel_model_grid_ro = space_time_cubes["fuel_model"].getSpatialPlane(0, None, None) # read-only
fuel_model_grid    = np.copy(fuel_model_grid_ro)                                   # writable

# Add a non-burnable fire-break in the northeastern corner of the grid
(ys, xs) = np.diag_indices(40)
fuel_model_grid[60:,60:][(list(reversed(ys)), xs)] = 91 # NB1

# Replace the old fuel_model cube with a new fire-break-containing cube
space_time_cubes_fork["fuel_model"] = SpaceTimeCube(cube_shape, fuel_model_grid)

#============================================================================================
# Run both simulations for another 4 hours
#============================================================================================

# Day 2 @ 6:30pm
new_start_time = stop_time # minutes

# 4 hours
new_max_duration = 240     # minutes

# Spread the main simulation
runtime_start_main     = time.perf_counter()
fire_spread_results_12 = els.spread_fire_with_phi_field(space_time_cubes, output_matrices,
                                                        cube_resolution, new_start_time, new_max_duration)
runtime_stop_main      = time.perf_counter()

stop_time       = fire_spread_results_12["stop_time"]       # minutes
stop_condition  = fire_spread_results_12["stop_condition"]  # "max duration reached" or "no burnable cells"
output_matrices = fire_spread_results_12["output_matrices"] # updated 2D arrays (mutated from inputs)

# Spread the forked simulation
runtime_start_fork          = time.perf_counter()
fire_spread_results_12_fork = els.spread_fire_with_phi_field(space_time_cubes_fork, output_matrices_fork,
                                                             cube_resolution, new_start_time, new_max_duration)
runtime_stop_fork           = time.perf_counter()

stop_time_fork       = fire_spread_results_12_fork["stop_time"]       # minutes
stop_condition_fork  = fire_spread_results_12_fork["stop_condition"]  # "max duration reached" or "no burnable cells"
output_matrices_fork = fire_spread_results_12_fork["output_matrices"] # updated 2D arrays (mutated from inputs)

#============================================================================================
# Print out the acres burned, total runtime, and runtime per burned cell for the main run
#============================================================================================

num_burned_cells         = np.count_nonzero(output_matrices["fire_type"])       # cells
acres_burned             = num_burned_cells / 4.5                               # acres
simulation_runtime_main  = runtime_stop_main - runtime_start_main               # seconds
simulation_runtime_total = simulation_runtime + simulation_runtime_main         # seconds
runtime_per_burned_cell  = 1000.0 * simulation_runtime_total / num_burned_cells # ms/cell

print("Main Fire\n" + "=" * 60)
print("Acres Burned: " + str(acres_burned))
print("Total Runtime: " + str(simulation_runtime_total) + " seconds")
print("Runtime per Burned Cell: " + str(runtime_per_burned_cell) + " ms/cell")

#============================================================================================
# Print out the acres burned, total runtime, and runtime per burned cell for the forked run
#============================================================================================

num_burned_cells         = np.count_nonzero(output_matrices_fork["fire_type"])  # cells
acres_burned             = num_burned_cells / 4.5                               # acres
simulation_runtime_fork  = runtime_stop_fork - runtime_start_fork               # seconds
simulation_runtime_total = simulation_runtime + simulation_runtime_fork         # seconds
runtime_per_burned_cell  = 1000.0 * simulation_runtime_total / num_burned_cells # ms/cell

print("\nForked Fire\n" + "=" * 60)
print("Acres Burned: " + str(acres_burned))
print("Total Runtime: " + str(simulation_runtime_total) + " seconds")
print("Runtime per Burned Cell: " + str(runtime_per_burned_cell) + " ms/cell")
#+end_src

**** Display Summary Statistics of the Two Scenarios' Outputs
     :PROPERTIES:
     :CUSTOM_ID: display-summary-statistics-of-the-two-scenarios'-outputs
     :END:

#+NAME: run-spread-fire-with-phi-field-stats-forked
#+begin_src python
import numpy as np
from pprint import pprint

#============================================================================================
# Display summary statistics of our fire spread results
#============================================================================================

# Used as filters in get_array_stats and get_array_stats_fork below
burned_cells      = output_matrices["fire_type"] > 0
burned_cells_fork = output_matrices_fork["fire_type"] > 0

def get_array_stats(array, use_burn_scar_mask=True):
    array_values_to_analyze = array[burned_cells] if use_burn_scar_mask else array
    if len(array_values_to_analyze) > 0:
        return {
            "Min"  : np.min(array_values_to_analyze),
            "Max"  : np.max(array_values_to_analyze),
            "Mean" : np.mean(array_values_to_analyze),
            "Stdev": np.std(array_values_to_analyze),
        }
    else:
        return {
            "Min"  : "No Data",
            "Max"  : "No Data",
            "Mean" : "No Data",
            "Stdev": "No Data",
        }

def get_array_stats_fork(array, use_burn_scar_mask=True):
    array_values_to_analyze = array[burned_cells_fork] if use_burn_scar_mask else array
    if len(array_values_to_analyze) > 0:
        return {
            "Min"  : np.min(array_values_to_analyze),
            "Max"  : np.max(array_values_to_analyze),
            "Mean" : np.mean(array_values_to_analyze),
            "Stdev": np.std(array_values_to_analyze),
        }
    else:
        return {
            "Min"  : "No Data",
            "Max"  : "No Data",
            "Mean" : "No Data",
            "Stdev": "No Data",
        }

print("Fire Behavior from Day 2 @ 10:30am - Day 2 @ 10:30pm Spreading from Coordinate (50,50)\n" + "=" * 100)

print("Stop Time (Main): " + str(stop_time) + " (minutes)")
print("Stop Time (Fork): " + str(stop_time_fork) + " (minutes)")
print("Stop Condition (Main): " + stop_condition)
print("Stop Condition (Fork): " + stop_condition_fork)

print("\nPhi (phi <= 0: burned, phi > 0: unburned")
print("Main: ", end="")
pprint(get_array_stats(output_matrices["phi"], use_burn_scar_mask=False), sort_dicts=False)
print("Fork: ", end="")
pprint(get_array_stats_fork(output_matrices_fork["phi"], use_burn_scar_mask=False), sort_dicts=False)

print("\nFire Type (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)")
print("Main: ", end="")
pprint(get_array_stats(output_matrices["fire_type"]), sort_dicts=False)
print("Fork: ", end="")
pprint(get_array_stats_fork(output_matrices_fork["fire_type"]), sort_dicts=False)

print("\nSpread Rate (m/min)")
print("Main: ", end="")
pprint(get_array_stats(output_matrices["spread_rate"]), sort_dicts=False)
print("Fork: ", end="")
pprint(get_array_stats_fork(output_matrices_fork["spread_rate"]), sort_dicts=False)

print("\nSpread Direction (degrees clockwise from North)")
print("Main: ", end="")
pprint(get_array_stats(output_matrices["spread_direction"]), sort_dicts=False)
print("Fork: ", end="")
pprint(get_array_stats_fork(output_matrices_fork["spread_direction"]), sort_dicts=False)

print("\nFireline Intensity (kW/m)")
print("Main: ", end="")
pprint(get_array_stats(output_matrices["fireline_intensity"]), sort_dicts=False)
print("Fork: ", end="")
pprint(get_array_stats_fork(output_matrices_fork["fireline_intensity"]), sort_dicts=False)

print("\nFlame Length (meters)")
print("Main: ", end="")
pprint(get_array_stats(output_matrices["flame_length"]), sort_dicts=False)
print("Fork: ", end="")
pprint(get_array_stats_fork(output_matrices_fork["flame_length"]), sort_dicts=False)

print("\nTime of Arrival (minutes)")
print("Main: ", end="")
pprint(get_array_stats(output_matrices["time_of_arrival"]), sort_dicts=False)
print("Fork: ", end="")
pprint(get_array_stats_fork(output_matrices_fork["time_of_arrival"]), sort_dicts=False)
#+end_src

#+NAME: run-spread-fire-with-phi-field-stats-forked-results
#+RESULTS: run-spread-fire-with-phi-field-stats-forked
#+begin_example
Fire Behavior from Day 2 @ 10:30am - Day 2 @ 10:30pm Spreading from Coordinate (50,50)
====================================================================================================
Stop Time (Main): 2790.0 (minutes)
Stop Time (Fork): 2790.0 (minutes)
Stop Condition (Main): max duration reached
Stop Condition (Fork): max duration reached

Phi (phi <= 0: burned, phi > 0: unburned
Main: {'Min': -0.92524624, 'Max': 1.0, 'Mean': 0.7945679, 'Stdev': 0.5639848}
Fork: {'Min': -0.92524624, 'Max': 1.0, 'Mean': 0.7984585, 'Stdev': 0.56110543}

Fire Type (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)
Main: {'Min': 1, 'Max': 1, 'Mean': 1.0, 'Stdev': 0.0}
Fork: {'Min': 1, 'Max': 1, 'Mean': 1.0, 'Stdev': 0.0}

Spread Rate (m/min)
Main: {'Min': 0.16077116, 'Max': 2.2964668, 'Mean': 1.2057376, 'Stdev': 0.6379757}
Fork: {'Min': 0.16077116, 'Max': 2.2964668, 'Mean': 1.1890496, 'Stdev': 0.63051146}

Spread Direction (degrees clockwise from North)
Main: {'Min': 0.27235666, 'Max': 359.69885, 'Mean': 190.26033, 'Stdev': 117.35212}
Fork: {'Min': 0.27235666, 'Max': 359.69885, 'Mean': 192.25833, 'Stdev': 116.70386}

Fireline Intensity (kW/m)
Main: {'Min': 2.2772384, 'Max': 32.528233, 'Mean': 17.078634, 'Stdev': 9.036588}
Fork: {'Min': 2.2772384, 'Max': 32.528233, 'Mean': 16.842258, 'Stdev': 8.9308605}

Flame Length (meters)
Main: {'Min': 0.11312115, 'Max': 0.38439324, 'Mean': 0.27460182, 'Stdev': 0.073415086}
Fork: {'Min': 0.11312115, 'Max': 0.38439324, 'Mean': 0.27287114, 'Stdev': 0.07285743}

Time of Arrival (minutes)
Main: {'Min': 2081.8516, 'Max': 2789.743, 'Mean': 2543.6892, 'Stdev': 173.15518}
Fork: {'Min': 2081.8516, 'Max': 2789.743, 'Mean': 2539.6372, 'Stdev': 171.93945}
#+end_example

**** Create Images of the Two Scenarios' Outputs
     :PROPERTIES:
     :CUSTOM_ID: create-images-of-the-two-scenarios'-outputs
     :END:

#+NAME: run-spread-fire-with-phi-field-images-forked
#+begin_src python :results silent
import matplotlib.pyplot as plt
import numpy as np


def save_matrix_as_heatmap(matrix, colors, units, title, filename, vmin=None, vmax=None, ticks=None):
    image    = plt.imshow(matrix, origin="lower", cmap=colors, vmin=vmin, vmax=vmax)
    colorbar = plt.colorbar(image, orientation="vertical", ticks=ticks)
    colorbar.set_label(units)
    plt.title(title)
    plt.savefig(filename)
    plt.close("all")


def save_matrix_as_contours(matrix, title, filename, levels=None):
    fig, ax = plt.subplots()
    cs      = ax.contour(matrix, levels=levels)
    ax.clabel(cs, inline=True, fontsize=10)
    ax.set_aspect('equal', 'box')
    ax.set_title(title)
    plt.savefig(filename)
    plt.close("all")


# See https://matplotlib.org/stable/gallery/color/colormap_reference.html for the available options for "colors"
heatmap_configs = [
    {
        "matrix"  : space_time_cubes["fuel_model"].getSpatialPlane(0, None, None),
        "colors"  : "viridis_r",
        "units"   : "fuel model number: 91-204",
        "title"   : "Fuel Model",
        "filename": "pics/els_fuel_model_main.png",
        "vmin"    : 91,
        "vmax"    : 204,
    },
    {
        "matrix"  : space_time_cubes_fork["fuel_model"].getSpatialPlane(0, None, None),
        "colors"  : "viridis_r",
        "units"   : "fuel model number: 91-204",
        "title"   : "Fuel Model",
        "filename": "pics/els_fuel_model_fork.png",
        "vmin"    : 91,
        "vmax"    : 204,
    },
    {
        "matrix"  : output_matrices["phi"],
        "colors"  : "plasma",
        "units"   : "phi <= 0: burned, phi > 0: unburned",
        "title"   : "Phi",
        "filename": "pics/els_phi_main.png",
    },
    {
        "matrix"  : output_matrices_fork["phi"],
        "colors"  : "plasma",
        "units"   : "phi <= 0: burned, phi > 0: unburned",
        "title"   : "Phi",
        "filename": "pics/els_phi_fork.png",
    },
    {
        "matrix"  : output_matrices["fire_type"],
        "colors"  : "viridis",
        "units"   : "0=unburned, 1=surface, 2=passive_crown, 3=active_crown",
        "title"   : "Fire Type",
        "filename": "pics/els_fire_type_main.png",
        "vmin"    : 0,
        "vmax"    : 3,
        "ticks"   : [0,1,2,3],
    },
    {
        "matrix"  : output_matrices_fork["fire_type"],
        "colors"  : "viridis",
        "units"   : "0=unburned, 1=surface, 2=passive_crown, 3=active_crown",
        "title"   : "Fire Type",
        "filename": "pics/els_fire_type_fork.png",
        "vmin"    : 0,
        "vmax"    : 3,
        "ticks"   : [0,1,2,3],
    },
    {
        "matrix"  : output_matrices["spread_rate"],
        "colors"  : "hot",
        "units"   : "m/min",
        "title"   : "Spread Rate",
        "filename": "pics/els_spread_rate_main.png",
    },
    {
        "matrix"  : output_matrices_fork["spread_rate"],
        "colors"  : "hot",
        "units"   : "m/min",
        "title"   : "Spread Rate",
        "filename": "pics/els_spread_rate_fork.png",
    },
    {
        "matrix"  : output_matrices["spread_direction"],
        "colors"  : "viridis",
        "units"   : "degrees clockwise from North",
        "title"   : "Spread Direction",
        "filename": "pics/els_spread_direction_main.png",
        "vmin"    : 0,
        "vmax"    : 360,
        "ticks"   : [0,45,90,135,180,225,270,315,360]
    },
    {
        "matrix"  : output_matrices_fork["spread_direction"],
        "colors"  : "viridis",
        "units"   : "degrees clockwise from North",
        "title"   : "Spread Direction",
        "filename": "pics/els_spread_direction_fork.png",
        "vmin"    : 0,
        "vmax"    : 360,
        "ticks"   : [0,45,90,135,180,225,270,315,360]
    },
    {
        "matrix"  : output_matrices["fireline_intensity"],
        "colors"  : "hot",
        "units"   : "kW/m",
        "title"   : "Fireline Intensity",
        "filename": "pics/els_fireline_intensity_main.png",
    },
    {
        "matrix"  : output_matrices_fork["fireline_intensity"],
        "colors"  : "hot",
        "units"   : "kW/m",
        "title"   : "Fireline Intensity",
        "filename": "pics/els_fireline_intensity_fork.png",
    },
    {
        "matrix"  : output_matrices["flame_length"],
        "colors"  : "hot",
        "units"   : "meters",
        "title"   : "Flame Length",
        "filename": "pics/els_flame_length_main.png",
    },
    {
        "matrix"  : output_matrices_fork["flame_length"],
        "colors"  : "hot",
        "units"   : "meters",
        "title"   : "Flame Length",
        "filename": "pics/els_flame_length_fork.png",
    },
]


contour_configs = [
    {
        "matrix"  : output_matrices["time_of_arrival"],
        "title"   : "Time of Arrival",
        "filename": "pics/els_time_of_arrival_main.png",
        "levels"  : int(start_time) + np.asarray(range(0, int(max_duration) + 1, 60)),
    },
    {
        "matrix"  : output_matrices_fork["time_of_arrival"],
        "title"   : "Time of Arrival",
        "filename": "pics/els_time_of_arrival_fork.png",
        "levels"  : int(start_time) + np.asarray(range(0, int(max_duration) + 1, 60)),
    },
]


for heatmap_config in heatmap_configs:
    save_matrix_as_heatmap(**heatmap_config)


for contour_config in contour_configs:
    save_matrix_as_contours(**contour_config)
#+end_src

#+NAME: fuel-model-matplotlib-heatmaps-forked
#+caption: Fuel model [Left: Main, Right: Fork]
|-----------------------------------+-----------------------------------|
| file:pics/els_fuel_model_main.png | file:pics/els_fuel_model_fork.png |
|-----------------------------------+-----------------------------------|

#+NAME: fire-behavior-matplotlib-heatmaps-forked
#+caption: Fire behavior attributes after 12 hours of spread [Left: Main, Right: Fork]
|-------------------------------------------+-------------------------------------------|
| file:pics/els_phi_main.png                | file:pics/els_phi_fork.png                |
| file:pics/els_fire_type_main.png          | file:pics/els_fire_type_fork.png          |
| file:pics/els_spread_rate_main.png        | file:pics/els_spread_rate_fork.png        |
| file:pics/els_spread_direction_main.png   | file:pics/els_spread_direction_fork.png   |
| file:pics/els_fireline_intensity_main.png | file:pics/els_fireline_intensity_fork.png |
| file:pics/els_flame_length_main.png       | file:pics/els_flame_length_fork.png       |
|-------------------------------------------+-------------------------------------------|

#+NAME: time-of-arrival-matplotlib-countours-forked
#+caption: Time of arrival with hourly perimeters [Left: Main, Right: Fork]
|----------------------------------------+----------------------------------------|
| file:pics/els_time_of_arrival_main.png | file:pics/els_time_of_arrival_fork.png |
|----------------------------------------+----------------------------------------|

* [WIP] Fire Suppression Algorithms (pyretechnics.suppression) :noexport:
  :PROPERTIES:
  :CUSTOM_ID: [wip]-fire-suppression-algorithms-(pyretechnics.suppression)
  :END:
** For Developers
   :PROPERTIES:
   :CUSTOM_ID: for-developers-suppression
   :header-args:python+: :session *pyretechnics.suppression*
   :header-args:python+: :tangle  ../src/pyretechnics/suppression.py
   :header-args:python+: :exports code
   :END:

** For Users
   :PROPERTIES:
   :CUSTOM_ID: for-users-suppression
   :header-args:python+: :session *examples:pyretechnics.suppression*
   :header-args:python+: :results output replace
   :header-args:python+: :exports both
   :END:

* [WIP] Urban Spread Algorithms :noexport:
  :PROPERTIES:
  :CUSTOM_ID: [wip]-urban-spread-algorithms
  :END:
** For Developers
   :PROPERTIES:
   :CUSTOM_ID: for-developers-urban-spread
   :header-args:python+: :session *pyretechnics.urban_spread*
   :header-args:python+: :tangle  ../src/pyretechnics/urban_spread.py
   :header-args:python+: :exports code
   :END:

** For Users
   :PROPERTIES:
   :CUSTOM_ID: for-users-urban-spread
   :header-args:python+: :session *examples:pyretechnics.urban_spread*
   :header-args:python+: :results output replace
   :header-args:python+: :exports both
   :END:

* [WIP] Fire Spread API :noexport:
  :PROPERTIES:
  :CUSTOM_ID: [wip]-fire-spread-api
  :END:

Pyretechnics provides two main functions for simulating fire behavior over a region of space-time:

** grow_fire
   :PROPERTIES:
   :CUSTOM_ID: grow-fire
   :END:

Simulates the growth of a fire over space and time starting from one
or more actively burning cells. Suppression effects may be optionally
applied, and several different stop conditions may be specified. A
random seed may be optionally provided to ensure deterministically
reproducible runs, despite the presence of stochastic calculations
within the fire spread algorithm.

*** Inputs
    :PROPERTIES:
    :CUSTOM_ID: inputs
    :END:

The ~grow_fire~ function takes a single =world_state= dictionary as input with these fields:

- simulation_clock :: a float specifying the number of minutes from the start time of the simulated space-time cube to begin the simulation

- config_dict :: a dictionary of parameter names to their values with the following types:

  *TODO*: Determine whether rectangular cells will work for the GridFire and ELMFIRE spread algorithms. If not, eliminate this degree of freedom from the API.
  *TODO*: Add interpolation options to the gridded data source class
  *TODO*: simulation_north_angle may be dropped if we require inputs to use North-up projections for both fuels and weather

  |---------------------------+-----------------------------+-------------------------------------------------------------------------------------------+-----------+---------|
  | Parameter Name            | Type                        | Units                                                                                     | Optional? | Default |
  |---------------------------+-----------------------------+-------------------------------------------------------------------------------------------+-----------+---------|
  | simulation_shape          | Tuple (int, int, int)       | (num timesteps, num rows, num cols)                                                       |           |         |
  | simulation_resolution     | Tuple (float, float, float) | (minutes per timestep, meters per row, meters per column)                                 |           |         |
  | simulation_north_angle    | float                       | degrees clockwise from the top of the circle [0,360)                                      | Yes       | 0.0     |
  | simulation_stop_condition | Dictionary {string: float}  | either {'max_burn_duration': minutes} or {'max_burned_area': square_meters}               | Yes       | None    |
  | random_seed               | integer or Generator        | the seed value to initialize the random number generator                                  | Yes       | None    |
  | overwrite_outputs         | boolean                     | True or False, whether to mutate or copy the Numpy arrays provided in *output_layer_dict* | Yes       | False   |
  | alpha_suppression         | Dictionary {string: float}  | parameters for the *alpha* suppression algorithm (see table below)                        | Yes       | None    |
  | sdi_suppression           | Dictionary {string: float}  | parameters for the *sdi* suppression algorithm (see table below)                          | Yes       | None    |
  | spotting                  | Dictionary {string: float}  | parameters for the spotting algorithm (see table below)                                   | Yes       | None    |
  |---------------------------+-----------------------------+-------------------------------------------------------------------------------------------+-----------+---------|

  - alpha_suppression :: a dictionary of parameter names to their values for the *alpha* suppression algorithm:

  |-------------------------+-------+------------------------------------|
  | Parameter Name          | Type  | Units                              |
  |-------------------------+-------+------------------------------------|
  | suppression_timestep    | float | minutes between suppression events |
  | suppression_coefficient | float | unitless                           |
  |-------------------------+-------+------------------------------------|

  - sdi_suppression :: a dictionary of parameter names to their values for the *sdi* suppression algorithm:

  |-----------------------------------------------+-------+------------------------------------|
  | Parameter Name                                | Type  | Units                              |
  |-----------------------------------------------+-------+------------------------------------|
  | suppression_timestep                          | float | minutes between suppression events |
  | sdi_sensitivity_to_difficulty                 | float | unitless                           |
  | sdi_containment_overwhelming_area_growth_rate | float | hectares/day                       |
  | sdi_reference_suppression_speed               | float | percent/day                        |
  |-----------------------------------------------+-------+------------------------------------|

  - spotting :: a dictionary of parameter names to their values for the spotting algorithm:

  |--------------------------------+---------+------------------------+------------|
  | Parameter Name                 | Type    | Units                  | Fire Model |
  |--------------------------------+---------+------------------------+------------|
  | firebrands_per_unit_heat       | float   | firebrands/kJ          | Yiren Qin  |
  | downwind_distance_mean         | float   | meters                 | GridFire   |
  | fireline_intensity_exponent    | float   | unitless               | GridFire   |
  | wind_speed_exponent            | float   | unitless               | GridFire   |
  | downwind_variance_mean_ratio   | float   | meters^2 / meters      | GridFire   |
  | crosswind_distance_stdev       | float   | meters                 | GridFire   |
  | decay_distance                 | float   | meters                 | GridFire   |
  |--------------------------------+---------+------------------------+------------|
  | ember_gr                       | int     | TODO: find units range | ELMFIRE    |
  | pign                           | float   | percent [0-100]        | ELMFIRE    |
  | pign_max                       | float   | percent [0-100]        | ELMFIRE    |
  | pign_min                       | float   | percent [0-100]        | ELMFIRE    |
  | tau_embergen                   | float   | TODO: find units range | ELMFIRE    |
  | use_umd_spotting_model         | boolean | True or False          | ELMFIRE    |
  | p_eps                          | float   | TODO: find units range | ELMFIRE    |
  | use_physical_spotting_duration | boolean | True or False          | ELMFIRE    |
  | use_physical_ember_number      | boolean | True or False          | ELMFIRE    |
  | ember_sampling_factor          | float   | TODO: find units range | ELMFIRE    |
  | use_superseded_spotting        | boolean | True or False          | ELMFIRE    |
  |--------------------------------+---------+------------------------+------------|

- input_layer_dict :: a dictionary of layer names to either 2-arity (2D) or 3-arity (3D) functions for accessing the numeric values at each =(y,x)= or =(z,y,x)= coordinate in the simulated space-time cube:

  |--------------------------------------------+---------+--------------------------------------------------------+-----------+-------|
  | Layer Name                                 | Type    | Units                                                  | Optional? | Arity |
  |--------------------------------------------+---------+--------------------------------------------------------+-----------+-------|
  | elevation                                  | float32 | meters above sea level [0-8850]                        |           |     2 |
  | slope                                      | float32 | meters rise / meters run [0-4]                         |           |     2 |
  | aspect                                     | int16   | degrees clockwise from North [0-360)                   |           |     2 |
  | fuel_model                                 | int16   | integer classes [1-204]                                |           |     2 |
  | canopy_cover                               | float32 | canopy area / total area [0-0.95]                      |           |     2 |
  | canopy_height                              | float32 | meters  [0-51]                                         |           |     2 |
  | canopy_base_height                         | float32 | meters  [0-10]                                         |           |     2 |
  | canopy_bulk_density                        | float32 | kilograms/meters^3 [0-0.45]                            |           |     2 |
  | fuel_spread_adjustment                     | float   | real number >= 0.0 (1.0 means no adjustment)           | Yes       |     2 |
  | suppression_difficulty_index               | float   | integer >= 0  (TODO: What is the correct value range?) | Yes       |     2 |
  | surface_spotting_fireline_intensity        | float   | kilowatts/meter                                        | Yes       |     2 |
  | surface_spotting_percent (TODO: min, max?) | float   | percent [0-1]                                          | Yes       |     2 |
  | crown_spotting_percent   (TODO: min, max?) | float   | percent [0-1]                                          | Yes       |     2 |
  | temperature                                | float   | degrees Celsius                                        | Yes       |     3 |
  | relative_humidity                          | float   | percent [0-1+]                                         | Yes       |     3 |
  | wind_speed_10m                             | float   | km/hr                                                  |           |     3 |
  | upwind_direction                           | int16   | degrees clockwise from North [0-360)                   |           |     3 |
  | fuel_moisture_dead_1hr                     | float   | ratio [0-1+] grams moisture/grams ovendry weight       |           |     3 |
  | fuel_moisture_dead_10hr                    | float   | ratio [0-1+] grams moisture/grams ovendry weight       |           |     3 |
  | fuel_moisture_dead_100hr                   | float   | ratio [0-1+] grams moisture/grams ovendry weight       |           |     3 |
  | fuel_moisture_live_herbaceous              | float   | ratio [0-1+] grams moisture/grams ovendry weight       |           |     3 |
  | fuel_moisture_live_woody                   | float   | ratio [0-1+] grams moisture/grams ovendry weight       |           |     3 |
  | foliar_moisture                            | float   | ratio [0-1+] grams moisture/grams ovendry weight       |           |     3 |
  | weather_spread_adjustment                  | float   | real number >= 0.0 (1.0 means no adjustment)           | Yes       |     3 |
  |--------------------------------------------+---------+--------------------------------------------------------+-----------+-------|

- output_layer_dict :: an *optional* dictionary of layer names to 2D Numpy arrays with the following units to pre-populate the simulation output arrays:
  *TODO* Consider whether some of these layers should be kept as internal state and not returned to the user.

  |--------------------------------+---------+----------------------------------------------------------------+-----------|
  | Parameter Name                 | Type    | Units                                                          | Optional? |
  |--------------------------------+---------+----------------------------------------------------------------+-----------|
  | eulerian_level_set_phi_field   | float16 | TODO: find units range                                         | No        |
  | time_of_arrival                | float32 | minutes from the start time of the simulated space-time cube   | Yes       |
  | max_surface_spread_direction   | float16 | degrees clockwise from North                                   | Yes       |
  | max_crown_spread_direction     | float16 | degrees clockwise from North                                   | Yes       |
  | perimeter_spread_direction     | float16 | degrees clockwise from North                                   | Yes       |
  | max_surface_spread_rate        | float16 | meters/second                                                  | Yes       |
  | max_crown_spread_rate          | float16 | meters/second                                                  | Yes       |
  | perimeter_spread_rate          | float16 | meters/second                                                  | Yes       |
  | surface_eccentricity           | float16 | dimensionless (0: circular fire, >0: elliptical fire)          | Yes       |
  | crown_eccentricity             | float16 | dimensionless (0: circular fire, >0: elliptical fire)          | Yes       |
  | max_surface_fireline_intensity | float32 | kilowatts/meter                                                | Yes       |
  | max_crown_fireline_intensity   | float32 | kilowatts/meter                                                | Yes       |
  | perimeter_fireline_intensity   | float32 | kilowatts/meter                                                | Yes       |
  | max_surface_flame_length       | float16 | meters                                                         | Yes       |
  | max_crown_flame_length         | float16 | meters                                                         | Yes       |
  | perimeter_flame_length         | float16 | meters                                                         | Yes       |
  | fire_type                      | uint8   | 0 = unburned, 1 = surface, 2 = passive_crown, 3 = active_crown | Yes       |
  | firebrand_count                | uint32  | number of firebrands landing in each cell                      | Yes       |
  | firebrand_ignition             | bool8   | True for cells ignited by firebrands, False otherwise          | Yes       |
  |--------------------------------+---------+----------------------------------------------------------------+-----------|

- ignited_cells_set :: set of cells that are actively burning at the simulation start time, specified as 3D coordinates =(z,y,x)= in the simulated space-time cube

*** Outputs
    :PROPERTIES:
    :CUSTOM_ID: outputs
    :END:

The ~grow_fire~ function will return a dictionary with these fields:

- simulation_clock :: a float specifying the number of minutes from the start time of the simulated space-time cube at which the simulation stopped

- simulation_stop_condition_encountered :: max_burn_duration | max_burned_area | no_burnable_fuel | end_of_temporal_data | fully_suppressed

- config_dict :: a dictionary of parameter names to their values as defined in section [[Inputs]] above

- input_layer_dict :: a dictionary of layer names to either 2-arity (2D) or 3-arity (3D) functions as defined in section [[Inputs]] above

- output_layer_dict :: a dictionary of layer names to 2D Numpy arrays as defined in section [[Inputs]] above

- ignited_cells_set :: set of cells that are actively burning at the simulation stop time, specified as 3D coordinates =(z,y,x)= in the simulated space-time cube

Note that =config_dict= and =input_layer_dict= will be unchanged from
the input dictionary that was provided to ~grow_fire~. All other
fields will contain values updated by the fire spread simulation.

*** Play/Pause/Continue Workflow
    :PROPERTIES:
    :CUSTOM_ID: play/pause/continue-workflow
    :END:

The inputs and outputs of ~grow_fire~ are structured so as to enable
you to simulate fire spread from =simulation_clock= until a stop
condition is encountered and then to easily resume the fire spread
simulation from the output =simulation_clock= until the next stop
condition is met. Here is an example of how to do this.

#+NAME: play-pause-continue-workflow
#+begin_src python
import numpy as np

#=======================================================
# Phase 1: Initial fire simulation - first 12 hours
#=======================================================

world_state = {
    simulation_clock: 0.0,

    config_dict: {
        "simulation_shape"         : (24, 1000, 1000),
        "simulation_resolution"    : (60, 30, 30),
        "simulation_stop_condition": {"max_burn_duration": 720.0},
    },

    input_layer_dict: {
        # 2D Arrays (e.g. 30m x 30m resolution, 30km x 30km extent)
        "elevation"                    : lambda y,x: 0.0,
        "slope"                        : lambda y,x: 0.0,
        "aspect"                       : lambda y,x: 0.0,
        "fuel_model"                   : lambda y,x: 100,
        "canopy_cover"                 : lambda y,x: 0.0,
        "canopy_height"                : lambda y,x: 0.0,
        "canopy_base_height"           : lambda y,x: 0.0,
        "canopy_bulk_density"          : lambda y,x: 0.0,
        # 3D Arrays (e.g. 1hr x 300m x 300m resolution, 1day x 30km x 30km extent)
        "temperature"                  : lambda z,y,x: 10.0,
        "relative_humidity"            : lambda z,y,x: 10.0,
        "wind_speed_10m"               : lambda z,y,x: 0.0,
        "upwind_direction"             : lambda z,y,x: 0.0,
        "fuel_moisture_dead_1hr"       : lambda z,y,x: 10.0,
        "fuel_moisture_dead_10hr"      : lambda z,y,x: 10.0,
        "fuel_moisture_dead_100hr"     : lambda z,y,x: 10.0,
        "fuel_moisture_live_herbaceous": lambda z,y,x: 10.0,
        "fuel_moisture_live_woody"     : lambda z,y,x: 10.0,
        "foliar_moisture"              : lambda z,y,x: 10.0,
    },

    output_layer_dict: {
        "eulerian_level_set_phi_field" : np.full((1000, 1000), 0.0, dtype="float16"),
    },

    ignited_cells_set: set([(0, 100, 100)]),
}

world_state2 = grow_fire(world_state)

#=======================================================
# Phase 2: Continued fire simulation - second 12 hours
#=======================================================

world_state3 = grow_fire(world_state2)
#+end_src

** burn_cells
   :PROPERTIES:
   :CUSTOM_ID: burn-cells
   :END:

TODO: stub

* [WIP] Fire Spread Functions :noexport:
  :PROPERTIES:
  :CUSTOM_ID: [wip]-fire-spread-functions
  :END:

# TODO: How do I want to memoize the no_wind_no_slope_surface_fire_min values?

#       - IDEA: We can just save max_spread_rate,
#       - max_spread_direction, eccentricity, and fireline_intensity
#       - for surface and crown conditions (plus crown_fire_type) in
#       - chunked arrays. When combined with a fireline normal
#       - direction multiplier, you can just multiply max_spread_rate
#       - and fireline_intensity by it to get the fireline normal
#       - spread rate and fireline intensity. Also, don't store flame
#       - length during the simulation. Compute it at the end in
#       - postprocessing.

# TODO: Consider implementing a chunked array class and using it to store intermediate/output arrays as well

#+NAME: fire-spread-functions
#+begin_src python :tangle ../src/pyretechnics/fire_spread.py
# TODO: Compare this with numpy.random (is there a generator object that I can use here?)
import random
import numpy as np


def supply_layer(layer_dict, layer_name, layer_shape, layer_type, initial_value, overwrite_layers):
    layer = layer_dict.get(layer_name)
    if layer:
        if overwrite_layers:
            return layer
        else:
            return layer.copy()
    else:
        return np.full(layer_shape, initial_value, dtype=layer_type)


# FIXME: stub
def burn_cells(world_state):
    """
    1. Validate inputs
       - Make sure that all required parameters are present in config_dict
       - Make sure that all required entries are present in layer_dict
       - Check for entries in output_layer_dict; if present, copy/use as new output layers
         - Use time of arrival raster to identify the burn scar(s); if missing, we are simulating point ignitions
       - Make sure that ignited_cells_set is a set of integer 3-tuples
    2. Iterate through all cells in (rows, cols), compute the maximum spread rate and severity values, and store them in output arrays
       - Run surface and crown equations per cell
    3. Return a dictionary of the outputs
    """
    simulation_clock  = world_state["simulation_clock"]
    config_dict       = world_state["config_dict"]
    input_layer_dict  = world_state["input_layer_dict"]
    output_layer_dict = world_state.get("output_layer_dict", {})
    ignited_cells_set = world_state["ignited_cells_set"]

    # The random seed affects input layer perturbations.
    if config_dict.get("random_seed"):
        random.seed(config_dict.get("random_seed"))

    return None


# FIXME: stub
def grow_fire(world_state):
    """
    1. Validate inputs
       - Make sure that all required parameters are present in config_dict
       - Make sure that all required entries are present in layer_dict
       - Check for entries in output_layer_dict; if present, copy/use as new output layers
         - Use time of arrival raster to identify the burn scar(s); if missing, we are simulating point ignitions
       - Make sure that ignited_cells_set is a set of integer 3-tuples
    2. Iterate through all cells in ignited_cells_set, compute the perimeter-oriented spread rate and severity values, and store them in output arrays
    3. Perform constant spread out over the landscape in all directions
       - Run surface, crown, and spot equations per ignited cell
    4. Record the time_of_arrival in each cell as it spreads
    5. Continue until a stop condition is met (e.g., max_burn_duration or max_burned_area)
    6. Return a dictionary of the outputs
    """
    simulation_clock  = world_state["simulation_clock"]
    config_dict       = world_state["config_dict"]
    input_layer_dict  = world_state["input_layer_dict"]
    output_layer_dict = world_state.get("output_layer_dict", {})
    ignited_cells_set = world_state["ignited_cells_set"]

    # The random seed affects input layer perturbations and spotting calculations.
    if config_dict.get("random_seed"):
        random.seed(config_dict.get("random_seed"))

    # GridFire initializes the following 2D arrays for its spread algorithm:
    #
    #   :burn-time-matrix                [float32] time_of_arrival (with -1 for values in the interior of the burn scar)
    #   :eccentricity-matrix             [float32] -1 in burn scar, 0 otherwise
    #   :fireline-intensity-matrix       [float32] -1 in burn scar, 0 otherwise
    #   :fire-spread-matrix              [float32] +1 in burn scar, 0 otherwise
    #   :fire-type-matrix                [float32] -1 in burn scar, 0 otherwise
    #   :firebrand-count-matrix          [ int32 ]  0 everywhere (when spotting params are passed)
    #   :flame-length-matrix             [float32] -1 in burn scar, 0 otherwise
    #   :directional-flame-length-matrix [float32] -1 in burn scar, 0 otherwise (when compute-directional-values? = true)
    #   :max-spread-direction-matrix     [float32] -1 in burn scar, 0 otherwise
    #   :max-spread-rate-matrix          [float32] -1 in burn scar, 0 otherwise
    #   :modified-time-matrix            [ int32 ]  0 everywhere
    #   :residence-time-matrix           [float32] -1 in burn scar, 0 otherwise (when compute-directional-values? = true)
    #   :reaction-intensity-matrix       [float32] -1 in burn scar, 0 otherwise (when compute-directional-values? = true)
    #   :spot-matrix                     [float32]  0 everywhere (when spotting params are passed)
    #   :spread-rate-matrix              [float32] -1 in burn scar, 0 otherwise
    #   :spread-rate-sum-matrix          [float32]  0 everywhere (when compute-directional-values? = true)
    #   :travel-lines-matrix             [ int16 ]  0 everywhere
    #   :x-magnitude-sum-matrix          [float32]  0 everywhere (when compute-directional-values? = true)
    #   :y-magnitude-sum-matrix          [float32]  0 everywhere (when compute-directional-values? = true)
    #
    # Equivalent Pyretechnics 2D arrays in output_layer_dict:
    #
    #   ========================= Output 2D Arrays =========================
    #   time_of_arrival                  :burn-time-matrix
    #   max_surface_spread_direction     :max-spread-direction-matrix
    #   max_crown_spread_direction       :max-spread-direction-matrix
    #   perimeter_spread_direction       N/A
    #   max_surface_spread_rate          :max-spread-rate-matrix
    #   max_crown_spread_rate            :max-spread-rate-matrix
    #   perimeter_spread_rate            :spread-rate-matrix
    #   max_surface_fireline_intensity   :fireline-intensity-matrix
    #   max_crown_fireline_intensity     :fireline-intensity-matrix
    #   perimeter_fireline_intensity     :fireline-intensity-matrix
    #   max_surface_flame_length         :flame-length-matrix
    #   max_crown_flame_length           :flame-length-matrix
    #   perimeter_flame_length           :directional-flame-length-matrix
    #   fire_type                        :fire-type-matrix
    #   firebrand_ignition               :spot-matrix
    #
    #   ======================== Internal 2D Arrays ========================
    #   surface_eccentricity             :eccentricity-matrix
    #   crown_eccentricity               :eccentricity-matrix
    #
    # GridFire 2D arrays that are not needed by Pyretechnics:
    #
    #   ======================== Replaced 2D Arrays ========================
    #   :fire-spread-matrix              time_of_arrival
    #   :residence-time-matrix           max_surface_fireline_intensity, max_crown_fireline_intensity, surface_eccentricity, crown_eccentricity
    #   :reaction-intensity-matrix       max_surface_fireline_intensity, max_crown_fireline_intensity, surface_eccentricity, crown_eccentricity
    #
    #   ======================== Internal 2D Arrays ========================
    #   :modified-time-matrix            \
    #   :travel-lines-matrix              |
    #   :spread-rate-sum-matrix           |-- for its 2D spread algorithm
    #   :x-magnitude-sum-matrix           |
    #   :y-magnitude-sum-matrix          /

    (num_timesteps, num_rows, num_cols) = config_dict["simulation_shape"]
    layer_shape = (num_rows, num_cols)
    overwrite_outputs = config_dict["overwrite_outputs"]

    output_layer_dict = {
        "eulerian_level_set_phi_field"  : supply_layer(output_layer_dict, "eulerian_level_set_phi_field"  , layer_shape, "float16", np.nan, overwrite_outputs),
        "time_of_arrival"               : supply_layer(output_layer_dict, "time_of_arrival"               , layer_shape, "float32", np.nan, overwrite_outputs),
        "max_surface_spread_direction"  : supply_layer(output_layer_dict, "max_surface_spread_direction"  , layer_shape, "float16", np.nan, overwrite_outputs),
        "max_crown_spread_direction"    : supply_layer(output_layer_dict, "max_crown_spread_direction"    , layer_shape, "float16", np.nan, overwrite_outputs),
        "perimeter_spread_direction"    : supply_layer(output_layer_dict, "perimeter_spread_direction"    , layer_shape, "float16", np.nan, overwrite_outputs),
        "max_surface_spread_rate"       : supply_layer(output_layer_dict, "max_surface_spread_rate"       , layer_shape, "float16", np.nan, overwrite_outputs),
        "max_crown_spread_rate"         : supply_layer(output_layer_dict, "max_crown_spread_rate"         , layer_shape, "float16", np.nan, overwrite_outputs),
        "perimeter_spread_rate"         : supply_layer(output_layer_dict, "perimeter_spread_rate"         , layer_shape, "float16", np.nan, overwrite_outputs),
        "surface_eccentricity"          : supply_layer(output_layer_dict, "surface_eccentricity"          , layer_shape, "float16", np.nan, overwrite_outputs),
        "crown_eccentricity"            : supply_layer(output_layer_dict, "crown_eccentricity"            , layer_shape, "float16", np.nan, overwrite_outputs),
        "max_surface_fireline_intensity": supply_layer(output_layer_dict, "max_surface_fireline_intensity", layer_shape, "float32", np.nan, overwrite_outputs),
        "max_crown_fireline_intensity"  : supply_layer(output_layer_dict, "max_crown_fireline_intensity"  , layer_shape, "float32", np.nan, overwrite_outputs),
        "perimeter_fireline_intensity"  : supply_layer(output_layer_dict, "perimeter_fireline_intensity"  , layer_shape, "float32", np.nan, overwrite_outputs),
        "max_surface_flame_length"      : supply_layer(output_layer_dict, "max_surface_flame_length"      , layer_shape, "float16", np.nan, overwrite_outputs),
        "max_crown_flame_length"        : supply_layer(output_layer_dict, "max_crown_flame_length"        , layer_shape, "float16", np.nan, overwrite_outputs),
        "perimeter_flame_length"        : supply_layer(output_layer_dict, "perimeter_flame_length"        , layer_shape, "float16", np.nan, overwrite_outputs),
        "fire_type"                     : supply_layer(output_layer_dict, "fire_type"                     , layer_shape, "uint8"  ,      0, overwrite_outputs),
        "firebrand_ignition"            : supply_layer(output_layer_dict, "firebrand_ignition"                , layer_shape, "bool8"  ,  False, overwrite_outputs),
    }

    # RESUME at [[file:~/code/sig-gis/gridfire/src/gridfire/fire_spread.clj::(defn- run-loop]]
    # TODO: Investigate ELMFIRE's inputs to determine if we are missing anything needed by its API.

    return None
#+end_src

** ELMFIRE Inputs
   :PROPERTIES:
   :CUSTOM_ID: elmfire-inputs
   :END:

This section lists the full set of inputs used in any =elmfire.data= or =elmfire.data.in= file in:

- the current =main= branch of the =elmfire= repository located here: https://github.com/lautenberger/elmfire
- the current =main= branch of the =runway-scripts= repository located here: https://gitlab.sig-gis.com/sig-gis/runway-scripts

The following table contains the current mapping from ELMFIRE parameters to Pyretechnics parameters:

|------------------------------------------+---------------------------------------+-----------------------------------------|
| ELMFIRE                                  | Pyretechnics Group                    | Pyretechnics Parameter                  |
|------------------------------------------+---------------------------------------+-----------------------------------------|
| DT_METEOROLOGY                           | config_dict                           | simulation_resolution[0]                |
| COMPUTATIONAL_DOMAIN_CELLSIZE            | config_dict                           | simulation_resolution[1:]               |
| SIMULATION_TSTART                        |                                       | ?                                       |
| SIMULATION_TSTOP                         | config_dict.simulation_stop_condition | max_burn_duration                       |
| EMBER_GR                                 | config_dict.spotting                  | ember_gr                                |
| EMBER_SAMPLING_FACTOR                    | config_dict.spotting                  | ember_sampling_factor                   |
| ENABLE_SPOTTING                          | config_dict.spotting                  | Enabled if dictionary is present        |
| P_EPS                                    | config_dict.spotting                  | p_eps                                   |
| PIGN                                     | config_dict.spotting                  | pign                                    |
| PIGN_MAX                                 | config_dict.spotting                  | pign_max                                |
| PIGN_MIN                                 | config_dict.spotting                  | pign_min                                |
| TAU_EMBERGEN                             | config_dict.spotting                  | tau_embergen                            |
|------------------------------------------+---------------------------------------+-----------------------------------------|
| DEM_FILENAME                             | input_layer_dict                      | elevation                               |
| SLP_FILENAME                             | input_layer_dict                      | slope                                   |
| ASP_FILENAME                             | input_layer_dict                      | aspect                                  |
| FBFM_FILENAME                            | input_layer_dict                      | fuel_model                              |
| CC_FILENAME                              | input_layer_dict                      | canopy_cover                            |
| CH_FILENAME                              | input_layer_dict                      | canopy_height                           |
| CBH_FILENAME                             | input_layer_dict                      | canopy_base_height                      |
| CBD_FILENAME                             | input_layer_dict                      | canopy_bulk_density                     |
| ADJ_FILENAME                             | input_layer_dict                      | fuel_spread_adjustment                  |
| CRITICAL_SPOTTING_FIRELINE_INTENSITY(:)  | input_layer_dict                      | surface_spotting_fireline_intensity     |
| GLOBAL_SURFACE_FIRE_SPOTTING_PERCENT_MAX | input_layer_dict                      | surface_spotting_percent                |
| GLOBAL_SURFACE_FIRE_SPOTTING_PERCENT_MIN | input_layer_dict                      | surface_spotting_percent                |
| WS_FILENAME                              | input_layer_dict                      | wind_speed_10m                          |
| WD_FILENAME                              | input_layer_dict                      | upwind_direction                        |
| M1_FILENAME                              | input_layer_dict                      | fuel_moisture_dead_1hr                  |
| M10_FILENAME                             | input_layer_dict                      | fuel_moisture_dead_10hr                 |
| M100_FILENAME                            | input_layer_dict                      | fuel_moisture_dead_100hr                |
| MLH_FILENAME                             | input_layer_dict                      | fuel_moisture_live_herbaceous           |
| MLW_FILENAME                             | input_layer_dict                      | fuel_moisture_live_woody                |
|------------------------------------------+---------------------------------------+-----------------------------------------|
| PHI_FILENAME                             | output_layer_dict                     | eulerian_level_set_phi_field            |
|------------------------------------------+---------------------------------------+-----------------------------------------|
| T_IGN(1)                                 | ignited_cells_set                     | (t, _, _)                               |
| Y_IGN(1)                                 | ignited_cells_set                     | (_, y, _)                               |
| X_IGN(1)                                 | ignited_cells_set                     | (_, _, x)                               |
|------------------------------------------+---------------------------------------+-----------------------------------------|
| BANDTHICKNESS                            |                                       | ?                                       |
| METEOROLOGY_BAND_SKIP_INTERVAL           |                                       | ?                                       |
| METEOROLOGY_BAND_START                   |                                       | ?                                       |
| METEOROLOGY_BAND_STOP                    |                                       | ?                                       |
| NUM_METEOROLOGY_TIMES                    |                                       | ?                                       |
| CROWN_FIRE_MODEL                         |                                       | ?                                       |
| MODE                                     |                                       | ?                                       |
| SIMULATION_DT                            |                                       | ?                                       |
| SIMULATION_DTMAX                         |                                       | ?                                       |
| TARGET_CFL                               |                                       | ?                                       |
| USE_BLDG_SPREAD_MODEL                    |                                       | ?                                       |
| USE_EULERIAN_FRAMEWORK                   |                                       | ?                                       |
| USE_PHYSICAL_EMBER_NUMBER                |                                       | ?                                       |
| USE_PHYSICAL_SPOTTING_DURATION           |                                       | ?                                       |
| USE_SUPERSEDED_SPOTTING                  |                                       | ?                                       |
| USE_UMD_SPOTTING_MODEL                   |                                       | ?                                       |
| WX_BILINEAR_INTERPOLATION                |                                       | ?                                       |
| ALLOW_MULTIPLE_IGNITIONS_AT_A_PIXEL      |                                       | ?                                       |
|------------------------------------------+---------------------------------------+-----------------------------------------|
| FUELS_AND_TOPOGRAPHY_DIRECTORY           | N/A                                   | Input reading managed externally        |
| A_SRS                                    | N/A                                   | GIS operations managed externally       |
| LATITUDE                                 | N/A                                   | GIS operations managed externally       |
| LONGITUDE                                | N/A                                   | GIS operations managed externally       |
| COMPUTATIONAL_DOMAIN_XLLCORNER           | N/A                                   | GIS operations managed externally       |
| COMPUTATIONAL_DOMAIN_YLLCORNER           | N/A                                   | GIS operations managed externally       |
| FORECAST_START_HOUR                      | N/A                                   | GIS operations managed externally       |
| UTC_OFFSET_HOURS                         | N/A                                   | GIS operations managed externally       |
| CURRENT_YEAR                             | N/A                                   | GIS operations managed externally       |
| HOUR_OF_YEAR                             | N/A                                   | GIS operations managed externally       |
| PATH_TO_GDAL                             | N/A                                   | GIS operations managed externally       |
| NUM_ENSEMBLE_MEMBERS                     | N/A                                   | Random sampling managed externally      |
| NUM_IGNITIONS                            | N/A                                   | Random sampling managed externally      |
| RANDOM_IGNITIONS                         | N/A                                   | Random sampling managed externally      |
| USE_IGNITION_MASK                        | N/A                                   | Random sampling managed externally      |
| USE_CONSTANT_LH                          | N/A                                   | Replaced by abstract gridded datasource |
| USE_CONSTANT_LW                          | N/A                                   | Replaced by abstract gridded datasource |
| LH_MOISTURE_CONTENT                      | N/A                                   | Replaced by abstract gridded datasource |
| LW_MOISTURE_CONTENT                      | N/A                                   | Replaced by abstract gridded datasource |
| OUTPUTS_DIRECTORY                        | N/A                                   | Output writing managed externally       |
| SCRATCH                                  | N/A                                   | Output writing managed externally       |
| CONVERT_TO_GEOTIFF                       | N/A                                   | Output writing managed externally       |
| DTDUMP                                   | N/A                                   | Output writing managed externally       |
| DT_DUMP_EMBER_FLUX                       | N/A                                   | Output writing managed externally       |
| DUMP_EMBER_FLUX_UMD                      | N/A                                   | Output writing managed externally       |
| DUMP_FLAME_LENGTH                        | N/A                                   | Output writing managed externally       |
| DUMP_FLIN                                | N/A                                   | Output writing managed externally       |
| DUMP_SPOTTING_OUTPUTS                    | N/A                                   | Output writing managed externally       |
| DUMP_SPREAD_RATE                         | N/A                                   | Output writing managed externally       |
| DUMP_TIME_OF_ARRIVAL                     | N/A                                   | Output writing managed externally       |
|------------------------------------------+---------------------------------------+-----------------------------------------|

* Appendices
  :PROPERTIES:
  :CUSTOM_ID: appendices
  :END:
** Units Conversion Functions (pyretechnics.conversion)
   :PROPERTIES:
   :CUSTOM_ID: units-conversion-functions-(pyretechnics.conversion)
   :header-args:python+: :session *pyretechnics.conversion*
   :header-args:python+: :tangle  ../src/pyretechnics/conversion.py
   :header-args:python+: :exports code
   :END:

#+NAME: units-conversion
#+begin_src python
import cython
import cython as cy
if cython.compiled:
    from cython.cimports.libc.math import pi, sqrt, sin, cos, tan, atan, atan2
    from cython.cimports.pyretechnics.cy_types import vec_xy
else:
    from math import pi, sqrt, sin, cos, tan, atan, atan2
    from pyretechnics.py_types import vec_xy


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def rad_to_deg(radians: cy.float) -> cy.float:
    """Convert radians to degrees."""
    return radians * 180.0 / pi


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def deg_to_rad(degrees: cy.float) -> cy.float:
    """Convert degrees to radians."""
    return degrees * pi / 180.0


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def deg_to_ratio(degrees: cy.float) -> cy.float:
    """Convert degrees to ratio."""
    return tan(deg_to_rad(degrees))


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def ratio_to_deg(ratio: cy.float) -> cy.float:
    """Convert ratio to degrees."""
    return rad_to_deg(atan(ratio))


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def F_to_K(degrees: cy.float) -> cy.float:
    """Convert fahrenheit to kelvin."""
    return (degrees + 459.67) * 0.5555555555555556


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def K_to_F(degrees: cy.float) -> cy.float:
    """Convert kelvin to fahrenheit."""
    return (degrees * 1.8) - 459.67


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def F_to_C(degrees: cy.float) -> cy.float:
    """Convert fahrenheit to celsius."""
    return (degrees - 32.0) * 0.5555555555555556


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def C_to_F(degrees: cy.float) -> cy.float:
    """Convert celsius to fahrenheit."""
    return (degrees * 1.8) + 32.0


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def ch_to_m(ch: cy.float) -> cy.float:
    """Convert chains to meters."""
    return ch * 20.1168


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def m_to_ch(m: cy.float) -> cy.float:
    """Convert meters to chains."""
    return m * 0.0497097


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def m_to_ft(m: cy.float) -> cy.float:
    """Convert meters to feet."""
    return m * 3.281


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def ft_to_m(ft: cy.float) -> cy.float:
    """Convert feet to meters."""
    return ft * 0.30478512648582745


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def mph_to_mps(mph: cy.float) -> cy.float:
    """Convert miles per hour to meters per second."""
    return mph * 0.44701818551254696


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def mps_to_mph(mps: cy.float) -> cy.float:
    """Convert meters per second to miles per hour."""
    return mps * 2.237045454545455


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def km_hr_to_mps(km_hr: cy.float) -> cy.float:
    """Convert kilometers per hour to meters per second."""
    return km_hr * 0.277764222883701


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def mps_to_km_hr(mps: cy.float) -> cy.float:
    """Convert meters per second to kilometers per hour."""
    return mps * 3.6001756800000004


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def mph_to_km_hr(mph: cy.float) -> cy.float:
    """Convert miles per hour to kilometers per hour."""
    return mph * 1.609344


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def km_hr_to_mph(km_hr: cy.float) -> cy.float:
    """Convert kilometers per hour to miles per hour."""
    return km_hr * 0.621371192237334


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def m_min_to_km_hr(m_min: cy.float) -> cy.float:
    """Convert meters per minute to kilometers per hour."""
    return m_min * 0.06


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def km_hr_to_m_min(km_hr: cy.float) -> cy.float:
    """Convert kilometers per hour to meters per minute."""
    return km_hr / 0.06


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def m_min_to_mph(m_min: cy.float) -> cy.float:
    """Convert meters per minute to miles per hour."""
    return m_min * 0.0372840909091


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def mph_to_m_min(mph: cy.float) -> cy.float:
    """Convert miles per hour to meters per minute."""
    return mph * 26.8210911307


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def mps_to_fpm(mps: cy.float) -> cy.float:
    """Convert meters per second to feet per minute."""
    return mps * 196.86


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def fpm_to_mps(fpm: cy.float) -> cy.float:
    """Convert feet per minute to meters per second."""
    return fpm / 196.86


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def mph_to_fpm(mph: cy.float) -> cy.float:
    """Convert miles per hour to feet per minute."""
    return mph * 88.0


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def fpm_to_mph(fpm: cy.float) -> cy.float:
    """Convert feet per minute to miles per hour."""
    return fpm / 88.0


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def Btu_ft_s_to_kW_m(Btu_ft_s: cy.float) -> cy.float:
    """Convert BTU per feet per second to kilowatt per meter."""
    return Btu_ft_s * 3.46165186


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def kW_m_to_Btu_ft_s(kW_m: cy.float) -> cy.float:
    """Convert kilowatt per meter to BTU per feet per second."""
    return kW_m * 0.28887942532730604


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def Btu_lb_to_kJ_kg(Btu_lb: cy.float) -> cy.float:
    """Convert BTU per lb to kilojoule per kilogram."""
    return Btu_lb * 2.3259999996185


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def kJ_kg_to_Btu_lb(kJ_kg: cy.float) -> cy.float:
    """Convert kilojoule per kilogram to BTU per lb."""
    return kJ_kg / 2.3259999996185


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def kg_m3_to_lb_ft3(kg_m3: cy.float) -> cy.float:
    """Convert kilogram per cubic meter to pound per cubic foot."""
    return kg_m3 * 0.0624


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def lb_ft3_to_kg_m3(lb_ft3: cy.float) -> cy.float:
    """Convert pound per cubic foot to kilogram per cubic meter."""
    return lb_ft3 * 16.025641025641026


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def percent_to_dec(percent: cy.float) -> cy.float:
    """Convert percent to decimal."""
    return percent * 0.01


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def dec_to_percent(decimal: cy.float) -> cy.float:
    """Convert decimal to percent."""
    return decimal * 100.0


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def sec_to_min(seconds: cy.float) -> cy.float:
    """Convert seconds to minutes."""
    return seconds * 0.016666666666666666


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def min_to_sec(minutes: cy.float) -> cy.float:
    """Convert minutes to seconds."""
    return minutes * 60.0


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def ms_to_min(milliseconds: cy.float) -> cy.float:
    """Convert milliseconds to minutes."""
    return milliseconds * 0.000016667


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def min_to_ms(minutes: cy.float) -> cy.float:
    """Convert minutes to milliseconds."""
    return minutes * 60000.0


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def hour_to_min(hours: cy.float) -> cy.float:
    """Converts hours to minutes."""
    return hours * 60.0


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def min_to_hour(minutes: cy.float) -> cy.float:
    """Converts minutes to hours."""
    return minutes / 60.0


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def day_to_min(days: cy.float) -> cy.float:
    """Convert days to minutes."""
    return days * 1440.0


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def min_to_day(minutes: cy.float) -> cy.float:
    """Convert minutes to days."""
    return minutes / 1440.0


# TODO Return vec_rt
@cy.cfunc
@cy.exceptval(check=False)
def cartesian_to_polar(x: cy.float, y: cy.float) -> vec_xy:
    """Convert cartesian coordinates (x, y) to polar coordinates (r, theta)."""
    r        : cy.float = sqrt(x * x + y * y)
    theta_rad: cy.float = atan2(y, x)
    theta    : cy.float = rad_to_deg(theta_rad) % 360.0
    return (r, theta)


@cy.cfunc
@cy.exceptval(check=False)
def polar_to_cartesian(r: cy.float, theta: cy.float) -> vec_xy:
    """Convert polar coordinates (r, theta) to cartesian coordinates (x, y)."""
    theta_rad: cy.float = deg_to_rad(theta)
    x        : cy.float = r * cos(theta_rad)
    y        : cy.float = r * sin(theta_rad)
    return (x, y)


# TODO Return vec_ra
@cy.cfunc
@cy.exceptval(check=False)
def cartesian_to_azimuthal(x: cy.float, y: cy.float) -> vec_xy:
    """Convert cartesian coordinates (x, y) to azimuthal coordinates (r, azimuth)."""
    r          : cy.float = sqrt(x * x + y * y)
    azimuth_rad: cy.float = atan2(x, y)
    azimuth    : cy.float = rad_to_deg(azimuth_rad) % 360.0
    return (r, azimuth)


@cy.cfunc
@cy.exceptval(check=False)
def azimuthal_to_cartesian(r: cy.float, azimuth: cy.float) -> vec_xy:
    """Convert azimuthal coordinates (r, azimuth) to cartesian coordinates (x, y)."""
    azimuth_rad: cy.float = deg_to_rad(azimuth)
    x          : cy.float = r * sin(azimuth_rad)
    y          : cy.float = r * cos(azimuth_rad)
    return (x, y)


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def opposite_direction(theta: cy.float) -> cy.float:
    """Convert theta to theta + 180 degrees."""
    return (theta + 180.0) % 360.0


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def wind_speed_10m_to_wind_speed_20ft(wind_speed_10m: cy.float) -> cy.float:
    """Convert wind speed at 10m to wind speed at 20ft."""
    return wind_speed_10m / 1.15


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def wind_speed_20ft_to_wind_speed_10m(wind_speed_20ft: cy.float) -> cy.float:
    """Convert wind speed at 20ft to wind speed at 10m."""
    return wind_speed_20ft * 1.15
#+end_src

#+NAME: conversion-pxd
#+begin_src python :eval no :tangle ../src/pyretechnics/conversion.pxd
from pyretechnics.cy_types cimport vec_xy

cdef float rad_to_deg(float radians) noexcept
cdef float deg_to_rad(float degrees) noexcept
cdef float deg_to_ratio(float degrees) noexcept
cdef float ratio_to_deg(float ratio) noexcept
cdef float F_to_K(float degrees) noexcept
cdef float K_to_F(float degrees) noexcept
cdef float F_to_C(float degrees) noexcept
cdef float C_to_F(float degrees) noexcept
cdef float ch_to_m(float ch) noexcept
cdef float m_to_ch(float m) noexcept
cdef float m_to_ft(float m) noexcept
cdef float ft_to_m(float ft) noexcept
cdef float mph_to_mps(float mph) noexcept
cdef float mps_to_mph(float mps) noexcept
cdef float km_hr_to_mps(float km_hr) noexcept
cdef float mps_to_km_hr(float mps) noexcept
cdef float mph_to_km_hr(float mph) noexcept
cdef float km_hr_to_mph(float km_hr) noexcept
cdef float m_min_to_km_hr(float m_min) noexcept
cdef float km_hr_to_m_min(float km_hr) noexcept
cdef float m_min_to_mph(float m_min) noexcept
cdef float mph_to_m_min(float mph) noexcept
cdef float mps_to_fpm(float mps) noexcept
cdef float fpm_to_mps(float fpm) noexcept
cdef float mph_to_fpm(float mph) noexcept
cdef float fpm_to_mph(float fpm) noexcept
cdef float Btu_ft_s_to_kW_m(float Btu_ft_s) noexcept
cdef float kW_m_to_Btu_ft_s(float kW_m) noexcept
cdef float Btu_lb_to_kJ_kg(float Btu_lb) noexcept
cdef float kJ_kg_to_Btu_lb(float kJ_kg) noexcept
cdef float kg_m3_to_lb_ft3(float kg_m3) noexcept
cdef float lb_ft3_to_kg_m3(float lb_ft3) noexcept
cdef float percent_to_dec(float percent) noexcept
cdef float dec_to_percent(float decimal) noexcept
cdef float sec_to_min(float seconds) noexcept
cdef float min_to_sec(float minutes) noexcept
cdef float ms_to_min(float milliseconds) noexcept
cdef float min_to_ms(float minutes) noexcept
cdef float hour_to_min(float hours) noexcept
cdef float min_to_hour(float minutes) noexcept
cdef float day_to_min(float days) noexcept
cdef float min_to_day(float minutes) noexcept
cdef vec_xy cartesian_to_polar(float x, float y) noexcept
cdef vec_xy polar_to_cartesian(float r, float theta) noexcept
cdef vec_xy cartesian_to_azimuthal(float x, float y) noexcept
cdef vec_xy azimuthal_to_cartesian(float r, float azimuth) noexcept
cdef float opposite_direction(float theta) noexcept
cdef float wind_speed_10m_to_wind_speed_20ft(float wind_speed_10m) noexcept
cdef float wind_speed_20ft_to_wind_speed_10m(float wind_speed_20ft) noexcept
#+end_src

** Vector Utility Functions (pyretechnics.vector_utils)
   :PROPERTIES:
   :CUSTOM_ID: vector-utility-functions-(pyretechnics.vector_utils)
   :header-args:python+: :session *pyretechnics.vector_utils*
   :header-args:python+: :tangle  ../src/pyretechnics/vector_utils.py
   :header-args:python+: :exports code
   :END:

#+NAME: vector-utilities
#+begin_src python
import cython
import cython as cy
if cython.compiled:
    from cython.cimports.libc.math import sqrt, sin, cos
    from cython.cimports.pyretechnics.cy_types import pyidx, vec_xy, vec_xyz
    import cython.cimports.pyretechnics.conversion as conv
else:
    from math import sqrt, sin, cos
    from pyretechnics.py_types import pyidx, vec_xy, vec_xyz
    import pyretechnics.conversion as conv


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def dot_2d(vector1: vec_xy, vector2: vec_xy) -> cy.float:
    return vector1[0] * vector2[0] + vector1[1] * vector2[1]


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def dot_3d(vector1: vec_xyz, vector2: vec_xyz) -> cy.float:
    return vector1[0] * vector2[0] + vector1[1] * vector2[1] + vector1[2] * vector2[2]


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def scale_2d(scalar: cy.float, vector: vec_xy) -> vec_xy:
    return (scalar * vector[0], scalar * vector[1])


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def scale_3d(scalar: cy.float, vector: vec_xyz) -> vec_xyz:
    return (scalar * vector[0], scalar * vector[1], scalar * vector[2])


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def add_2d(vector1: vec_xy, vector2: vec_xy) -> vec_xy:
    return (vector1[0] + vector2[0], vector1[1] + vector2[1])


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def add_3d(vector1: vec_xyz, vector2: vec_xyz) -> vec_xyz:
    return (vector1[0] + vector2[0], vector1[1] + vector2[1], vector1[2] + vector2[2])


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def vector_magnitude_2d(vector: vec_xy) -> cy.float:
    return sqrt(dot_2d(vector, vector))


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def vector_magnitude_3d(vector: vec_xyz) -> cy.float:
    return sqrt(dot_3d(vector, vector))


@cy.cfunc
@cy.exceptval(check=False)
def as_unit_vector_2d(vector: vec_xy) -> vec_xy:
    magnitude: cy.float = vector_magnitude_2d(vector)
    if magnitude == 0.0:
        return vector
    else:
        ux: cy.float = vector[0] / magnitude
        uy: cy.float = vector[1] / magnitude
        return (ux, uy)


@cy.cfunc
@cy.exceptval(check=False)
def as_unit_vector_3d(vector: vec_xyz) -> vec_xyz:
    magnitude: cy.float = vector_magnitude_3d(vector)
    if magnitude == 0.0:
        return vector
    else:
        ux: cy.float = vector[0] / magnitude
        uy: cy.float = vector[1] / magnitude
        uz: cy.float = vector[2] / magnitude
        return (ux, uy, uz)


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def to_slope_plane(vector_2d: vec_xy, elevation_gradient: vec_xy) -> vec_xyz:
    return (
        vector_2d[0],
        vector_2d[1],
        dot_2d(vector_2d, elevation_gradient)
    )


@cy.cfunc
@cy.inline
@cy.exceptval(check=False)
def to_horizontal_plane(vector_3d: vec_xyz) -> vec_xy:
    return (vector_3d[0], vector_3d[1])


@cy.cfunc
@cy.exceptval(check=False)
def spread_direction_vector_to_angle(vector_3d: vec_xyz) -> cy.float:
    x        : cy.float = vector_3d[0]
    y        : cy.float = vector_3d[1]
    az_coords: vec_xy   = conv.cartesian_to_azimuthal(x, y)
    azimuth  : cy.float = az_coords[1]
    return azimuth


@cy.cfunc
@cy.exceptval(check=False)
def get_slope_normal_vector(elevation_gradient: vec_xy) -> vec_xyz:
    (dz_dx, dz_dy)               = elevation_gradient
    slope_normal_vector: vec_xyz = (-dz_dx, -dz_dy, 1.0)
    return as_unit_vector_3d(slope_normal_vector)


@cy.cfunc
@cy.exceptval(check=False)
def cross_3d(vector1: vec_xyz, vector2: vec_xyz) -> vec_xyz:
    (a, b, c) = vector1
    (d, e, f) = vector2
    return (
        b * f - e * c,
        -a * f + d * c,
        a * e - d * b,
    )


@cy.cfunc
@cy.exceptval(check=False)
def rotate_on_sloped_plane(vector: vec_xyz, theta: cy.float, slope: cy.float, aspect: cy.float) -> vec_xyz:
    """
    Rotate a 3D vector <x,y,z> theta degrees clockwise on the plane defined by the slope and aspect.
    """
    # Calculate the slope normal vector from the slope and aspect
    elevation_gradient : vec_xy  = conv.azimuthal_to_cartesian(slope, conv.opposite_direction(aspect))
    slope_normal_vector: vec_xyz = get_slope_normal_vector(elevation_gradient)
    # Calculate sine and cosine of theta
    theta_rad: cy.float = conv.deg_to_rad(theta)
    cos_theta: cy.float = cos(theta_rad)
    sin_theta: cy.float = sin(theta_rad)
    # Rotate theta degrees clockwise around the slope_normal_vector
    vector_i: vec_xyz = (
        cos_theta * vector[0],
        cos_theta * vector[1],
        cos_theta * vector[2],
    )
    vector_j: vec_xyz = (
        sin_theta * vector[0],
        sin_theta * vector[1],
        sin_theta * vector[2],
    )
    vector_k: vec_xyz = cross_3d(vector_j, slope_normal_vector)
    return (
        vector_i[0] + vector_k[0],
        vector_i[1] + vector_k[1],
        vector_i[2] + vector_k[2],
    )
#+end_src

#+NAME: vector-utils-pxd
#+begin_src python :eval no :tangle ../src/pyretechnics/vector_utils.pxd
from pyretechnics.cy_types cimport vec_xy, vec_xyz

cdef float dot_2d(vec_xy vector1, vec_xy vector2) noexcept
cdef float dot_3d(vec_xyz vector1, vec_xyz vector2) noexcept
cdef vec_xy scale_2d(float scalar, vec_xy vector) noexcept
cdef vec_xyz scale_3d(float scalar, vec_xyz vector) noexcept
cdef vec_xy add_2d(vec_xy vector1, vec_xy vector2) noexcept
cdef vec_xyz add_3d(vec_xyz vector1, vec_xyz vector2) noexcept
cdef float vector_magnitude_2d(vec_xy vector) noexcept
cdef float vector_magnitude_3d(vec_xyz vector) noexcept
cdef vec_xy as_unit_vector_2d(vec_xy vector) noexcept
cdef vec_xyz as_unit_vector_3d(vec_xyz vector) noexcept
cdef vec_xyz to_slope_plane(vec_xy vector_2d, vec_xy elevation_gradient) noexcept
cdef vec_xy to_horizontal_plane(vec_xyz vector_3d) noexcept
cdef float spread_direction_vector_to_angle(vec_xyz vector_3d) noexcept
cdef vec_xyz get_slope_normal_vector(vec_xy elevation_gradient) noexcept
cdef vec_xyz cross_3d(vec_xyz vector1, vec_xyz vector2) noexcept
cdef vec_xyz rotate_on_sloped_plane(vec_xyz vector, float theta, float slope, float aspect) noexcept
#+end_src

#+NAME: cy-types-pxd
#+begin_src python :eval no :tangle ../src/pyretechnics/cy_types.pxd
#==================================================
# Compile-time-defined type aliases
#==================================================

ctypedef Py_ssize_t pyidx
ctypedef (float, float) vec_xy
ctypedef (float, float, float) vec_xyz
ctypedef (pyidx, pyidx) coord_yx
ctypedef (pyidx, pyidx, pyidx) coord_tyx
ctypedef (float, float) fcatarr
ctypedef (float, float, float, float, float, float) fclaarr
ctypedef (float, float, float, float, float, float, float, float, float, float, float, float, float) CompactFuelModel

cdef struct FuelModel:
    int number
    float delta
    fclaarr M_x
    fclaarr M_f
    fclaarr w_o
    fclaarr sigma
    fclaarr h
    fclaarr rho_p
    fclaarr S_T
    fclaarr S_e
    bint dynamic
    bint burnable
    fclaarr exp_A_sigma
    fclaarr firemod_size_classes
    fclaarr f_ij
    fcatarr f_i
    fclaarr g_ij

cdef struct ProjectedVectors:
    vec_xyz wind_vector_3d
    vec_xyz slope_vector_3d

cdef struct FireBehaviorMin:
    float base_spread_rate
    float base_fireline_intensity
    float max_effective_wind_speed
    float _phiS_G
    float _phiW_scalr
    float _phiW_expnt
    float _ws_scalr
    float _ws_expnt

cdef struct FireBehaviorMax:
    int max_fire_type
    float max_spread_rate
    vec_xyz max_spread_direction
    float max_fireline_intensity
    float max_flame_length
    float length_to_width_ratio
    float eccentricity
    float critical_spread_rate

cdef struct SpreadBehavior:
    float dphi_dt
    int fire_type
    float spread_rate
    vec_xyz spread_direction
    float fireline_intensity
    float flame_length

cdef struct CrownSpreadInfo:
    int fire_type
    float spread_rate
    float critical_spread_rate

cdef struct SpotConfig:
    long random_seed
    float firebrands_per_unit_heat
    float downwind_distance_mean
    float fireline_intensity_exponent
    float wind_speed_exponent
    float downwind_variance_mean_ratio
    float crosswind_distance_stdev
    float decay_distance

cdef struct JumpDistribution:
    float mu_x
    float sigma_x
    float sigma_y

cdef struct PartialedEllWavelet:
    vec_xyz Vh_3d
    float ewc_A
    float ewc_B
    float ewc_C

cdef struct CellInputs:
    float slope
    float aspect
    float fuel_model_number
    float canopy_cover
    float canopy_height
    float canopy_base_height
    float canopy_bulk_density
    float wind_speed_10m
    float upwind_direction
    float fuel_moisture_dead_1hr
    float fuel_moisture_dead_10hr
    float fuel_moisture_dead_100hr
    float fuel_moisture_live_herbaceous
    float fuel_moisture_live_woody
    float foliar_moisture
    float fuel_spread_adjustment
    float weather_spread_adjustment

cdef struct EllipticalInfo:
    coord_yx cell_index
    vec_xy elevation_gradient
    PartialedEllWavelet surface_wavelet
    PartialedEllWavelet crown_wavelet
    float crowning_spread_rate

cdef struct Pass1CellOutput:
    coord_yx cell_index
    vec_xy phi_gradient_xy
    float dphi_dt_flim
    float phi_old
#+end_src

#+NAME: py-types-py
#+begin_src python :tangle ../src/pyretechnics/py_types.py
#==============================================================
# Runtime-defined type aliases
#==============================================================

import cython as cy

pyidx            = cy.typedef(cy.Py_ssize_t)
vec_xy           = cy.typedef(tuple[cy.float, cy.float])
vec_xyz          = cy.typedef(tuple[cy.float, cy.float, cy.float])
coord_yx         = cy.typedef(tuple[pyidx, pyidx])
coord_tyx        = cy.typedef(tuple[pyidx, pyidx, pyidx])
fcatarr          = cy.typedef(tuple[cy.float, cy.float])
fclaarr          = cy.typedef(tuple[cy.float, cy.float, cy.float, cy.float, cy.float, cy.float])
CompactFuelModel = cy.typedef(tuple[cy.float, cy.float, cy.float, cy.float, cy.float, cy.float,
                                    cy.float, cy.float, cy.float, cy.float, cy.float, cy.float, cy.float])

FuelModel = cy.struct(
    number               = cy.int,
    delta                = cy.float,
    M_x                  = fclaarr,
    M_f                  = fclaarr,
    w_o                  = fclaarr,
    sigma                = fclaarr,
    h                    = fclaarr,
    rho_p                = fclaarr,
    S_T                  = fclaarr,
    S_e                  = fclaarr,
    dynamic              = cy.bint,
    burnable             = cy.bint,
    exp_A_sigma          = fclaarr,
    firemod_size_classes = fclaarr,
    f_ij                 = fclaarr,
    f_i                  = fcatarr,
    g_ij                 = fclaarr,
)

ProjectedVectors = cy.struct(
    wind_vector_3d  = vec_xyz,
    slope_vector_3d = vec_xyz,
)

FireBehaviorMin = cy.struct(
    base_spread_rate         = cy.float,
    base_fireline_intensity  = cy.float,
    max_effective_wind_speed = cy.float,
    _phiS_G                  = cy.float,
    _phiW_scalr              = cy.float,
    _phiW_expnt              = cy.float,
    _ws_scalr                = cy.float,
    _ws_expnt                = cy.float,
)

FireBehaviorMax = cy.struct(
    max_fire_type          = cy.int,
    max_spread_rate        = cy.float,
    max_spread_direction   = vec_xyz,
    max_fireline_intensity = cy.float,
    max_flame_length       = cy.float,
    length_to_width_ratio  = cy.float,
    eccentricity           = cy.float,
    critical_spread_rate   = cy.float,
)

SpreadBehavior = cy.struct(
    dphi_dt            = cy.float,
    fire_type          = cy.int,
    spread_rate        = cy.float,
    spread_direction   = vec_xyz,
    fireline_intensity = cy.float,
    flame_length       = cy.float,
)

CrownSpreadInfo = cy.struct(
    fire_type            = cy.int,
    spread_rate          = cy.float,
    critical_spread_rate = cy.float,
)

SpotConfig = cy.struct(
    random_seed                  = cy.long,
    firebrands_per_unit_heat     = cy.float,
    downwind_distance_mean       = cy.float,
    fireline_intensity_exponent  = cy.float,
    wind_speed_exponent          = cy.float,
    downwind_variance_mean_ratio = cy.float,
    crosswind_distance_stdev     = cy.float,
    decay_distance               = cy.float,
)

JumpDistribution = cy.struct(
    # Downwind LogNormal params
    # Formally, we have ln(downwind_jump / 1m) ~ Normal(mu = mu_x, sigma = sigma_x)
    mu_x    = cy.float, # dimensionless (log-space)
    sigma_x = cy.float, # dimensionless (log-space)
    # Crosswind normal params
    # Formally, we have crosswind_jump ~ Normal(mu = 0, sigma = sigma_y)
    sigma_y = cy.float, # meters
)

# Pre-computed coefficients to apply elliptical wavelet math as fast as possible
# once the phi gradient information is available.
# See `pyretechnics.eulerian_level_set.dphi_dt_from_partialed_wavelet`.
PartialedEllWavelet = cy.struct(
    Vh_3d = vec_xyz,  # Heading spread rate vector (m/min)
    ewc_A = cy.float, # Dimensionless elliptical wavelet coefficient (<= 0)
    ewc_B = cy.float, # Dimensionless elliptical wavelet coefficient (<= 0)
    ewc_C = cy.float, # Dimensionless elliptical wavelet coefficient (>= 0)
)

CellInputs = cy.struct(
    slope                         = cy.float,
    aspect                        = cy.float,
    fuel_model_number             = cy.float,
    canopy_cover                  = cy.float,
    canopy_height                 = cy.float,
    canopy_base_height            = cy.float,
    canopy_bulk_density           = cy.float,
    wind_speed_10m                = cy.float,
    upwind_direction              = cy.float,
    fuel_moisture_dead_1hr        = cy.float,
    fuel_moisture_dead_10hr       = cy.float,
    fuel_moisture_dead_100hr      = cy.float,
    fuel_moisture_live_herbaceous = cy.float,
    fuel_moisture_live_woody      = cy.float,
    foliar_moisture               = cy.float,
    fuel_spread_adjustment        = cy.float,
    weather_spread_adjustment     = cy.float,
)

# Pre-computed information required to compute dphi/dt once the phi
# gradient is known. Derived from the surface and crown wavelets.
#
# NOTE: The reason to make this a small struct stored in an array is
#       efficiency - we want the CPU to have a low cache miss rate.
#
# NOTE: A significant benefit of this architecture is that it's
#       Rothermel-agnostic. EllipticalInfo could conceivably be
#       implemented using variants of the Rothermel model. This can be
#       valuable to give flexibility to users.
EllipticalInfo = cy.struct(
    cell_index           = coord_yx,
    elevation_gradient   = vec_xy,
    surface_wavelet      = PartialedEllWavelet,
    crown_wavelet        = PartialedEllWavelet,
    crowning_spread_rate = cy.float, # Surface spread rate at which crowning occurs
)

# Some data saved during the 1st Runge-Kutta pass.
Pass1CellOutput = cy.struct(
    cell_index      = coord_yx,
    phi_gradient_xy = vec_xy,
    dphi_dt_flim    = cy.float, # Flux-limited dphi/dt (phi/min, <= 0).
    phi_old         = cy.float,
)
#+end_src

** SpaceTimeCube and LazySpaceTimeCube Tests (pyretechnics_test.test_space_time_cube)
   :PROPERTIES:
   :CUSTOM_ID: spacetimecube-and-lazyspacetimecube-tests-(pyretechnics_test.test_space_time_cube)
   :header-args:python+: :session *pyretechnics_test.test_space_time_cube*
   :header-args:python+: :tangle  ../test/pyretechnics_test/test_space_time_cube.py
   :header-args:python+: :exports code
   :END:

#+NAME: test-space-time-cube
#+begin_src python
import numpy as np
from pyretechnics.space_time_cube import SpaceTimeCube

#==============================================================
# Raw Data - Managed by the Caller
#==============================================================

# 2D Arrays (e.g. 30m x 30m resolution, 30km x 30km extent)
elevation_layer                    = np.arange(0,1000000).reshape(1000,1000)
slope_layer                        = np.arange(0,1000000).reshape(1000,1000)
aspect_layer                       = np.arange(0,1000000).reshape(1000,1000)
fuel_model_layer                   = np.arange(0,1000000).reshape(1000,1000)
canopy_cover_layer                 = np.arange(0,1000000).reshape(1000,1000)
canopy_height_layer                = np.arange(0,1000000).reshape(1000,1000)
canopy_base_height_layer           = np.arange(0,1000000).reshape(1000,1000)
canopy_bulk_density_layer          = np.arange(0,1000000).reshape(1000,1000)
fuel_spread_adjustment_layer       = np.arange(0,1000000).reshape(1000,1000) # Optional
suppression_difficulty_index_layer = np.arange(0,1000000).reshape(1000,1000) # Optional

# 3D Arrays (e.g. 1hr x 300m x 300m resolution, 1day x 30km x 30km extent)
temperature_layer                   = np.arange(240000).reshape(24,100,100) # Optional
relative_humidity_layer             = np.arange(240000).reshape(24,100,100) # Optional
wind_speed_10m_layer                = np.arange(240000).reshape(24,100,100)
upwind_direction_layer              = np.arange(240000).reshape(24,100,100)
fuel_moisture_dead_1hr_layer        = np.arange(240000).reshape(24,100,100)
fuel_moisture_dead_10hr_layer       = np.arange(240000).reshape(24,100,100)
fuel_moisture_dead_100hr_layer      = np.arange(240000).reshape(24,100,100)
fuel_moisture_live_herbaceous_layer = np.arange(240000).reshape(24,100,100)
fuel_moisture_live_woody_layer      = np.arange(240000).reshape(24,100,100)
foliar_moisture_layer               = np.arange(240000).reshape(24,100,100)
weather_spread_adjustment_layer     = np.arange(240000).reshape(24,100,100) # Optional

#==============================================================
# Specify the SpaceTimeCube Dimensions
#==============================================================

cube_shape = (
    24,   # bands: 1 day @ 1 hour/band
    1000, # rows:  30 km @ 30 meters/row
    1000, # cols:  30 km @ 30 meters/col
)

#==============================================================
# Create the Dictionary of Layer Names to SpaceTimeCubes
#==============================================================

def make_layer_lookup():
    return {
        # 2D Arrays (e.g. 30m x 30m resolution, 30km x 30km extent)
        "elevation"                    : SpaceTimeCube(cube_shape, elevation_layer),
        "slope"                        : SpaceTimeCube(cube_shape, slope_layer),
        "aspect"                       : SpaceTimeCube(cube_shape, aspect_layer),
        "fuel_model"                   : SpaceTimeCube(cube_shape, fuel_model_layer),
        "canopy_cover"                 : SpaceTimeCube(cube_shape, canopy_cover_layer),
        "canopy_height"                : SpaceTimeCube(cube_shape, canopy_height_layer),
        "canopy_base_height"           : SpaceTimeCube(cube_shape, canopy_base_height_layer),
        "canopy_bulk_density"          : SpaceTimeCube(cube_shape, canopy_bulk_density_layer),
        "fuel_spread_adjustment"       : SpaceTimeCube(cube_shape, fuel_spread_adjustment_layer),       # Optional
        "suppression_difficulty_index" : SpaceTimeCube(cube_shape, suppression_difficulty_index_layer), # Optional

        # 3D Arrays (e.g. 1hr x 300m x 300m resolution, 1day x 30km x 30km extent)
        "temperature"                  : SpaceTimeCube(cube_shape, temperature_layer),
        "relative_humidity"            : SpaceTimeCube(cube_shape, relative_humidity_layer),
        "wind_speed_10m"               : SpaceTimeCube(cube_shape, wind_speed_10m_layer),
        "upwind_direction"             : SpaceTimeCube(cube_shape, upwind_direction_layer),
        "fuel_moisture_dead_1hr"       : SpaceTimeCube(cube_shape, fuel_moisture_dead_1hr_layer),
        "fuel_moisture_dead_10hr"      : SpaceTimeCube(cube_shape, fuel_moisture_dead_10hr_layer),
        "fuel_moisture_dead_100hr"     : SpaceTimeCube(cube_shape, fuel_moisture_dead_100hr_layer),
        "fuel_moisture_live_herbaceous": SpaceTimeCube(cube_shape, fuel_moisture_live_herbaceous_layer),
        "fuel_moisture_live_woody"     : SpaceTimeCube(cube_shape, fuel_moisture_live_woody_layer),
        "foliar_moisture"              : SpaceTimeCube(cube_shape, foliar_moisture_layer),
        "weather_spread_adjustment"    : SpaceTimeCube(cube_shape, weather_spread_adjustment_layer),    # Optional
    }


def test_make_layer_lookup():
    layer_lookup = make_layer_lookup()
    assert all(map(lambda cube: isinstance(cube, SpaceTimeCube), layer_lookup.values()))

#==============================================================
# Looking Up Values in the Layers
#==============================================================

def test_use_layer_lookup_2d():
    layer_lookup = make_layer_lookup()
    dem_100_100  = layer_lookup["elevation"].get(0, 100, 100)
    slp_100_100  = layer_lookup["slope"].get(0, 100, 100)
    asp_100_100  = layer_lookup["aspect"].get(0, 100, 100)
    fbfm_100_100 = layer_lookup["fuel_model"].get(0, 100, 100)
    cc_100_100   = layer_lookup["canopy_cover"].get(0, 100, 100)
    ch_100_100   = layer_lookup["canopy_height"].get(0, 100, 100)
    cbh_100_100  = layer_lookup["canopy_base_height"].get(0, 100, 100)
    cbd_100_100  = layer_lookup["canopy_bulk_density"].get(0, 100, 100)
    fsa_100_100  = layer_lookup["fuel_spread_adjustment"].get(0, 100, 100)           # Optional
    sdi_100_100  = layer_lookup["suppression_difficulty_index"].get(0, 100, 100)     # Optional
    assert dem_100_100  == 100100
    assert slp_100_100  == 100100
    assert asp_100_100  == 100100
    assert fbfm_100_100 == 100100
    assert cc_100_100   == 100100
    assert ch_100_100   == 100100
    assert cbh_100_100  == 100100
    assert cbd_100_100  == 100100
    assert fsa_100_100  == 100100
    assert sdi_100_100  == 100100


def test_use_layer_lookup_3d():
    layer_lookup     = make_layer_lookup()
    temp_12_100_100  = layer_lookup["temperature"].get(12, 100, 100)
    rh_12_100_100    = layer_lookup["relative_humidity"].get(12, 100, 100)
    wsp_12_100_100   = layer_lookup["wind_speed_10m"].get(12, 100, 100)
    wdir_12_100_100  = layer_lookup["upwind_direction"].get(12, 100, 100)
    md1_12_100_100   = layer_lookup["fuel_moisture_dead_1hr"].get(12, 100, 100)
    md10_12_100_100  = layer_lookup["fuel_moisture_dead_10hr"].get(12, 100, 100)
    md100_12_100_100 = layer_lookup["fuel_moisture_dead_100hr"].get(12, 100, 100)
    mlh_12_100_100   = layer_lookup["fuel_moisture_live_herbaceous"].get(12, 100, 100)
    mlw_12_100_100   = layer_lookup["fuel_moisture_live_woody"].get(12, 100, 100)
    fm_12_100_100    = layer_lookup["foliar_moisture"].get(12, 100, 100)
    wsa_12_100_100   = layer_lookup["weather_spread_adjustment"].get(12, 100, 100) # Optional
    assert temp_12_100_100  == 121010
    assert rh_12_100_100    == 121010
    assert wsp_12_100_100   == 121010
    assert wdir_12_100_100  == 121010
    assert md1_12_100_100   == 121010
    assert md10_12_100_100  == 121010
    assert md100_12_100_100 == 121010
    assert mlh_12_100_100   == 121010
    assert mlw_12_100_100   == 121010
    assert fm_12_100_100    == 121010
    assert wsa_12_100_100   == 121010
#+end_src

** Loading LANDFIRE Inputs (pyretechnics.load_landfire)
   :PROPERTIES:
   :CUSTOM_ID: loading-landfire-inputs-(pyretechnics.load_landfire)
   :header-args:python+: :session *pyretechnics.load_landfire*
   :header-args:python+: :tangle  ../src/pyretechnics/load_landfire.py
   :header-args:python+: :exports code
   :END:

In order to use the functions from =pyretechnics.burn_cells= (see
section [[Burning Cells on a Grid (pyretechnics.burn_cells)]]), we must
first create a collection of =SpaceTimeCube= objects, representing all
of the input layers that are needed to describe the simulation
environment. A popular source of data for the space-varying
topography, fuels, and vegetation layers are the 30m raster layers
provided by the US LANDFIRE program[fn::https://landfire.gov] (see
table [[tab:landfire-layers]] for details).

#+NAME: tab:landfire-layers
#+caption: 2022 LANDFIRE Raster Layers
|---------------------+--------+------------------------------------------+-----+------+--------+---------------+-------+-----------+-----------|
| Layer Name          | Label  | Units                                    | Min |  Max | NoData | Notes         | Type  | SRID      | Cell Size |
|---------------------+--------+------------------------------------------+-----+------+--------+---------------+-------+-----------+-----------|
| Elevation           | DEM    | meters above sea level                   |   0 | 8850 |  32767 |               | int16 | EPSG:5070 | 30m x 30m |
| Slope               | SLP    | percent (100 * meters rise / meters run) |   0 |  400 |  32767 |               | int16 | EPSG:5070 | 30m x 30m |
| Aspect              | ASP    | degrees CW from North                    |   0 |  359 |  32767 | -1 = no slope | int16 | EPSG:5070 | 30m x 30m |
| Fuel Model (S&B 40) | FBFM40 | integer classes                          |  91 |  204 |  32767 |               | int16 | EPSG:5070 | 30m x 30m |
| Canopy Cover        | CC     | percent (100 * canopy area / total area) |   0 |   95 |  32767 | 0 = no canopy | int16 | EPSG:5070 | 30m x 30m |
| Canopy Height       | CH     | meters * 10                              |   0 |  510 |  32767 | 0 = no canopy | int16 | EPSG:5070 | 30m x 30m |
| Canopy Base Height  | CBH    | meters * 10                              |   0 |  100 |  32767 | 0 = no canopy | int16 | EPSG:5070 | 30m x 30m |
| Canopy Bulk Density | CBD    | kg/m^3 * 100                             |   0 |   45 |  32767 | 0 = no canopy | int16 | EPSG:5070 | 30m x 30m |
|---------------------+--------+------------------------------------------+-----+------+--------+---------------+-------+-----------+-----------|

For convenience, this section introduces functionality to load these
raster layers from files on disk into a Python dictionary of
=SpaceTimeCube= objects.

*** Module Imports
    :PROPERTIES:
    :CUSTOM_ID: module-imports-load-landfire
    :END:

#+NAME: load-landfire-imports
#+begin_src python
import cython
import numpy as np
import rasterio
if cython.compiled:
    from cython.cimports.pyretechnics.space_time_cube import SpaceTimeCube
else:
    from pyretechnics.space_time_cube import SpaceTimeCube
#+end_src

*** Loading Raster Files with Python Rasterio
    :PROPERTIES:
    :CUSTOM_ID: loading-raster-files-with-python-rasterio
    :END:

We will begin by defining a =load_raster= function that takes a path
to a raster file (e.g., a GeoTIFF) and returns a dictionary containing
these keys:

- array :: raster data as a 3D Numpy array =(bands, rows, cols)= of the specified =dtype= (default: =float32=)
- metadata :: dictionary of raster metadata values (e.g., number of bands/rows/cols, band dtypes, nodata value, georeferencing info)

#+NAME: load-raster
#+begin_src python
def raster_metadata(raster):
    return {
        "name"      : raster.name,
        "bands"     : raster.count,
        "rows"      : raster.height,
        "cols"      : raster.width,
        "band_types": {i: dtype for i, dtype in zip(raster.indexes, raster.dtypes)},
        "nodata"    : raster.nodata,
        "crs"       : raster.crs,
        "bounds"    : raster.bounds,
        "transform" : raster.transform,
    }


# TODO: rasterio.open can also load chunks of a raster file: https://pypi.org/project/rasterio/
def load_raster(file_path, dtype=None):
    with rasterio.open(file_path, "r") as input_raster:
        return {
            "array"   : input_raster.read(out_dtype=dtype),
            "metadata": raster_metadata(input_raster),
        }
#+end_src

*** Converting LANDFIRE Units and Datatypes
    :PROPERTIES:
    :CUSTOM_ID: converting-landfire-units-and-datatypes
    :END:

The units and datatypes of our LANDFIRE GeoTIFFs are documented in
Table [[tab:landfire-layers]]. In order to make them match those required
by the Pyretechnics Fire Spread API, we need to apply some conversions
during the layer loading process.

#+NAME: load-and-convert-landfire-rasters
#+begin_src python
landfire_array_conversions = {
    #==============================================================================
    # Layer Name         : (New dtype, Mult), # New Units                [Min-Max]
    #==============================================================================
    "elevation"          : ("float32", 1.00), # meters above sea level   [0-8850]
    "slope"              : ("float32", 0.01), # meters rise / meters run [0-4]
    "aspect"             : ("int16"  , 1   ), # degrees CW from North    [0-359]
    "fuel_model"         : ("int16"  , 1   ), # integer classes          [1-204]
    "canopy_cover"       : ("float32", 0.01), # canopy area / total area [0-0.95]
    "canopy_height"      : ("float32", 0.10), # meters                   [0-51]
    "canopy_base_height" : ("float32", 0.10), # meters                   [0-10]
    "canopy_bulk_density": ("float32", 0.01), # kilograms/meters^3       [0-0.45]
}


def load_and_convert_landfire_rasters(landfire_file_paths):
    landfire_rasters = {}

    for name, path in landfire_file_paths.items():
        (dtype, multiplier) = landfire_array_conversions[name]
        landfire_rasters[name] = load_raster(path, dtype)
        if multiplier != 1:
            array  = landfire_rasters[name]["array"]
            nodata = landfire_rasters[name]["metadata"]["nodata"]
            array[array != nodata] *= multiplier

    return landfire_rasters
#+end_src

*** Verifying Raster Constraints
    :PROPERTIES:
    :CUSTOM_ID: verifying-raster-constraints
    :END:

In order to work with the Pyretechnics Fire Spread API, all rasters
must meet certain requirements:

1. All rasters must have array shapes =(bands, rows, cols)= that evenly divide a user-specified space-time cube shape =(t,y,x)=.
2. All rasters must share the same spatial extent and projection.

Below we implement functions to check these constraints:

#+NAME: verify-raster-constraints
#+begin_src python
def verify_cube_compatible_dimensions(cube_shape, rasters):
    cube_shape_ = np.asarray(cube_shape)
    for r in rasters:
        raster_shape = np.asarray((r["metadata"]["bands"],
                                   r["metadata"]["rows"],
                                   r["metadata"]["cols"]))
        if any(map(lambda x: x != 0, cube_shape_ % raster_shape)):
            raise ValueError("Some rasters do not evenly divide the space-time cube dimensions.")

    return True


def verify_same_georeferences(rasters):
    georeferences = [
        (r["metadata"]["crs"],
         r["metadata"]["bounds"],
         r["metadata"]["transform"])
        for r in rasters
    ]
    if len(set(georeferences)) == 1:
        return True
    else:
        raise ValueError("All rasters do not share the same georeferences.")


def verify_raster_constraints(cube_shape, rasters):
    return verify_cube_compatible_dimensions(cube_shape, rasters) and verify_same_georeferences(rasters)
#+end_src

*** Converting Rasters to SpaceTimeCubes
    :PROPERTIES:
    :CUSTOM_ID: converting-rasters-to-spacetimecubes
    :END:

Another requirement of the Pyretechnics Fire Spread API is that each
input layer must be specified as a =SpaceTimeCube= or
=LazySpaceTimeCube= object (see section [[Loading Data into the 3D
Space-Time Cube (pyretechnics.space_time_cube)]]). This abstracts away
the underlying data representation (e.g., an ND array, a single
constant value, a random sampling function), allowing many different
sources of information to interoperate through a simple unified
interface.

For our LANDFIRE use case, the following function converts a
dictionary of single-band rasters =(1, rows, cols)= into a dictionary
of =SpaceTimeCube= objects, that always return the same value for each
=(t,y,x)= coordinate regardless of the time value =t= specified in
lookup calls.

#+NAME: convert-rasters-to-space-time-cubes
#+begin_src python
def convert_rasters_to_space_time_cubes(cube_shape, raster_dict):
    fn_dict = {}

    for name, raster in raster_dict.items():
        fn_dict[name] = SpaceTimeCube(cube_shape, raster["array"])

    return fn_dict
#+end_src

*** Putting It All Together
    :PROPERTIES:
    :CUSTOM_ID: putting-it-all-together
    :END:

By combining the functions defined in the previous sections, we can
now read in a dictionary of layer names to file paths, load the
associated rasters and apply the correct dtype and unit conversions,
verify all of our raster constraints, and wrap each raster's array
with a =SpaceTimeCube= object.

#+NAME: read-landfire-rasters-as-space-time-cubes
#+begin_src python
def read_landfire_rasters_as_space_time_cubes(cube_shape, landfire_file_paths):
    landfire_rasters = load_and_convert_landfire_rasters(landfire_file_paths)
    if verify_raster_constraints(cube_shape, landfire_rasters.values()):
        return convert_rasters_to_space_time_cubes(cube_shape, landfire_rasters)
#+end_src

** [WIP] Testing pyretechnics.burn_cells on Worcester, VT (pyretechnics_test.test_burn_cells) :noexport:
   :PROPERTIES:
   :CUSTOM_ID: [wip]-testing-pyretechnics.burn_cells-on-worcester,-vt-(pyretechnics_test.test_burn_cells)
   :header-args:python+: :session *pyretechnics_test.test_burn_cells*
   :header-args:python+: :tangle  ../test/pyretechnics_test/test_burn_cells.py
   :header-args:python+: :exports code
   :END:

*Note:* For testing purposes, we have downloaded the LANDFIRE rasters
described in table [[tab:landfire-layers]], clipped to a small region in
central Vermont, and stored them in the [[file:../test/data/landfire_inputs][../test/data/landfire_inputs]]
directory of this repository.

*** Loading Topography, Fuel Model, and Tree Canopy Inputs from LANDFIRE GeoTIFFs
    :PROPERTIES:
    :CUSTOM_ID: loading-topography,-fuel-model,-and-tree-canopy-inputs-from-landfire-geotiffs
    :END:

We begin by loading in the eight LANDFIRE GeoTIFFs that we downloaded
from https://landfire.gov/, using the function we defined in section
[[Putting It All Together]].

#+NAME: add-landfire-layers-to-test-dataset
#+begin_src python
import os
from pyretechnics.space_time_cube import SpaceTimeCube
from pyretechnics.load_landfire import read_landfire_rasters_as_space_time_cubes


def get_project_root(current_dir=os.curdir):
    """
    Search up the directory tree from current_dir until we find a directory containing guix.scm,
    and return this directory path. If the filesystem root directory (/) is reached, return None.
    """
    if current_dir == "/":
        return None
    elif os.path.exists(current_dir + "/guix.scm"):
        return current_dir
    else:
        return get_project_root(os.path.dirname(os.path.abspath(current_dir)))


project_root = get_project_root()


landfire_file_paths = {
    "elevation"          : project_root + "/test/data/landfire_inputs/LF2020_Elev_220_CONUS/LC20_Elev_220.tif",
    "slope"              : project_root + "/test/data/landfire_inputs/LF2020_SlpP_220_CONUS/LC20_SlpP_220.tif",
    "aspect"             : project_root + "/test/data/landfire_inputs/LF2020_Asp_220_CONUS/LC20_Asp_220.tif",
    "fuel_model"         : project_root + "/test/data/landfire_inputs/LF2022_FBFM40_230_CONUS/LC22_F40_230.tif",
    "canopy_cover"       : project_root + "/test/data/landfire_inputs/LF2022_CC_230_CONUS/LC22_CC_230.tif",
    "canopy_height"      : project_root + "/test/data/landfire_inputs/LF2022_CH_230_CONUS/LC22_CH_230.tif",
    "canopy_base_height" : project_root + "/test/data/landfire_inputs/LF2022_CBH_230_CONUS/LC22_CBH_230.tif",
    "canopy_bulk_density": project_root + "/test/data/landfire_inputs/LF2022_CBD_230_CONUS/LC22_CBD_230.tif",
}


cube_shape = (1, 613, 549) # Matches the resolution of the GeoTIFFs


landfire_cubes = read_landfire_rasters_as_space_time_cubes(cube_shape, landfire_file_paths)


def test_read_landfire_rasters():
    assert type(landfire_cubes) == dict
    assert landfire_cubes.keys() == landfire_file_paths.keys()
    assert all(map(lambda cube: isinstance(cube, SpaceTimeCube), landfire_cubes.values()))
#+end_src

*** Adding Constant Wind and Moisture Values
    :PROPERTIES:
    :CUSTOM_ID: adding-constant-wind-and-moisture-values
    :END:

In order to complete our input dataset for a test run of the
=pyretechnics.burn_cells= functions, we need to provide the remaining
required wind and moisture layers as =SpaceTimeCube= objects. The
following example shows how we can easily set constant values for each
of these layers:

#+NAME: add-constant-wind-and-moisture-to-test-dataset
#+begin_src python
weather_cubes = {
    "wind_speed_10m"               : SpaceTimeCube(cube_shape, 0.00), # km/hr
    "upwind_direction"             : SpaceTimeCube(cube_shape, 0.00), # degrees clockwise from North
    "fuel_moisture_dead_1hr"       : SpaceTimeCube(cube_shape, 0.06), # kg moisture/kg ovendry weight
    "fuel_moisture_dead_10hr"      : SpaceTimeCube(cube_shape, 0.08), # kg moisture/kg ovendry weight
    "fuel_moisture_dead_100hr"     : SpaceTimeCube(cube_shape, 0.10), # kg moisture/kg ovendry weight
    "fuel_moisture_live_herbaceous": SpaceTimeCube(cube_shape, 0.75), # kg moisture/kg ovendry weight
    "fuel_moisture_live_woody"     : SpaceTimeCube(cube_shape, 0.60), # kg moisture/kg ovendry weight
    "foliar_moisture"              : SpaceTimeCube(cube_shape, 1.20), # kg moisture/kg ovendry weight
}


space_time_cubes = landfire_cubes | weather_cubes


def test_add_weather_cubes():
    assert type(space_time_cubes) == dict
    assert set(space_time_cubes.keys()) == set(landfire_file_paths.keys()).union(set(weather_cubes.keys()))
    assert all(map(lambda cube: isinstance(cube, SpaceTimeCube), space_time_cubes.values()))
#+end_src

*** Burning a Single Cell in the Dataset as a Head Fire
    :PROPERTIES:
    :CUSTOM_ID: burning-a-single-cell-in-the-dataset-as-a-head-fire
    :END:

Now that our input layers are all loaded, our next step will be to
make sure that we can burn a single cell as a head fire and get back
meaningful results.

#+NAME: burn-single-cell-in-test-dataset
#+begin_src python
from pyretechnics.burn_cells import burn_cell_as_head_fire


def test_burn_cell_as_head_fire():
    space_time_coordinate = (0, 100, 100) # (t,y,x)
    spread_behavior       = burn_cell_as_head_fire(space_time_cubes,
                                                   space_time_coordinate,
                                                   surface_lw_ratio_model="rothermel")
    assert spread_behavior["fire_type"] == 1 # surface
    assert spread_behavior["spread_rate"]         - 0.32044995422500555 < 0.001
    assert spread_behavior["spread_direction"][0] - 0.644528432121562   < 0.001
    assert spread_behavior["spread_direction"][1] - 0.7414451458683358  < 0.001
    assert spread_behavior["spread_direction"][2] - 0.18666064356259804 < 0.001
    assert spread_behavior["fireline_intensity"]  - 26.66139842420774   < 0.001
    assert spread_behavior["flame_length"]        - 0.3507858529698898  < 0.001
#+end_src

*** Burning All Cells in the Dataset as a Head Fire
    :PROPERTIES:
    :CUSTOM_ID: burning-all-cells-in-the-dataset-as-a-head-fire
    :END:

#+NAME: burn-all-cells-in-test-dataset
#+begin_src python
import numpy as np
from pyretechnics.burn_cells import burn_all_cells_as_head_fire

def test_burn_all_cells_as_head_fire():
    spread_behavior = burn_all_cells_as_head_fire(space_time_cubes,
                                                  0,
                                                  surface_lw_ratio_model="rothermel")
    assert all(map(lambda matrix: isinstance(matrix, np.ndarray), spread_behavior.values()))
#+end_src

*** Comparing Pyretechnics Outputs with FLAMMAP Outputs
    :PROPERTIES:
    :CUSTOM_ID: comparing-pyretechnics-outputs-with-flammap-outputs
    :END:

#+NAME: load-flammap-outputs
#+begin_src python
from math import pi
from pyretechnics.load_landfire import load_raster, verify_raster_constraints


flammap_file_paths = {
    "max_fire_type"         : project_root + "/test/data/flammap_outputs/fire_type.tif",
    "max_spread_rate"       : project_root + "/test/data/flammap_outputs/ROS_ch_hr.tif",
    "max_spread_direction"  : project_root + "/test/data/flammap_outputs/max_spread_direction_radians.tif",
    "max_fireline_intensity": project_root + "/test/data/flammap_outputs/FLI_BTU_ft-s.tif",
    "max_flame_length"      : project_root + "/test/data/flammap_outputs/FL_ft.tif",
}


flammap_array_conversions = {
    #====================================================================================
    # Layer Name            : (New dtype, Mult),                # In Units -> Out Units
    #====================================================================================
    "max_fire_type"         : ("uint8"  , 1.0),                 # 0=unburned,1=surface,2=passive_crown,3=active_crown
    "max_spread_rate"       : ("float32", 0.33528),             # ch/hr -> m/min
    "max_spread_direction"  : ("float32", 180.0 / pi),          # radians -> degrees
    "max_fireline_intensity": ("float32", 3.46165186),          # Btu/ft/s -> kW/m
    "max_flame_length"      : ("float32", 0.30478512648582745), # ft -> m
}


def load_and_convert_flammap_rasters(flammap_file_paths):
    flammap_rasters = {}

    for name, path in flammap_file_paths.items():
        (dtype, multiplier)    = flammap_array_conversions[name]
        flammap_rasters[name]  = load_raster(path, dtype)
        array                  = flammap_rasters[name]["array"]
        nodata                 = flammap_rasters[name]["metadata"]["nodata"]
        array[array == nodata] = 0
        if multiplier != 1:
            array *= multiplier

    return flammap_rasters


def read_flammap_outputs(flammap_file_paths):
    cube_shape  = (1, 613, 549) # Matches the resolution of the GeoTIFFs
    raster_dict = load_and_convert_flammap_rasters(flammap_file_paths)
    if verify_raster_constraints(cube_shape, raster_dict.values()):
        return {name: raster["array"] for name, raster in raster_dict.items()}


def test_read_flammap_outputs():
    flammap_outputs = read_flammap_outputs(flammap_file_paths)
    assert all(map(lambda matrix: isinstance(matrix, np.ndarray), flammap_outputs.values()))
#+end_src

** [WIP] Visualizing the Burned Layers :noexport:
   :PROPERTIES:
   :CUSTOM_ID: [wip]-visualizing-the-burned-layers
   :header-args:python+: :session *view-worcester-layers*
   :header-args:python+: :exports code
   :END:

#+NAME: compute-worcester-burned-layers
#+begin_src python
import matplotlib.pyplot as plt
# import numpy as np
from pyretechnics_test.test_burn_cells import test_burn_all_cells_as_head_fire, test_read_flammap_outputs


pyretechnics = test_burn_all_cells_as_head_fire()
flammap      = test_read_flammap_outputs()


def savefig(title, layer, units, colors):
    title     = "Worcester, VT - " + title
    file_name = "pics/worcester_" + layer + ".png"
    image     = plt.imshow(pyretechnics[layer], cmap=colors)
    # image     = plt.imshow(flammap[layer][0], cmap=colors)
    # image     = plt.imshow(pyretechnics[layer] - flammap[layer][0], cmap=colors)
    # copy      = np.zeros((613, 549))
    # copy[crown_fire == 0] = (pyretechnics[layer][crown_fire == 0] - flammap[layer][0][crown_fire == 0])
    # image     = plt.imshow(copy, clim=(-0.05,0.05))
    colorbar  = plt.colorbar(image, orientation="vertical")
    colorbar.set_label(units)
    plt.title(title)
    plt.savefig(file_name)
    plt.close("all")
    return file_name

savefig(title="Max Fire Type", layer="max_fire_type", units="0=unburned,1=surface,2=passive_crown,3=active_crown", colors="viridis")
savefig(title="Max Spread Rate", layer="max_spread_rate", units="m/min", colors="hot")
savefig(title="Max Spread Direction", layer="max_spread_direction", units="degrees", colors="viridis")
savefig(title="Max Fireline Intensity", layer="max_fireline_intensity", units="kW/m", colors="hot")
savefig(title="Max Flame Length", layer="max_flame_length", units="m", colors="hot")
#+end_src

#+NAME: max-fire-behavior-matplotlib-heatmaps
#+caption: Max fire behavior attributes
|------------------------------------------------+----------------------------------------------|
|                                                | file:pics/worcester_max_fire_type.png        |
| file:pics/worcester_max_spread_rate.png        | file:pics/worcester_max_spread_direction.png |
| file:pics/worcester_max_fireline_intensity.png | file:pics/worcester_max_flame_length.png     |
|------------------------------------------------+----------------------------------------------|

# #+begin_src python
# frq, edges = np.histogram(copy)
# fig, ax = plt.subplots()
# ax.bar(edges[:-1], frq, width=np.diff(edges), edgecolor="black", align="edge")
# plt.savefig("pics/worcester_max_spread_rate_diff.png")
# #+end_src

Layer Disagreement: [-10.93608, 8.9857025] inches/min
