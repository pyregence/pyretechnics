#+TITLE: The Pyretechnics Fire Behavior Library
#+AUTHOR: Gary W. Johnson, Valentin Waeselynck, Chris Lautenberger
#+DATE: Copyright Â© 2023-2024 Spatial Informatics Group, LLC
#+OPTIONS: ^:{} toc:nil h:3
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [11pt]
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{amsfonts}
#+LATEX_HEADER: \usepackage{amssymb}
#+LATEX_HEADER: \usepackage{fancyhdr}
#+LATEX_HEADER: \usepackage[top=1in,bottom=1in,left=0.75in,right=0.75in]{geometry}
#+LATEX_HEADER: \usepackage{geometry}
#+LATEX_HEADER: \pagestyle{fancyplain}
#+LATEX_HEADER: \usepackage{wrapfig}
#+LATEX_HEADER: \usepackage{subfigure}
#+LATEX_HEADER: \usepackage{setspace}
#+LATEX_HEADER: \usepackage{epsfig}
#+LATEX_HEADER: \usepackage{color}
#+LATEX_HEADER: \usepackage[round,comma]{natbib}
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usetikzlibrary{calc}
#+LATEX_HEADER: \usepackage{cancel}
#+LATEX_HEADER: \setlength{\headheight}{13.6pt}
#+LATEX_HEADER: \hypersetup{
#+LATEX_HEADER:     colorlinks=true,
#+LATEX_HEADER:     citecolor=black,
#+LATEX_HEADER:     linkbordercolor=black,
#+LATEX_HEADER:     linkcolor=black}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \graphicspath{{pics/}}
#+LATEX_HEADER: \DeclareUnicodeCharacter{394}{$\Delta$}
#+LATEX_HEADER: \DeclareUnicodeCharacter{3C7}{$\chi$}

* Preface

This document is a Literate
Program[fn::https://en.wikipedia.org/wiki/Literate_programming],
containing both the source code of the software it describes as well
as the rationale used in each step of its design and implementation.
The purpose of this approach is to enable anyone sufficiently
experienced in programming to easily retrace the author's footsteps as
they read through the text and code. By the time they have reached the
end of this document, the reader should have just as strong a grasp of
the system as the original programmer.

To execute the code illustrated within this document, you will need to
install several pieces of software, all of which are open source
and/or freely available for all major operating systems. These
programs are listed in Table [[tab:required-software]] along with their
minimum required versions and URLs from which they may be downloaded.

#+NAME: tab:required-software
#+CAPTION: Software necessary to evaluate the code in this document
#+ATTR_LATEX: :align |l|r|l| :font \small
|--------+---------+-----------------------------------|
| Name   | Version | URL                               |
|--------+---------+-----------------------------------|
| Python | 3.x     | https://www.python.org/downloads/ |
| Numpy  | LATEST  | https://numpy.org/                |
|--------+---------+-----------------------------------|

* Data Model
** Lazy-Loading Multi-Resolution Array Lookup Functions

#+begin_src python :tangle ../src/pyretechnics/lazy_array.py
import numpy as np

#==============================================================
# Lazy-Loading Multi-Resolution Array Lookup Functions
#==============================================================

def translate_coords_2d(coords_2d, simulation_shape_2d, layer_shape_2d, chunk_shape_2d):
    """
    Given row y and column x on the simulation grid, return chunk
    row cy, chunk column cx, subchunk row c_y, and subchunk column c_x on
    the chunk grid.
    NOTE: (y,x) = (0,0) is the upper-left corner of the array.
    NOTE: simulation_shape_2d >= layer_shape_2d >= chunk_shape_2d
    """
    (y, x) = coords_2d
    (simulation_rows, simulation_cols) = simulation_shape_2d
    (layer_rows, layer_cols) = layer_shape_2d
    (chunk_rows, chunk_cols) = chunk_shape_2d
    ly = y // (simulation_rows // layer_rows)
    lx = x // (simulation_cols // layer_cols)
    cy  = ly // chunk_rows
    cx  = lx // chunk_cols
    c_y = ly % chunk_rows
    c_x = lx % chunk_cols
    return (cy, cx, c_y, c_x)

def translate_coords_3d(coords_3d, simulation_shape_3d, layer_shape_3d, chunk_shape_3d):
    """
    Given band z, row y, and column x on the simulation grid,
    return chunk band cz, chunk row cy, chunk column cx, subchunk band
    c_z, subchunk row c_y, and subchunk column c_x on the chunk grid.
    NOTE: (z,y,x) = (0,0,0) is the upper-left corner of the array in the first timestep.
    NOTE: simulation_shape_3d >= layer_shape_3d >= chunk_shape_3d
    """
    (z, y, x) = coords_3d
    (simulation_bands, simulation_rows, simulation_cols) = simulation_shape_3d
    (layer_bands, layer_rows, layer_cols) = layer_shape_3d
    (chunk_bands, chunk_rows, chunk_cols) = chunk_shape_3d
    lz = z // (simulation_bands // layer_bands)
    ly = y // (simulation_rows // layer_rows)
    lx = x // (simulation_cols // layer_cols)
    cz  = lz // chunk_bands
    cy  = ly // chunk_rows
    cx  = lx // chunk_cols
    c_z = lz % chunk_bands
    c_y = ly % chunk_rows
    c_x = lx % chunk_cols
    return (cz, cy, cx, c_z, c_y, c_x)

def get_or_load_chunk_2d(chunk_cache_2d, cy, cx, load_chunk_2d):
    """
    Checks whether chunk_cache_2d contains chunk (cy, cx). If so,
    return it. Otherwise, call load_chunk_2d(cy, cx) to retrieve it,
    store it in chunk_cache_2d, and return it.
    """
    chunk_2d = chunk_cache_2d[cy, cx]
    if (type(chunk_2d) == np.ndarray):
        return chunk_2d
    else:
        chunk_2d = load_chunk_2d(cy, cx)
        chunk_cache_2d[cy, cx] = chunk_2d
        return chunk_2d

def get_or_load_chunk_3d(chunk_cache_3d, cz, cy, cx, load_chunk_3d):
    """
    Checks whether chunk_cache_3d contains chunk (cz, cy, cx). If so,
    return it. Otherwise, call load_chunk_3d(cz, cy, cx) to retrieve it,
    store it in chunk_cache_3d, and return it.
    """
    chunk_3d = chunk_cache_3d[cz, cy, cx]
    if (type(chunk_3d) == np.ndarray):
        return chunk_3d
    else:
        chunk_3d = load_chunk_3d(cz, cy, cx)
        chunk_cache_3d[cz, cy, cx] = chunk_3d
        return chunk_3d

def at_coords_2d(coords_2d, simulation_shape_2d, layer_shape_2d, chunk_shape_2d, chunk_cache_2d, load_chunk_2d):
    """
    Given row y and column x on the simulation grid, return the
    value at that index in the underlying chunk cache.
    NOTE: (y,x) = (0,0) is the upper-left corner of the array.
    """
    (cy, cx, c_y, c_x) = translate_coords_2d(coords_2d, simulation_shape_2d, layer_shape_2d, chunk_shape_2d)
    chunk_2d = get_or_load_chunk_2d(chunk_cache_2d, cy, cx, load_chunk_2d)
    return chunk_2d[c_y, c_x]

def at_coords_3d(coords_3d, simulation_shape_3d, layer_shape_3d, chunk_shape_3d, chunk_cache_3d, load_chunk_3d):
    """
    Given band z, row y, and column x on the simulation grid,
    return the value at that index in the underlying chunk cache.
    NOTE: (z,y,x) = (0,0,0) is the upper-left corner of the array in the first timestep.
    """
    (cz, cy, cx, c_z, c_y, c_x) = translate_coords_3d(coords_3d, simulation_shape_3d, layer_shape_3d, chunk_shape_3d)
    chunk_3d = get_or_load_chunk_3d(chunk_cache_3d, cz, cy, cx, load_chunk_3d)
    return chunk_3d[c_z, c_y, c_x]

#==============================================================
# Constructor: Returns a 2D/3D Lookup Function for One Array
#==============================================================

def make_lookup_fn_2d(simulation_shape_2d, layer_shape_2d, chunk_shape_2d, load_chunk_2d):
    """
    Given the array shapes of the simulation space (|Y|,|X|), the
    underlying data layer (|LY|,|LX|), and a single chunk within the
    chunk cache (|CY|,|CX|) as well as a function to load one chunk
    on demand, return a closure that will retrieve the value from the
    underlying data layer corresponding to coordinate (y,x) in the
    simulation space. Chunks will be loaded on demand using load_chunk_2d.
    NOTE: (y,x) = (0,0) is the upper-left corner of the array.
    NOTE: simulation_shape_2d >= layer_shape_2d >= chunk_shape_2d
    """
    (layer_rows, layer_cols) = layer_shape_2d
    (chunk_rows, chunk_cols) = chunk_shape_2d
    chunk_cache_2d = np.empty((layer_rows // chunk_rows,
                               layer_cols // chunk_cols),
                              dtype=object)
    return lambda y, x: at_coords_2d((y, x),
                                     simulation_shape_2d,
                                     layer_shape_2d,
                                     chunk_shape_2d,
                                     chunk_cache_2d,
                                     load_chunk_2d)

def make_lookup_fn_3d(simulation_shape_3d, layer_shape_3d, chunk_shape_3d, load_chunk_3d):
    """
    Given the array shapes of the simulation space (|Z|,|Y|,|X|), the
    underlying data layer (|LZ|,|LY|,|LX|), and a single chunk within the
    chunk cache (|CZ|,|CY|,|CX|) as well as a function to load one chunk
    on demand, return a closure that will retrieve the value from the
    underlying data layer corresponding to coordinate (z,y,x) in the
    simulation space. Chunks will be loaded on demand using load_chunk_3d.
    NOTE: (z,y,x) = (0,0,0) is the upper-left corner of the array in the first timestep.
    NOTE: simulation_shape_3d >= layer_shape_3d >= chunk_shape_3d
    """
    (layer_bands, layer_rows, layer_cols) = layer_shape_3d
    (chunk_bands, chunk_rows, chunk_cols) = chunk_shape_3d
    chunk_cache_3d = np.empty((layer_bands // chunk_bands,
                               layer_rows // chunk_rows,
                               layer_cols // chunk_cols),
                              dtype=object)
    return lambda z, y, x: at_coords_3d((z, y, x),
                                        simulation_shape_3d,
                                        layer_shape_3d,
                                        chunk_shape_3d,
                                        chunk_cache_3d,
                                        load_chunk_3d)
#+end_src

** Lazy Array Usage Examples

#+begin_src python :tangle ../test/pyretechnics/lazy_array_test.py
import numpy as np
from pyretechnics.lazy_array import make_lookup_fn_2d, make_lookup_fn_3d

#==============================================================
# Raw Data - managed by the caller
#==============================================================

# 2D Arrays (e.g. 30m x 30m resolution, 30km x 30km extent)
elevation_layer                    = np.arange(0,1000000).reshape(1000,1000)
slope_layer                        = np.arange(0,1000000).reshape(1000,1000)
aspect_layer                       = np.arange(0,1000000).reshape(1000,1000)
fuel_model_layer                   = np.arange(0,1000000).reshape(1000,1000)
canopy_cover_layer                 = np.arange(0,1000000).reshape(1000,1000)
canopy_height_layer                = np.arange(0,1000000).reshape(1000,1000)
canopy_base_height_layer           = np.arange(0,1000000).reshape(1000,1000)
canopy_bulk_density_layer          = np.arange(0,1000000).reshape(1000,1000)
time_of_arrival_layer              = np.arange(0,1000000).reshape(1000,1000) # Optional Layer
suppression_difficulty_index_layer = np.arange(0,1000000).reshape(1000,1000) # Optional Layer
fuel_spread_adjustment_layer       = np.arange(0,1000000).reshape(1000,1000) # Optional Layer

# 3D Arrays (e.g. 1hr x 300m x 300m resolution, 1day x 30km x 30km extent)
temperature_layer                   = np.arange(240000).reshape(24,100,100)
relative_humidity_layer             = np.arange(240000).reshape(24,100,100)
wind_speed_layer                    = np.arange(240000).reshape(24,100,100)
wind_direction_layer                = np.arange(240000).reshape(24,100,100)
fuel_moisture_dead_1hr_layer        = np.arange(240000).reshape(24,100,100)
fuel_moisture_dead_10hr_layer       = np.arange(240000).reshape(24,100,100)
fuel_moisture_dead_100hr_layer      = np.arange(240000).reshape(24,100,100)
fuel_moisture_live_herbaceous_layer = np.arange(240000).reshape(24,100,100)
fuel_moisture_live_woody_layer      = np.arange(240000).reshape(24,100,100)
foliar_moisture_layer               = np.arange(240000).reshape(24,100,100)
weather_spread_adjustment_layer     = np.arange(240000).reshape(24,100,100) # Optional Layer

#==============================================================
# Chunk Loading Functions
#==============================================================

def make_load_chunk_2d(layer_2d, chunk_shape_2d):
    """
    Example 2D chunk loading function. Since we are calling the
    lazy array functions from Python and they will be used as
    read-only data by the caller, we can just provide a sliced view of
    the underlying array rather than generating a copy.
    """
    (chunk_rows, chunk_cols) = chunk_shape_2d
    return lambda cy, cx: layer_2d[cy * chunk_rows : (cy + 1) * chunk_rows,
                                   cx * chunk_cols : (cx + 1) * chunk_cols]

def make_load_chunk_3d(layer_3d, chunk_shape_3d):
    """
    Example 3D chunk loading function. Since we are calling the
    lazy array functions from Python and they will be used as
    read-only data by the caller, we can just provide a sliced view of
    the underlying array rather than generating a copy.
    """
    (chunk_bands, chunk_rows, chunk_cols) = chunk_shape_3d
    return lambda cz, cy, cx: layer_3d[cz * chunk_bands : (cz + 1) * chunk_bands,
                                       cy * chunk_rows  : (cy + 1) * chunk_rows,
                                       cx * chunk_cols  : (cx + 1) * chunk_cols]

#==============================================================
# Creating the Dictionary of Layer Names to Lookup Functions
#==============================================================

#--------------------  bands, rows, cols
simulation_shape_2d = (       1000, 1000)
layer_shape_2d      = (       1000, 1000)
chunk_shape_2d      = (        100,  100)

simulation_shape_3d = (   24, 1000, 1000)
layer_shape_3d      = (   24,  100,  100)
chunk_shape_3d      = (    1,   10,   10)

# Partial Application Functions
def make_lookup_fn_2d_for_layer(layer_2d):
    make_lookup_fn_2d(simulation_shape_2d,
                      layer_shape_2d,
                      chunk_shape_2d,
                      make_load_chunk_2d(layer_2d, chunk_shape_2d))

def make_lookup_fn_3d_for_layer(layer_3d):
    make_lookup_fn_3d(simulation_shape_3d,
                      layer_shape_3d,
                      chunk_shape_3d,
                      make_load_chunk_3d(layer_3d, chunk_shape_3d))

# Layer Dictionary
layer_lookup = {
    # 2D Arrays (e.g. 30m x 30m resolution, 30km x 30km extent)
    "elevation"                    : make_lookup_fn_2d_for_layer(elevation_layer),
    "slope"                        : make_lookup_fn_2d_for_layer(slope_layer),
    "aspect"                       : make_lookup_fn_2d_for_layer(aspect_layer),
    "fuel_model"                   : make_lookup_fn_2d_for_layer(fuel_model_layer),
    "canopy_cover"                 : make_lookup_fn_2d_for_layer(canopy_cover_layer),
    "canopy_height"                : make_lookup_fn_2d_for_layer(canopy_height_layer),
    "canopy_base_height"           : make_lookup_fn_2d_for_layer(canopy_base_height_layer),
    "canopy_bulk_density"          : make_lookup_fn_2d_for_layer(canopy_bulk_density_layer),
    "time_of_arrival"              : make_lookup_fn_2d_for_layer(time_of_arrival_layer),              # Optional Layer
    "suppression_difficulty_index" : make_lookup_fn_2d_for_layer(suppression_difficulty_index_layer), # Optional Layer
    "fuel_spread_adjustment"       : make_lookup_fn_2d_for_layer(fuel_spread_adjustment_layer),       # Optional Layer

    # 3D Arrays (e.g. 1hr x 300m x 300m resolution, 1day x 30km x 30km extent)
    "temperature"                  : make_lookup_fn_3d_for_layer(temperature_layer),
    "relative_humidity"            : make_lookup_fn_3d_for_layer(relative_humidity_layer),
    "wind_speed"                   : make_lookup_fn_3d_for_layer(wind_speed_layer),
    "wind_direction"               : make_lookup_fn_3d_for_layer(wind_direction_layer),
    "fuel_moisture_dead_1hr"       : make_lookup_fn_3d_for_layer(fuel_moisture_dead_1hr_layer),
    "fuel_moisture_dead_10hr"      : make_lookup_fn_3d_for_layer(fuel_moisture_dead_10hr_layer),
    "fuel_moisture_dead_100hr"     : make_lookup_fn_3d_for_layer(fuel_moisture_dead_100hr_layer),
    "fuel_moisture_live_herbaceous": make_lookup_fn_3d_for_layer(fuel_moisture_live_herbaceous_layer),
    "fuel_moisture_live_woody"     : make_lookup_fn_3d_for_layer(fuel_moisture_live_woody_layer),
    "foliar_moisture"              : make_lookup_fn_3d_for_layer(foliar_moisture_layer),
    "weather_spread_adjustment"    : make_lookup_fn_3d_for_layer(weather_spread_adjustment_layer),    # Optional Layer
}

#==============================================================
# Looking Up Values in the Layers
#==============================================================

# NOTE: 2D coords should be provided as (y,x) in simulation space.

dem_100_100  = layer_lookup["elevation"](100,100)
slp_100_100  = layer_lookup["slope"](100,100)
asp_100_100  = layer_lookup["aspect"](100,100)
fbfm_100_100 = layer_lookup["fuel_model"](100,100)
cc_100_100   = layer_lookup["canopy_cover"](100,100)
ch_100_100   = layer_lookup["canopy_height"](100,100)
cbh_100_100  = layer_lookup["canopy_base_height"](100,100)
cbd_100_100  = layer_lookup["canopy_bulk_density"](100,100)
toa_100_100  = layer_lookup["time_of_arrival"](100,100)                  # Optional Layer
sdi_100_100  = layer_lookup["suppression_difficulty_index"](100,100)     # Optional Layer
fsa_100_100  = layer_lookup["fuel_spread_adjustment"](100,100)           # Optional Layer

# NOTE: 3D coords should be provided as (z,y,x) in simulation space.

temp_12_100_100  = layer_lookup["temperature"](12,100,100)
rh_12_100_100    = layer_lookup["relative_humidity"](12,100,100)
wsp_12_100_100   = layer_lookup["wind_speed"](12,100,100)
wd_12_100_100    = layer_lookup["wind_direction"](12,100,100)
md1_12_100_100   = layer_lookup["fuel_moisture_dead_1hr"](12,100,100)
md10_12_100_100  = layer_lookup["fuel_moisture_dead_10hr"](12,100,100)
md100_12_100_100 = layer_lookup["fuel_moisture_dead_100hr"](12,100,100)
mlh_12_100_100   = layer_lookup["fuel_moisture_live_herbaceous"](12,100,100)
mlw_12_100_100   = layer_lookup["fuel_moisture_live_woody"](12,100,100)
fm_12_100_100    = layer_lookup["foliar_moisture"](12,100,100)
wsa_12_100_100   = layer_lookup["weather_spread_adjustment"](12,100,100) # Optional Layer
#+end_src

* Fire Spread Functions

#+begin_src python :tangle ../src/pyretechnics/fire_spread.py
#==============================================================
# Fire Spread Functions
#==============================================================

# FIXME: stub
# RESUME HERE: [[file:~/code/sig-gis/gridfire/src/gridfire/simulations.clj::(defn run-simulation!]]
def burn_cells(config_dict, input_layer_dict, output_layer_dict, ignited_cells_set):
    """
    1. Validate inputs
       - Make sure that all required parameters are present in config_dict (like spec-checking config.edn)
         - simulation_shape (z,y,x) = (int bands, int rows, int cols)
         - simulation_resolution (z,y,x) = (minutes, meters, meters)
         - simulation_north_angle (default: 0)
         - simulation_start_time (minute)
         - simulation_stop_condition (max_burn_duration: mins, max_burned_area: m^2)
         - random_generator (MUTABLE!)
         - ellipse_adjustment_factor (not needed by ELMFIRE)
         - alpha_suppression:
           - suppression_dt
           - suppression_coefficient
         - sdi_suppression:
           - suppression_dt
           - sdi_sensitivity_to_difficulty
           - sdi_containment_overwhelming_area_growth_rate
           - sdi_reference_suppression_speed
         - modify_outputs (True, False)
       - Make sure that all required entries are present in layer_dict
         - Document raster layer units
           - include metric/imperial units and relevant multipliers
           - user has to get these right, no checking!
           - don't forget to remind them about angular corrections to wind and aspect if the projection isn't oriented to due North
         - Check for entries in output_layer_dict; if present, copy/use as new output layers
         - Use time of arrival raster to identify the burn scar(s); if missing, we are simulating point ignitions
       - Specify 3D space-time points in ignited_cells_set = (minute, row, col)
       - The simulation will return a dictionary with these fields:
         - simulation_stop_time (minute)
         - simulation_stop_condition_encountered (max_burn_duration, max_burned_area, no_burnable_fuel, end_of_temporal_data, fully_suppressed)
         - ignited_cells_set (returning the actively burning cells allows someone to restart the simulation from this point)
         - output_layer_dict: (should we split up surface and crown matrices or combine them?)
           - spread_rate_matrix
           - spread_direction_matrix
           - flame_length_matrix
           - fire_line_intensity_matrix
           - fire_type_matrix
           - ember_count_matrix
           - time_of_arrival_matrix
    2. Create input parameter dictionary
       - load rasters
       - load ignitions
       - compute samples
       - apply perturbations
       - load ignition/weather start times and burn periods
       - load suppression parameters
       - add spread rate adjustment factors
    3. Load data for the ignited area without a buffer
    4. Burn all the ignited cells
    5. Return a dictionary of the output strings to their corresponding 2D matrices
    """
    return None

# FIXME: stub
def spread(layer_dict, ignited_cells_set, outputs_list, stop_condition):
    """
    1. Validate inputs
    2. Load data for the ignited area plus a buffer size (user-specified?)
    3. Perform constant spread out over the landscape in all directions
       - Run surface, crown, and spot equations per ignited cell
    4. Record the time-of-arrival (ignition-time) in each cell as it spreads
    5. Load more data whenever the buffer extent is exceeded or stop spreading if no more data is available
    6. Continue until a stop condition is met (max burn duration or max fire size)
    7. Return a dictionary of the output strings to their corresponding 2D matrices (start with time-of-arrival)
    """
    return None
#+end_src
