#+TITLE: The Pyretechnics Fire Behavior Library
#+AUTHOR: Gary W. Johnson, Valentin Waeselynck, Chris Lautenberger
#+DATE: Copyright Â© 2023-2024 Spatial Informatics Group, LLC
#+OPTIONS: ^:{} toc:nil h:3
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [11pt]
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{amsfonts}
#+LATEX_HEADER: \usepackage{amssymb}
#+LATEX_HEADER: \usepackage{fancyhdr}
#+LATEX_HEADER: \usepackage[top=1in,bottom=1in,left=0.75in,right=0.75in]{geometry}
#+LATEX_HEADER: \usepackage{geometry}
#+LATEX_HEADER: \pagestyle{fancyplain}
#+LATEX_HEADER: \usepackage{wrapfig}
#+LATEX_HEADER: \usepackage{subfigure}
#+LATEX_HEADER: \usepackage{setspace}
#+LATEX_HEADER: \usepackage{epsfig}
#+LATEX_HEADER: \usepackage{color}
#+LATEX_HEADER: \usepackage[round,comma]{natbib}
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usetikzlibrary{calc}
#+LATEX_HEADER: \usepackage{cancel}
#+LATEX_HEADER: \setlength{\headheight}{13.6pt}
#+LATEX_HEADER: \hypersetup{
#+LATEX_HEADER:     colorlinks=true,
#+LATEX_HEADER:     citecolor=black,
#+LATEX_HEADER:     linkbordercolor=black,
#+LATEX_HEADER:     linkcolor=black}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \graphicspath{{pics/}}
#+LATEX_HEADER: \DeclareUnicodeCharacter{394}{$\Delta$}
#+LATEX_HEADER: \DeclareUnicodeCharacter{3C7}{$\chi$}

* Preface

This document is a Literate
Program[fn::https://en.wikipedia.org/wiki/Literate_programming],
containing both the source code of the software it describes as well
as the rationale used in each step of its design and implementation.
The purpose of this approach is to enable anyone sufficiently
experienced in programming to easily retrace the author's footsteps as
they read through the text and code. By the time they have reached the
end of this document, the reader should have just as strong a grasp of
the system as the original programmer.

To execute the code illustrated within this document, you will need to
install several pieces of software, all of which are open source
and/or freely available for all major operating systems. These
programs are listed in Table [[tab:required-software]] along with their
minimum required versions and URLs from which they may be downloaded.

#+NAME: tab:required-software
#+CAPTION: Software necessary to evaluate the code in this document
#+ATTR_LATEX: :align |l|r|l| :font \small
|--------+---------+-----------------------------------|
| Name   | Version | URL                               |
|--------+---------+-----------------------------------|
| Python | 3.x     | https://www.python.org/downloads/ |
| Numpy  | LATEST  | https://numpy.org/                |
|--------+---------+-----------------------------------|

* Data Model
** Lazy-Loading Multi-Resolution Array Lookup Functions

#+begin_src python :tangle ../src/pyretechnics/lazy_array.py
import numpy as np

#==============================================================
# Lazy-Loading Multi-Resolution Array Lookup Functions
#==============================================================

def translate_coords_2d(coords_2d, simulation_shape_2d, layer_shape_2d, chunk_shape_2d):
    """
    Given row y and column x on the simulation grid, return chunk
    row cy, chunk column cx, subchunk row c_y, and subchunk column c_x on
    the chunk grid.
    NOTE: (y,x) = (0,0) is the upper-left corner of the array.
    NOTE: simulation_shape_2d >= layer_shape_2d >= chunk_shape_2d
    """
    (y, x) = coords_2d
    (simulation_rows, simulation_cols) = simulation_shape_2d
    (layer_rows, layer_cols) = layer_shape_2d
    (chunk_rows, chunk_cols) = chunk_shape_2d
    ly = y // (simulation_rows // layer_rows)
    lx = x // (simulation_cols // layer_cols)
    cy  = ly // chunk_rows
    cx  = lx // chunk_cols
    c_y = ly % chunk_rows
    c_x = lx % chunk_cols
    return (cy, cx, c_y, c_x)

def translate_coords_3d(coords_3d, simulation_shape_3d, layer_shape_3d, chunk_shape_3d):
    """
    Given band z, row y, and column x on the simulation grid,
    return chunk band cz, chunk row cy, chunk column cx, subchunk band
    c_z, subchunk row c_y, and subchunk column c_x on the chunk grid.
    NOTE: (z,y,x) = (0,0,0) is the upper-left corner of the array in the first timestep.
    NOTE: simulation_shape_3d >= layer_shape_3d >= chunk_shape_3d
    """
    (z, y, x) = coords_3d
    (simulation_bands, simulation_rows, simulation_cols) = simulation_shape_3d
    (layer_bands, layer_rows, layer_cols) = layer_shape_3d
    (chunk_bands, chunk_rows, chunk_cols) = chunk_shape_3d
    lz = z // (simulation_bands // layer_bands)
    ly = y // (simulation_rows // layer_rows)
    lx = x // (simulation_cols // layer_cols)
    cz  = lz // chunk_bands
    cy  = ly // chunk_rows
    cx  = lx // chunk_cols
    c_z = lz % chunk_bands
    c_y = ly % chunk_rows
    c_x = lx % chunk_cols
    return (cz, cy, cx, c_z, c_y, c_x)

def get_or_load_chunk_2d(chunk_cache_2d, cy, cx, load_chunk_2d):
    """
    Checks whether chunk_cache_2d contains chunk (cy, cx). If so,
    return it. Otherwise, call load_chunk_2d(cy, cx) to retrieve it,
    store it in chunk_cache_2d, and return it.
    """
    chunk_2d = chunk_cache_2d[cy, cx]
    if (type(chunk_2d) == np.ndarray):
        return chunk_2d
    else:
        chunk_2d = load_chunk_2d(cy, cx)
        chunk_cache_2d[cy, cx] = chunk_2d
        return chunk_2d

def get_or_load_chunk_3d(chunk_cache_3d, cz, cy, cx, load_chunk_3d):
    """
    Checks whether chunk_cache_3d contains chunk (cz, cy, cx). If so,
    return it. Otherwise, call load_chunk_3d(cz, cy, cx) to retrieve it,
    store it in chunk_cache_3d, and return it.
    """
    chunk_3d = chunk_cache_3d[cz, cy, cx]
    if (type(chunk_3d) == np.ndarray):
        return chunk_3d
    else:
        chunk_3d = load_chunk_3d(cz, cy, cx)
        chunk_cache_3d[cz, cy, cx] = chunk_3d
        return chunk_3d

def at_coords_2d(coords_2d, simulation_shape_2d, layer_shape_2d, chunk_shape_2d, chunk_cache_2d, load_chunk_2d):
    """
    Given row y and column x on the simulation grid, return the
    value at that index in the underlying chunk cache.
    NOTE: (y,x) = (0,0) is the upper-left corner of the array.
    """
    (cy, cx, c_y, c_x) = translate_coords_2d(coords_2d, simulation_shape_2d, layer_shape_2d, chunk_shape_2d)
    chunk_2d = get_or_load_chunk_2d(chunk_cache_2d, cy, cx, load_chunk_2d)
    return chunk_2d[c_y, c_x]

def at_coords_3d(coords_3d, simulation_shape_3d, layer_shape_3d, chunk_shape_3d, chunk_cache_3d, load_chunk_3d):
    """
    Given band z, row y, and column x on the simulation grid,
    return the value at that index in the underlying chunk cache.
    NOTE: (z,y,x) = (0,0,0) is the upper-left corner of the array in the first timestep.
    """
    (cz, cy, cx, c_z, c_y, c_x) = translate_coords_3d(coords_3d, simulation_shape_3d, layer_shape_3d, chunk_shape_3d)
    chunk_3d = get_or_load_chunk_3d(chunk_cache_3d, cz, cy, cx, load_chunk_3d)
    return chunk_3d[c_z, c_y, c_x]

#==============================================================
# Constructor: Returns a 2D/3D Lookup Function for One Array
#==============================================================

def make_lookup_fn_2d(simulation_shape_2d, layer_shape_2d, chunk_shape_2d, load_chunk_2d):
    """
    Given the array shapes of the simulation space (|Y|,|X|), the
    underlying data layer (|LY|,|LX|), and a single chunk within the
    chunk cache (|CY|,|CX|) as well as a function to load one chunk
    on demand, return a closure that will retrieve the value from the
    underlying data layer corresponding to coordinate (y,x) in the
    simulation space. Chunks will be loaded on demand using load_chunk_2d.
    NOTE: (y,x) = (0,0) is the upper-left corner of the array.
    NOTE: simulation_shape_2d >= layer_shape_2d >= chunk_shape_2d
    """
    (layer_rows, layer_cols) = layer_shape_2d
    (chunk_rows, chunk_cols) = chunk_shape_2d
    chunk_cache_2d = np.empty((layer_rows // chunk_rows,
                               layer_cols // chunk_cols),
                              dtype=object)
    return lambda y, x: at_coords_2d((y, x),
                                     simulation_shape_2d,
                                     layer_shape_2d,
                                     chunk_shape_2d,
                                     chunk_cache_2d,
                                     load_chunk_2d)

def make_lookup_fn_3d(simulation_shape_3d, layer_shape_3d, chunk_shape_3d, load_chunk_3d):
    """
    Given the array shapes of the simulation space (|Z|,|Y|,|X|), the
    underlying data layer (|LZ|,|LY|,|LX|), and a single chunk within the
    chunk cache (|CZ|,|CY|,|CX|) as well as a function to load one chunk
    on demand, return a closure that will retrieve the value from the
    underlying data layer corresponding to coordinate (z,y,x) in the
    simulation space. Chunks will be loaded on demand using load_chunk_3d.
    NOTE: (z,y,x) = (0,0,0) is the upper-left corner of the array in the first timestep.
    NOTE: simulation_shape_3d >= layer_shape_3d >= chunk_shape_3d
    """
    (layer_bands, layer_rows, layer_cols) = layer_shape_3d
    (chunk_bands, chunk_rows, chunk_cols) = chunk_shape_3d
    chunk_cache_3d = np.empty((layer_bands // chunk_bands,
                               layer_rows // chunk_rows,
                               layer_cols // chunk_cols),
                              dtype=object)
    return lambda z, y, x: at_coords_3d((z, y, x),
                                        simulation_shape_3d,
                                        layer_shape_3d,
                                        chunk_shape_3d,
                                        chunk_cache_3d,
                                        load_chunk_3d)
#+end_src

** Lazy Array Usage Examples

#+begin_src python :tangle ../test/pyretechnics/lazy_array_test.py
import numpy as np
from pyretechnics.lazy_array import make_lookup_fn_2d, make_lookup_fn_3d

#==============================================================
# Raw Data - managed by the caller
#==============================================================

# 2D Arrays (e.g. 30m x 30m resolution, 30km x 30km extent)
elevation_layer                    = np.arange(0,1000000).reshape(1000,1000)
slope_layer                        = np.arange(0,1000000).reshape(1000,1000)
aspect_layer                       = np.arange(0,1000000).reshape(1000,1000)
fuel_model_layer                   = np.arange(0,1000000).reshape(1000,1000)
canopy_cover_layer                 = np.arange(0,1000000).reshape(1000,1000)
canopy_height_layer                = np.arange(0,1000000).reshape(1000,1000)
canopy_base_height_layer           = np.arange(0,1000000).reshape(1000,1000)
canopy_bulk_density_layer          = np.arange(0,1000000).reshape(1000,1000)
time_of_arrival_layer              = np.arange(0,1000000).reshape(1000,1000) # Optional Layer
suppression_difficulty_index_layer = np.arange(0,1000000).reshape(1000,1000) # Optional Layer
fuel_spread_adjustment_layer       = np.arange(0,1000000).reshape(1000,1000) # Optional Layer

# 3D Arrays (e.g. 1hr x 300m x 300m resolution, 1day x 30km x 30km extent)
temperature_layer                   = np.arange(240000).reshape(24,100,100)
relative_humidity_layer             = np.arange(240000).reshape(24,100,100)
wind_speed_layer                    = np.arange(240000).reshape(24,100,100)
wind_direction_layer                = np.arange(240000).reshape(24,100,100)
fuel_moisture_dead_1hr_layer        = np.arange(240000).reshape(24,100,100)
fuel_moisture_dead_10hr_layer       = np.arange(240000).reshape(24,100,100)
fuel_moisture_dead_100hr_layer      = np.arange(240000).reshape(24,100,100)
fuel_moisture_live_herbaceous_layer = np.arange(240000).reshape(24,100,100)
fuel_moisture_live_woody_layer      = np.arange(240000).reshape(24,100,100)
foliar_moisture_layer               = np.arange(240000).reshape(24,100,100)
weather_spread_adjustment_layer     = np.arange(240000).reshape(24,100,100) # Optional Layer

#==============================================================
# Chunk Loading Functions
#==============================================================

def make_load_chunk_2d(layer_2d, chunk_shape_2d):
    """
    Example 2D chunk loading function. Since we are calling the
    lazy array functions from Python and they will be used as
    read-only data by the caller, we can just provide a sliced view of
    the underlying array rather than generating a copy.
    """
    (chunk_rows, chunk_cols) = chunk_shape_2d
    return lambda cy, cx: layer_2d[cy * chunk_rows : (cy + 1) * chunk_rows,
                                   cx * chunk_cols : (cx + 1) * chunk_cols]

def make_load_chunk_3d(layer_3d, chunk_shape_3d):
    """
    Example 3D chunk loading function. Since we are calling the
    lazy array functions from Python and they will be used as
    read-only data by the caller, we can just provide a sliced view of
    the underlying array rather than generating a copy.
    """
    (chunk_bands, chunk_rows, chunk_cols) = chunk_shape_3d
    return lambda cz, cy, cx: layer_3d[cz * chunk_bands : (cz + 1) * chunk_bands,
                                       cy * chunk_rows  : (cy + 1) * chunk_rows,
                                       cx * chunk_cols  : (cx + 1) * chunk_cols]

#==============================================================
# Creating the Dictionary of Layer Names to Lookup Functions
#==============================================================

#--------------------  bands, rows, cols
simulation_shape_2d = (       1000, 1000)
layer_shape_2d      = (       1000, 1000)
chunk_shape_2d      = (        100,  100)

simulation_shape_3d = (   24, 1000, 1000)
layer_shape_3d      = (   24,  100,  100)
chunk_shape_3d      = (    1,   10,   10)

# Partial Application Functions
def make_lookup_fn_2d_for_layer(layer_2d):
    make_lookup_fn_2d(simulation_shape_2d,
                      layer_shape_2d,
                      chunk_shape_2d,
                      make_load_chunk_2d(layer_2d, chunk_shape_2d))

def make_lookup_fn_3d_for_layer(layer_3d):
    make_lookup_fn_3d(simulation_shape_3d,
                      layer_shape_3d,
                      chunk_shape_3d,
                      make_load_chunk_3d(layer_3d, chunk_shape_3d))

# Layer Dictionary
layer_lookup = {
    # 2D Arrays (e.g. 30m x 30m resolution, 30km x 30km extent)
    "elevation"                    : make_lookup_fn_2d_for_layer(elevation_layer),
    "slope"                        : make_lookup_fn_2d_for_layer(slope_layer),
    "aspect"                       : make_lookup_fn_2d_for_layer(aspect_layer),
    "fuel_model"                   : make_lookup_fn_2d_for_layer(fuel_model_layer),
    "canopy_cover"                 : make_lookup_fn_2d_for_layer(canopy_cover_layer),
    "canopy_height"                : make_lookup_fn_2d_for_layer(canopy_height_layer),
    "canopy_base_height"           : make_lookup_fn_2d_for_layer(canopy_base_height_layer),
    "canopy_bulk_density"          : make_lookup_fn_2d_for_layer(canopy_bulk_density_layer),
    "time_of_arrival"              : make_lookup_fn_2d_for_layer(time_of_arrival_layer),              # Optional Layer
    "suppression_difficulty_index" : make_lookup_fn_2d_for_layer(suppression_difficulty_index_layer), # Optional Layer
    "fuel_spread_adjustment"       : make_lookup_fn_2d_for_layer(fuel_spread_adjustment_layer),       # Optional Layer

    # 3D Arrays (e.g. 1hr x 300m x 300m resolution, 1day x 30km x 30km extent)
    "temperature"                  : make_lookup_fn_3d_for_layer(temperature_layer),
    "relative_humidity"            : make_lookup_fn_3d_for_layer(relative_humidity_layer),
    "wind_speed"                   : make_lookup_fn_3d_for_layer(wind_speed_layer),
    "wind_direction"               : make_lookup_fn_3d_for_layer(wind_direction_layer),
    "fuel_moisture_dead_1hr"       : make_lookup_fn_3d_for_layer(fuel_moisture_dead_1hr_layer),
    "fuel_moisture_dead_10hr"      : make_lookup_fn_3d_for_layer(fuel_moisture_dead_10hr_layer),
    "fuel_moisture_dead_100hr"     : make_lookup_fn_3d_for_layer(fuel_moisture_dead_100hr_layer),
    "fuel_moisture_live_herbaceous": make_lookup_fn_3d_for_layer(fuel_moisture_live_herbaceous_layer),
    "fuel_moisture_live_woody"     : make_lookup_fn_3d_for_layer(fuel_moisture_live_woody_layer),
    "foliar_moisture"              : make_lookup_fn_3d_for_layer(foliar_moisture_layer),
    "weather_spread_adjustment"    : make_lookup_fn_3d_for_layer(weather_spread_adjustment_layer),    # Optional Layer
}

#==============================================================
# Looking Up Values in the Layers
#==============================================================

# NOTE: 2D coords should be provided as (y,x) in simulation space.

dem_100_100  = layer_lookup["elevation"](100,100)
slp_100_100  = layer_lookup["slope"](100,100)
asp_100_100  = layer_lookup["aspect"](100,100)
fbfm_100_100 = layer_lookup["fuel_model"](100,100)
cc_100_100   = layer_lookup["canopy_cover"](100,100)
ch_100_100   = layer_lookup["canopy_height"](100,100)
cbh_100_100  = layer_lookup["canopy_base_height"](100,100)
cbd_100_100  = layer_lookup["canopy_bulk_density"](100,100)
toa_100_100  = layer_lookup["time_of_arrival"](100,100)                  # Optional Layer
sdi_100_100  = layer_lookup["suppression_difficulty_index"](100,100)     # Optional Layer
fsa_100_100  = layer_lookup["fuel_spread_adjustment"](100,100)           # Optional Layer

# NOTE: 3D coords should be provided as (z,y,x) in simulation space.

temp_12_100_100  = layer_lookup["temperature"](12,100,100)
rh_12_100_100    = layer_lookup["relative_humidity"](12,100,100)
wsp_12_100_100   = layer_lookup["wind_speed"](12,100,100)
wd_12_100_100    = layer_lookup["wind_direction"](12,100,100)
md1_12_100_100   = layer_lookup["fuel_moisture_dead_1hr"](12,100,100)
md10_12_100_100  = layer_lookup["fuel_moisture_dead_10hr"](12,100,100)
md100_12_100_100 = layer_lookup["fuel_moisture_dead_100hr"](12,100,100)
mlh_12_100_100   = layer_lookup["fuel_moisture_live_herbaceous"](12,100,100)
mlw_12_100_100   = layer_lookup["fuel_moisture_live_woody"](12,100,100)
fm_12_100_100    = layer_lookup["foliar_moisture"](12,100,100)
wsa_12_100_100   = layer_lookup["weather_spread_adjustment"](12,100,100) # Optional Layer
#+end_src

* Fire Spread API

Pyretechnics provides two main functions for simulating fire behavior over a region of space-time:

** grow_fire

Simulates the growth of a fire over space and time starting from one
or more actively burning cells. Suppression effects may be optionally
applied, and several different stop conditions may be specified. A
random seed may be optionally provided to ensure deterministically
reproducible runs, despite the presence of stochastic calculations
within the fire spread algorithm.

*** Inputs

These are the inputs to the ~grow_fire~ function:

- config_dict :: a dictionary of parameter names to their values with the following types:

  |---------------------------+-----------------------------+-------------------------------------------------------------------------------------------+-----------+---------|
  | Parameter Name            | Type                        | Units                                                                                     | Optional? | Default |
  |---------------------------+-----------------------------+-------------------------------------------------------------------------------------------+-----------+---------|
  | simulation_shape          | Tuple (int, int, int)       | (num timesteps, num rows, num cols)                                                       |           |         |
  | simulation_resolution     | Tuple (float, float, float) | (minutes per timestep, meters per row, meters per column)                                 |           |         |
  | simulation_north_angle    | float                       | degrees clockwise from the top of the circle                                              | Yes       | 0.0     |
  | simulation_start_time     | float                       | minutes from the start time of the simulated space-time cube                              | Yes       | 0.0     |
  | simulation_stop_condition | Dictionary {string: float}  | either {'max_burn_duration': minutes} or {'max_burned_area': square_meters}               | Yes       | None    |
  | random_seed               | number or string            | the seed value to initialize the random number generator                                  | Yes       | None    |
  | overwrite_outputs         | boolean                     | True or False, whether to mutate or copy the Numpy arrays provided in *output_layer_dict* | Yes       | False   |
  | alpha_suppression         | Dictionary {string: float}  | parameters for the *alpha* suppression algorithm (see table below)                        | Yes       | None    |
  | sdi_suppression           | Dictionary {string: float}  | parameters for the *sdi* suppression algorithm (see table below)                          | Yes       | None    |
  |---------------------------+-----------------------------+-------------------------------------------------------------------------------------------+-----------+---------|

  - alpha_suppression :: a dictionary of parameter names to their values for the *alpha* suppression algorithm:

  |-------------------------+-------+------------------------------------|
  | Parameter Name          | Type  | Units                              |
  |-------------------------+-------+------------------------------------|
  | suppression_timestep    | float | minutes between suppression events |
  | suppression_coefficient | float | TODO: find units range             |
  |-------------------------+-------+------------------------------------|

  - sdi_suppression :: a dictionary of parameter names to their values for the *sdi* suppression algorithm:

  |-----------------------------------------------+-------+------------------------------------|
  | Parameter Name                                | Type  | Units                              |
  |-----------------------------------------------+-------+------------------------------------|
  | suppression_timestep                          | float | minutes between suppression events |
  | sdi_sensitivity_to_difficulty                 | float | TODO: find units range             |
  | sdi_containment_overwhelming_area_growth_rate | float | TODO: find units range             |
  | sdi_reference_suppression_speed               | float | TODO: find units range             |
  |-----------------------------------------------+-------+------------------------------------|

- ignited_cells_set :: set of cells that are actively burning at the simulation start time, specified as 3D coordinates =(z,y,x)= in the simulated space-time cube

- input_layer_dict :: a dictionary of layer names to either 2-arity (2D) or 3-arity (3D) functions for accessing the numeric values at each =(y,x)= or =(z,y,x)= coordinate in the simulated space-time cube:

  |-------------------------------+-------+----------------------------------------------------------------+-----------+-------|
  | Layer Name                    | Type  | Units                                                          | Optional? | Arity |
  |-------------------------------+-------+----------------------------------------------------------------+-----------+-------|
  | elevation                     | float | meters                                                         |           |     2 |
  | slope                         | float | vertical meters/horizontal meters                              |           |     2 |
  | aspect                        | float | degrees clockwise from North                                   |           |     2 |
  | fuel_model                    | int   | fuel model numbers 1-256                                       |           |     2 |
  | canopy_cover                  | float | percent (0-100)                                                |           |     2 |
  | canopy_height                 | float | meters                                                         |           |     2 |
  | canopy_base_height            | float | meters                                                         |           |     2 |
  | canopy_bulk_density           | float | kilograms/meters^3                                             |           |     2 |
  | suppression_difficulty_index  | float | integer >= 0  (TODO: What is the correct value range?)         | Yes       |     2 |
  | fuel_spread_adjustment        | float | real number >= 0.0 (1.0 means no adjustment)                   | Yes       |     2 |
  | temperature                   | float | degrees Celsius                                                |           |     3 |
  | relative_humidity             | float | percent (0-100)                                                |           |     3 |
  | wind_speed                    | float | kilometers/hour                                                |           |     3 |
  | wind_direction                | float | degrees clockwise from North                                   |           |     3 |
  | fuel_moisture_dead_1hr        | float | percent (0-100)  (TODO: Can these values be greater than 100?) |           |     3 |
  | fuel_moisture_dead_10hr       | float | percent (0-100)                                                |           |     3 |
  | fuel_moisture_dead_100hr      | float | percent (0-100)                                                |           |     3 |
  | fuel_moisture_live_herbaceous | float | percent (0-100)                                                |           |     3 |
  | fuel_moisture_live_woody      | float | percent (0-100)                                                |           |     3 |
  | foliar_moisture               | float | percent (0-100)                                                |           |     3 |
  | weather_spread_adjustment     | float | real number >= 0.0 (1.0 means no adjustment)                   | Yes       |     3 |
  |-------------------------------+-------+----------------------------------------------------------------+-----------+-------|

- output_layer_dict :: an *optional* dictionary of layer names to 2D Numpy arrays with the following units to pre-populate the simulation output arrays:

  |------------------------------+----------------+------------------------------------------------------------------------------+-----------|
  | Parameter Name               | Type           | Units                                                                        | Optional? |
  |------------------------------+----------------+------------------------------------------------------------------------------+-----------|
  | surface_spread_rate          | 2D float array | meters/second                                                                | Yes       |
  | crown_spread_rate            | 2D float array | meters/second                                                                | Yes       |
  | dominant_spread_rate         | 2D float array | meters/second                                                                | Yes       |
  | spread_direction             | 2D float array | degrees clockwise from North                                                 | Yes       |
  | surface_flame_length         | 2D float array | meters                                                                       | Yes       |
  | crown_flame_length           | 2D float array | meters                                                                       | Yes       |
  | combined_flame_length        | 2D float array | meters                                                                       | Yes       |
  | surface_fire_line_intensity  | 2D float array | kilowatts/meter                                                              | Yes       |
  | crown_fire_line_intensity    | 2D float array | kilowatts/meter                                                              | Yes       |
  | combined_fire_line_intensity | 2D float array | kilowatts/meter                                                              | Yes       |
  | fire_type                    | 2D float array | 0 = no_fire, 1 = surface_fire, 2 = passive_crown_fire, 3 = active_crown_fire | Yes       |
  | ember_count                  | 2D float array | number of embers landing in each cell                                        | Yes       |
  | time_of_arrival              | 2D float array | minutes from the start time of the simulated space-time cube                 | Yes       |
  |------------------------------+----------------+------------------------------------------------------------------------------+-----------|

*** Outputs

The ~grow_fire~ function will return a dictionary with these fields:

- simulation_stop_time :: minutes from the start time of the simulated space-time cube

- simulation_stop_condition_encountered :: max_burn_duration | max_burned_area | no_burnable_fuel | end_of_temporal_data | fully_suppressed

- ignited_cells_set :: set of cells that are actively burning at the simulation stop time, specified as 3D coordinates =(z,y,x)= in the simulated space-time cube

- output_layer_dict :: a dictionary of layer names to 2D Numpy arrays with the following units:

  |------------------------------+----------------+------------------------------------------------------------------------------|
  | Parameter Name               | Type           | Units                                                                        |
  |------------------------------+----------------+------------------------------------------------------------------------------|
  | surface_spread_rate          | 2D float array | meters/second                                                                |
  | crown_spread_rate            | 2D float array | meters/second                                                                |
  | dominant_spread_rate         | 2D float array | meters/second                                                                |
  | spread_direction             | 2D float array | degrees clockwise from North                                                 |
  | surface_flame_length         | 2D float array | meters                                                                       |
  | crown_flame_length           | 2D float array | meters                                                                       |
  | combined_flame_length        | 2D float array | meters                                                                       |
  | surface_fire_line_intensity  | 2D float array | kilowatts/meter                                                              |
  | crown_fire_line_intensity    | 2D float array | kilowatts/meter                                                              |
  | combined_fire_line_intensity | 2D float array | kilowatts/meter                                                              |
  | fire_type                    | 2D float array | 0 = no_fire, 1 = surface_fire, 2 = passive_crown_fire, 3 = active_crown_fire |
  | ember_count                  | 2D float array | number of embers landing in each cell                                        |
  | time_of_arrival              | 2D float array | minutes from the start time of the simulated space-time cube                 |
  |------------------------------+----------------+------------------------------------------------------------------------------|

*** Play/Pause/Continue Semantics

The inputs and outputs of ~grow_fire~ are structured so as to enable
you to simulate fire spread from =simulation_start_time= (or 0) until
a stop condition is encountered and then to easily resume the fire
spread simulation from =simulation_stop_time= until the next stop
condition is met. Here is an example of how to do this.

#+begin_src python
#=======================================================
# Phase 1: Initial fire simulation - first 12 hours
#=======================================================

config_dict = {
    "simulation_shape"         : (24, 1000, 1000),
    "simulation_resolution"    : (60, 30, 30),
    "simulation_start_time"    : 0.0,
    "simulation_stop_condition": {"max_burn_duration": 720.0},
}

ignited_cells_set = set([(0, 100, 100)])

input_layer_dict = {
    # 2D Arrays (e.g. 30m x 30m resolution, 30km x 30km extent)
    "elevation"                    : lambda y,x: 0.0,
    "slope"                        : lambda y,x: 0.0,
    "aspect"                       : lambda y,x: 0.0,
    "fuel_model"                   : lambda y,x: 100,
    "canopy_cover"                 : lambda y,x: 0.0,
    "canopy_height"                : lambda y,x: 0.0,
    "canopy_base_height"           : lambda y,x: 0.0,
    "canopy_bulk_density"          : lambda y,x: 0.0,
    # 3D Arrays (e.g. 1hr x 300m x 300m resolution, 1day x 30km x 30km extent)
    "temperature"                  : lambda z,y,x: 10.0,
    "relative_humidity"            : lambda z,y,x: 10.0,
    "wind_speed"                   : lambda z,y,x: 0.0,
    "wind_direction"               : lambda z,y,x: 0.0,
    "fuel_moisture_dead_1hr"       : lambda z,y,x: 10.0,
    "fuel_moisture_dead_10hr"      : lambda z,y,x: 10.0,
    "fuel_moisture_dead_100hr"     : lambda z,y,x: 10.0,
    "fuel_moisture_live_herbaceous": lambda z,y,x: 10.0,
    "fuel_moisture_live_woody"     : lambda z,y,x: 10.0,
    "foliar_moisture"              : lambda z,y,x: 10.0,
}

output_dict1 = grow_fire(config_dict, ignited_cells_set, input_layer_dict)

#=======================================================
# Phase 2: Continued fire simulation - second 12 hours
#=======================================================

config_dict["simulation_start_time"] = output_dict1["simulation_stop_time"]

ignited_cells_set = output_dict1["ignited_cells_set"]

output_layer_dict = output_dict1["output_layer_dict"]

output_dict2 = grow_fire(config_dict, ignited_cells_set, input_layer_dict, output_layer_dict)
#+end_src

** burn_cells

TODO: stub

* Fire Spread Functions

# RESUME HERE: [[file:~/code/sig-gis/gridfire/src/gridfire/simulations.clj::(defn run-simulation!]]

#+begin_src python :tangle ../src/pyretechnics/fire_spread.py
# FIXME: stub
def grow_fire(config_dict, ignited_cells_set, input_layer_dict, output_layer_dict = {}):
    """
    1. Validate inputs
    2. Load data for the ignited area plus a buffer size (user-specified?)
    3. Perform constant spread out over the landscape in all directions
       - Run surface, crown, and spot equations per ignited cell
    4. Record the time-of-arrival (ignition-time) in each cell as it spreads
    5. Load more data whenever the buffer extent is exceeded or stop spreading if no more data is available
    6. Continue until a stop condition is met (e.g., max_burn_duration or max_burned_area)
    7. Return a dictionary of the outputs
    """
    return None

# FIXME: stub
def burn_cells(config_dict, input_layer_dict, output_layer_dict, ignited_cells_set):
    """
    1. Validate inputs
       - Make sure that all required parameters are present in config_dict (like spec-checking config.edn)
         - simulation_shape (z,y,x) = (int bands, int rows, int cols)
         - simulation_resolution (z,y,x) = (minutes, meters, meters)
         - simulation_north_angle (default: 0)
         - simulation_start_time (minute)
         - simulation_stop_condition (max_burn_duration: mins, max_burned_area: m^2)
         - random_generator (MUTABLE!)
         - ellipse_adjustment_factor (not needed by ELMFIRE)
         - alpha_suppression:
           - suppression_dt
           - suppression_coefficient
         - sdi_suppression:
           - suppression_dt
           - sdi_sensitivity_to_difficulty
           - sdi_containment_overwhelming_area_growth_rate
           - sdi_reference_suppression_speed
         - modify_outputs (True, False)
       - Make sure that all required entries are present in layer_dict
         - Document raster layer units
           - include metric/imperial units and relevant multipliers
           - user has to get these right, no checking!
           - don't forget to remind them about angular corrections to wind and aspect if the projection isn't oriented to due North
         - Check for entries in output_layer_dict; if present, copy/use as new output layers
         - Use time of arrival raster to identify the burn scar(s); if missing, we are simulating point ignitions
       - Specify 3D space-time points in ignited_cells_set = (minute, row, col)
       - The simulation will return a dictionary with these fields:
         - simulation_stop_time (minute)
         - simulation_stop_condition_encountered (max_burn_duration, max_burned_area, no_burnable_fuel, end_of_temporal_data, fully_suppressed)
         - ignited_cells_set (returning the actively burning cells allows someone to restart the simulation from this point)
         - output_layer_dict: (should we split up surface and crown matrices or combine them?)
           - spread_rate_matrix
           - spread_direction_matrix
           - flame_length_matrix
           - fire_line_intensity_matrix
           - fire_type_matrix
           - ember_count_matrix
           - time_of_arrival_matrix
    2. Create input parameter dictionary
       - load rasters
       - load ignitions
       - compute samples
       - apply perturbations
       - load ignition/weather start times and burn periods
       - load suppression parameters
       - add spread rate adjustment factors
    3. Load data for the ignited area without a buffer
    4. Burn all the ignited cells
    5. Return a dictionary of the output strings to their corresponding 2D matrices
    """
    return None
#+end_src
