#+TITLE: The Pyretechnics Fire Behavior Library
#+AUTHOR: Gary W. Johnson, Valentin Waeselynck, Chris Lautenberger
#+DATE: Copyright Â© 2023-2024 Spatial Informatics Group, LLC
#+OPTIONS: ^:{} toc:nil h:3
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [11pt]
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{amsfonts}
#+LATEX_HEADER: \usepackage{amssymb}
#+LATEX_HEADER: \usepackage{fancyhdr}
#+LATEX_HEADER: \usepackage[top=1in,bottom=1in,left=0.75in,right=0.75in]{geometry}
#+LATEX_HEADER: \usepackage{geometry}
#+LATEX_HEADER: \pagestyle{fancyplain}
#+LATEX_HEADER: \usepackage{wrapfig}
#+LATEX_HEADER: \usepackage{subfigure}
#+LATEX_HEADER: \usepackage{setspace}
#+LATEX_HEADER: \usepackage{epsfig}
#+LATEX_HEADER: \usepackage{color}
#+LATEX_HEADER: \usepackage[round,comma]{natbib}
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usetikzlibrary{calc}
#+LATEX_HEADER: \usepackage{cancel}
#+LATEX_HEADER: \setlength{\headheight}{13.6pt}
#+LATEX_HEADER: \hypersetup{
#+LATEX_HEADER:     colorlinks=true,
#+LATEX_HEADER:     citecolor=black,
#+LATEX_HEADER:     linkbordercolor=black,
#+LATEX_HEADER:     linkcolor=black}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \graphicspath{{pics/}}
#+LATEX_HEADER: \DeclareUnicodeCharacter{394}{$\Delta$}
#+LATEX_HEADER: \DeclareUnicodeCharacter{3C7}{$\chi$}

# Global Settings
#+PROPERTY: header-args:python+ :results silent
#+PROPERTY: header-args:python+ :exports code
#+PROPERTY: header-args:python+ :no-expand
#+PROPERTY: header-args:python+ :padline no
#+PROPERTY: header-args:python+ :comments link

* Preface

This document is a Literate
Program[fn::https://en.wikipedia.org/wiki/Literate_programming],
containing both the source code of the software it describes as well
as the rationale used in each step of its design and implementation.
The purpose of this approach is to enable anyone sufficiently
experienced in programming to easily retrace the author's footsteps as
they read through the text and code. By the time they have reached the
end of this document, the reader should have just as strong a grasp of
the system as the original programmer.

To execute the code illustrated within this document, you will need to
install several pieces of software, all of which are open source
and/or freely available for all major operating systems. These
programs are listed in Table [[tab:required-software]] along with their
minimum required versions and URLs from which they may be downloaded.

#+NAME: tab:required-software
#+CAPTION: Software necessary to evaluate the code in this document
#+ATTR_LATEX: :align |l|r|l| :font \small
|--------+---------+-----------------------------------|
| Name   | Version | URL                               |
|--------+---------+-----------------------------------|
| Python | 3.x     | https://www.python.org/downloads/ |
| Numpy  | LATEST  | https://numpy.org/                |
|--------+---------+-----------------------------------|

* Data Model
** Working in a 3D Space-Time Cube

In Pyretechnics, a fire is viewed as a three-dimensional event
occurring within a bounded region of space-time =(T, Y, X)=. In this
mental model, the environment in which a fire develops can be
visualized as a cube in which space is described in 2D by the =X= and
=Y= dimensions and time projects this 2D world into 3D along the =T=
dimension.

Note, in particular, that this is not the same thing as a
three-dimensional model of fire behavior that incorporates surface
elevation as the third dimension. Although terrain data (such as
elevation, slope, and aspect) and tree cover characteristics (such as
canopy height and canopy base height) are incorporated into the
implemented spread equations in order to determine the rate,
direction, and mode of fire spread, the outputs of the fire behavior
algorithms in Pyretechnics currently only use two dimensions to
describe spatial heterogeneity within the simulation environment. The
third dimension is instead reserved for temporal variations in the
model outputs.

** Fires as Conical Shapes in Space-Time

All fire events begin from an ignition somewhere in space-time. As
combustion and propagation occur in burnable fuels, the burned area
(a.k.a "burn scar") of a fire spreads monotonically outward in space.
Viewed from the lens of our 3D space-time cube, these monotonically
expanding burn scars form conical solids within the simulation
environment, with the bottom point of the cone representing the
initial ignition point and the upper edge of the cone representing the
actively burning fire perimeter. Of course, we only expect idealized
fire cones to appear in environments with homogeneous topography,
weather, fuels, and fuel moisture. As these inputs become more
heterogenous throughout the burned region of space-time, these
idealized cones will become distorted in the directions of faster or
slower spread and their perimeters will become more finely dissected.
However, we use this conical shape description of fire events within
the simulated space-time cube to convey both their monotonically
increasing spatial area over time as well as to provide the foundation
for a more visually intuitive understanding of the effect of
temporally varying environmental conditions on the behavior (and thus
shape) of fires.

** Support for Input Datasets of Varying Dimensionality and Resolution

At the beginning of a fire behavior simulation, our 3D space-time cube
is populated with all of the information that describes the
environment and will remain effectively static as the fire event
unfolds. This includes (but is not limited to) topography, weather,
fuels, and fuel moisture. In many common simulation scenarios, we
expect that topography and fuels will probably vary in space but not
in time, and weather and fuel moisture may vary in both space and
time. However, we use "may" in these statements because the data model
within Pyretechnics is flexibly designed to allow any of these
environmental input variables to take on any of these forms:

- constant in space and time
- constant in space but variable in time
- variable in space but constant in time
- variable in space and time

This is accomplished by representing each such input value as an
abstract datatype with a 3D space-time look-up function. From within
our fire behavior algorithms, we should always be able to call the
look-up function for any environmental input variable with a 3D
space-time coordinate =(t, y, x)= and get back the correct value for
that location. Moreover, such look-ups must be referentially
transparent, so as to ensure that subsequent look-ups with the same
coordinate will always yield the same values.

Note, that for performance reasons, input values that are constant in
either space or time will not be broadcast into these constant
dimensions when stored in memory. Instead, their native
representations will be preserved, and the 3D look-up function
assigned to that input will correctly map the 3D space-time coordinate
into the corresponding index within the native dataset.

Similarly, input datasets may be provided at different resolutions
from one another, provided that:

1. All spatial and temporal extents must match
2. All spatial and temporal resolutions must be exact multiples of one another
3. All spatially varying datasets must share the same projection

Provided that these conditions are met, the 3D look-up function for
each input will also be able to automatically translate the 3D
space-time coordinate it receives into the correct coordinate for the
underlying dataset's native resolution and dimensionality.

** Lazy Loading of Space-Time Chunks

In order to avoid the need to fully load all of the 3D space-time
cube's environmental datasets into memory at the beginning of a fire
behavior simulation, Pyretechnics implements a lazy-loading mechanism
that works as follows:

1. The 3D space-time cube is assigned a *simulation shape* $(T_s, Y_s,
   X_s)$, which describes the number of timesteps, rows, and columns
   it contains. This must be an exact multiple (in every dimension) of
   the *layer shapes* described below.

2. Each input dataset is assigned a *layer shape* $(T_l, Y_l, X_l)$,
   which describes the number of timesteps, rows, and columns it
   contains.

3. Each input dataset is assigned a *chunk shape* $(T_c, Y_c,
   X_c)$, which describes the number of timesteps, rows, and columns
   to be loaded from the corresponding layer when requesting a new
   chunk of data within its spatio-temporal extent. All chunk
   dimensions must exactly divide their corresponding layer
   dimensions.

4. Each input dataset is assigned a *chunk cache* with shape
   $(T_l/T_c, Y_l/Y_c, X_l/X_c)$. This is represented in memory as a
   3D array of pointers, initialized to nulls.

5. Each input dataset is assigned a 3D look-up function to be used in
   fire behavior calculations.

   1. Whenever this function is called on a space-time coordinate
      which has no value in the *chunk cache*, a call is first made
      automatically to load the array chunk containing this coordinate
      from the underlying input dataset into the *chunk cache*, and
      then the coordinate value is looked up and returned.

   2. Whenever this function is called on a space-time coordinate
      which has a value in the *chunk cache*, it is looked up and
      returned.

The net effect of this chunked data model approach is that
Pyretechnics only needs to load into memory those space-time chunks
which are intersected by the expanding conical burn scar. In
simulations of fires that are small relative to the extent of the full
3D space-time environment, these memory savings may be substantial and
may make it possible to run simulations over larger extents and/or
finer resolutions than have been used previously.

** Lazy-Loading Multi-Resolution Array Lookup Functions

#+begin_src python :tangle ../src/pyretechnics/lazy_array.py
import numpy as np

#==============================================================
# Lazy-Loading Multi-Resolution Array Lookup Functions
#==============================================================

def translate_coords_2d(coords_2d, simulation_shape_2d, layer_shape_2d, chunk_shape_2d):
    """
    Given row y and column x on the simulation grid, return chunk
    row cy, chunk column cx, subchunk row c_y, and subchunk column c_x on
    the chunk grid.
    NOTE: (y,x) = (0,0) is the upper-left corner of the array.
    NOTE: simulation_shape_2d >= layer_shape_2d >= chunk_shape_2d
    """
    (y, x) = coords_2d
    (simulation_rows, simulation_cols) = simulation_shape_2d
    (layer_rows, layer_cols) = layer_shape_2d
    (chunk_rows, chunk_cols) = chunk_shape_2d
    ly = y // (simulation_rows // layer_rows)
    lx = x // (simulation_cols // layer_cols)
    cy  = ly // chunk_rows
    cx  = lx // chunk_cols
    c_y = ly % chunk_rows
    c_x = lx % chunk_cols
    return (cy, cx, c_y, c_x)

def translate_coords_3d(coords_3d, simulation_shape_3d, layer_shape_3d, chunk_shape_3d):
    """
    Given band z, row y, and column x on the simulation grid,
    return chunk band cz, chunk row cy, chunk column cx, subchunk band
    c_z, subchunk row c_y, and subchunk column c_x on the chunk grid.
    NOTE: (z,y,x) = (0,0,0) is the upper-left corner of the array in the first timestep.
    NOTE: simulation_shape_3d >= layer_shape_3d >= chunk_shape_3d
    """
    (z, y, x) = coords_3d
    (simulation_bands, simulation_rows, simulation_cols) = simulation_shape_3d
    (layer_bands, layer_rows, layer_cols) = layer_shape_3d
    (chunk_bands, chunk_rows, chunk_cols) = chunk_shape_3d
    lz = z // (simulation_bands // layer_bands)
    ly = y // (simulation_rows // layer_rows)
    lx = x // (simulation_cols // layer_cols)
    cz  = lz // chunk_bands
    cy  = ly // chunk_rows
    cx  = lx // chunk_cols
    c_z = lz % chunk_bands
    c_y = ly % chunk_rows
    c_x = lx % chunk_cols
    return (cz, cy, cx, c_z, c_y, c_x)

def get_or_load_chunk_2d(chunk_cache_2d, cy, cx, load_chunk_2d):
    """
    Checks whether chunk_cache_2d contains chunk (cy, cx). If so,
    return it. Otherwise, call load_chunk_2d(cy, cx) to retrieve it,
    store it in chunk_cache_2d, and return it.
    """
    chunk_2d = chunk_cache_2d[cy, cx]
    if (type(chunk_2d) == np.ndarray):
        return chunk_2d
    else:
        chunk_2d = load_chunk_2d(cy, cx)
        chunk_cache_2d[cy, cx] = chunk_2d
        return chunk_2d

def get_or_load_chunk_3d(chunk_cache_3d, cz, cy, cx, load_chunk_3d):
    """
    Checks whether chunk_cache_3d contains chunk (cz, cy, cx). If so,
    return it. Otherwise, call load_chunk_3d(cz, cy, cx) to retrieve it,
    store it in chunk_cache_3d, and return it.
    """
    chunk_3d = chunk_cache_3d[cz, cy, cx]
    if (type(chunk_3d) == np.ndarray):
        return chunk_3d
    else:
        chunk_3d = load_chunk_3d(cz, cy, cx)
        chunk_cache_3d[cz, cy, cx] = chunk_3d
        return chunk_3d

def at_coords_2d(coords_2d, simulation_shape_2d, layer_shape_2d, chunk_shape_2d, chunk_cache_2d, load_chunk_2d):
    """
    Given row y and column x on the simulation grid, return the
    value at that index in the underlying chunk cache.
    NOTE: (y,x) = (0,0) is the upper-left corner of the array.
    """
    (cy, cx, c_y, c_x) = translate_coords_2d(coords_2d, simulation_shape_2d, layer_shape_2d, chunk_shape_2d)
    chunk_2d = get_or_load_chunk_2d(chunk_cache_2d, cy, cx, load_chunk_2d)
    return chunk_2d[c_y, c_x]

def at_coords_3d(coords_3d, simulation_shape_3d, layer_shape_3d, chunk_shape_3d, chunk_cache_3d, load_chunk_3d):
    """
    Given band z, row y, and column x on the simulation grid,
    return the value at that index in the underlying chunk cache.
    NOTE: (z,y,x) = (0,0,0) is the upper-left corner of the array in the first timestep.
    """
    (cz, cy, cx, c_z, c_y, c_x) = translate_coords_3d(coords_3d, simulation_shape_3d, layer_shape_3d, chunk_shape_3d)
    chunk_3d = get_or_load_chunk_3d(chunk_cache_3d, cz, cy, cx, load_chunk_3d)
    return chunk_3d[c_z, c_y, c_x]

#==============================================================
# Constructor: Returns a 2D/3D Lookup Function for One Array
#==============================================================

def make_lookup_fn_2d(simulation_shape_2d, layer_shape_2d, chunk_shape_2d, load_chunk_2d):
    """
    Given the array shapes of the simulation space (|Y|,|X|), the
    underlying data layer (|LY|,|LX|), and a single chunk within the
    chunk cache (|CY|,|CX|) as well as a function to load one chunk
    on demand, return a closure that will retrieve the value from the
    underlying data layer corresponding to coordinate (y,x) in the
    simulation space. Chunks will be loaded on demand using load_chunk_2d.
    NOTE: (y,x) = (0,0) is the upper-left corner of the array.
    NOTE: simulation_shape_2d >= layer_shape_2d >= chunk_shape_2d
    """
    (layer_rows, layer_cols) = layer_shape_2d
    (chunk_rows, chunk_cols) = chunk_shape_2d
    chunk_cache_2d = np.empty((layer_rows // chunk_rows,
                               layer_cols // chunk_cols),
                              dtype=object)
    return lambda y, x: at_coords_2d((y, x),
                                     simulation_shape_2d,
                                     layer_shape_2d,
                                     chunk_shape_2d,
                                     chunk_cache_2d,
                                     load_chunk_2d)

def make_lookup_fn_3d(simulation_shape_3d, layer_shape_3d, chunk_shape_3d, load_chunk_3d):
    """
    Given the array shapes of the simulation space (|Z|,|Y|,|X|), the
    underlying data layer (|LZ|,|LY|,|LX|), and a single chunk within the
    chunk cache (|CZ|,|CY|,|CX|) as well as a function to load one chunk
    on demand, return a closure that will retrieve the value from the
    underlying data layer corresponding to coordinate (z,y,x) in the
    simulation space. Chunks will be loaded on demand using load_chunk_3d.
    NOTE: (z,y,x) = (0,0,0) is the upper-left corner of the array in the first timestep.
    NOTE: simulation_shape_3d >= layer_shape_3d >= chunk_shape_3d
    """
    (layer_bands, layer_rows, layer_cols) = layer_shape_3d
    (chunk_bands, chunk_rows, chunk_cols) = chunk_shape_3d
    chunk_cache_3d = np.empty((layer_bands // chunk_bands,
                               layer_rows // chunk_rows,
                               layer_cols // chunk_cols),
                              dtype=object)
    return lambda z, y, x: at_coords_3d((z, y, x),
                                        simulation_shape_3d,
                                        layer_shape_3d,
                                        chunk_shape_3d,
                                        chunk_cache_3d,
                                        load_chunk_3d)
#+end_src

** Lazy Array Usage Examples

#+begin_src python :tangle ../test/pyretechnics/lazy_array_test.py
import numpy as np
from pyretechnics.lazy_array import make_lookup_fn_2d, make_lookup_fn_3d

#==============================================================
# Raw Data - managed by the caller
#==============================================================

# 2D Arrays (e.g. 30m x 30m resolution, 30km x 30km extent)
elevation_layer                    = np.arange(0,1000000).reshape(1000,1000)
slope_layer                        = np.arange(0,1000000).reshape(1000,1000)
aspect_layer                       = np.arange(0,1000000).reshape(1000,1000)
fuel_model_layer                   = np.arange(0,1000000).reshape(1000,1000)
canopy_cover_layer                 = np.arange(0,1000000).reshape(1000,1000)
canopy_height_layer                = np.arange(0,1000000).reshape(1000,1000)
canopy_base_height_layer           = np.arange(0,1000000).reshape(1000,1000)
canopy_bulk_density_layer          = np.arange(0,1000000).reshape(1000,1000)
fuel_spread_adjustment_layer       = np.arange(0,1000000).reshape(1000,1000) # Optional Layer
suppression_difficulty_index_layer = np.arange(0,1000000).reshape(1000,1000) # Optional Layer

# 3D Arrays (e.g. 1hr x 300m x 300m resolution, 1day x 30km x 30km extent)
temperature_layer                   = np.arange(240000).reshape(24,100,100)
relative_humidity_layer             = np.arange(240000).reshape(24,100,100)
wind_speed_x_layer                  = np.arange(240000).reshape(24,100,100)
wind_speed_y_layer                  = np.arange(240000).reshape(24,100,100)
fuel_moisture_dead_1hr_layer        = np.arange(240000).reshape(24,100,100)
fuel_moisture_dead_10hr_layer       = np.arange(240000).reshape(24,100,100)
fuel_moisture_dead_100hr_layer      = np.arange(240000).reshape(24,100,100)
fuel_moisture_live_herbaceous_layer = np.arange(240000).reshape(24,100,100)
fuel_moisture_live_woody_layer      = np.arange(240000).reshape(24,100,100)
foliar_moisture_layer               = np.arange(240000).reshape(24,100,100)
weather_spread_adjustment_layer     = np.arange(240000).reshape(24,100,100) # Optional Layer

#==============================================================
# Chunk Loading Functions
#==============================================================

def make_load_chunk_2d(layer_2d, chunk_shape_2d):
    """
    Example 2D chunk loading function. Since we are calling the
    lazy array functions from Python and they will be used as
    read-only data by the caller, we can just provide a sliced view of
    the underlying array rather than generating a copy.
    """
    (chunk_rows, chunk_cols) = chunk_shape_2d
    return lambda cy, cx: layer_2d[cy * chunk_rows : (cy + 1) * chunk_rows,
                                   cx * chunk_cols : (cx + 1) * chunk_cols]

def make_load_chunk_3d(layer_3d, chunk_shape_3d):
    """
    Example 3D chunk loading function. Since we are calling the
    lazy array functions from Python and they will be used as
    read-only data by the caller, we can just provide a sliced view of
    the underlying array rather than generating a copy.
    """
    (chunk_bands, chunk_rows, chunk_cols) = chunk_shape_3d
    return lambda cz, cy, cx: layer_3d[cz * chunk_bands : (cz + 1) * chunk_bands,
                                       cy * chunk_rows  : (cy + 1) * chunk_rows,
                                       cx * chunk_cols  : (cx + 1) * chunk_cols]

#==============================================================
# Creating the Dictionary of Layer Names to Lookup Functions
#==============================================================

#--------------------  bands, rows, cols
simulation_shape_2d = (       1000, 1000)
layer_shape_2d      = (       1000, 1000)
chunk_shape_2d      = (        100,  100)

simulation_shape_3d = (   24, 1000, 1000)
layer_shape_3d      = (   24,  100,  100)
chunk_shape_3d      = (    1,   10,   10)

# Partial Application Functions
def make_lookup_fn_2d_for_layer(layer_2d):
    make_lookup_fn_2d(simulation_shape_2d,
                      layer_shape_2d,
                      chunk_shape_2d,
                      make_load_chunk_2d(layer_2d, chunk_shape_2d))

def make_lookup_fn_3d_for_layer(layer_3d):
    make_lookup_fn_3d(simulation_shape_3d,
                      layer_shape_3d,
                      chunk_shape_3d,
                      make_load_chunk_3d(layer_3d, chunk_shape_3d))

# Layer Dictionary
layer_lookup = {
    # 2D Arrays (e.g. 30m x 30m resolution, 30km x 30km extent)
    "elevation"                    : make_lookup_fn_2d_for_layer(elevation_layer),
    "slope"                        : make_lookup_fn_2d_for_layer(slope_layer),
    "aspect"                       : make_lookup_fn_2d_for_layer(aspect_layer),
    "fuel_model"                   : make_lookup_fn_2d_for_layer(fuel_model_layer),
    "canopy_cover"                 : make_lookup_fn_2d_for_layer(canopy_cover_layer),
    "canopy_height"                : make_lookup_fn_2d_for_layer(canopy_height_layer),
    "canopy_base_height"           : make_lookup_fn_2d_for_layer(canopy_base_height_layer),
    "canopy_bulk_density"          : make_lookup_fn_2d_for_layer(canopy_bulk_density_layer),
    "fuel_spread_adjustment"       : make_lookup_fn_2d_for_layer(fuel_spread_adjustment_layer),       # Optional Layer
    "suppression_difficulty_index" : make_lookup_fn_2d_for_layer(suppression_difficulty_index_layer), # Optional Layer

    # 3D Arrays (e.g. 1hr x 300m x 300m resolution, 1day x 30km x 30km extent)
    "temperature"                  : make_lookup_fn_3d_for_layer(temperature_layer),
    "relative_humidity"            : make_lookup_fn_3d_for_layer(relative_humidity_layer),
    "wind_speed_x"                 : make_lookup_fn_3d_for_layer(wind_speed_x_layer),
    "wind_speed_y"                 : make_lookup_fn_3d_for_layer(wind_speed_y_layer),
    "fuel_moisture_dead_1hr"       : make_lookup_fn_3d_for_layer(fuel_moisture_dead_1hr_layer),
    "fuel_moisture_dead_10hr"      : make_lookup_fn_3d_for_layer(fuel_moisture_dead_10hr_layer),
    "fuel_moisture_dead_100hr"     : make_lookup_fn_3d_for_layer(fuel_moisture_dead_100hr_layer),
    "fuel_moisture_live_herbaceous": make_lookup_fn_3d_for_layer(fuel_moisture_live_herbaceous_layer),
    "fuel_moisture_live_woody"     : make_lookup_fn_3d_for_layer(fuel_moisture_live_woody_layer),
    "foliar_moisture"              : make_lookup_fn_3d_for_layer(foliar_moisture_layer),
    "weather_spread_adjustment"    : make_lookup_fn_3d_for_layer(weather_spread_adjustment_layer),    # Optional Layer
}

#==============================================================
# Looking Up Values in the Layers
#==============================================================

# NOTE: 2D coords should be provided as (y,x) in simulation space.

dem_100_100  = layer_lookup["elevation"](100,100)
slp_100_100  = layer_lookup["slope"](100,100)
asp_100_100  = layer_lookup["aspect"](100,100)
fbfm_100_100 = layer_lookup["fuel_model"](100,100)
cc_100_100   = layer_lookup["canopy_cover"](100,100)
ch_100_100   = layer_lookup["canopy_height"](100,100)
cbh_100_100  = layer_lookup["canopy_base_height"](100,100)
cbd_100_100  = layer_lookup["canopy_bulk_density"](100,100)
fsa_100_100  = layer_lookup["fuel_spread_adjustment"](100,100)           # Optional Layer
sdi_100_100  = layer_lookup["suppression_difficulty_index"](100,100)     # Optional Layer

# NOTE: 3D coords should be provided as (z,y,x) in simulation space.

temp_12_100_100  = layer_lookup["temperature"](12,100,100)
rh_12_100_100    = layer_lookup["relative_humidity"](12,100,100)
wspx_12_100_100  = layer_lookup["wind_speed_x"](12,100,100)
wspy_12_100_100  = layer_lookup["wind_speed_y"](12,100,100)
md1_12_100_100   = layer_lookup["fuel_moisture_dead_1hr"](12,100,100)
md10_12_100_100  = layer_lookup["fuel_moisture_dead_10hr"](12,100,100)
md100_12_100_100 = layer_lookup["fuel_moisture_dead_100hr"](12,100,100)
mlh_12_100_100   = layer_lookup["fuel_moisture_live_herbaceous"](12,100,100)
mlw_12_100_100   = layer_lookup["fuel_moisture_live_woody"](12,100,100)
fm_12_100_100    = layer_lookup["foliar_moisture"](12,100,100)
wsa_12_100_100   = layer_lookup["weather_spread_adjustment"](12,100,100) # Optional Layer
#+end_src

* Fire Spread API

Pyretechnics provides two main functions for simulating fire behavior over a region of space-time:

** grow_fire

Simulates the growth of a fire over space and time starting from one
or more actively burning cells. Suppression effects may be optionally
applied, and several different stop conditions may be specified. A
random seed may be optionally provided to ensure deterministically
reproducible runs, despite the presence of stochastic calculations
within the fire spread algorithm.

*** Inputs

The ~grow_fire~ function takes a single =world_state= dictionary as input with these fields:

- simulation_clock :: a float specifying the number of minutes from the start time of the simulated space-time cube to begin the simulation

- config_dict :: a dictionary of parameter names to their values with the following types:

  *TODO*: Determine whether rectangular cells will work for the GridFire and ELMFIRE spread algorithms. If not, eliminate this degree of freedom from the API.
  *TODO*: Add interpolation options to the gridded data source class
  *TODO*: simulation_north_angle may be dropped if we require inputs to use North-up projections for both fuels and weather

  |---------------------------+-----------------------------+-------------------------------------------------------------------------------------------+-----------+---------|
  | Parameter Name            | Type                        | Units                                                                                     | Optional? | Default |
  |---------------------------+-----------------------------+-------------------------------------------------------------------------------------------+-----------+---------|
  | simulation_shape          | Tuple (int, int, int)       | (num timesteps, num rows, num cols)                                                       |           |         |
  | simulation_resolution     | Tuple (float, float, float) | (minutes per timestep, meters per row, meters per column)                                 |           |         |
  | simulation_north_angle    | float                       | degrees clockwise from the top of the circle [0,360)                                      | Yes       | 0.0     |
  | simulation_stop_condition | Dictionary {string: float}  | either {'max_burn_duration': minutes} or {'max_burned_area': square_meters}               | Yes       | None    |
  | random_seed               | number or string            | the seed value to initialize the random number generator                                  | Yes       | None    |
  | overwrite_outputs         | boolean                     | True or False, whether to mutate or copy the Numpy arrays provided in *output_layer_dict* | Yes       | False   |
  | alpha_suppression         | Dictionary {string: float}  | parameters for the *alpha* suppression algorithm (see table below)                        | Yes       | None    |
  | sdi_suppression           | Dictionary {string: float}  | parameters for the *sdi* suppression algorithm (see table below)                          | Yes       | None    |
  | spotting                  | Dictionary {string: float}  | parameters for the spotting algorithm (see table below)                                   | Yes       | None    |
  |---------------------------+-----------------------------+-------------------------------------------------------------------------------------------+-----------+---------|

  - alpha_suppression :: a dictionary of parameter names to their values for the *alpha* suppression algorithm:

  |-------------------------+-------+------------------------------------|
  | Parameter Name          | Type  | Units                              |
  |-------------------------+-------+------------------------------------|
  | suppression_timestep    | float | minutes between suppression events |
  | suppression_coefficient | float | unitless                           |
  |-------------------------+-------+------------------------------------|

  - sdi_suppression :: a dictionary of parameter names to their values for the *sdi* suppression algorithm:

  |-----------------------------------------------+-------+------------------------------------|
  | Parameter Name                                | Type  | Units                              |
  |-----------------------------------------------+-------+------------------------------------|
  | suppression_timestep                          | float | minutes between suppression events |
  | sdi_sensitivity_to_difficulty                 | float | unitless                           |
  | sdi_containment_overwhelming_area_growth_rate | float | hectares/day                       |
  | sdi_reference_suppression_speed               | float | percent/day                        |
  |-----------------------------------------------+-------+------------------------------------|

  - spotting :: a dictionary of parameter names to their values for the spotting algorithm:

  |--------------------------------+---------+--------------------------------------------------+------------|
  | Parameter Name                 | Type    | Units                                            | Fire Model |
  |--------------------------------+---------+--------------------------------------------------+------------|
  | firebrands_per_cell            | int     | number of embers to cast from each spotting cell | GridFire   |
  | decay_constant                 | float   | TODO: find units range                           | GridFire   |
  | mean_distance                  | float   | TODO: find units range                           | GridFire   |
  | flin_exp                       | float   | TODO: find units range                           | GridFire   |
  | ws_exp                         | float   | TODO: find units range                           | GridFire   |
  | normalized_distance_variance   | float   | TODO: find units range                           | GridFire   |
  | delta_y_sigma                  | float   | TODO: find units range                           | GridFire   |
  |--------------------------------+---------+--------------------------------------------------+------------|
  | ember_gr                       | int     | TODO: find units range                           | ELMFIRE    |
  | pign                           | float   | percent [0-100]                                  | ELMFIRE    |
  | pign_max                       | float   | percent [0-100]                                  | ELMFIRE    |
  | pign_min                       | float   | percent [0-100]                                  | ELMFIRE    |
  | tau_embergen                   | float   | TODO: find units range                           | ELMFIRE    |
  | use_umd_spotting_model         | boolean | True or False                                    | ELMFIRE    |
  | p_eps                          | float   | TODO: find units range                           | ELMFIRE    |
  | use_physical_spotting_duration | boolean | True or False                                    | ELMFIRE    |
  | use_physical_ember_number      | boolean | True or False                                    | ELMFIRE    |
  | ember_sampling_factor          | float   | TODO: find units range                           | ELMFIRE    |
  | use_superseded_spotting        | boolean | True or False                                    | ELMFIRE    |
  |--------------------------------+---------+--------------------------------------------------+------------|

- input_layer_dict :: a dictionary of layer names to either 2-arity (2D) or 3-arity (3D) functions for accessing the numeric values at each =(y,x)= or =(z,y,x)= coordinate in the simulated space-time cube:

  |--------------------------------------------+-------+--------------------------------------------------------+-----------+-------|
  | Layer Name                                 | Type  | Units                                                  | Optional? | Arity |
  |--------------------------------------------+-------+--------------------------------------------------------+-----------+-------|
  | elevation                                  | float | meters                                                 |           |     2 |
  | slope                                      | float | percent [0-100+] (vertical meters/horizontal meters)   |           |     2 |
  | aspect                                     | float | degrees clockwise from North [0-360)                   |           |     2 |
  | fuel_model                                 | int   | fuel model numbers [1-256]                             |           |     2 |
  | canopy_cover                               | float | percent [0-100]                                        |           |     2 |
  | canopy_height                              | float | meters                                                 |           |     2 |
  | canopy_base_height                         | float | meters                                                 |           |     2 |
  | canopy_bulk_density                        | float | kilograms/meters^3                                     |           |     2 |
  | fuel_spread_adjustment                     | float | real number >= 0.0 (1.0 means no adjustment)           | Yes       |     2 |
  | suppression_difficulty_index               | float | integer >= 0  (TODO: What is the correct value range?) | Yes       |     2 |
  | surface_spotting_fire_line_intensity       | float | kilowatts/meter                                        | Yes       |     2 |
  | surface_spotting_percent (TODO: min, max?) | float | percent [0-100]                                        | Yes       |     2 |
  | crown_spotting_percent   (TODO: min, max?) | float | percent [0-100]                                        | Yes       |     2 |
  | temperature                                | float | degrees Celsius                                        | Yes       |     3 |
  | relative_humidity                          | float | percent [0-100+]                                       | Yes       |     3 |
  | wind_speed_10m_x                           | float | meters/second                                          |           |     3 |
  | wind_speed_10m_y                           | float | meters/second                                          |           |     3 |
  | fuel_moisture_dead_1hr                     | float | percent [0-100+] grams moisture/grams ovendry wood     |           |     3 |
  | fuel_moisture_dead_10hr                    | float | percent [0-100+] grams moisture/grams ovendry wood     |           |     3 |
  | fuel_moisture_dead_100hr                   | float | percent [0-100+] grams moisture/grams ovendry wood     |           |     3 |
  | fuel_moisture_live_herbaceous              | float | percent [0-100+] grams moisture/grams ovendry wood     |           |     3 |
  | fuel_moisture_live_woody                   | float | percent [0-100+] grams moisture/grams ovendry wood     |           |     3 |
  | foliar_moisture                            | float | percent [0-100+] grams moisture/grams ovendry foliage  |           |     3 |
  | weather_spread_adjustment                  | float | real number >= 0.0 (1.0 means no adjustment)           | Yes       |     3 |
  |--------------------------------------------+-------+--------------------------------------------------------+-----------+-------|

- output_layer_dict :: an *optional* dictionary of layer names to 2D Numpy arrays with the following units to pre-populate the simulation output arrays:
  *TODO* Consider whether some of these layers should be kept as internal state and not returned to the user.

  |---------------------------------+---------+------------------------------------------------------------------------------+-----------|
  | Parameter Name                  | Type    | Units                                                                        | Optional? |
  |---------------------------------+---------+------------------------------------------------------------------------------+-----------|
  | eulerian_level_set_phi_field    | float16 | TODO: find units range                                                       | No        |
  | time_of_arrival                 | float32 | minutes from the start time of the simulated space-time cube                 | Yes       |
  | max_surface_spread_direction    | float16 | degrees clockwise from North                                                 | Yes       |
  | max_crown_spread_direction      | float16 | degrees clockwise from North                                                 | Yes       |
  | perimeter_spread_direction      | float16 | degrees clockwise from North                                                 | Yes       |
  | max_surface_spread_rate         | float16 | meters/second                                                                | Yes       |
  | max_crown_spread_rate           | float16 | meters/second                                                                | Yes       |
  | perimeter_spread_rate           | float16 | meters/second                                                                | Yes       |
  | surface_eccentricity            | float16 | dimensionless (0: circular fire, >0: elliptical fire)                        | Yes       |
  | crown_eccentricity              | float16 | dimensionless (0: circular fire, >0: elliptical fire)                        | Yes       |
  | max_surface_fire_line_intensity | float32 | kilowatts/meter                                                              | Yes       |
  | max_crown_fire_line_intensity   | float32 | kilowatts/meter                                                              | Yes       |
  | perimeter_fire_line_intensity   | float32 | kilowatts/meter                                                              | Yes       |
  | max_surface_flame_length        | float16 | meters                                                                       | Yes       |
  | max_crown_flame_length          | float16 | meters                                                                       | Yes       |
  | perimeter_flame_length          | float16 | meters                                                                       | Yes       |
  | fire_type                       | uint8   | 0 = no_fire, 1 = surface_fire, 2 = passive_crown_fire, 3 = active_crown_fire | Yes       |
  | ember_count                     | uint32  | number of embers landing in each cell                                        | Yes       |
  | ember_ignition                  | bool8   | True for cells ignited by embers, False otherwise                            | Yes       |
  |---------------------------------+---------+------------------------------------------------------------------------------+-----------|

- ignited_cells_set :: set of cells that are actively burning at the simulation start time, specified as 3D coordinates =(z,y,x)= in the simulated space-time cube

*** Outputs

The ~grow_fire~ function will return a dictionary with these fields:

- simulation_clock :: a float specifying the number of minutes from the start time of the simulated space-time cube at which the simulation stopped

- simulation_stop_condition_encountered :: max_burn_duration | max_burned_area | no_burnable_fuel | end_of_temporal_data | fully_suppressed

- config_dict :: a dictionary of parameter names to their values as defined in section [[Inputs]] above

- input_layer_dict :: a dictionary of layer names to either 2-arity (2D) or 3-arity (3D) functions as defined in section [[Inputs]] above

- output_layer_dict :: a dictionary of layer names to 2D Numpy arrays as defined in section [[Inputs]] above

- ignited_cells_set :: set of cells that are actively burning at the simulation stop time, specified as 3D coordinates =(z,y,x)= in the simulated space-time cube

Note that =config_dict= and =input_layer_dict= will be unchanged from
the input dictionary that was provided to ~grow_fire~. All other
fields will contain values updated by the fire spread simulation.

*** Play/Pause/Continue Workflow

The inputs and outputs of ~grow_fire~ are structured so as to enable
you to simulate fire spread from =simulation_clock= until a stop
condition is encountered and then to easily resume the fire spread
simulation from the output =simulation_clock= until the next stop
condition is met. Here is an example of how to do this.

#+begin_src python
import numpy as np

#=======================================================
# Phase 1: Initial fire simulation - first 12 hours
#=======================================================

world_state = {
    simulation_clock: 0.0,

    config_dict: {
        "simulation_shape"         : (24, 1000, 1000),
        "simulation_resolution"    : (60, 30, 30),
        "simulation_stop_condition": {"max_burn_duration": 720.0},
    },

    input_layer_dict: {
        # 2D Arrays (e.g. 30m x 30m resolution, 30km x 30km extent)
        "elevation"                    : lambda y,x: 0.0,
        "slope"                        : lambda y,x: 0.0,
        "aspect"                       : lambda y,x: 0.0,
        "fuel_model"                   : lambda y,x: 100,
        "canopy_cover"                 : lambda y,x: 0.0,
        "canopy_height"                : lambda y,x: 0.0,
        "canopy_base_height"           : lambda y,x: 0.0,
        "canopy_bulk_density"          : lambda y,x: 0.0,
        # 3D Arrays (e.g. 1hr x 300m x 300m resolution, 1day x 30km x 30km extent)
        "temperature"                  : lambda z,y,x: 10.0,
        "relative_humidity"            : lambda z,y,x: 10.0,
        "wind_speed_x"                 : lambda z,y,x: 0.0,
        "wind_speed_y"                 : lambda z,y,x: 0.0,
        "fuel_moisture_dead_1hr"       : lambda z,y,x: 10.0,
        "fuel_moisture_dead_10hr"      : lambda z,y,x: 10.0,
        "fuel_moisture_dead_100hr"     : lambda z,y,x: 10.0,
        "fuel_moisture_live_herbaceous": lambda z,y,x: 10.0,
        "fuel_moisture_live_woody"     : lambda z,y,x: 10.0,
        "foliar_moisture"              : lambda z,y,x: 10.0,
    },

    output_layer_dict: {
        "eulerian_level_set_phi_field" : np.full((1000, 1000), 0.0, dtype="float16"),
    },

    ignited_cells_set: set([(0, 100, 100)]),
}

world_state2 = grow_fire(world_state)

#=======================================================
# Phase 2: Continued fire simulation - second 12 hours
#=======================================================

world_state3 = grow_fire(world_state2)
#+end_src

** burn_cells

TODO: stub

* Fire Spread Functions

# TODO: How do I want to memoize the no_wind_no_slope_surface_fire_min values?

#       - IDEA: We can just save max_spread_rate,
#       - max_spread_direction, eccentricity, and fire_line_intensity
#       - for surface and crown conditions (plus crown_fire_type) in
#       - chunked arrays. When combined with a fire-line normal
#       - direction multiplier, you can just multiply max_spread_rate
#       - and fire_line_intensity by it to get the fire-line normal
#       - spread rate and fire-line intensity. Also, don't store flame
#       - length during the simulation. Compute it at the end in
#       - postprocessing.

# TODO: Consider implementing a chunked array class and using it to store intermediate/output arrays as well

#+begin_src python :tangle ../src/pyretechnics/fire_spread.py
# TODO: Compare this with numpy.random (is there a generator object that I can use here?)
import random
import numpy as np

def supply_layer(layer_dict, layer_name, layer_shape, layer_type, initial_value, overwrite_layers):
    layer = layer_dict.get(layer_name)
    if layer:
        if overwrite_layers:
            return layer
        else:
            return layer.copy()
    else:
        return np.full(layer_shape, initial_value, dtype=layer_type)


# FIXME: stub
def burn_cells(world_state):
    """
    1. Validate inputs
       - Make sure that all required parameters are present in config_dict
       - Make sure that all required entries are present in layer_dict
       - Check for entries in output_layer_dict; if present, copy/use as new output layers
         - Use time of arrival raster to identify the burn scar(s); if missing, we are simulating point ignitions
       - Make sure that ignited_cells_set is a set of integer 3-tuples
    2. Iterate through all cells in (rows, cols), compute the maximum spread rate and severity values, and store them in output arrays
       - Run surface and crown equations per cell
    3. Return a dictionary of the outputs
    """
    simulation_clock  = world_state["simulation_clock"]
    config_dict       = world_state["config_dict"]
    input_layer_dict  = world_state["input_layer_dict"]
    output_layer_dict = world_state.get("output_layer_dict", {})
    ignited_cells_set = world_state["ignited_cells_set"]

    # The random seed affects input layer perturbations.
    if config_dict.get("random_seed"):
        random.seed(config_dict.get("random_seed"))

    return None


# FIXME: stub
def grow_fire(world_state):
    """
    1. Validate inputs
       - Make sure that all required parameters are present in config_dict
       - Make sure that all required entries are present in layer_dict
       - Check for entries in output_layer_dict; if present, copy/use as new output layers
         - Use time of arrival raster to identify the burn scar(s); if missing, we are simulating point ignitions
       - Make sure that ignited_cells_set is a set of integer 3-tuples
    2. Iterate through all cells in ignited_cells_set, compute the perimeter-oriented spread rate and severity values, and store them in output arrays
    3. Perform constant spread out over the landscape in all directions
       - Run surface, crown, and spot equations per ignited cell
    4. Record the time_of_arrival in each cell as it spreads
    5. Continue until a stop condition is met (e.g., max_burn_duration or max_burned_area)
    6. Return a dictionary of the outputs
    """
    simulation_clock  = world_state["simulation_clock"]
    config_dict       = world_state["config_dict"]
    input_layer_dict  = world_state["input_layer_dict"]
    output_layer_dict = world_state.get("output_layer_dict", {})
    ignited_cells_set = world_state["ignited_cells_set"]

    # The random seed affects input layer perturbations and spotting calculations.
    if config_dict.get("random_seed"):
        random.seed(config_dict.get("random_seed"))

    # GridFire initializes the following 2D arrays for its spread algorithm:
    #
    #   :burn-time-matrix                [float32] time_of_arrival (with -1 for values in the interior of the burn scar)
    #   :eccentricity-matrix             [float32] -1 in burn scar, 0 otherwise
    #   :fire-line-intensity-matrix      [float32] -1 in burn scar, 0 otherwise
    #   :fire-spread-matrix              [float32] +1 in burn scar, 0 otherwise
    #   :fire-type-matrix                [float32] -1 in burn scar, 0 otherwise
    #   :firebrand-count-matrix          [ int32 ]  0 everywhere (when spotting params are passed)
    #   :flame-length-matrix             [float32] -1 in burn scar, 0 otherwise
    #   :directional-flame-length-matrix [float32] -1 in burn scar, 0 otherwise (when compute-directional-values? = true)
    #   :max-spread-direction-matrix     [float32] -1 in burn scar, 0 otherwise
    #   :max-spread-rate-matrix          [float32] -1 in burn scar, 0 otherwise
    #   :modified-time-matrix            [ int32 ]  0 everywhere
    #   :residence-time-matrix           [float32] -1 in burn scar, 0 otherwise (when compute-directional-values? = true)
    #   :reaction-intensity-matrix       [float32] -1 in burn scar, 0 otherwise (when compute-directional-values? = true)
    #   :spot-matrix                     [float32]  0 everywhere (when spotting params are passed)
    #   :spread-rate-matrix              [float32] -1 in burn scar, 0 otherwise
    #   :spread-rate-sum-matrix          [float32]  0 everywhere (when compute-directional-values? = true)
    #   :travel-lines-matrix             [ int16 ]  0 everywhere
    #   :x-magnitude-sum-matrix          [float32]  0 everywhere (when compute-directional-values? = true)
    #   :y-magnitude-sum-matrix          [float32]  0 everywhere (when compute-directional-values? = true)
    #
    # Equivalent Pyretechnics 2D arrays in output_layer_dict:
    #
    #   ========================= Output 2D Arrays =========================
    #   time_of_arrival                  :burn-time-matrix
    #   max_surface_spread_direction     :max-spread-direction-matrix
    #   max_crown_spread_direction       :max-spread-direction-matrix
    #   perimeter_spread_direction       N/A
    #   max_surface_spread_rate          :max-spread-rate-matrix
    #   max_crown_spread_rate            :max-spread-rate-matrix
    #   perimeter_spread_rate            :spread-rate-matrix
    #   max_surface_fire_line_intensity  :fire-line-intensity-matrix
    #   max_crown_fire_line_intensity    :fire-line-intensity-matrix
    #   perimeter_fire_line_intensity    :fire-line-intensity-matrix
    #   max_surface_flame_length         :flame-length-matrix
    #   max_crown_flame_length           :flame-length-matrix
    #   perimeter_flame_length           :directional-flame-length-matrix
    #   fire_type                        :fire-type-matrix
    #   ember_count                      :firebrand-count-matrix
    #   ember_ignition                   :spot-matrix
    #
    #   ======================== Internal 2D Arrays ========================
    #   surface_eccentricity             :eccentricity-matrix
    #   crown_eccentricity               :eccentricity-matrix
    #
    # GridFire 2D arrays that are not needed by Pyretechnics:
    #
    #   ======================== Replaced 2D Arrays ========================
    #   :fire-spread-matrix              time_of_arrival
    #   :residence-time-matrix           max_surface_fire_line_intensity, max_crown_fire_line_intensity, surface_eccentricity, crown_eccentricity
    #   :reaction-intensity-matrix       max_surface_fire_line_intensity, max_crown_fire_line_intensity, surface_eccentricity, crown_eccentricity
    #
    #   ======================== Internal 2D Arrays ========================
    #   :modified-time-matrix            \
    #   :travel-lines-matrix              |
    #   :spread-rate-sum-matrix           |-- for its 2D spread algorithm
    #   :x-magnitude-sum-matrix           |
    #   :y-magnitude-sum-matrix          /

    (num_timesteps, num_rows, num_cols) = config_dict["simulation_shape"]
    layer_shape = (num_rows, num_cols)
    overwrite_outputs = config_dict["overwrite_outputs"]

    output_layer_dict = {
        "eulerian_level_set_phi_field"   : supply_layer(output_layer_dict, "eulerian_level_set_phi_field"   , layer_shape, "float16", np.nan, overwrite_outputs),
        "time_of_arrival"                : supply_layer(output_layer_dict, "time_of_arrival"                , layer_shape, "float32", np.nan, overwrite_outputs),
        "max_surface_spread_direction"   : supply_layer(output_layer_dict, "max_surface_spread_direction"   , layer_shape, "float16", np.nan, overwrite_outputs),
        "max_crown_spread_direction"     : supply_layer(output_layer_dict, "max_crown_spread_direction"     , layer_shape, "float16", np.nan, overwrite_outputs),
        "perimeter_spread_direction"     : supply_layer(output_layer_dict, "perimeter_spread_direction"     , layer_shape, "float16", np.nan, overwrite_outputs),
        "max_surface_spread_rate"        : supply_layer(output_layer_dict, "max_surface_spread_rate"        , layer_shape, "float16", np.nan, overwrite_outputs),
        "max_crown_spread_rate"          : supply_layer(output_layer_dict, "max_crown_spread_rate"          , layer_shape, "float16", np.nan, overwrite_outputs),
        "perimeter_spread_rate"          : supply_layer(output_layer_dict, "perimeter_spread_rate"          , layer_shape, "float16", np.nan, overwrite_outputs),
        "surface_eccentricity"           : supply_layer(output_layer_dict, "surface_eccentricity"           , layer_shape, "float16", np.nan, overwrite_outputs),
        "crown_eccentricity"             : supply_layer(output_layer_dict, "crown_eccentricity"             , layer_shape, "float16", np.nan, overwrite_outputs),
        "max_surface_fire_line_intensity": supply_layer(output_layer_dict, "max_surface_fire_line_intensity", layer_shape, "float32", np.nan, overwrite_outputs),
        "max_crown_fire_line_intensity"  : supply_layer(output_layer_dict, "max_crown_fire_line_intensity"  , layer_shape, "float32", np.nan, overwrite_outputs),
        "perimeter_fire_line_intensity"  : supply_layer(output_layer_dict, "perimeter_fire_line_intensity"  , layer_shape, "float32", np.nan, overwrite_outputs),
        "max_surface_flame_length"       : supply_layer(output_layer_dict, "max_surface_flame_length"       , layer_shape, "float16", np.nan, overwrite_outputs),
        "max_crown_flame_length"         : supply_layer(output_layer_dict, "max_crown_flame_length"         , layer_shape, "float16", np.nan, overwrite_outputs),
        "perimeter_flame_length"         : supply_layer(output_layer_dict, "perimeter_flame_length"         , layer_shape, "float16", np.nan, overwrite_outputs),
        "fire_type"                      : supply_layer(output_layer_dict, "fire_type"                      , layer_shape, "uint8"  ,      0, overwrite_outputs),
        "ember_count"                    : supply_layer(output_layer_dict, "ember_count"                    , layer_shape, "uint32" ,      0, overwrite_outputs),
        "ember_ignition"                 : supply_layer(output_layer_dict, "ember_ignition"                 , layer_shape, "bool8"  ,  False, overwrite_outputs),
    }

    # RESUME at [[file:~/code/sig-gis/gridfire/src/gridfire/fire_spread.clj::(defn- run-loop]]
    # TODO: Investigate ELMFIRE's inputs to determine if we are missing anything needed by its API.

    return None
#+end_src

** ELMFIRE Inputs

This section lists the full set of inputs used in any =elmfire.data= or =elmfire.data.in= file in:

- the current =main= branch of the =elmfire= repository located here: https://github.com/lautenberger/elmfire
- the current =main= branch of the =runway-scripts= repository located here: https://gitlab.sig-gis.com/sig-gis/runway-scripts

The following table contains the current mapping from ELMFIRE parameters to Pyretechnics parameters:

|------------------------------------------+---------------------------------------+-----------------------------------------|
| ELMFIRE                                  | Pyretechnics Group                    | Pyretechnics Parameter                  |
|------------------------------------------+---------------------------------------+-----------------------------------------|
| DT_METEOROLOGY                           | config_dict                           | simulation_resolution[0]                |
| COMPUTATIONAL_DOMAIN_CELLSIZE            | config_dict                           | simulation_resolution[1:]               |
| SIMULATION_TSTART                        |                                       | ?                                       |
| SIMULATION_TSTOP                         | config_dict.simulation_stop_condition | max_burn_duration                       |
| EMBER_GR                                 | config_dict.spotting                  | ember_gr                                |
| EMBER_SAMPLING_FACTOR                    | config_dict.spotting                  | ember_sampling_factor                   |
| ENABLE_SPOTTING                          | config_dict.spotting                  | Enabled if dictionary is present        |
| P_EPS                                    | config_dict.spotting                  | p_eps                                   |
| PIGN                                     | config_dict.spotting                  | pign                                    |
| PIGN_MAX                                 | config_dict.spotting                  | pign_max                                |
| PIGN_MIN                                 | config_dict.spotting                  | pign_min                                |
| TAU_EMBERGEN                             | config_dict.spotting                  | tau_embergen                            |
|------------------------------------------+---------------------------------------+-----------------------------------------|
| DEM_FILENAME                             | input_layer_dict                      | elevation                               |
| SLP_FILENAME                             | input_layer_dict                      | slope                                   |
| ASP_FILENAME                             | input_layer_dict                      | aspect                                  |
| FBFM_FILENAME                            | input_layer_dict                      | fuel_model                              |
| CC_FILENAME                              | input_layer_dict                      | canopy_cover                            |
| CH_FILENAME                              | input_layer_dict                      | canopy_height                           |
| CBH_FILENAME                             | input_layer_dict                      | canopy_base_height                      |
| CBD_FILENAME                             | input_layer_dict                      | canopy_bulk_density                     |
| ADJ_FILENAME                             | input_layer_dict                      | fuel_spread_adjustment                  |
| CRITICAL_SPOTTING_FIRELINE_INTENSITY(:)  | input_layer_dict                      | surface_spotting_fire_line_intensity    |
| GLOBAL_SURFACE_FIRE_SPOTTING_PERCENT_MAX | input_layer_dict                      | surface_spotting_percent                |
| GLOBAL_SURFACE_FIRE_SPOTTING_PERCENT_MIN | input_layer_dict                      | surface_spotting_percent                |
| WS_FILENAME                              | input_layer_dict                      | wind_speed_x, wind_speed_y              |
| WD_FILENAME                              | input_layer_dict                      | wind_speed_x, wind_speed_y              |
| M1_FILENAME                              | input_layer_dict                      | fuel_moisture_dead_1hr                  |
| M10_FILENAME                             | input_layer_dict                      | fuel_moisture_dead_10hr                 |
| M100_FILENAME                            | input_layer_dict                      | fuel_moisture_dead_100hr                |
| MLH_FILENAME                             | input_layer_dict                      | fuel_moisture_live_herbaceous           |
| MLW_FILENAME                             | input_layer_dict                      | fuel_moisture_live_woody                |
|------------------------------------------+---------------------------------------+-----------------------------------------|
| PHI_FILENAME                             | output_layer_dict                     | eulerian_level_set_phi_field            |
|------------------------------------------+---------------------------------------+-----------------------------------------|
| T_IGN(1)                                 | ignited_cells_set                     | (t, _, _)                               |
| Y_IGN(1)                                 | ignited_cells_set                     | (_, y, _)                               |
| X_IGN(1)                                 | ignited_cells_set                     | (_, _, x)                               |
|------------------------------------------+---------------------------------------+-----------------------------------------|
| BANDTHICKNESS                            |                                       | ?                                       |
| METEOROLOGY_BAND_SKIP_INTERVAL           |                                       | ?                                       |
| METEOROLOGY_BAND_START                   |                                       | ?                                       |
| METEOROLOGY_BAND_STOP                    |                                       | ?                                       |
| NUM_METEOROLOGY_TIMES                    |                                       | ?                                       |
| CROWN_FIRE_MODEL                         |                                       | ?                                       |
| MODE                                     |                                       | ?                                       |
| SIMULATION_DT                            |                                       | ?                                       |
| SIMULATION_DTMAX                         |                                       | ?                                       |
| TARGET_CFL                               |                                       | ?                                       |
| USE_BLDG_SPREAD_MODEL                    |                                       | ?                                       |
| USE_EULERIAN_FRAMEWORK                   |                                       | ?                                       |
| USE_PHYSICAL_EMBER_NUMBER                |                                       | ?                                       |
| USE_PHYSICAL_SPOTTING_DURATION           |                                       | ?                                       |
| USE_SUPERSEDED_SPOTTING                  |                                       | ?                                       |
| USE_UMD_SPOTTING_MODEL                   |                                       | ?                                       |
| WX_BILINEAR_INTERPOLATION                |                                       | ?                                       |
| ALLOW_MULTIPLE_IGNITIONS_AT_A_PIXEL      |                                       | ?                                       |
|------------------------------------------+---------------------------------------+-----------------------------------------|
| FUELS_AND_TOPOGRAPHY_DIRECTORY           | N/A                                   | Input reading managed externally        |
| A_SRS                                    | N/A                                   | GIS operations managed externally       |
| LATITUDE                                 | N/A                                   | GIS operations managed externally       |
| LONGITUDE                                | N/A                                   | GIS operations managed externally       |
| COMPUTATIONAL_DOMAIN_XLLCORNER           | N/A                                   | GIS operations managed externally       |
| COMPUTATIONAL_DOMAIN_YLLCORNER           | N/A                                   | GIS operations managed externally       |
| FORECAST_START_HOUR                      | N/A                                   | GIS operations managed externally       |
| UTC_OFFSET_HOURS                         | N/A                                   | GIS operations managed externally       |
| CURRENT_YEAR                             | N/A                                   | GIS operations managed externally       |
| HOUR_OF_YEAR                             | N/A                                   | GIS operations managed externally       |
| PATH_TO_GDAL                             | N/A                                   | GIS operations managed externally       |
| NUM_ENSEMBLE_MEMBERS                     | N/A                                   | Random sampling managed externally      |
| NUM_IGNITIONS                            | N/A                                   | Random sampling managed externally      |
| RANDOM_IGNITIONS                         | N/A                                   | Random sampling managed externally      |
| USE_IGNITION_MASK                        | N/A                                   | Random sampling managed externally      |
| USE_CONSTANT_LH                          | N/A                                   | Replaced by abstract gridded datasource |
| USE_CONSTANT_LW                          | N/A                                   | Replaced by abstract gridded datasource |
| LH_MOISTURE_CONTENT                      | N/A                                   | Replaced by abstract gridded datasource |
| LW_MOISTURE_CONTENT                      | N/A                                   | Replaced by abstract gridded datasource |
| OUTPUTS_DIRECTORY                        | N/A                                   | Output writing managed externally       |
| SCRATCH                                  | N/A                                   | Output writing managed externally       |
| CONVERT_TO_GEOTIFF                       | N/A                                   | Output writing managed externally       |
| DTDUMP                                   | N/A                                   | Output writing managed externally       |
| DT_DUMP_EMBER_FLUX                       | N/A                                   | Output writing managed externally       |
| DUMP_EMBER_FLUX_UMD                      | N/A                                   | Output writing managed externally       |
| DUMP_FLAME_LENGTH                        | N/A                                   | Output writing managed externally       |
| DUMP_FLIN                                | N/A                                   | Output writing managed externally       |
| DUMP_SPOTTING_OUTPUTS                    | N/A                                   | Output writing managed externally       |
| DUMP_SPREAD_RATE                         | N/A                                   | Output writing managed externally       |
| DUMP_TIME_OF_ARRIVAL                     | N/A                                   | Output writing managed externally       |
|------------------------------------------+---------------------------------------+-----------------------------------------|

* Fire Behavior Model

Pyretechnics implements the following fire behavior formulas from the
fire science literature:

- Surface Fire Spread: Rothermel 1972 with FIREMODS adjustments from Albini 1976
- Crown Fire Initiation: Van Wagner 1977
- Passive/Active Crown Fire Spread: Cruz 2005
- Flame Length and Fire Line Intensity: Byram 1959
- Midflame Wind Adjustment Factor: Albini & Baughman 1979 parameterized as in BehavePlus, FARSITE, FlamMap, FSPro, and FPA according to Andrews 2012\nocite{Albini1979,Andrews2012}
- Fire Spread on a Raster Grid: Morais 2001 (method of adaptive timesteps and fractional distances)
- Spot Fire: Perryman 2013

The following fuel models are supported:

- Anderson 13: no dynamic loading
- Scott & Burgan 40: dynamic loading implemented according to Scott & Burgan 2005

In the following sections, we describe the operation of this system in
detail.

** Fuel Model Definitions

All fires ignite and travel through some form of burnable fuel.
Although the effects of wind and slope on the rate of fire spread can
be quite pronounced, its fundamental thermodynamic characteristics are
largely determined by the fuel type in which it is sustained. For
wildfires, these fuels are predominantly herbaceous and woody
vegetation (both alive and dead) as well as decomposing elements of
dead vegetation, such as duff or leaf litter. To estimate the heat
output and rate of spread of a fire burning through any of these
fuels, we must determine those physical properties that affect heat
absorption and release.

Of course, measuring these fuel properties for every kind of
vegetation that may be burned in a wildfire is an intractable task. To
cope with this, fuels are classified into categories called ``fuel
models'' which share similar burning characteristics. Each fuel model
is then assigned a set of representative values for each of the
thermally relevant physical properties shown in Table
[[tab:fuel-model-properties]].

#+NAME: tab:fuel-model-properties
#+CAPTION: Physical properties assigned to each fuel model
#+ATTR_LATEX: :align |l|l|l| :font \small
|----------+--------------------------------------------+-----------------------------------------|
| Property | Description                                | Units                                   |
|----------+--------------------------------------------+-----------------------------------------|
| \delta   | fuel depth                                 | ft                                      |
| w_{o}    | ovendry fuel loading                       | lb/ft^{2}                               |
| \sigma   | fuel particle surface-area-to-volume ratio | ft^{2}/ft^{3}                           |
| M_{x}    | moisture content of extinction             | lb moisture/lb ovendry wood             |
| h        | fuel particle low heat content             | Btu/lb                                  |
| \rho_{p} | ovendry particle density                   | lb/ft^{3}                               |
| S_{T}    | fuel particle total mineral content        | lb minerals/lb ovendry wood             |
| S_{e}    | fuel particle effective mineral content    | lb silica-free minerals/lb ovendry wood |
| M_{f}    | fuel particle moisture content             | lb moisture/lb ovendry wood             |
|----------+--------------------------------------------+-----------------------------------------|

TODO: Change units to metric in the table above.

*Note:* While M_{f} is not, in fact, directly assigned to any of these
fuel models, their definitions remain incomplete for the purposes of
fire spread modelling (particularly those reliant on the curing
formulas of dynamic fuel loading) until it is provided as a
characteristic of local weather conditions.

The fuel models supported by Pyretechnics include the standard 13 fuel
models of Rothermel, Albini, and Anderson\citep{Anderson1982} and the
additional 40 fuel models defined by Scott and
Burgan\citep{Scott2005}. These are all concisely encoded in an
internal data structure, which may be updated to include additional
custom fuel models desired by the user.

#+name: fuel-model-definitions
#+begin_src python :tangle ../src/pyretechnics/fuel_models.py
# Lookup table including one entry for each of the Anderson 13 and
# Scott & Burgan 40 fuel models. The fields have the following
# meanings:
# {fuel-model-number
#  [name delta M_x-dead h
#   [w_o-dead-1hr w_o-dead-10hr w_o-dead-100hr w_o-live-herbaceous w_o-live-woody]
#   [sigma-dead-1hr sigma-dead-10hr sigma-dead-100hr sigma-live-herbaceous sigma-live-woody]]
# }
fuel_models = {
    # Anderson 13:
    # Grass and Grass-dominated (short-grass,timber-grass-and-understory,tall-grass)
    1   : ["R01", 1.0, 12, 8, [0.0340, 0.0000, 0.0000, 0.0000, 0.0000], [3500.0,   0.0,  0.0,    0.0,    0.0]],
    2   : ["R02", 1.0, 15, 8, [0.0920, 0.0460, 0.0230, 0.0230, 0.0000], [3000.0, 109.0, 30.0, 1500.0,    0.0]],
    3   : ["R03", 2.5, 25, 8, [0.1380, 0.0000, 0.0000, 0.0000, 0.0000], [1500.0,   0.0,  0.0,    0.0,    0.0]],
    # Chaparral and Shrubfields (chaparral,brush,dormant-brush-hardwood-slash,southern-rough)
    4   : ["R04", 6.0, 20, 8, [0.2300, 0.1840, 0.0920, 0.2300, 0.0000], [2000.0, 109.0, 30.0, 1500.0,    0.0]],
    5   : ["R05", 2.0, 20, 8, [0.0460, 0.0230, 0.0000, 0.0920, 0.0000], [2000.0, 109.0,  0.0, 1500.0,    0.0]],
    6   : ["R06", 2.5, 25, 8, [0.0690, 0.1150, 0.0920, 0.0000, 0.0000], [1750.0, 109.0, 30.0,    0.0,    0.0]],
    7   : ["R07", 2.5, 40, 8, [0.0520, 0.0860, 0.0690, 0.0170, 0.0000], [1750.0, 109.0, 30.0, 1550.0,    0.0]],
    # Timber Litter (closed-timber-litter,hardwood-litter,timber-litter-and-understory)
    8   : ["R08", 0.2, 30, 8, [0.0690, 0.0460, 0.1150, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    9   : ["R09", 0.2, 25, 8, [0.1340, 0.0190, 0.0070, 0.0000, 0.0000], [2500.0, 109.0, 30.0,    0.0,    0.0]],
    10  : ["R10", 1.0, 25, 8, [0.1380, 0.0920, 0.2300, 0.0920, 0.0000], [2000.0, 109.0, 30.0, 1500.0,    0.0]],
    # Logging Slash (light-logging-slash,medium-logging-slash,heavy-logging-slash)
    11  : ["R11", 1.0, 15, 8, [0.0690, 0.2070, 0.2530, 0.0000, 0.0000], [1500.0, 109.0, 30.0,    0.0,    0.0]],
    12  : ["R12", 2.3, 20, 8, [0.1840, 0.6440, 0.7590, 0.0000, 0.0000], [1500.0, 109.0, 30.0,    0.0,    0.0]],
    13  : ["R13", 3.0, 25, 8, [0.3220, 1.0580, 1.2880, 0.0000, 0.0000], [1500.0, 109.0, 30.0,    0.0,    0.0]],
    # Nonburnable (NB)
    91  : ["NB1", 0.0,  0, 0, [0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [   0.0,   0.0,  0.0,    0.0,    0.0]],
    92  : ["NB2", 0.0,  0, 0, [0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [   0.0,   0.0,  0.0,    0.0,    0.0]],
    93  : ["NB3", 0.0,  0, 0, [0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [   0.0,   0.0,  0.0,    0.0,    0.0]],
    98  : ["NB4", 0.0,  0, 0, [0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [   0.0,   0.0,  0.0,    0.0,    0.0]],
    99  : ["NB5", 0.0,  0, 0, [0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [   0.0,   0.0,  0.0,    0.0,    0.0]],
    # Scott & Burgan 40:
    # Grass (GR)
    101 : ["GR1", 0.4, 15, 8, [0.0046, 0.0000, 0.0000, 0.0138, 0.0000], [2200.0, 109.0, 30.0, 2000.0,    0.0]],
    102 : ["GR2", 1.0, 15, 8, [0.0046, 0.0000, 0.0000, 0.0459, 0.0000], [2000.0, 109.0, 30.0, 1800.0,    0.0]],
    103 : ["GR3", 2.0, 30, 8, [0.0046, 0.0184, 0.0000, 0.0689, 0.0000], [1500.0, 109.0, 30.0, 1300.0,    0.0]],
    104 : ["GR4", 2.0, 15, 8, [0.0115, 0.0000, 0.0000, 0.0872, 0.0000], [2000.0, 109.0, 30.0, 1800.0,    0.0]],
    105 : ["GR5", 1.5, 40, 8, [0.0184, 0.0000, 0.0000, 0.1148, 0.0000], [1800.0, 109.0, 30.0, 1600.0,    0.0]],
    106 : ["GR6", 1.5, 40, 9, [0.0046, 0.0000, 0.0000, 0.1561, 0.0000], [2200.0, 109.0, 30.0, 2000.0,    0.0]],
    107 : ["GR7", 3.0, 15, 8, [0.0459, 0.0000, 0.0000, 0.2479, 0.0000], [2000.0, 109.0, 30.0, 1800.0,    0.0]],
    108 : ["GR8", 4.0, 30, 8, [0.0230, 0.0459, 0.0000, 0.3352, 0.0000], [1500.0, 109.0, 30.0, 1300.0,    0.0]],
    109 : ["GR9", 5.0, 40, 8, [0.0459, 0.0459, 0.0000, 0.4132, 0.0000], [1800.0, 109.0, 30.0, 1600.0,    0.0]],
    # Grass-Shrub (GS)
    121 : ["GS1", 0.9, 15, 8, [0.0092, 0.0000, 0.0000, 0.0230, 0.0298], [2000.0, 109.0, 30.0, 1800.0, 1800.0]],
    122 : ["GS2", 1.5, 15, 8, [0.0230, 0.0230, 0.0000, 0.0275, 0.0459], [2000.0, 109.0, 30.0, 1800.0, 1800.0]],
    123 : ["GS3", 1.8, 40, 8, [0.0138, 0.0115, 0.0000, 0.0666, 0.0574], [1800.0, 109.0, 30.0, 1600.0, 1600.0]],
    124 : ["GS4", 2.1, 40, 8, [0.0872, 0.0138, 0.0046, 0.1561, 0.3260], [1800.0, 109.0, 30.0, 1600.0, 1600.0]],
    # Shrub (SH)
    141 : ["SH1", 1.0, 15, 8, [0.0115, 0.0115, 0.0000, 0.0069, 0.0597], [2000.0, 109.0, 30.0, 1800.0, 1600.0]],
    142 : ["SH2", 1.0, 15, 8, [0.0620, 0.1102, 0.0344, 0.0000, 0.1768], [2000.0, 109.0, 30.0,    0.0, 1600.0]],
    143 : ["SH3", 2.4, 40, 8, [0.0207, 0.1377, 0.0000, 0.0000, 0.2847], [1600.0, 109.0, 30.0,    0.0, 1400.0]],
    144 : ["SH4", 3.0, 30, 8, [0.0390, 0.0528, 0.0092, 0.0000, 0.1171], [2000.0, 109.0, 30.0, 1800.0, 1600.0]],
    145 : ["SH5", 6.0, 15, 8, [0.1653, 0.0964, 0.0000, 0.0000, 0.1331], [ 750.0, 109.0, 30.0,    0.0, 1600.0]],
    146 : ["SH6", 2.0, 30, 8, [0.1331, 0.0666, 0.0000, 0.0000, 0.0643], [ 750.0, 109.0, 30.0,    0.0, 1600.0]],
    147 : ["SH7", 6.0, 15, 8, [0.1607, 0.2433, 0.1010, 0.0000, 0.1561], [ 750.0, 109.0, 30.0,    0.0, 1600.0]],
    148 : ["SH8", 3.0, 40, 8, [0.0941, 0.1561, 0.0390, 0.0000, 0.1997], [ 750.0, 109.0, 30.0,    0.0, 1600.0]],
    149 : ["SH9", 4.4, 40, 8, [0.2066, 0.1125, 0.0000, 0.0712, 0.3214], [ 750.0, 109.0, 30.0, 1800.0, 1500.0]],
    # Timber-Understory (TU)
    161 : ["TU1", 0.6, 20, 8, [0.0092, 0.0413, 0.0689, 0.0092, 0.0413], [2000.0, 109.0, 30.0, 1800.0, 1600.0]],
    162 : ["TU2", 1.0, 30, 8, [0.0436, 0.0826, 0.0574, 0.0000, 0.0092], [2000.0, 109.0, 30.0,    0.0, 1600.0]],
    163 : ["TU3", 1.3, 30, 8, [0.0505, 0.0069, 0.0115, 0.0298, 0.0505], [1800.0, 109.0, 30.0, 1600.0, 1400.0]],
    164 : ["TU4", 0.5, 12, 8, [0.2066, 0.0000, 0.0000, 0.0000, 0.0918], [2300.0, 109.0, 30.0,    0.0, 2000.0]],
    165 : ["TU5", 1.0, 25, 8, [0.1837, 0.1837, 0.1377, 0.0000, 0.1377], [1500.0, 109.0, 30.0,    0.0,  750.0]],
    # Timber Litter (TL)
    181 : ["TL1", 0.2, 30, 8, [0.0459, 0.1010, 0.1653, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    182 : ["TL2", 0.2, 25, 8, [0.0643, 0.1056, 0.1010, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    183 : ["TL3", 0.3, 20, 8, [0.0230, 0.1010, 0.1286, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    184 : ["TL4", 0.4, 25, 8, [0.0230, 0.0689, 0.1928, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    185 : ["TL5", 0.6, 25, 8, [0.0528, 0.1148, 0.2020, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0, 1600.0]],
    186 : ["TL6", 0.3, 25, 8, [0.1102, 0.0551, 0.0551, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    187 : ["TL7", 0.4, 25, 8, [0.0138, 0.0643, 0.3719, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    188 : ["TL8", 0.3, 35, 8, [0.2663, 0.0643, 0.0505, 0.0000, 0.0000], [1800.0, 109.0, 30.0,    0.0,    0.0]],
    189 : ["TL9", 0.6, 35, 8, [0.3053, 0.1515, 0.1905, 0.0000, 0.0000], [1800.0, 109.0, 30.0,    0.0, 1600.0]],
    # Slash-Blowdown (SB)
    201 : ["SB1", 1.0, 25, 8, [0.0689, 0.1377, 0.5051, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    202 : ["SB2", 1.0, 25, 8, [0.2066, 0.1951, 0.1837, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    203 : ["SB3", 1.2, 25, 8, [0.2525, 0.1263, 0.1377, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    204 : ["SB4", 2.7, 25, 8, [0.2410, 0.1607, 0.2410, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
}
#+end_src
