<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Pyretechnics Fire Behavior Library</title>
<meta name="author" content="Gary W. Johnson, Valentin Waeselynck, Chris Lautenberger, David Saah" />
<meta name="description" content="A Python library for simulating fire behavior in a variety of ways." />
<meta name="keywords" content="pyretechnics fire behavior model python library pyregence pyrecast" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="pyretechnics-base.css" />
<link rel="stylesheet" type="text/css" href="pyretechnics-custom.css" />

<script src="org-info.js">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
// @license-end
</script>

<script>
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
org_html_manager.set("TOC_DEPTH", "3");
org_html_manager.set("LINK_HOME", "");
org_html_manager.set("LINK_UP", "");
org_html_manager.set("LOCAL_TOC", "1");
org_html_manager.set("VIEW_BUTTONS", "0");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "1");
org_html_manager.set("VIEW", "info");
org_html_manager.setup();  // activate after the parameters are set
// @license-end
</script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">The Pyretechnics Fire Behavior Library
<br>
<span class="subtitle">Copyright Â© 2023-2024 Spatial Informatics Group, LLC</span>
</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#preface">1. Preface</a></li>
<li><a href="#data-model">2. Data Model</a>
<ul>
<li><a href="#working-in-a-3d-space-time-cube">2.1. Working in a 3D Space-Time Cube</a></li>
<li><a href="#fires-as-conical-shapes-in-space-time">2.2. Fires as Conical Shapes in Space-Time</a></li>
<li><a href="#support-for-input-datasets-of-varying-dimensionality">2.3. Support for Input Datasets of Varying Dimensionality</a></li>
<li><a href="#support-for-input-datasets-of-varying-resolution">2.4. Support for Input Datasets of Varying Resolution</a></li>
</ul>
</li>
<li><a href="#loading-data-into-the-3d-space-time-cube-(pyretechnics.space_time_cube)">3. Loading Data into the 3D Space-Time Cube (pyretechnics.space_time_cube)</a>
<ul>
<li><a href="#for-developers-spacetimecube">3.1. For Developers</a>
<ul>
<li><a href="#module-imports">3.1.1. Module Imports</a></li>
<li><a href="#utility-functions">3.1.2. Utility Functions</a></li>
<li><a href="#spacetimecube-class">3.1.3. SpaceTimeCube Class</a></li>
<li><a href="#lazyspacetimecube-class">3.1.4. LazySpaceTimeCube Class</a></li>
</ul>
</li>
<li><a href="#for-users-spacetimecube">3.2. For Users</a>
<ul>
<li><a href="#how-to-use-spacetimecube">3.2.1. How to Use SpaceTimeCube</a></li>
<li><a href="#how-to-use-lazyspacetimecube">3.2.2. How to Use LazySpaceTimeCube</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#fuel-model-and-moisture-definitions-(pyretechnics.fuel_models)">4. Fuel Model and Moisture Definitions (pyretechnics.fuel_models)</a>
<ul>
<li><a href="#for-developers-fuel">4.1. For Developers</a>
<ul>
<li><a href="#fuel-model-properties">4.1.1. Fuel Model Properties</a></li>
<li><a href="#fuel-model-definitions">4.1.2. Fuel Model Definitions</a></li>
<li><a href="#fuel-categories-and-size-classes">4.1.3. Fuel Categories and Size Classes</a></li>
<li><a href="#dynamic-fuel-loading">4.1.4. Dynamic Fuel Loading</a></li>
<li><a href="#size-class-weighting-factors">4.1.5. Size Class Weighting Factors</a></li>
<li><a href="#live-moisture-of-extinction">4.1.6. Live Moisture of Extinction</a></li>
<li><a href="#applying-fuel-moisture-to-a-fuel-model">4.1.7. Applying Fuel Moisture to a Fuel Model</a></li>
</ul>
</li>
<li><a href="#for-users-fuel">4.2. For Users</a>
<ul>
<li><a href="#how-to-look-up-a-fuel-model's-properties">4.2.1. How to Look Up a Fuel Model's Properties</a></li>
<li><a href="#how-to-apply-fuel-moisture-to-a-fuel-model">4.2.2. How to Apply Fuel Moisture to a Fuel Model</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#surface-fire-equations-(pyretechnics.surface_fire)">5. Surface Fire Equations (pyretechnics.surface_fire)</a>
<ul>
<li><a href="#for-developers-surface">5.1. For Developers</a>
<ul>
<li><a href="#rothermel's-surface-fire-rate-of-spread-equation">5.1.1. Rothermel's Surface Fire Rate of Spread Equation</a></li>
<li><a href="#surface-fire-spread-rate-functions-(no-wind-no-slope)">5.1.2. Surface Fire Spread Rate Functions (No Wind No Slope)</a></li>
<li><a href="#surface-fire-intensity-functions">5.1.3. Surface Fire Intensity Functions</a></li>
<li><a href="#wind-and-slope-factor-functions">5.1.4. Wind and Slope Factor Functions</a></li>
<li><a href="#surface-fire-behavior-functions-(no-wind-no-slope)">5.1.5. Surface Fire Behavior Functions (No Wind No Slope)</a></li>
<li><a href="#midflame-wind-speed">5.1.6. Midflame Wind Speed</a></li>
<li><a href="#combining-wind-and-slope-vectors">5.1.7. Combining Wind and Slope Vectors</a></li>
<li><a href="#surface-elliptical-eccentricity">5.1.8. Surface Elliptical Eccentricity</a></li>
<li><a href="#surface-fire-behavior-in-the-direction-of-maximum-spread">5.1.9. Surface Fire Behavior in the Direction of Maximum Spread</a></li>
<li><a href="#surface-fire-behavior-in-any-direction">5.1.10. Surface Fire Behavior in Any Direction</a></li>
</ul>
</li>
<li><a href="#for-users-surface">5.2. For Users</a>
<ul>
<li><a href="#how-to-calculate-the-no-wind-no-slope-surface-fire-behavior">5.2.1. How to Calculate the No-Wind-No-Slope Surface Fire Behavior</a></li>
<li><a href="#how-to-translate-the-10m-wind-speed-vector-into-the-midflame-wind-speed-vector">5.2.2. How to Translate the 10m Wind Speed Vector into the Midflame Wind Speed Vector</a></li>
<li><a href="#how-to-calculate-the-surface-fire-behavior-in-the-direction-of-maximum-spread">5.2.3. How to Calculate the Surface Fire Behavior in the Direction of Maximum Spread</a></li>
<li><a href="#how-to-calculate-the-surface-fire-behavior-in-any-direction">5.2.4. How to Calculate the Surface Fire Behavior in Any Direction</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#crown-fire-equations-(pyretechnics.crown_fire)">6. Crown Fire Equations (pyretechnics.crown_fire)</a>
<ul>
<li><a href="#for-developers-crown">6.1. For Developers</a>
<ul>
<li><a href="#crown-fire-initiation">6.1.1. Crown Fire Initiation</a></li>
<li><a href="#passive-and-active-crown-fire-spread-rate-functions">6.1.2. Passive and Active Crown Fire Spread Rate Functions</a></li>
<li><a href="#crown-fire-intensity-functions">6.1.3. Crown Fire Intensity Functions</a></li>
<li><a href="#crown-elliptical-eccentricity">6.1.4. Crown Elliptical Eccentricity</a></li>
<li><a href="#crown-fire-behavior-in-the-direction-of-maximum-spread">6.1.5. Crown Fire Behavior in the Direction of Maximum Spread</a></li>
<li><a href="#crown-fire-behavior-in-any-direction">6.1.6. Crown Fire Behavior in Any Direction</a></li>
<li><a href="#combining-surface-and-crown-fire-behavior">6.1.7. Combining Surface and Crown Fire Behavior</a></li>
</ul>
</li>
<li><a href="#for-users-crown">6.2. For Users</a>
<ul>
<li><a href="#how-to-determine-whether-a-surface-fire-transitions-to-a-crown-fire">6.2.1. How to Determine Whether a Surface Fire Transitions to a Crown Fire</a></li>
<li><a href="#how-to-calculate-the-crown-fire-behavior-in-the-direction-of-maximum-spread">6.2.2. How to Calculate the Crown Fire Behavior in the Direction of Maximum Spread</a></li>
<li><a href="#how-to-calculate-the-crown-fire-behavior-in-any-direction">6.2.3. How to Calculate the Crown Fire Behavior in Any Direction</a></li>
<li><a href="#how-to-calculate-the-combined-surface-and-crown-fire-behavior-in-any-direction">6.2.4. How to Calculate the Combined Surface and Crown Fire Behavior in Any Direction</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#spot-fire-equations-(pyretechnics.spot_fire)">7. Spot Fire Equations (pyretechnics.spot_fire)</a>
<ul>
<li><a href="#for-developers-spot">7.1. For Developers</a>
<ul>
<li><a href="#expected-firebrand-production">7.1.1. Expected Firebrand Production</a></li>
<li><a href="#firebrand-dispersal-model">7.1.2. Firebrand Dispersal Model</a></li>
<li><a href="#resolution-of-log-normal-parameters">7.1.3. Resolution of Log-Normal Parameters</a></li>
<li><a href="#wind-perpendicular-dispersal">7.1.4. Wind-Perpendicular Dispersal</a></li>
<li><a href="#sampling-firebrand-casting-distances">7.1.5. Sampling Firebrand Casting Distances</a></li>
<li><a href="#spotting-probability-and-number-of-firebrands">7.1.6. Spotting Probability and Number of Firebrands</a></li>
<li><a href="#spot-ignition-model">7.1.7. Spot Ignition Model</a></li>
<li><a href="#time-to-spot-ignition">7.1.8. Time to Spot Ignition</a></li>
<li><a href="#spreading-firebrands">7.1.9. Spreading Firebrands</a></li>
</ul>
</li>
<li><a href="#for-users-spot">7.2. For Users</a>
<ul>
<li><a href="#how-to-estimate-the-areal-heat-output-for-all-surface-fuel-models">7.2.1. How to Estimate the Areal Heat Output for All Surface Fuel Models</a></li>
<li><a href="#how-to-estimate-the-number-of-firebrands-cast-per-burned-cell">7.2.2. How to Estimate the Number of Firebrands Cast per Burned Cell</a></li>
<li><a href="#how-to-estimate-typical-ranges-for-the-$\vec{\delta}$-distribution-characteristics">7.2.3. How to Estimate Typical Ranges for the \(\vec{\Delta}\) Distribution Characteristics</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#burning-cells-on-a-grid-(pyretechnics.burn_cells)">8. Burning Cells on a Grid (pyretechnics.burn_cells)</a>
<ul>
<li><a href="#for-developers-burn-cells">8.1. For Developers</a>
<ul>
<li><a href="#burn-cell-as-a-head-fire">8.1.1. Burn Cell as a Head Fire</a></li>
<li><a href="#burn-cell-in-any-direction">8.1.2. Burn Cell in Any Direction</a></li>
</ul>
</li>
<li><a href="#for-users-burn-cells">8.2. For Users</a>
<ul>
<li><a href="#how-to-burn-a-cell-as-a-head-fire">8.2.1. How to Burn a Cell as a Head Fire</a></li>
<li><a href="#how-to-burn-a-cell-in-any-direction">8.2.2. How to Burn a Cell in Any Direction</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#fire-spread-algorithm:-eulerian-level-set-method-(pyretechnics.eulerian_level_set)">9. Fire Spread Algorithm: Eulerian Level Set Method (ELMFIRE) (pyretechnics.eulerian_level_set)</a>
<ul>
<li><a href="#for-developers-fire-spread">9.1. For Developers</a>
<ul>
<li><a href="#the-$\phi$-field">9.1.1. The \(\phi\) Field</a></li>
<li><a href="#fire-front-normal-vector">9.1.2. Fire Front Normal Vector</a></li>
<li><a href="#numerical-solution-of-the-$\phi$-field-equation">9.1.3. Numerical Solution of the \(\phi\) Field Equation</a></li>
<li><a href="#calculate-the-surface/crown-fireline-normal-behavior">9.1.4. Calculate the Surface/Crown Fireline Normal Behavior</a></li>
<li><a href="#burn-cell-normal-to-the-fire-perimeter">9.1.5. Burn Cell Normal to the Fire Perimeter</a></li>
<li><a href="#identify-cells-near-the-fire-perimeter-($\phi-=-0$)">9.1.6. Identify Cells Near the Fire Perimeter (\(\phi = 0\))</a></li>
<li><a href="#spread-phi-field">9.1.7. Spread Phi Field</a></li>
</ul>
</li>
<li><a href="#for-users-fire-spread">9.2. For Users</a>
<ul>
<li><a href="#how-to-spread-a-fire-from-a-point-ignition">9.2.1. How to Spread a Fire from a Point Ignition</a></li>
<li><a href="#how-to-spread-a-fire-from-a-point-ignition-with-spotting-enabled">9.2.2. How to Spread a Fire from a Point Ignition with Spotting Enabled</a></li>
<li><a href="#how-to-spread-a-fire,-pause,-fork,-and-continue">9.2.3. How to Spread a Fire, Pause, Fork, and Continue</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#appendices">10. Appendices</a>
<ul>
<li><a href="#units-conversion-functions-(pyretechnics.conversion)">10.1. Units Conversion Functions (pyretechnics.conversion)</a></li>
<li><a href="#vector-utility-functions-(pyretechnics.vector_utils)">10.2. Vector Utility Functions (pyretechnics.vector_utils)</a></li>
<li><a href="#spacetimecube-and-lazyspacetimecube-tests-(pyretechnics_test.test_space_time_cube)">10.3. SpaceTimeCube and LazySpaceTimeCube Tests (pyretechnics_test.test_space_time_cube)</a></li>
<li><a href="#loading-landfire-inputs-(pyretechnics.load_landfire)">10.4. Loading LANDFIRE Inputs (pyretechnics.load_landfire)</a>
<ul>
<li><a href="#loading-raster-files-with-python-rasterio">10.4.1. Loading Raster Files with Python Rasterio</a></li>
<li><a href="#converting-landfire-units-and-datatypes">10.4.2. Converting LANDFIRE Units and Datatypes</a></li>
<li><a href="#verifying-raster-constraints">10.4.3. Verifying Raster Constraints</a></li>
<li><a href="#converting-rasters-to-spacetimecubes">10.4.4. Converting Rasters to SpaceTimeCubes</a></li>
<li><a href="#putting-it-all-together">10.4.5. Putting It All Together</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-preface" class="outline-2">
<h2 id="preface"><span class="section-number-2">1.</span> Preface</h2>
<div class="outline-text-2" id="text-preface">
<p>
This document is a Literate
Program<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>,
containing both the source code of the software it describes as well
as the rationale used in each step of its design and implementation.
The purpose of this approach is to enable both programmers and
non-programmers alike to retrace the author's footsteps as they read
through the text and code. By the time they have reached the end of
this document, the reader should have just as strong a grasp of the
system as the original programmer.
</p>

<p>
The source code repository containing this document provides a
comprehensive reproducible development environment through the use of
the open source GNU Guix<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup> transactional
package manager. This tool will automatically install all the software
needed to tangle, detangle, weave, test, build, and install this
library on your machine without conflicting with the main package
manager of your operating system. See <a href="../README.md">README.md</a> for more details.
</p>
</div>
</div>
<div id="outline-container-data-model" class="outline-2">
<h2 id="data-model"><span class="section-number-2">2.</span> Data Model</h2>
<div class="outline-text-2" id="text-data-model">
</div>
<div id="outline-container-working-in-a-3d-space-time-cube" class="outline-3">
<h3 id="working-in-a-3d-space-time-cube"><span class="section-number-3">2.1.</span> Working in a 3D Space-Time Cube</h3>
<div class="outline-text-3" id="text-working-in-a-3d-space-time-cube">
<p>
In Pyretechnics, a fire is viewed as a three-dimensional event
occurring within a bounded region of space-time \((T,Y,X)\). In this
mental model, the environment in which a fire develops can be
visualized as a cube in which space is described in 2D by the \(X\) and
\(Y\) dimensions and time projects this 2D world into 3D along the \(T\)
dimension.
</p>

<p>
Note, in particular, that this is not the same thing as a
three-dimensional model of fire behavior that incorporates surface
elevation as the third dimension. Although terrain data (such as
elevation, slope, and aspect) and tree cover characteristics (such as
canopy height and canopy base height) are incorporated into the
implemented spread equations in order to determine the rate,
direction, and mode of fire spread, the outputs of the fire behavior
algorithms in Pyretechnics currently only use two dimensions to
describe spatial heterogeneity within the simulation environment. The
third dimension is instead reserved for temporal variations in the
model inputs and outputs.
</p>
</div>
</div>
<div id="outline-container-fires-as-conical-shapes-in-space-time" class="outline-3">
<h3 id="fires-as-conical-shapes-in-space-time"><span class="section-number-3">2.2.</span> Fires as Conical Shapes in Space-Time</h3>
<div class="outline-text-3" id="text-fires-as-conical-shapes-in-space-time">
<p>
All fire events begin from an ignition somewhere in space-time. As
combustion and propagation occur in burnable fuels, the burned area
(a.k.a "burn scar") of a fire spreads monotonically outward in space.
Viewed from the lens of our 3D space-time cube, these monotonically
expanding burn scars form conical solids within the simulation
environment, with the bottom point of the cone representing the
initial ignition point and the upper edge of the cone representing the
actively burning fire perimeter. Of course, we only expect idealized
fire cones to appear in environments with homogeneous topography,
weather, fuels, and fuel moisture. As these inputs become more
heterogenous throughout the burned region of space-time, these
idealized cones will become distorted in the directions of faster or
slower spread and their perimeters may become more finely dissected.
However, we use this conical shape description of fire events within
the simulated space-time cube to convey both their monotonically
increasing spatial area over time as well as to provide the foundation
for a more visually intuitive understanding of the effect of
temporally varying environmental conditions on the behavior (and thus
shape) of fires.
</p>
</div>
</div>
<div id="outline-container-support-for-input-datasets-of-varying-dimensionality" class="outline-3">
<h3 id="support-for-input-datasets-of-varying-dimensionality"><span class="section-number-3">2.3.</span> Support for Input Datasets of Varying Dimensionality</h3>
<div class="outline-text-3" id="text-support-for-input-datasets-of-varying-dimensionality">
<p>
At the beginning of a fire behavior simulation, our 3D space-time cube
will be populated with all of the information that describes the
environment and will remain effectively static as the fire event
unfolds. This includes (but is not limited to) topography, weather,
fuels, and fuel moisture. In many common simulation scenarios, we
expect that topography and fuels will probably vary in space but not
in time, and weather and fuel moisture may vary in both space and
time. However, we use "may" in these statements because the data model
within Pyretechnics is flexibly designed to allow any of these
environmental input variables to take on any of these forms:
</p>

<dl class="org-dl">
<dt>Constant</dt><dd>Constant in both space and time. <br>
<b>Ex</b>: A single constant foliar moisture value could be used over the
simulation area for the entire simulation duration.</dd>

<dt>Temporal</dt><dd>Constant in space but variable in time. <br>
<b>Ex</b>: An hourly sequence of spread rate adjustment factors could be
used to globally ramp up and down fire spread rates throughout a
day/night cycle, creating burn periods of arbitrary length and
intensity.</dd>

<dt>Spatial</dt><dd>Variable in space but constant in time. <br>
<b>Ex</b>: A raster layer downloaded from
LANDFIRE<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup> can be used to specify the
spatial distribution of FBFM40 fuel model values on a landscape.</dd>

<dt>Spatio-temporal</dt><dd>Variable in both space and time. <br>
<b>Ex</b>: Hourly
RTMA<sup><a id="fnr.4" class="footref" href="#fn.4" role="doc-backlink">4</a></sup> weather
data can be loaded from a multi-band raster and used to specify the
spatio-temporal distribution of wind speed and direction throughout
the simulation domain.</dd>
</dl>

<p>
This is accomplished by representing each such input value as an
abstract datatype with a set of 3D space-time lookup functions for
accessing its values within 0D, 1D, 2D, and 3D slices of the
space-time cube at the simulation resolution. Such lookups should
always be referentially transparent, so as to ensure that subsequent
lookups with the same coordinate will always yield the same values.
See section <a href="#loading-data-into-the-3d-space-time-cube-(pyretechnics.space_time_cube)">3</a> for implementation details.
</p>
</div>
</div>
<div id="outline-container-support-for-input-datasets-of-varying-resolution" class="outline-3">
<h3 id="support-for-input-datasets-of-varying-resolution"><span class="section-number-3">2.4.</span> Support for Input Datasets of Varying Resolution</h3>
<div class="outline-text-3" id="text-support-for-input-datasets-of-varying-resolution">
<p>
Even when dimensions are the same between input datasets, they may be
provided at different resolutions from one another, provided that the
following conditions are met:
</p>

<dl class="org-dl">
<dt>Same Projection</dt><dd>All spatially varying datasets must share the
same projection.</dd>

<dt>Same Extent</dt><dd>All spatial and temporal extents must match.</dd>

<dt>Data Resolutions Divide Simulation Resolutions Evenly</dt><dd>All
spatial and temporal resolutions must be exact divisors of the
simulation resolution.</dd>
</dl>

<p>
The simulated space-time cube will share the same projection and
extent as the input datasets, but its resolution may be specified by
the user, provided that it meets condition 3 above. The 3D lookup
functions for each input will then be responsible for translating the
space-time coordinates they receive at the simulation resolution into
the correct coordinates for their underlying dataset's native
resolution. See section <a href="#loading-data-into-the-3d-space-time-cube-(pyretechnics.space_time_cube)">3</a> for implementation details.
</p>
</div>
</div>
</div>
<div id="outline-container-loading-data-into-the-3d-space-time-cube-(pyretechnics.space_time_cube)" class="outline-2">
<h2 id="loading-data-into-the-3d-space-time-cube-(pyretechnics.space_time_cube)"><span class="section-number-2">3.</span> Loading Data into the 3D Space-Time Cube (pyretechnics.space_time_cube)</h2>
<div class="outline-text-2" id="text-loading-data-into-the-3d-space-time-cube-(pyretechnics.space_time_cube)">
</div>
<div id="outline-container-for-developers-spacetimecube" class="outline-3">
<h3 id="for-developers-spacetimecube"><span class="section-number-3">3.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-for-developers-spacetimecube">
<p>
The following sections define Python classes that construct 3D
space-time cubes corresponding to the data model described above for
various types of input datasets.
</p>
</div>
<div id="outline-container-module-imports" class="outline-4">
<h4 id="module-imports"><span class="section-number-4">3.1.1.</span> Module Imports</h4>
<div class="outline-text-4" id="text-module-imports">
<div class="org-src-container">
<pre class="src src-python" id="space-time-cube-imports"><span class="org-keyword">from</span> functools <span class="org-keyword">import</span> <span class="org-builtin">reduce</span>
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
</pre>
</div>
</div>
</div>
<div id="outline-container-utility-functions" class="outline-4">
<h4 id="utility-functions"><span class="section-number-4">3.1.2.</span> Utility Functions</h4>
<div class="outline-text-4" id="text-utility-functions">
<div class="org-src-container">
<pre class="src src-python" id="space-time-cube-utilities"><span class="org-keyword">def</span> <span class="org-function-name">is_pos_int</span>(x):
    <span class="org-keyword">return</span> <span class="org-builtin">isinstance</span>(x, <span class="org-builtin">int</span>) <span class="org-keyword">and</span> x <span class="org-operator">&gt;</span> 0


<span class="org-keyword">def</span> <span class="org-function-name">divide_evenly</span>(dividend, divisor):
    (<span class="org-variable-name">quotient</span>, <span class="org-variable-name">remainder</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(dividend, divisor)
    <span class="org-keyword">if</span> remainder <span class="org-operator">==</span> 0:
        <span class="org-keyword">return</span> quotient
    <span class="org-keyword">else</span>:
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-builtin">str</span>(dividend) <span class="org-operator">+</span> <span class="org-string">" must be an exact multiple of "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(divisor) <span class="org-operator">+</span> <span class="org-string">"."</span>)


<span class="org-keyword">def</span> <span class="org-function-name">to_positive_index_range</span>(index_range, axis_length):
    <span class="org-doc">"""</span>
<span class="org-doc">    Translate None and negative indices to positive indices.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">if</span> index_range <span class="org-operator">==</span> <span class="org-constant">None</span>:
        <span class="org-keyword">return</span> (0, axis_length)
    <span class="org-keyword">else</span>:
        (<span class="org-variable-name">start</span>, <span class="org-variable-name">stop</span>) <span class="org-operator">=</span> index_range
        <span class="org-keyword">return</span> (
            0 <span class="org-keyword">if</span> start <span class="org-operator">==</span> <span class="org-constant">None</span> <span class="org-keyword">else</span> axis_length <span class="org-operator">+</span> start <span class="org-keyword">if</span> start <span class="org-operator">&lt;</span> 0 <span class="org-keyword">else</span> start,
            axis_length <span class="org-keyword">if</span> stop <span class="org-operator">==</span> <span class="org-constant">None</span> <span class="org-keyword">else</span> axis_length <span class="org-operator">+</span> stop <span class="org-keyword">if</span> stop <span class="org-operator">&lt;</span> 0 <span class="org-keyword">else</span> stop
        )


<span class="org-keyword">def</span> <span class="org-function-name">maybe_repeat_array</span>(array, axis_repetitions):
    <span class="org-doc">"""</span>
<span class="org-doc">    Return a new array that is created by repeating the elements from the input</span>
<span class="org-doc">    array repetitions times along the specified array axis. Avoid allocating</span>
<span class="org-doc">    new memory if repetitions == 1 or if the repeated array axis has length 1.</span>
<span class="org-doc">    """</span>
    (<span class="org-variable-name">axis</span>, <span class="org-variable-name">repetitions</span>) <span class="org-operator">=</span> axis_repetitions
    <span class="org-keyword">if</span> repetitions <span class="org-operator">==</span> 1:
        <span class="org-keyword">return</span> array
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">array_shape</span> <span class="org-operator">=</span> <span class="org-builtin">list</span>(np.shape(array))
        <span class="org-keyword">if</span> array_shape[axis] <span class="org-operator">==</span> 1:
            <span class="org-variable-name">array_shape</span>[axis] <span class="org-operator">=</span> repetitions
            <span class="org-keyword">return</span> np.broadcast_to(array, array_shape)
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> np.repeat(array, repetitions, axis)
</pre>
</div>
</div>
</div>
<div id="outline-container-spacetimecube-class" class="outline-4">
<h4 id="spacetimecube-class"><span class="section-number-4">3.1.3.</span> SpaceTimeCube Class</h4>
<div class="outline-text-4" id="text-spacetimecube-class">
<p>
When an input dataset is already loaded into memory as either a single
scalar value or a 1D, 2D, or 3D array of values, it can be made
available to the various Pyretechnics algorithms by wrapping it in a
<code>SpaceTimeCube</code> object. As described in sections <a href="#support-for-input-datasets-of-varying-dimensionality">2.3</a> and <a href="#support-for-input-datasets-of-varying-resolution">2.4</a>, this input data can be provided in a variety of
dimensions and resolutions, subject to some simple constraints.
</p>

<p>
The <code>SpaceTimeCube</code> object will be created with a tuple of
user-specified spatio-temporal resolutions, called the <i>cube shape</i>,
which must be equal to or exact multiples of those of the underlying
data. For memory efficiency, input values are stored within the
<code>SpaceTimeCube</code> object at their native resolution but can be accessed
at any spatio-temporal point or region within the <code>SpaceTimeCube</code>'s
extent using coordinates from the <i>cube shape</i> resolution.
</p>

<p>
The various accessor functions provided by this class receive 3D
space-time coordinates at the <i>cube shape</i> resolution and will
correctly map them into the corresponding index within the native
dataset. Whenever a bounded region of space-time is requested via an
accessor function, the underlying data will be expanded to fill a new
Numpy array at the <i>cube shape</i> resolution. Whenever possible, Numpy
array broadcasting will be used instead of data copying for any
constant input dimensions.
</p>

<div class="org-src-container">
<pre class="src src-python" id="space-time-cube-class"><span class="org-keyword">class</span> <span class="org-type">SpaceTimeCube</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Create an object that represents a 3D array with dimensions (T,Y,X) given by cube_shape.</span>
<span class="org-doc">    Internally, data is stored as a 3D Numpy array at the resolution of the provided base data.</span>
<span class="org-doc">    Whenever a point value or contiguous space-time region of values is requested, translate</span>
<span class="org-doc">    the given cube_shape coordinates into base coordinates, look up the values from the base data,</span>
<span class="org-doc">    expand them (if necessary) back into the cube_shape resolution, and return the resulting scalar</span>
<span class="org-doc">    value or array to the caller.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, cube_shape, base):
        <span class="org-doc">"""</span>
<span class="org-doc">        NOTE: The resolutions in cube_shape must be exact multiples of any existing dimensions</span>
<span class="org-doc">              in the base data.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that cube_shape contains 3 values or throw an error</span>
        (<span class="org-variable-name">cube_bands</span>, <span class="org-variable-name">cube_rows</span>, <span class="org-variable-name">cube_cols</span>) <span class="org-operator">=</span> cube_shape

        <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that cube_shape only contains positive integers or throw an error</span>
        <span class="org-keyword">if</span> <span class="org-keyword">not</span>(<span class="org-builtin">all</span>(<span class="org-builtin">map</span>(is_pos_int, cube_shape))):
            <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The cube_shape must only contain positive integers."</span>)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Store the cube metadata for later</span>
        <span class="org-keyword">self</span>.<span class="org-variable-name">ndim</span>  <span class="org-operator">=</span> 3
        <span class="org-keyword">self</span>.<span class="org-variable-name">size</span>  <span class="org-operator">=</span> cube_bands <span class="org-operator">*</span> cube_rows <span class="org-operator">*</span> cube_cols
        <span class="org-keyword">self</span>.<span class="org-variable-name">shape</span> <span class="org-operator">=</span> cube_shape
        <span class="org-keyword">self</span>.<span class="org-variable-name">base</span>  <span class="org-operator">=</span> base

        <span class="org-comment-delimiter"># </span><span class="org-comment">Store the base data as a 3D array along with its axis repetitions</span>
        <span class="org-variable-name">base_dimensions</span> <span class="org-operator">=</span> np.ndim(base)

        <span class="org-keyword">if</span> base_dimensions <span class="org-operator">==</span> 0:
            <span class="org-comment-delimiter"># </span><span class="org-comment">0D: Constant Input</span>
            <span class="org-keyword">self</span>.<span class="org-variable-name">t_repetitions</span> <span class="org-operator">=</span> cube_bands
            <span class="org-keyword">self</span>.<span class="org-variable-name">y_repetitions</span> <span class="org-operator">=</span> cube_rows
            <span class="org-keyword">self</span>.<span class="org-variable-name">x_repetitions</span> <span class="org-operator">=</span> cube_cols
            <span class="org-keyword">self</span>.<span class="org-variable-name">data</span> <span class="org-operator">=</span> np.asarray([[[base]]])

        <span class="org-keyword">elif</span> base_dimensions <span class="org-operator">==</span> 1:
            <span class="org-comment-delimiter"># </span><span class="org-comment">1D: Time-Series Input</span>
            <span class="org-variable-name">base_bands</span> <span class="org-operator">=</span> <span class="org-builtin">len</span>(base)
            <span class="org-keyword">self</span>.<span class="org-variable-name">t_repetitions</span> <span class="org-operator">=</span> divide_evenly(cube_bands, base_bands)
            <span class="org-keyword">self</span>.<span class="org-variable-name">y_repetitions</span> <span class="org-operator">=</span> cube_rows
            <span class="org-keyword">self</span>.<span class="org-variable-name">x_repetitions</span> <span class="org-operator">=</span> cube_cols
            <span class="org-comment-delimiter"># </span><span class="org-comment">Expand (base_bands) -&gt; (base_bands,1,1)</span>
            <span class="org-keyword">self</span>.<span class="org-variable-name">data</span> <span class="org-operator">=</span> np.expand_dims(base, axis<span class="org-operator">=</span>(1,2))

        <span class="org-keyword">elif</span> base_dimensions <span class="org-operator">==</span> 2:
            <span class="org-comment-delimiter"># </span><span class="org-comment">2D: Spatial Input</span>
            (<span class="org-variable-name">base_rows</span>, <span class="org-variable-name">base_cols</span>) <span class="org-operator">=</span> np.shape(base)
            <span class="org-keyword">self</span>.<span class="org-variable-name">t_repetitions</span> <span class="org-operator">=</span> cube_bands
            <span class="org-keyword">self</span>.<span class="org-variable-name">y_repetitions</span> <span class="org-operator">=</span> divide_evenly(cube_rows, base_rows)
            <span class="org-keyword">self</span>.<span class="org-variable-name">x_repetitions</span> <span class="org-operator">=</span> divide_evenly(cube_cols, base_cols)
            <span class="org-comment-delimiter"># </span><span class="org-comment">Expand (base_rows,base_cols) -&gt; (1,base_rows,base_cols)</span>
            <span class="org-keyword">self</span>.<span class="org-variable-name">data</span> <span class="org-operator">=</span> np.expand_dims(base, axis<span class="org-operator">=</span>0)

        <span class="org-keyword">elif</span> base_dimensions <span class="org-operator">==</span> 3:
            <span class="org-comment-delimiter"># </span><span class="org-comment">3D: Spatio-Temporal Input</span>
            (<span class="org-variable-name">base_bands</span>, <span class="org-variable-name">base_rows</span>, <span class="org-variable-name">base_cols</span>) <span class="org-operator">=</span> np.shape(base)
            <span class="org-keyword">self</span>.<span class="org-variable-name">t_repetitions</span> <span class="org-operator">=</span> divide_evenly(cube_bands, base_bands)
            <span class="org-keyword">self</span>.<span class="org-variable-name">y_repetitions</span> <span class="org-operator">=</span> divide_evenly(cube_rows, base_rows)
            <span class="org-keyword">self</span>.<span class="org-variable-name">x_repetitions</span> <span class="org-operator">=</span> divide_evenly(cube_cols, base_cols)
            <span class="org-keyword">self</span>.<span class="org-variable-name">data</span> <span class="org-operator">=</span> np.asarray(base)

        <span class="org-keyword">else</span>:
            <span class="org-comment-delimiter"># </span><span class="org-comment">4D+: Invalid Input</span>
            <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"Invalid input: base must have 0-3 dimensions."</span>)


    <span class="org-keyword">def</span> <span class="org-function-name">get</span>(<span class="org-keyword">self</span>, t, y, x):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the scalar value at index (t,y,x) by translating these cube coordinates</span>
<span class="org-doc">        to base coordinates and looking up the value within the base data.</span>

<span class="org-doc">        NOTE: Indices may be negative.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select value by spatio-temporal coordinate</span>
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>.data[t <span class="org-operator">//</span> <span class="org-keyword">self</span>.t_repetitions,
                         y <span class="org-operator">//</span> <span class="org-keyword">self</span>.y_repetitions,
                         x <span class="org-operator">//</span> <span class="org-keyword">self</span>.x_repetitions]


    <span class="org-keyword">def</span> <span class="org-function-name">getTimeSeries</span>(<span class="org-keyword">self</span>, t_range, y, x):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 1D array given by the slice (t_range,y,x) by translating these cube</span>
<span class="org-doc">        coordinates to base coordinates, looking up the array slice within the base data,</span>
<span class="org-doc">        and expanding it back to the cube_shape resolution.</span>

<span class="org-doc">        NOTE: Indices may be negative.</span>
<span class="org-doc">        NOTE: Range indices may include one or more None values and</span>
<span class="org-doc">              provide (inclusion, exclusion) semantics like Python array slice notation.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the argument range</span>
        (<span class="org-variable-name">t_start</span>, <span class="org-variable-name">t_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(t_range, <span class="org-keyword">self</span>.shape[0])
        <span class="org-variable-name">t_stop</span> <span class="org-operator">=</span> t_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res coordinates to low-res coordinates</span>
        <span class="org-variable-name">t_start_chunk</span> <span class="org-operator">=</span> t_start <span class="org-operator">//</span> <span class="org-keyword">self</span>.t_repetitions
        <span class="org-variable-name">t_stop_chunk</span>  <span class="org-operator">=</span> t_stop  <span class="org-operator">//</span> <span class="org-keyword">self</span>.t_repetitions
        <span class="org-variable-name">y_chunk</span>       <span class="org-operator">=</span> y       <span class="org-operator">//</span> <span class="org-keyword">self</span>.y_repetitions
        <span class="org-variable-name">x_chunk</span>       <span class="org-operator">=</span> x       <span class="org-operator">//</span> <span class="org-keyword">self</span>.x_repetitions
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select the array slice that completely contains all low-res coordinates</span>
        <span class="org-variable-name">low_res_time</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.data[t_start_chunk:(t_stop_chunk <span class="org-operator">+</span> 1),
                                 y_chunk,
                                 x_chunk]
        <span class="org-comment-delimiter"># </span><span class="org-comment">Expand the low-res slice into a high-res slice</span>
        <span class="org-variable-name">high_res_time</span> <span class="org-operator">=</span> maybe_repeat_array(low_res_time, (0, <span class="org-keyword">self</span>.t_repetitions))
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res global coordinates to high-res slice coordinates</span>
        <span class="org-variable-name">t_chunk_origin</span> <span class="org-operator">=</span> t_start_chunk <span class="org-operator">*</span> <span class="org-keyword">self</span>.t_repetitions
        <span class="org-variable-name">t_start_idx</span>    <span class="org-operator">=</span> t_start <span class="org-operator">-</span> t_chunk_origin
        <span class="org-variable-name">t_stop_idx</span>     <span class="org-operator">=</span> t_stop  <span class="org-operator">-</span> t_chunk_origin
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select the array slice that matches the high-res slice coordinates</span>
        <span class="org-keyword">return</span> high_res_time[t_start_idx:(t_stop_idx <span class="org-operator">+</span> 1)]


    <span class="org-keyword">def</span> <span class="org-function-name">getSpatialPlane</span>(<span class="org-keyword">self</span>, t, y_range, x_range):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 2D array given by the slice (t,y_range,x_range) by translating these</span>
<span class="org-doc">        cube coordinates to base coordinates, looking up the array slice within the base</span>
<span class="org-doc">        data, and expanding it back to the cube_shape resolution.</span>

<span class="org-doc">        NOTE: Indices may be negative.</span>
<span class="org-doc">        NOTE: Range indices may include one or more None values and</span>
<span class="org-doc">              provide (inclusion, exclusion) semantics like Python array slice notation.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the argument ranges</span>
        (<span class="org-variable-name">y_start</span>, <span class="org-variable-name">y_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(y_range, <span class="org-keyword">self</span>.shape[1])
        (<span class="org-variable-name">x_start</span>, <span class="org-variable-name">x_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(x_range, <span class="org-keyword">self</span>.shape[2])
        <span class="org-variable-name">y_stop</span> <span class="org-operator">=</span> y_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-variable-name">x_stop</span> <span class="org-operator">=</span> x_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res coordinates to low-res coordinates</span>
        <span class="org-variable-name">t_chunk</span>       <span class="org-operator">=</span> t       <span class="org-operator">//</span> <span class="org-keyword">self</span>.t_repetitions
        <span class="org-variable-name">y_start_chunk</span> <span class="org-operator">=</span> y_start <span class="org-operator">//</span> <span class="org-keyword">self</span>.y_repetitions
        <span class="org-variable-name">y_stop_chunk</span>  <span class="org-operator">=</span> y_stop  <span class="org-operator">//</span> <span class="org-keyword">self</span>.y_repetitions
        <span class="org-variable-name">x_start_chunk</span> <span class="org-operator">=</span> x_start <span class="org-operator">//</span> <span class="org-keyword">self</span>.x_repetitions
        <span class="org-variable-name">x_stop_chunk</span>  <span class="org-operator">=</span> x_stop  <span class="org-operator">//</span> <span class="org-keyword">self</span>.x_repetitions
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select the array slice that completely contains all low-res coordinates</span>
        <span class="org-variable-name">low_res_space</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.data[t_chunk,
                                  y_start_chunk:(y_stop_chunk <span class="org-operator">+</span> 1),
                                  x_start_chunk:(x_stop_chunk <span class="org-operator">+</span> 1)]
        <span class="org-comment-delimiter"># </span><span class="org-comment">Expand the low-res slice into a high-res slice</span>
        <span class="org-variable-name">high_res_space</span> <span class="org-operator">=</span> <span class="org-builtin">reduce</span>(maybe_repeat_array,
                                ((0, <span class="org-keyword">self</span>.y_repetitions),
                                 (1, <span class="org-keyword">self</span>.x_repetitions)),
                                low_res_space)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res global coordinates to high-res slice coordinates</span>
        <span class="org-variable-name">y_chunk_origin</span> <span class="org-operator">=</span> y_start_chunk <span class="org-operator">*</span> <span class="org-keyword">self</span>.y_repetitions
        <span class="org-variable-name">x_chunk_origin</span> <span class="org-operator">=</span> x_start_chunk <span class="org-operator">*</span> <span class="org-keyword">self</span>.x_repetitions
        <span class="org-variable-name">y_start_idx</span>    <span class="org-operator">=</span> y_start <span class="org-operator">-</span> y_chunk_origin
        <span class="org-variable-name">y_stop_idx</span>     <span class="org-operator">=</span> y_stop  <span class="org-operator">-</span> y_chunk_origin
        <span class="org-variable-name">x_start_idx</span>    <span class="org-operator">=</span> x_start <span class="org-operator">-</span> x_chunk_origin
        <span class="org-variable-name">x_stop_idx</span>     <span class="org-operator">=</span> x_stop  <span class="org-operator">-</span> x_chunk_origin
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select the array slice that matches the high-res slice coordinates</span>
        <span class="org-keyword">return</span> high_res_space[y_start_idx:(y_stop_idx <span class="org-operator">+</span> 1),
                              x_start_idx:(x_stop_idx <span class="org-operator">+</span> 1)]


    <span class="org-keyword">def</span> <span class="org-function-name">getSubcube</span>(<span class="org-keyword">self</span>, t_range, y_range, x_range):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 3D array given by the slice (t_range,y_range,x_range) by translating</span>
<span class="org-doc">        these cube coordinates to base coordinates, looking up the array slice within the</span>
<span class="org-doc">        base data, and expanding it back to the cube_shape resolution.</span>

<span class="org-doc">        NOTE: Indices may be negative.</span>
<span class="org-doc">        NOTE: Range indices may include one or more None values and</span>
<span class="org-doc">              provide (inclusion, exclusion) semantics like Python array slice notation.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the argument ranges</span>
        (<span class="org-variable-name">t_start</span>, <span class="org-variable-name">t_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(t_range, <span class="org-keyword">self</span>.shape[0])
        (<span class="org-variable-name">y_start</span>, <span class="org-variable-name">y_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(y_range, <span class="org-keyword">self</span>.shape[1])
        (<span class="org-variable-name">x_start</span>, <span class="org-variable-name">x_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(x_range, <span class="org-keyword">self</span>.shape[2])
        <span class="org-variable-name">t_stop</span> <span class="org-operator">=</span> t_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-variable-name">y_stop</span> <span class="org-operator">=</span> y_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-variable-name">x_stop</span> <span class="org-operator">=</span> x_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res coordinates to low-res coordinates</span>
        <span class="org-variable-name">t_start_chunk</span> <span class="org-operator">=</span> t_start <span class="org-operator">//</span> <span class="org-keyword">self</span>.t_repetitions
        <span class="org-variable-name">t_stop_chunk</span>  <span class="org-operator">=</span> t_stop  <span class="org-operator">//</span> <span class="org-keyword">self</span>.t_repetitions
        <span class="org-variable-name">y_start_chunk</span> <span class="org-operator">=</span> y_start <span class="org-operator">//</span> <span class="org-keyword">self</span>.y_repetitions
        <span class="org-variable-name">y_stop_chunk</span>  <span class="org-operator">=</span> y_stop  <span class="org-operator">//</span> <span class="org-keyword">self</span>.y_repetitions
        <span class="org-variable-name">x_start_chunk</span> <span class="org-operator">=</span> x_start <span class="org-operator">//</span> <span class="org-keyword">self</span>.x_repetitions
        <span class="org-variable-name">x_stop_chunk</span>  <span class="org-operator">=</span> x_stop  <span class="org-operator">//</span> <span class="org-keyword">self</span>.x_repetitions
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select the array slice that completely contains all low-res coordinates</span>
        <span class="org-variable-name">low_res_cube</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.data[t_start_chunk:(t_stop_chunk <span class="org-operator">+</span> 1),
                                 y_start_chunk:(y_stop_chunk <span class="org-operator">+</span> 1),
                                 x_start_chunk:(x_stop_chunk <span class="org-operator">+</span> 1)]
        <span class="org-comment-delimiter"># </span><span class="org-comment">Expand the low-res slice into a high-res slice</span>
        <span class="org-variable-name">high_res_cube</span> <span class="org-operator">=</span> <span class="org-builtin">reduce</span>(maybe_repeat_array,
                               ((0, <span class="org-keyword">self</span>.t_repetitions),
                                (1, <span class="org-keyword">self</span>.y_repetitions),
                                (2, <span class="org-keyword">self</span>.x_repetitions)),
                               low_res_cube)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res global coordinates to high-res slice coordinates</span>
        <span class="org-variable-name">t_chunk_origin</span> <span class="org-operator">=</span> t_start_chunk <span class="org-operator">*</span> <span class="org-keyword">self</span>.t_repetitions
        <span class="org-variable-name">y_chunk_origin</span> <span class="org-operator">=</span> y_start_chunk <span class="org-operator">*</span> <span class="org-keyword">self</span>.y_repetitions
        <span class="org-variable-name">x_chunk_origin</span> <span class="org-operator">=</span> x_start_chunk <span class="org-operator">*</span> <span class="org-keyword">self</span>.x_repetitions
        <span class="org-variable-name">t_start_idx</span>    <span class="org-operator">=</span> t_start <span class="org-operator">-</span> t_chunk_origin
        <span class="org-variable-name">t_stop_idx</span>     <span class="org-operator">=</span> t_stop  <span class="org-operator">-</span> t_chunk_origin
        <span class="org-variable-name">y_start_idx</span>    <span class="org-operator">=</span> y_start <span class="org-operator">-</span> y_chunk_origin
        <span class="org-variable-name">y_stop_idx</span>     <span class="org-operator">=</span> y_stop  <span class="org-operator">-</span> y_chunk_origin
        <span class="org-variable-name">x_start_idx</span>    <span class="org-operator">=</span> x_start <span class="org-operator">-</span> x_chunk_origin
        <span class="org-variable-name">x_stop_idx</span>     <span class="org-operator">=</span> x_stop  <span class="org-operator">-</span> x_chunk_origin
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select the array slice that matches the high-res slice coordinates</span>
        <span class="org-keyword">return</span> high_res_cube[t_start_idx:(t_stop_idx <span class="org-operator">+</span> 1),
                             y_start_idx:(y_stop_idx <span class="org-operator">+</span> 1),
                             x_start_idx:(x_stop_idx <span class="org-operator">+</span> 1)]


    <span class="org-keyword">def</span> <span class="org-function-name">__getFullyRealizedCube</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 3D array created by expanding the base data to the cube_shape resolution.</span>
<span class="org-doc">        Wherever possible, Numpy broadcasting is used to avoid memory allocation along</span>
<span class="org-doc">        constant array dimensions.</span>
<span class="org-doc">        """</span>
        <span class="org-variable-name">base_dimensions</span> <span class="org-operator">=</span> np.ndim(<span class="org-keyword">self</span>.base)

        <span class="org-keyword">if</span> base_dimensions <span class="org-operator">==</span> 0:
            <span class="org-comment-delimiter"># </span><span class="org-comment">0D: Constant Input</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Broadcast (0,0,0) -&gt; (t,y,x)</span>
            <span class="org-keyword">return</span> np.broadcast_to(<span class="org-keyword">self</span>.data, <span class="org-keyword">self</span>.shape)

        <span class="org-keyword">elif</span> base_dimensions <span class="org-operator">==</span> 1:
            <span class="org-comment-delimiter"># </span><span class="org-comment">1D: Time-Series Input</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Repeat (t0,1,1) -&gt; (t,1,1)</span>
            <span class="org-variable-name">repeated_array</span> <span class="org-operator">=</span> maybe_repeat_array(<span class="org-keyword">self</span>.data, (0, <span class="org-keyword">self</span>.t_repetitions))
            <span class="org-comment-delimiter"># </span><span class="org-comment">Broadcast (t,1,1) -&gt; (t,y,x)</span>
            <span class="org-keyword">return</span> np.broadcast_to(repeated_array, <span class="org-keyword">self</span>.shape)

        <span class="org-keyword">elif</span> base_dimensions <span class="org-operator">==</span> 2:
            <span class="org-comment-delimiter"># </span><span class="org-comment">2D: Spatial Input</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Repeat (1,y0,x0) -&gt; (1,y,x)</span>
            <span class="org-variable-name">repeated_array</span> <span class="org-operator">=</span> <span class="org-builtin">reduce</span>(maybe_repeat_array,
                                    ((1, <span class="org-keyword">self</span>.y_repetitions),
                                     (2, <span class="org-keyword">self</span>.x_repetitions)),
                                    <span class="org-keyword">self</span>.data)
            <span class="org-comment-delimiter"># </span><span class="org-comment">Broadcast (1,y,x) -&gt; (t,y,x)</span>
            <span class="org-keyword">return</span> np.broadcast_to(repeated_array, <span class="org-keyword">self</span>.shape)

        <span class="org-keyword">else</span>:
            <span class="org-comment-delimiter"># </span><span class="org-comment">3D: Spatio-Temporal Input</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Repeat (t0,y0,x0) -&gt; (t,y,x)</span>
            <span class="org-keyword">return</span> <span class="org-builtin">reduce</span>(maybe_repeat_array,
                          ((0, <span class="org-keyword">self</span>.t_repetitions),
                           (1, <span class="org-keyword">self</span>.y_repetitions),
                           (2, <span class="org-keyword">self</span>.x_repetitions)),
                          <span class="org-keyword">self</span>.data)


    <span class="org-keyword">def</span> <span class="org-function-name">getFullyRealizedCube</span>(<span class="org-keyword">self</span>, cache<span class="org-operator">=</span><span class="org-constant">False</span>):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 3D array created by expanding the base data to the cube_shape resolution.</span>
<span class="org-doc">        Wherever possible, Numpy broadcasting is used to avoid memory allocation along</span>
<span class="org-doc">        constant array dimensions. When cache == True, this expanded 3D array is cached</span>
<span class="org-doc">        within the SpaceTimeCube object for future immediate retrieval.</span>
<span class="org-doc">        """</span>
        <span class="org-keyword">if</span> <span class="org-builtin">hasattr</span>(<span class="org-keyword">self</span>, <span class="org-string">"cube"</span>):
            <span class="org-keyword">return</span> <span class="org-keyword">self</span>.cube
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">cube</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.__getFullyRealizedCube()
            <span class="org-keyword">if</span> cache <span class="org-keyword">is</span> <span class="org-constant">True</span>:
                <span class="org-keyword">self</span>.<span class="org-variable-name">cube</span> <span class="org-operator">=</span> cube
            <span class="org-keyword">return</span> cube


    <span class="org-keyword">def</span> <span class="org-function-name">releaseFullyRealizedCube</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">"""</span>
<span class="org-doc">        Deletes the cached fully realized cube if it exists.</span>
<span class="org-doc">        """</span>
        <span class="org-keyword">if</span> <span class="org-builtin">hasattr</span>(<span class="org-keyword">self</span>, <span class="org-string">"cube"</span>):
            <span class="org-builtin">delattr</span>(<span class="org-keyword">self</span>, <span class="org-string">"cube"</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-lazyspacetimecube-class" class="outline-4">
<h4 id="lazyspacetimecube-class"><span class="section-number-4">3.1.4.</span> LazySpaceTimeCube Class</h4>
<div class="outline-text-4" id="text-lazyspacetimecube-class">
<p>
When a dataset is too large to fit easily into memory, it can be
partitioned into a collection of subcubes, which will be lazily loaded
on demand into a 3D cache grid of <code>SpaceTimeCube</code> objects provided by
the <code>LazySpaceTimeCube</code> class.
</p>

<p>
The <code>LazySpaceTimeCube</code> object will be created with a tuple of
user-specified spatio-temporal resolutions, called the <i>cube shape</i>,
which must be equal to or exact multiples of the <i>subcube shape</i>.
</p>

<p>
The various accessor functions provided by this class receive 3D
space-time coordinates at the <i>cube shape</i> resolution and will
correctly map them into the corresponding cache and subcube indexes.
Any intersected subcubes that are not already present in the cache
grid will be loaded on demand by calling a user-supplied
<code>load_subcube</code> function and stored in the cache grid for faster
retrieval later. If a bounded region of space-time that spans multiple
subcubes is requested via an accessor function, each of the
intersected subcubes will be loaded and cached, their relevant array
slices will be extracted, and these slices will be merged into a new
array at the <i>cube shape</i> resolution.
</p>

<p>
Fire spread simulations that use the <code>LazySpaceTimeCube</code> class will
only need to load into memory those subcubes which are intersected by
the expanding conical burn scar (see section <a href="#fires-as-conical-shapes-in-space-time">2.2</a>). In simulations of fires that are small relative to the
extent of the full 3D space-time environment, these memory savings may
be substantial and may make it possible to run simulations over larger
extents and/or finer resolutions than have been used previously.
</p>

<div class="org-src-container">
<pre class="src src-python" id="lazy-space-time-cube-class"><span class="org-keyword">class</span> <span class="org-type">LazySpaceTimeCube</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Create an object that represents a 3D array with dimensions (T,Y,X) given by cube_shape.</span>
<span class="org-doc">    Internally, data is stored as an initially empty 3D array of SpaceTimeCube objects.</span>
<span class="org-doc">    Whenever a point value or contiguous space-time region of values is requested, identify</span>
<span class="org-doc">    which SpaceTimeCubes contain the requested coordinates, load them into the cache array</span>
<span class="org-doc">    by calling load_subcube for any that are not already present, request the values from</span>
<span class="org-doc">    these SpaceTimeCubes, combine them together if necessary, and return the resulting scalar</span>
<span class="org-doc">    value or array to the caller.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, cube_shape, subcube_shape, load_subcube):
        <span class="org-doc">"""</span>
<span class="org-doc">        NOTE: The resolutions in cube_shape must be exact multiples of those in subcube_shape.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that cube_shape and subcube_shape both contain 3 values or throw an error</span>
        (<span class="org-variable-name">cube_bands</span>, <span class="org-variable-name">cube_rows</span>, <span class="org-variable-name">cube_cols</span>) <span class="org-operator">=</span> cube_shape
        (<span class="org-variable-name">subcube_bands</span>, <span class="org-variable-name">subcube_rows</span>, <span class="org-variable-name">subcube_cols</span>) <span class="org-operator">=</span> subcube_shape

        <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that cube_shape and subcube_shape only contain positive integers or throw an error</span>
        <span class="org-keyword">if</span> <span class="org-keyword">not</span>(<span class="org-builtin">all</span>(<span class="org-builtin">map</span>(is_pos_int, cube_shape <span class="org-operator">+</span> subcube_shape))):
            <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The cube_shape and subcube_shape must only contain positive integers."</span>)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that cube_shape is divided evenly by subcube_shape or throw an error</span>
        <span class="org-variable-name">cache_bands</span> <span class="org-operator">=</span> divide_evenly(cube_bands, subcube_bands)
        <span class="org-variable-name">cache_rows</span>  <span class="org-operator">=</span> divide_evenly(cube_rows, subcube_rows)
        <span class="org-variable-name">cache_cols</span>  <span class="org-operator">=</span> divide_evenly(cube_cols, subcube_cols)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Store the cube metadata, subcube_shape, cache_shape, cache, and load_subcube functions for later</span>
        <span class="org-keyword">self</span>.<span class="org-variable-name">ndim</span>          <span class="org-operator">=</span> 3
        <span class="org-keyword">self</span>.<span class="org-variable-name">size</span>          <span class="org-operator">=</span> cube_bands <span class="org-operator">*</span> cube_rows <span class="org-operator">*</span> cube_cols
        <span class="org-keyword">self</span>.<span class="org-variable-name">shape</span>         <span class="org-operator">=</span> cube_shape
        <span class="org-keyword">self</span>.<span class="org-variable-name">subcube_shape</span> <span class="org-operator">=</span> subcube_shape
        <span class="org-keyword">self</span>.<span class="org-variable-name">cache_shape</span>   <span class="org-operator">=</span> (cache_bands, cache_rows, cache_cols)
        <span class="org-keyword">self</span>.<span class="org-variable-name">cache</span>         <span class="org-operator">=</span> np.empty(<span class="org-keyword">self</span>.cache_shape, dtype<span class="org-operator">=</span><span class="org-builtin">object</span>)
        <span class="org-keyword">self</span>.<span class="org-variable-name">load_subcube</span>  <span class="org-operator">=</span> load_subcube


    <span class="org-keyword">def</span> <span class="org-function-name">__getOrLoadSubcube</span>(<span class="org-keyword">self</span>, cache_t, cache_y, cache_x):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the SpaceTimeCube stored at self.cache[cache_t, cache_y, cache_x] if it</span>
<span class="org-doc">        has already been loaded. Otherwise, call self.load_subcube to load it, store</span>
<span class="org-doc">        it in self.cache, and return it.</span>
<span class="org-doc">        """</span>
        <span class="org-variable-name">subcube</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.cache[cache_t, cache_y, cache_x]
        <span class="org-keyword">if</span> subcube:
            <span class="org-keyword">return</span> subcube
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">subcube</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.load_subcube((cache_t, cache_y, cache_x), <span class="org-keyword">self</span>.subcube_shape)
            <span class="org-keyword">self</span>.<span class="org-variable-name">cache</span>[<span class="org-variable-name">cache_t</span>, <span class="org-variable-name">cache_y</span>, <span class="org-variable-name">cache_x</span>] <span class="org-operator">=</span> subcube
            <span class="org-keyword">return</span> subcube


    <span class="org-keyword">def</span> <span class="org-function-name">get</span>(<span class="org-keyword">self</span>, t, y, x):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the scalar value at index (t,y,x) by translating these cube coordinates</span>
<span class="org-doc">        to cache and subcube coordinates, loading the matching subcube into the cache grid</span>
<span class="org-doc">        if not already present, and looking up the value within this subcube.</span>

<span class="org-doc">        NOTE: Indices may be negative provided that your load_subcube function can handle</span>
<span class="org-doc">              negative indices in its cache_index argument.</span>
<span class="org-doc">        """</span>
        (<span class="org-variable-name">subcube_bands</span>, <span class="org-variable-name">subcube_rows</span>, <span class="org-variable-name">subcube_cols</span>) <span class="org-operator">=</span> <span class="org-keyword">self</span>.subcube_shape
        (<span class="org-variable-name">cache_t</span>, <span class="org-variable-name">subcube_t</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(t, subcube_bands)
        (<span class="org-variable-name">cache_y</span>, <span class="org-variable-name">subcube_y</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(y, subcube_rows)
        (<span class="org-variable-name">cache_x</span>, <span class="org-variable-name">subcube_x</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(x, subcube_cols)
        <span class="org-variable-name">subcube</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.__getOrLoadSubcube(cache_t, cache_y, cache_x)
        <span class="org-keyword">return</span> subcube.get(subcube_t, subcube_y, subcube_x)


    <span class="org-keyword">def</span> <span class="org-function-name">getTimeSeries</span>(<span class="org-keyword">self</span>, t_range, y, x):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 1D array given by the slice (t_range,y,x) by translating these cube</span>
<span class="org-doc">        coordinates to cache and subcube coordinates, loading the matching subcubes into</span>
<span class="org-doc">        the cache grid if not already present, looking up the array slices within each</span>
<span class="org-doc">        subcube, and merging them together into a single 1D array.</span>

<span class="org-doc">        NOTE: Indices may be negative provided that your load_subcube function can handle</span>
<span class="org-doc">              negative indices in its cache_index argument.</span>
<span class="org-doc">        NOTE: Range indices may include one or more None values and</span>
<span class="org-doc">              provide (inclusion, exclusion) semantics like Python array slice notation.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the argument range</span>
        (<span class="org-variable-name">t_start</span>, <span class="org-variable-name">t_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(t_range, <span class="org-keyword">self</span>.shape[0])
        <span class="org-variable-name">t_stop</span> <span class="org-operator">=</span> t_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res coordinates to cache and subcube coordinates</span>
        (<span class="org-variable-name">subcube_bands</span>, <span class="org-variable-name">subcube_rows</span>, <span class="org-variable-name">subcube_cols</span>) <span class="org-operator">=</span> <span class="org-keyword">self</span>.subcube_shape
        (<span class="org-variable-name">cache_t_start</span>, <span class="org-variable-name">subcube_t_start</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(t_start, subcube_bands)
        (<span class="org-variable-name">cache_t_stop</span>,  <span class="org-variable-name">subcube_t_stop</span>)  <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(t_stop,  subcube_bands)
        (<span class="org-variable-name">cache_y</span>,       <span class="org-variable-name">subcube_y</span>)       <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(y,       subcube_rows)
        (<span class="org-variable-name">cache_x</span>,       <span class="org-variable-name">subcube_x</span>)       <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(x,       subcube_cols)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Load, expand, and combine subcubes</span>
        <span class="org-keyword">return</span> np.concatenate(
            [<span class="org-keyword">self</span>.__getOrLoadSubcube(cache_t,
                                     cache_y,
                                     cache_x
                                    ).getTimeSeries(
                                        (subcube_t_start    <span class="org-keyword">if</span> cache_t <span class="org-operator">==</span> cache_t_start <span class="org-keyword">else</span> 0,
                                         subcube_t_stop <span class="org-operator">+</span> 1 <span class="org-keyword">if</span> cache_t <span class="org-operator">==</span> cache_t_stop  <span class="org-keyword">else</span> subcube_bands),
                                        subcube_y,
                                        subcube_x
                                    )
             <span class="org-keyword">for</span> cache_t <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cache_t_start, cache_t_stop <span class="org-operator">+</span> 1)]
        )


    <span class="org-keyword">def</span> <span class="org-function-name">getSpatialPlane</span>(<span class="org-keyword">self</span>, t, y_range, x_range):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 2D array given by the slice (t,y_range,x_range) by translating these</span>
<span class="org-doc">        cube coordinates to cache and subcube coordinates, loading the matching subcubes</span>
<span class="org-doc">        into the cache grid if not already present, looking up the array slices within each</span>
<span class="org-doc">        subcube, and merging them together into a single 2D array.</span>

<span class="org-doc">        NOTE: Indices may be negative provided that your load_subcube function can handle</span>
<span class="org-doc">              negative indices in its cache_index argument.</span>
<span class="org-doc">        NOTE: Range indices may include one or more None values and</span>
<span class="org-doc">              provide (inclusion, exclusion) semantics like Python array slice notation.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the argument ranges</span>
        (<span class="org-variable-name">y_start</span>, <span class="org-variable-name">y_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(y_range, <span class="org-keyword">self</span>.shape[1])
        (<span class="org-variable-name">x_start</span>, <span class="org-variable-name">x_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(x_range, <span class="org-keyword">self</span>.shape[2])
        <span class="org-variable-name">y_stop</span> <span class="org-operator">=</span> y_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-variable-name">x_stop</span> <span class="org-operator">=</span> x_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res coordinates to cache and subcube coordinates</span>
        (<span class="org-variable-name">subcube_bands</span>, <span class="org-variable-name">subcube_rows</span>, <span class="org-variable-name">subcube_cols</span>) <span class="org-operator">=</span> <span class="org-keyword">self</span>.subcube_shape
        (<span class="org-variable-name">cache_t</span>,       <span class="org-variable-name">subcube_t</span>)       <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(t,       subcube_bands)
        (<span class="org-variable-name">cache_y_start</span>, <span class="org-variable-name">subcube_y_start</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(y_start, subcube_rows)
        (<span class="org-variable-name">cache_y_stop</span>,  <span class="org-variable-name">subcube_y_stop</span>)  <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(y_stop,  subcube_rows)
        (<span class="org-variable-name">cache_x_start</span>, <span class="org-variable-name">subcube_x_start</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(x_start, subcube_cols)
        (<span class="org-variable-name">cache_x_stop</span>,  <span class="org-variable-name">subcube_x_stop</span>)  <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(x_stop,  subcube_cols)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Load, expand, and combine subcubes</span>
        <span class="org-keyword">return</span> np.block(
            [[<span class="org-keyword">self</span>.__getOrLoadSubcube(cache_t,
                                      cache_y,
                                      cache_x
                                      ).getSpatialPlane(
                                          subcube_t,
                                          (subcube_y_start    <span class="org-keyword">if</span> cache_y <span class="org-operator">==</span> cache_y_start <span class="org-keyword">else</span> 0,
                                           subcube_y_stop <span class="org-operator">+</span> 1 <span class="org-keyword">if</span> cache_y <span class="org-operator">==</span> cache_y_stop  <span class="org-keyword">else</span> subcube_rows),
                                          (subcube_x_start    <span class="org-keyword">if</span> cache_x <span class="org-operator">==</span> cache_x_start <span class="org-keyword">else</span> 0,
                                           subcube_x_stop <span class="org-operator">+</span> 1 <span class="org-keyword">if</span> cache_x <span class="org-operator">==</span> cache_x_stop  <span class="org-keyword">else</span> subcube_cols)
                                      )
              <span class="org-keyword">for</span> cache_x <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cache_x_start, cache_x_stop <span class="org-operator">+</span> 1)]
             <span class="org-keyword">for</span> cache_y <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cache_y_start, cache_y_stop <span class="org-operator">+</span> 1)]
        )


    <span class="org-keyword">def</span> <span class="org-function-name">getSubcube</span>(<span class="org-keyword">self</span>, t_range, y_range, x_range):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 3D array given by the slice (t_range,y_range,x_range) by translating</span>
<span class="org-doc">        these cube coordinates to cache and subcube coordinates, loading the matching</span>
<span class="org-doc">        subcubes into the cache grid if not already present, looking up the array slices</span>
<span class="org-doc">        within each subcube, and merging them together into a single 3D array.</span>

<span class="org-doc">        NOTE: Indices may be negative provided that your load_subcube function can handle</span>
<span class="org-doc">              negative indices in its cache_index argument.</span>
<span class="org-doc">        NOTE: Range indices may include one or more None values and</span>
<span class="org-doc">              provide (inclusion, exclusion) semantics like Python array slice notation.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the argument ranges</span>
        (<span class="org-variable-name">t_start</span>, <span class="org-variable-name">t_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(t_range, <span class="org-keyword">self</span>.shape[0])
        (<span class="org-variable-name">y_start</span>, <span class="org-variable-name">y_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(y_range, <span class="org-keyword">self</span>.shape[1])
        (<span class="org-variable-name">x_start</span>, <span class="org-variable-name">x_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(x_range, <span class="org-keyword">self</span>.shape[2])
        <span class="org-variable-name">t_stop</span> <span class="org-operator">=</span> t_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-variable-name">y_stop</span> <span class="org-operator">=</span> y_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-variable-name">x_stop</span> <span class="org-operator">=</span> x_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res coordinates to cache and subcube coordinates</span>
        (<span class="org-variable-name">subcube_bands</span>, <span class="org-variable-name">subcube_rows</span>, <span class="org-variable-name">subcube_cols</span>) <span class="org-operator">=</span> <span class="org-keyword">self</span>.subcube_shape
        (<span class="org-variable-name">cache_t_start</span>, <span class="org-variable-name">subcube_t_start</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(t_start, subcube_bands)
        (<span class="org-variable-name">cache_t_stop</span>,  <span class="org-variable-name">subcube_t_stop</span>)  <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(t_stop,  subcube_bands)
        (<span class="org-variable-name">cache_y_start</span>, <span class="org-variable-name">subcube_y_start</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(y_start, subcube_rows)
        (<span class="org-variable-name">cache_y_stop</span>,  <span class="org-variable-name">subcube_y_stop</span>)  <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(y_stop,  subcube_rows)
        (<span class="org-variable-name">cache_x_start</span>, <span class="org-variable-name">subcube_x_start</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(x_start, subcube_cols)
        (<span class="org-variable-name">cache_x_stop</span>,  <span class="org-variable-name">subcube_x_stop</span>)  <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(x_stop,  subcube_cols)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Load, expand, and combine subcubes</span>
        <span class="org-keyword">return</span> np.block(
            [[[<span class="org-keyword">self</span>.__getOrLoadSubcube(cache_t,
                                       cache_y,
                                       cache_x
                                       ).getSubcube(
                                           (subcube_t_start    <span class="org-keyword">if</span> cache_t <span class="org-operator">==</span> cache_t_start <span class="org-keyword">else</span> 0,
                                            subcube_t_stop <span class="org-operator">+</span> 1 <span class="org-keyword">if</span> cache_t <span class="org-operator">==</span> cache_t_stop  <span class="org-keyword">else</span> subcube_bands),
                                           (subcube_y_start    <span class="org-keyword">if</span> cache_y <span class="org-operator">==</span> cache_y_start <span class="org-keyword">else</span> 0,
                                            subcube_y_stop <span class="org-operator">+</span> 1 <span class="org-keyword">if</span> cache_y <span class="org-operator">==</span> cache_y_stop  <span class="org-keyword">else</span> subcube_rows),
                                           (subcube_x_start    <span class="org-keyword">if</span> cache_x <span class="org-operator">==</span> cache_x_start <span class="org-keyword">else</span> 0,
                                            subcube_x_stop <span class="org-operator">+</span> 1 <span class="org-keyword">if</span> cache_x <span class="org-operator">==</span> cache_x_stop  <span class="org-keyword">else</span> subcube_cols)
                                       )
               <span class="org-keyword">for</span> cache_x <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cache_x_start, cache_x_stop <span class="org-operator">+</span> 1)]
              <span class="org-keyword">for</span> cache_y <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cache_y_start, cache_y_stop <span class="org-operator">+</span> 1)]
             <span class="org-keyword">for</span> cache_t <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cache_t_start, cache_t_stop <span class="org-operator">+</span> 1)]
        )


    <span class="org-keyword">def</span> <span class="org-function-name">getFullyRealizedCube</span>(<span class="org-keyword">self</span>, cache<span class="org-operator">=</span><span class="org-constant">False</span>):
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"getFullyRealizedCube is not implemented for LazySpaceTimeCube.</span><span class="org-constant">\n</span><span class="org-string">"</span>
                         <span class="org-operator">+</span> <span class="org-string">"You probably don't want to do this anyway."</span>)


    <span class="org-keyword">def</span> <span class="org-function-name">releaseFullyRealizedCube</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"releaseFullyRealizedCube is not implemented for LazySpaceTimeCube.</span><span class="org-constant">\n</span><span class="org-string">"</span>
                         <span class="org-operator">+</span> <span class="org-string">"You probably don't want to do this anyway."</span>)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-for-users-spacetimecube" class="outline-3">
<h3 id="for-users-spacetimecube"><span class="section-number-3">3.2.</span> For Users</h3>
<div class="outline-text-3" id="text-for-users-spacetimecube">
<p>
In the following sections, we will use functions from <a href="https://pypi.org/project/numpy/">numpy</a> and the
Python standard library to construct arrays of different resolutions
in memory to use in our <code>SpaceTimeCube</code> and <code>LazySpaceTimeCube</code>
examples. In many real world applications, this array data will
probably be read in from files or databases using Python libraries
such as <a href="https://pypi.org/project/rasterio/">rasterio</a> or <a href="https://pypi.org/project/psycopg2/">psycopg2</a>. All examples should apply equally well
in either case.
</p>
</div>
<div id="outline-container-how-to-use-spacetimecube" class="outline-4">
<h4 id="how-to-use-spacetimecube"><span class="section-number-4">3.2.1.</span> How to Use SpaceTimeCube</h4>
<div class="outline-text-4" id="text-how-to-use-spacetimecube">
</div>
<ol class="org-ol">
<li><a id="create-a-spacetimecube-from-0d,-1d,-2d,-or-3d-input-data"></a>Create a SpaceTimeCube from 0D, 1D, 2D, or 3D Input Data<br>
<div class="outline-text-5" id="text-create-a-spacetimecube-from-0d,-1d,-2d,-or-3d-input-data">
<div class="org-src-container">
<pre class="src src-python" id="space-time-cube-create"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Set a Random Seed</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

np.random.seed(0)

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube Dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (
    240,  <span class="org-comment-delimiter"># </span><span class="org-comment">bands: 10 days @ 1 hour/band</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">rows:  30 km @ 30 meters/row</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">cols:  30 km @ 30 meters/col</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Constant Data: foliar moisture = 70% everywhere</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">foliar_moisture</span> <span class="org-operator">=</span> 0.7
<span class="org-variable-name">constant_cube</span>   <span class="org-operator">=</span> SpaceTimeCube(cube_shape, foliar_moisture)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Temporal Data: 24-hour burn period with ramp up and ramp down for 10 days</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">spread_rate_adjustments</span> <span class="org-operator">=</span> ([0] <span class="org-operator">*</span> 6 <span class="org-operator">+</span> [0.33, 0.66] <span class="org-operator">+</span> [1] <span class="org-operator">*</span> 12 <span class="org-operator">+</span> [0.66, 0.33] <span class="org-operator">+</span> [0] <span class="org-operator">*</span> 2) <span class="org-operator">*</span> 10
<span class="org-variable-name">time_series_cube</span>        <span class="org-operator">=</span> SpaceTimeCube(cube_shape, spread_rate_adjustments)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Spatial Data: 2D elevation raster with 1000 (30m) x 1000 (30m) cells</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">elevation_raster</span> <span class="org-operator">=</span> np.random.normal(500, 100, 1000000).astype(<span class="org-string">"int"</span>).reshape(1000,1000)
<span class="org-variable-name">spatial_cube</span>     <span class="org-operator">=</span> SpaceTimeCube(cube_shape, elevation_raster)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Spatio-Temporal Data: 3D daily max wind speed raster with 10 (days) x 100 (300m) x 100 (300m) cells</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">wind_speed_raster</span>   <span class="org-operator">=</span> np.random.normal(30, 5, 100000).astype(<span class="org-string">"int"</span>).reshape(10,100,100)
<span class="org-variable-name">spatiotemporal_cube</span> <span class="org-operator">=</span> SpaceTimeCube(cube_shape, wind_speed_raster)
</pre>
</div>
</div>
</li>
<li><a id="retrieve-a-scalar-value-at-a-space-time-coordinate"></a>Retrieve a Scalar Value at a Space-Time Coordinate<br>
<div class="outline-text-5" id="text-retrieve-a-scalar-value-at-a-space-time-coordinate">
<div class="org-src-container">
<pre class="src src-python" id="space-time-cube-get-point"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinate</span>
<span class="org-variable-name">band</span> <span class="org-operator">=</span> 12
<span class="org-variable-name">row</span>  <span class="org-operator">=</span> 100
<span class="org-variable-name">col</span>  <span class="org-operator">=</span> 100

<span class="org-builtin">print</span>(<span class="org-string">"Value from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.get(band, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Value from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.get(band, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Value from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.get(band, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Value from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.get(band, row, col))
</pre>
</div>

<pre class="example" id="space-time-cube-get-point-results">
Value from Constant Data: Foliar Moisture
0.7 

Value from Time Series Data: Spread Rate Adjustment
1.0 

Value from Spatial Data: Elevation
564 

Value from Spatio-Temporal Data: Wind Speed
32
</pre>
</div>
</li>
<li><a id="retrieve-a-time-series-at-a-spatial-coordinate"></a>Retrieve a Time Series at a Spatial Coordinate<br>
<div class="outline-text-5" id="text-retrieve-a-time-series-at-a-spatial-coordinate">
<div class="org-src-container">
<pre class="src src-python" id="space-time-cube-get-time-series"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinates</span>
<span class="org-variable-name">band_range</span> <span class="org-operator">=</span> (18,30)
<span class="org-variable-name">row</span>        <span class="org-operator">=</span> 100
<span class="org-variable-name">col</span>        <span class="org-operator">=</span> 100

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.getTimeSeries(band_range, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.getTimeSeries(band_range, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.getTimeSeries(band_range, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.getTimeSeries(band_range, row, col))
</pre>
</div>

<pre class="example" id="space-time-cube-get-time-series-results">
Time Series from Constant Data: Foliar Moisture
[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7] 

Time Series from Time Series Data: Spread Rate Adjustment
[1.   1.   0.66 0.33 0.   0.   0.   0.   0.   0.   0.   0.  ] 

Time Series from Spatial Data: Elevation
[564 564 564 564 564 564 564 564 564 564 564 564] 

Time Series from Spatio-Temporal Data: Wind Speed
[32 32 32 32 32 32 37 37 37 37 37 37]
</pre>
</div>
</li>
<li><a id="retrieve-a-spatial-plane-at-a-temporal-coordinate"></a>Retrieve a Spatial Plane at a Temporal Coordinate<br>
<div class="outline-text-5" id="text-retrieve-a-spatial-plane-at-a-temporal-coordinate">
<div class="org-src-container">
<pre class="src src-python" id="space-time-cube-get-spatial-plane"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinates</span>
<span class="org-variable-name">band</span>      <span class="org-operator">=</span> 12
<span class="org-variable-name">row_range</span> <span class="org-operator">=</span> (95,105)
<span class="org-variable-name">col_range</span> <span class="org-operator">=</span> (95,105)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.getSpatialPlane(band, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.getSpatialPlane(band, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.getSpatialPlane(band, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.getSpatialPlane(band, row_range, col_range))
</pre>
</div>

<pre class="example" id="space-time-cube-get-spatial-plane-results">
Spatial Plane from Constant Data: Foliar Moisture
[[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]] 

Spatial Plane from Time Series Data: Spread Rate Adjustment
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]] 

Spatial Plane from Spatial Data: Elevation
[[574 369 544 310 517 488 565 549 450 470]
 [443 551 480 476 432 561 578 361 468 480]
 [520 712 396 393 584 292 424 391 494 586]
 [707 534 246 423 521 500 426 340 288 482]
 [542 285 607 555 645 559 461 603 330 452]
 [498 497 664 445 518 564 461 508 600 380]
 [454 500 276 487 447 591 413 378 458 508]
 [573 890 485 501 357 413 356 635 374 618]
 [535 558 491 482 539 572 598 703 463 329]
 [487 555 580 492 462 484 495 396 711 356]] 

Spatial Plane from Spatio-Temporal Data: Wind Speed
[[31 31 31 31 31 31 31 31 31 31]
 [31 31 31 31 31 31 31 31 31 31]
 [31 31 31 31 31 31 31 31 31 31]
 [31 31 31 31 31 31 31 31 31 31]
 [31 31 31 31 31 31 31 31 31 31]
 [26 26 26 26 26 32 32 32 32 32]
 [26 26 26 26 26 32 32 32 32 32]
 [26 26 26 26 26 32 32 32 32 32]
 [26 26 26 26 26 32 32 32 32 32]
 [26 26 26 26 26 32 32 32 32 32]]
</pre>
</div>
</li>
<li><a id="retrieve-a-subcube-within-a-space-time-region"></a>Retrieve a Subcube within a Space-Time Region<br>
<div class="outline-text-5" id="text-retrieve-a-subcube-within-a-space-time-region">
<div class="org-src-container">
<pre class="src src-python" id="space-time-cube-get-subcube"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinates</span>
<span class="org-variable-name">band_range</span> <span class="org-operator">=</span> (23,25)
<span class="org-variable-name">row_range</span>  <span class="org-operator">=</span> (95,105)
<span class="org-variable-name">col_range</span>  <span class="org-operator">=</span> (95,105)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.getSubcube(band_range, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.getSubcube(band_range, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.getSubcube(band_range, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.getSubcube(band_range, row_range, col_range))
</pre>
</div>

<pre class="example" id="space-time-cube-get-subcube-results">
Subcube from Constant Data: Foliar Moisture
[[[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]]

 [[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]]] 

Subcube from Time Series Data: Spread Rate Adjustment
[[[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]]

 [[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]]] 

Subcube from Spatial Data: Elevation
[[[574 369 544 310 517 488 565 549 450 470]
  [443 551 480 476 432 561 578 361 468 480]
  [520 712 396 393 584 292 424 391 494 586]
  [707 534 246 423 521 500 426 340 288 482]
  [542 285 607 555 645 559 461 603 330 452]
  [498 497 664 445 518 564 461 508 600 380]
  [454 500 276 487 447 591 413 378 458 508]
  [573 890 485 501 357 413 356 635 374 618]
  [535 558 491 482 539 572 598 703 463 329]
  [487 555 580 492 462 484 495 396 711 356]]

 [[574 369 544 310 517 488 565 549 450 470]
  [443 551 480 476 432 561 578 361 468 480]
  [520 712 396 393 584 292 424 391 494 586]
  [707 534 246 423 521 500 426 340 288 482]
  [542 285 607 555 645 559 461 603 330 452]
  [498 497 664 445 518 564 461 508 600 380]
  [454 500 276 487 447 591 413 378 458 508]
  [573 890 485 501 357 413 356 635 374 618]
  [535 558 491 482 539 572 598 703 463 329]
  [487 555 580 492 462 484 495 396 711 356]]] 

Subcube from Spatio-Temporal Data: Wind Speed
[[[31 31 31 31 31 31 31 31 31 31]
  [31 31 31 31 31 31 31 31 31 31]
  [31 31 31 31 31 31 31 31 31 31]
  [31 31 31 31 31 31 31 31 31 31]
  [31 31 31 31 31 31 31 31 31 31]
  [26 26 26 26 26 32 32 32 32 32]
  [26 26 26 26 26 32 32 32 32 32]
  [26 26 26 26 26 32 32 32 32 32]
  [26 26 26 26 26 32 32 32 32 32]
  [26 26 26 26 26 32 32 32 32 32]]

 [[30 30 30 30 30 36 36 36 36 36]
  [30 30 30 30 30 36 36 36 36 36]
  [30 30 30 30 30 36 36 36 36 36]
  [30 30 30 30 30 36 36 36 36 36]
  [30 30 30 30 30 36 36 36 36 36]
  [34 34 34 34 34 37 37 37 37 37]
  [34 34 34 34 34 37 37 37 37 37]
  [34 34 34 34 34 37 37 37 37 37]
  [34 34 34 34 34 37 37 37 37 37]
  [34 34 34 34 34 37 37 37 37 37]]]
</pre>
</div>
</li>
</ol>
</div>
<div id="outline-container-how-to-use-lazyspacetimecube" class="outline-4">
<h4 id="how-to-use-lazyspacetimecube"><span class="section-number-4">3.2.2.</span> How to Use LazySpaceTimeCube</h4>
<div class="outline-text-4" id="text-how-to-use-lazyspacetimecube">
</div>
<ol class="org-ol">
<li><a id="create-a-lazyspacetimecube-from-0d,-1d,-2d,-or-3d-input-data"></a>Create a LazySpaceTimeCube from 0D, 1D, 2D, or 3D Input Data<br>
<div class="outline-text-5" id="text-create-a-lazyspacetimecube-from-0d,-1d,-2d,-or-3d-input-data">
<div class="org-src-container">
<pre class="src src-python" id="lazy-space-time-cube-create"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube, LazySpaceTimeCube

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Set a Random Seed</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

np.random.seed(0)

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube Dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (
    240,  <span class="org-comment-delimiter"># </span><span class="org-comment">bands: 10 days @ 1 hour/band</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">rows:  30 km @ 30 meters/row</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">cols:  30 km @ 30 meters/col</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Constant Data: foliar moisture = 70% everywhere</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">foliar_moisture</span>               <span class="org-operator">=</span> 0.7
<span class="org-variable-name">foliar_moisture_subcube_shape</span> <span class="org-operator">=</span> cube_shape <span class="org-comment-delimiter"># </span><span class="org-comment">Only 1 subcube necessary</span>

<span class="org-keyword">def</span> <span class="org-function-name">foliar_moisture_load_subcube</span>(_, subcube_shape):
    <span class="org-keyword">return</span> SpaceTimeCube(subcube_shape, foliar_moisture)

<span class="org-variable-name">constant_cube</span> <span class="org-operator">=</span> LazySpaceTimeCube(cube_shape,
                                  foliar_moisture_subcube_shape,
                                  foliar_moisture_load_subcube)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Temporal Data: 24-hour burn period with ramp up and ramp down for 10 days</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">spread_rate_adjustments</span>               <span class="org-operator">=</span> ([0] <span class="org-operator">*</span> 6 <span class="org-operator">+</span> [0.33, 0.66] <span class="org-operator">+</span> [1] <span class="org-operator">*</span> 12 <span class="org-operator">+</span> [0.66, 0.33] <span class="org-operator">+</span> [0] <span class="org-operator">*</span> 2) <span class="org-operator">*</span> 10
<span class="org-variable-name">spread_rate_adjustments_subcube_shape</span> <span class="org-operator">=</span> (24, 1000, 1000) <span class="org-comment-delimiter"># </span><span class="org-comment">1 subcube per day (10 total)</span>

<span class="org-keyword">def</span> <span class="org-function-name">spread_rate_adjustments_load_subcube</span>(cache_index, subcube_shape):
    (<span class="org-variable-name">cache_t</span>, <span class="org-variable-name">_</span>, <span class="org-variable-name">_</span>) <span class="org-operator">=</span> cache_index
    <span class="org-variable-name">t_start</span> <span class="org-operator">=</span> 24 <span class="org-operator">*</span> cache_t
    <span class="org-variable-name">t_stop</span>  <span class="org-operator">=</span> 24 <span class="org-operator">*</span> (cache_t <span class="org-operator">+</span> 1)
    <span class="org-keyword">return</span> SpaceTimeCube(subcube_shape,
                         spread_rate_adjustments[t_start:t_stop])

<span class="org-variable-name">time_series_cube</span> <span class="org-operator">=</span> LazySpaceTimeCube(cube_shape,
                                     spread_rate_adjustments_subcube_shape,
                                     spread_rate_adjustments_load_subcube)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Spatial Data: 2D elevation raster with 1000 (30m) x 1000 (30m) cells</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">elevation_raster</span>               <span class="org-operator">=</span> np.random.normal(500, 100, 1000000).astype(<span class="org-string">"int"</span>).reshape(1000,1000)
<span class="org-variable-name">elevation_raster_subcube_shape</span> <span class="org-operator">=</span> (240, 100, 100) <span class="org-comment-delimiter"># </span><span class="org-comment">1 subcube per 100x100 cell region (10x10 = 100 total)</span>

<span class="org-keyword">def</span> <span class="org-function-name">elevation_raster_load_subcube</span>(cache_index, subcube_shape):
    (<span class="org-variable-name">_</span>, <span class="org-variable-name">cache_y</span>, <span class="org-variable-name">cache_x</span>) <span class="org-operator">=</span> cache_index
    <span class="org-variable-name">y_start</span> <span class="org-operator">=</span> 100 <span class="org-operator">*</span> cache_y
    <span class="org-variable-name">y_stop</span>  <span class="org-operator">=</span> 100 <span class="org-operator">*</span> (cache_y <span class="org-operator">+</span> 1)
    <span class="org-variable-name">x_start</span> <span class="org-operator">=</span> 100 <span class="org-operator">*</span> cache_x
    <span class="org-variable-name">x_stop</span>  <span class="org-operator">=</span> 100 <span class="org-operator">*</span> (cache_x <span class="org-operator">+</span> 1)
    <span class="org-keyword">return</span> SpaceTimeCube(subcube_shape,
                         elevation_raster[y_start:y_stop,
                                          x_start:x_stop])

<span class="org-variable-name">spatial_cube</span> <span class="org-operator">=</span> LazySpaceTimeCube(cube_shape,
                                 elevation_raster_subcube_shape,
                                 elevation_raster_load_subcube)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Spatio-Temporal Data: 3D daily max wind speed raster with 10 (days) x 100 (300m) x 100 (300m) cells</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">wind_speed_raster</span>               <span class="org-operator">=</span> np.random.normal(30, 5, 100000).astype(<span class="org-string">"int"</span>).reshape(10,100,100)
<span class="org-variable-name">wind_speed_raster_subcube_shape</span> <span class="org-operator">=</span> (24, 100, 100) <span class="org-comment-delimiter"># </span><span class="org-comment">1 subcube per day per 100x100 cell region (10x10x10 = 1000 total)</span>

<span class="org-keyword">def</span> <span class="org-function-name">wind_speed_raster_load_subcube</span>(cache_index, subcube_shape):
    (<span class="org-variable-name">cache_t</span>, <span class="org-variable-name">cache_y</span>, <span class="org-variable-name">cache_x</span>) <span class="org-operator">=</span> cache_index
    <span class="org-variable-name">t_start</span> <span class="org-operator">=</span> cache_t
    <span class="org-variable-name">t_stop</span>  <span class="org-operator">=</span> cache_t <span class="org-operator">+</span> 1
    <span class="org-variable-name">y_start</span> <span class="org-operator">=</span> 10 <span class="org-operator">*</span> cache_y
    <span class="org-variable-name">y_stop</span>  <span class="org-operator">=</span> 10 <span class="org-operator">*</span> (cache_y <span class="org-operator">+</span> 1)
    <span class="org-variable-name">x_start</span> <span class="org-operator">=</span> 10 <span class="org-operator">*</span> cache_x
    <span class="org-variable-name">x_stop</span>  <span class="org-operator">=</span> 10 <span class="org-operator">*</span> (cache_x <span class="org-operator">+</span> 1)
    <span class="org-keyword">return</span> SpaceTimeCube(subcube_shape,
                         wind_speed_raster[t_start:t_stop,
                                           y_start:y_stop,
                                           x_start:x_stop])

<span class="org-variable-name">spatiotemporal_cube</span> <span class="org-operator">=</span> LazySpaceTimeCube(cube_shape,
                                        wind_speed_raster_subcube_shape,
                                        wind_speed_raster_load_subcube)
</pre>
</div>
</div>
</li>
<li><a id="retrieve-a-scalar-value-at-a-space-time-coordinate"></a>Retrieve a Scalar Value at a Space-Time Coordinate<br>
<div class="outline-text-5" id="text-retrieve-a-scalar-value-at-a-space-time-coordinate">
<div class="org-src-container">
<pre class="src src-python" id="lazy-space-time-cube-get-point"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinate</span>
<span class="org-variable-name">band</span> <span class="org-operator">=</span> 12
<span class="org-variable-name">row</span>  <span class="org-operator">=</span> 100
<span class="org-variable-name">col</span>  <span class="org-operator">=</span> 100

<span class="org-builtin">print</span>(<span class="org-string">"Value from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.get(band, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Value from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.get(band, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Value from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.get(band, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Value from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.get(band, row, col))
</pre>
</div>

<pre class="example" id="lazy-space-time-cube-get-point-results">
Value from Constant Data: Foliar Moisture
0.7 

Value from Time Series Data: Spread Rate Adjustment
1.0 

Value from Spatial Data: Elevation
564 

Value from Spatio-Temporal Data: Wind Speed
32
</pre>
</div>
</li>
<li><a id="retrieve-a-time-series-at-a-spatial-coordinate"></a>Retrieve a Time Series at a Spatial Coordinate<br>
<div class="outline-text-5" id="text-retrieve-a-time-series-at-a-spatial-coordinate">
<div class="org-src-container">
<pre class="src src-python" id="lazy-space-time-cube-get-time-series"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinates</span>
<span class="org-variable-name">band_range</span> <span class="org-operator">=</span> (18,30)
<span class="org-variable-name">row</span>        <span class="org-operator">=</span> 100
<span class="org-variable-name">col</span>        <span class="org-operator">=</span> 100

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.getTimeSeries(band_range, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.getTimeSeries(band_range, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.getTimeSeries(band_range, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.getTimeSeries(band_range, row, col))
</pre>
</div>

<pre class="example" id="lazy-space-time-cube-get-time-series-results">
Time Series from Constant Data: Foliar Moisture
[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7] 

Time Series from Time Series Data: Spread Rate Adjustment
[1.   1.   0.66 0.33 0.   0.   0.   0.   0.   0.   0.   0.  ] 

Time Series from Spatial Data: Elevation
[564 564 564 564 564 564 564 564 564 564 564 564] 

Time Series from Spatio-Temporal Data: Wind Speed
[32 32 32 32 32 32 37 37 37 37 37 37]
</pre>
</div>
</li>
<li><a id="retrieve-a-spatial-plane-at-a-temporal-coordinate"></a>Retrieve a Spatial Plane at a Temporal Coordinate<br>
<div class="outline-text-5" id="text-retrieve-a-spatial-plane-at-a-temporal-coordinate">
<div class="org-src-container">
<pre class="src src-python" id="lazy-space-time-cube-get-spatial-plane"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinates</span>
<span class="org-variable-name">band</span>      <span class="org-operator">=</span> 12
<span class="org-variable-name">row_range</span> <span class="org-operator">=</span> (95,105)
<span class="org-variable-name">col_range</span> <span class="org-operator">=</span> (95,105)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.getSpatialPlane(band, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.getSpatialPlane(band, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.getSpatialPlane(band, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.getSpatialPlane(band, row_range, col_range))
</pre>
</div>

<pre class="example" id="lazy-space-time-cube-get-spatial-plane-results">
Spatial Plane from Constant Data: Foliar Moisture
[[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]] 

Spatial Plane from Time Series Data: Spread Rate Adjustment
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]] 

Spatial Plane from Spatial Data: Elevation
[[574 369 544 310 517 488 565 549 450 470]
 [443 551 480 476 432 561 578 361 468 480]
 [520 712 396 393 584 292 424 391 494 586]
 [707 534 246 423 521 500 426 340 288 482]
 [542 285 607 555 645 559 461 603 330 452]
 [498 497 664 445 518 564 461 508 600 380]
 [454 500 276 487 447 591 413 378 458 508]
 [573 890 485 501 357 413 356 635 374 618]
 [535 558 491 482 539 572 598 703 463 329]
 [487 555 580 492 462 484 495 396 711 356]] 

Spatial Plane from Spatio-Temporal Data: Wind Speed
[[31 31 31 31 31 31 31 31 31 31]
 [31 31 31 31 31 31 31 31 31 31]
 [31 31 31 31 31 31 31 31 31 31]
 [31 31 31 31 31 31 31 31 31 31]
 [31 31 31 31 31 31 31 31 31 31]
 [26 26 26 26 26 32 32 32 32 32]
 [26 26 26 26 26 32 32 32 32 32]
 [26 26 26 26 26 32 32 32 32 32]
 [26 26 26 26 26 32 32 32 32 32]
 [26 26 26 26 26 32 32 32 32 32]]
</pre>
</div>
</li>
<li><a id="retrieve-a-subcube-within-a-space-time-region"></a>Retrieve a Subcube within a Space-Time Region<br>
<div class="outline-text-5" id="text-retrieve-a-subcube-within-a-space-time-region">
<div class="org-src-container">
<pre class="src src-python" id="lazy-space-time-cube-get-subcube"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinates</span>
<span class="org-variable-name">band_range</span> <span class="org-operator">=</span> (23,25)
<span class="org-variable-name">row_range</span>  <span class="org-operator">=</span> (95,105)
<span class="org-variable-name">col_range</span>  <span class="org-operator">=</span> (95,105)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.getSubcube(band_range, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.getSubcube(band_range, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.getSubcube(band_range, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.getSubcube(band_range, row_range, col_range))
</pre>
</div>

<pre class="example" id="lazy-space-time-cube-get-subcube-results">
Subcube from Constant Data: Foliar Moisture
[[[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]]

 [[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]]] 

Subcube from Time Series Data: Spread Rate Adjustment
[[[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]]

 [[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]]] 

Subcube from Spatial Data: Elevation
[[[574 369 544 310 517 488 565 549 450 470]
  [443 551 480 476 432 561 578 361 468 480]
  [520 712 396 393 584 292 424 391 494 586]
  [707 534 246 423 521 500 426 340 288 482]
  [542 285 607 555 645 559 461 603 330 452]
  [498 497 664 445 518 564 461 508 600 380]
  [454 500 276 487 447 591 413 378 458 508]
  [573 890 485 501 357 413 356 635 374 618]
  [535 558 491 482 539 572 598 703 463 329]
  [487 555 580 492 462 484 495 396 711 356]]

 [[574 369 544 310 517 488 565 549 450 470]
  [443 551 480 476 432 561 578 361 468 480]
  [520 712 396 393 584 292 424 391 494 586]
  [707 534 246 423 521 500 426 340 288 482]
  [542 285 607 555 645 559 461 603 330 452]
  [498 497 664 445 518 564 461 508 600 380]
  [454 500 276 487 447 591 413 378 458 508]
  [573 890 485 501 357 413 356 635 374 618]
  [535 558 491 482 539 572 598 703 463 329]
  [487 555 580 492 462 484 495 396 711 356]]] 

Subcube from Spatio-Temporal Data: Wind Speed
[[[31 31 31 31 31 31 31 31 31 31]
  [31 31 31 31 31 31 31 31 31 31]
  [31 31 31 31 31 31 31 31 31 31]
  [31 31 31 31 31 31 31 31 31 31]
  [31 31 31 31 31 31 31 31 31 31]
  [26 26 26 26 26 32 32 32 32 32]
  [26 26 26 26 26 32 32 32 32 32]
  [26 26 26 26 26 32 32 32 32 32]
  [26 26 26 26 26 32 32 32 32 32]
  [26 26 26 26 26 32 32 32 32 32]]

 [[30 30 30 30 30 36 36 36 36 36]
  [30 30 30 30 30 36 36 36 36 36]
  [30 30 30 30 30 36 36 36 36 36]
  [30 30 30 30 30 36 36 36 36 36]
  [30 30 30 30 30 36 36 36 36 36]
  [34 34 34 34 34 37 37 37 37 37]
  [34 34 34 34 34 37 37 37 37 37]
  [34 34 34 34 34 37 37 37 37 37]
  [34 34 34 34 34 37 37 37 37 37]
  [34 34 34 34 34 37 37 37 37 37]]]
</pre>
</div>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-fuel-model-and-moisture-definitions-(pyretechnics.fuel_models)" class="outline-2">
<h2 id="fuel-model-and-moisture-definitions-(pyretechnics.fuel_models)"><span class="section-number-2">4.</span> Fuel Model and Moisture Definitions (pyretechnics.fuel_models)</h2>
<div class="outline-text-2" id="text-fuel-model-and-moisture-definitions-(pyretechnics.fuel_models)">
</div>
<div id="outline-container-for-developers-fuel" class="outline-3">
<h3 id="for-developers-fuel"><span class="section-number-3">4.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-for-developers-fuel">
<p>
The following sections encode various fire behavior fuel models as
Python dictionaries and then provide functions to augment their static
properties with additional information that is dependent upon fuel
moisture. This combination of fuel models and moisture form the basis
of many fire behavior analyses.
</p>
</div>
<div id="outline-container-fuel-model-properties" class="outline-4">
<h4 id="fuel-model-properties"><span class="section-number-4">4.1.1.</span> Fuel Model Properties</h4>
<div class="outline-text-4" id="text-fuel-model-properties">
<p>
All fires ignite and travel through some form of burnable fuel.
Although the effects of wind and slope on the rate of fire spread can
be quite pronounced, its fundamental thermodynamic characteristics are
largely determined by the fuel type in which it is sustained. For
wildfires, these fuels are predominantly herbaceous and woody
vegetation (both alive and dead) as well as decomposing elements of
dead vegetation, such as duff or leaf litter. To estimate the heat
output and rate of spread of a fire burning through any of these
fuels, we must determine those physical properties that affect heat
absorption and release.
</p>

<p>
Of course, measuring these fuel properties for every kind of
vegetation that may be burned in a wildfire is an intractable task. To
cope with this, fuels are classified into categories called "fuel
models" which share similar burning characteristics. Each fuel model
is then assigned a set of representative values for each of the
thermally relevant physical properties shown in Table
<a href="#tab:fuel-model-properties">1</a>.
</p>

<table id="tab:fuel-model-properties">
<caption class="t-above"><span class="table-number">Table 1:</span> Physical properties assigned to each fuel model</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Property</th>
<th scope="col" class="org-left">Description</th>
<th scope="col" class="org-left">Units</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">\(\delta\)</td>
<td class="org-left">fuel depth</td>
<td class="org-left">\(\text{ft}\)</td>
</tr>

<tr>
<td class="org-left">\(w_o\)</td>
<td class="org-left">ovendry fuel loading</td>
<td class="org-left">\(\text{lb}/\text{ft}^2\)</td>
</tr>

<tr>
<td class="org-left">\(\rho_p\)</td>
<td class="org-left">ovendry particle density</td>
<td class="org-left">\(\text{lb}/\text{ft}^3\)</td>
</tr>

<tr>
<td class="org-left">\(\sigma\)</td>
<td class="org-left">fuel particle surface-area-to-volume ratio</td>
<td class="org-left">\(\text{ft}^2/\text{ft}^3\)</td>
</tr>

<tr>
<td class="org-left">\(h\)</td>
<td class="org-left">fuel particle low heat content</td>
<td class="org-left">\(\text{Btu}/\text{lb}\)</td>
</tr>

<tr>
<td class="org-left">\(S_T\)</td>
<td class="org-left">fuel particle total mineral content</td>
<td class="org-left">\(\text{lb minerals}/\text{lb ovendry weight}\)</td>
</tr>

<tr>
<td class="org-left">\(S_e\)</td>
<td class="org-left">fuel particle effective mineral content</td>
<td class="org-left">\(\text{lb silica-free minerals}/\text{lb ovendry weight}\)</td>
</tr>

<tr>
<td class="org-left">\(M_x\)</td>
<td class="org-left">fuel particle moisture of extinction</td>
<td class="org-left">\(\text{lb moisture}/\text{lb ovendry weight}\)</td>
</tr>

<tr>
<td class="org-left">\(M_f\)</td>
<td class="org-left">fuel particle moisture content</td>
<td class="org-left">\(\text{lb moisture}/\text{lb ovendry weight}\)</td>
</tr>
</tbody>
</table>

<p>
While \(M_f\) is not, in fact, directly assigned to any of these fuel
models, their definitions remain incomplete for the purposes of fire
spread modelling (particularly those reliant on the curing formulas of
dynamic fuel loading) until it is provided as a characteristic of
local weather conditions.
</p>

<p>
Although most fuel model properties are static with respect to
environmental conditions, the fuel moisture content can have two
significant impacts on a fuel model's burning potential:
</p>

<ul class="org-ul">
<li>Dynamic fuel loading</li>
<li>Live moisture of extinction</li>
</ul>

<p>
These two topics are discussed in sections <a href="#dynamic-fuel-loading">4.1.4</a> and
<a href="#live-moisture-of-extinction">4.1.6</a>.
</p>
</div>
</div>
<div id="outline-container-fuel-model-definitions" class="outline-4">
<h4 id="fuel-model-definitions"><span class="section-number-4">4.1.2.</span> Fuel Model Definitions</h4>
<div class="outline-text-4" id="text-fuel-model-definitions">
<p>
The fuel models supported by Pyretechnics include the standard 13 fuel
models of Rothermel, Albini, and Anderson<sup><a id="fnr.5" class="footref" href="#fn.5" role="doc-backlink">5</a></sup> and the
additional 40 fuel models defined by Scott and Burgan<sup><a id="fnr.6" class="footref" href="#fn.6" role="doc-backlink">6</a></sup>.
These are all concisely encoded in an internal data structure, which
may be updated to include additional custom fuel models desired by the
user.
</p>

<div class="org-src-container">
<pre class="src src-python" id="fuel-model-compact-table"><span class="org-comment-delimiter"># </span><span class="org-comment">Lookup table including entries for each of the Anderson 13 and Scott &amp; Burgan 40 fuel models.</span>
<span class="org-comment-delimiter">#</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">The fields have the following meanings:</span>
<span class="org-comment-delimiter">#   </span><span class="org-comment">{fuel-model-number : [name, delta, M_x-dead, h, w_o, sigma]}</span>
<span class="org-comment-delimiter">#</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">where:</span>
<span class="org-comment-delimiter">#   </span><span class="org-comment">w_o   = [  w_o-dead-1hr,   w_o-dead-10hr,   w_o-dead-100hr,   w_o-live-herbaceous,   w_o-live-woody]</span>
<span class="org-comment-delimiter">#   </span><span class="org-comment">sigma = [sigma-dead-1hr, sigma-dead-10hr, sigma-dead-100hr, sigma-live-herbaceous, sigma-live-woody]</span>
<span class="org-variable-name">fuel_model_compact_table</span> <span class="org-operator">=</span> {
    <span class="org-comment-delimiter"># </span><span class="org-comment">Anderson 13:</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Grass and Grass-dominated (short-grass,timber-grass-and-understory,tall-grass)</span>
    1   : [<span class="org-string">"R01"</span>, 1.0, 12, 8, [0.0340, 0.0000, 0.0000, 0.0000, 0.0000], [3500.0,   0.0,  0.0,    0.0,    0.0]],
    2   : [<span class="org-string">"R02"</span>, 1.0, 15, 8, [0.0920, 0.0460, 0.0230, 0.0230, 0.0000], [3000.0, 109.0, 30.0, 1500.0,    0.0]],
    3   : [<span class="org-string">"R03"</span>, 2.5, 25, 8, [0.1380, 0.0000, 0.0000, 0.0000, 0.0000], [1500.0,   0.0,  0.0,    0.0,    0.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Chaparral and Shrubfields (chaparral,brush,dormant-brush-hardwood-slash,southern-rough)</span>
    4   : [<span class="org-string">"R04"</span>, 6.0, 20, 8, [0.2300, 0.1840, 0.0920, 0.2300, 0.0000], [2000.0, 109.0, 30.0, 1500.0,    0.0]],
    5   : [<span class="org-string">"R05"</span>, 2.0, 20, 8, [0.0460, 0.0230, 0.0000, 0.0920, 0.0000], [2000.0, 109.0,  0.0, 1500.0,    0.0]],
    6   : [<span class="org-string">"R06"</span>, 2.5, 25, 8, [0.0690, 0.1150, 0.0920, 0.0000, 0.0000], [1750.0, 109.0, 30.0,    0.0,    0.0]],
    7   : [<span class="org-string">"R07"</span>, 2.5, 40, 8, [0.0520, 0.0860, 0.0690, 0.0170, 0.0000], [1750.0, 109.0, 30.0, 1550.0,    0.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Timber Litter (closed-timber-litter,hardwood-litter,timber-litter-and-understory)</span>
    8   : [<span class="org-string">"R08"</span>, 0.2, 30, 8, [0.0690, 0.0460, 0.1150, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    9   : [<span class="org-string">"R09"</span>, 0.2, 25, 8, [0.1340, 0.0190, 0.0070, 0.0000, 0.0000], [2500.0, 109.0, 30.0,    0.0,    0.0]],
    10  : [<span class="org-string">"R10"</span>, 1.0, 25, 8, [0.1380, 0.0920, 0.2300, 0.0920, 0.0000], [2000.0, 109.0, 30.0, 1500.0,    0.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Logging Slash (light-logging-slash,medium-logging-slash,heavy-logging-slash)</span>
    11  : [<span class="org-string">"R11"</span>, 1.0, 15, 8, [0.0690, 0.2070, 0.2530, 0.0000, 0.0000], [1500.0, 109.0, 30.0,    0.0,    0.0]],
    12  : [<span class="org-string">"R12"</span>, 2.3, 20, 8, [0.1840, 0.6440, 0.7590, 0.0000, 0.0000], [1500.0, 109.0, 30.0,    0.0,    0.0]],
    13  : [<span class="org-string">"R13"</span>, 3.0, 25, 8, [0.3220, 1.0580, 1.2880, 0.0000, 0.0000], [1500.0, 109.0, 30.0,    0.0,    0.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Nonburnable (NB)</span>
    91  : [<span class="org-string">"NB1"</span>, 0.0,  0, 0, [0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [   0.0,   0.0,  0.0,    0.0,    0.0]],
    92  : [<span class="org-string">"NB2"</span>, 0.0,  0, 0, [0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [   0.0,   0.0,  0.0,    0.0,    0.0]],
    93  : [<span class="org-string">"NB3"</span>, 0.0,  0, 0, [0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [   0.0,   0.0,  0.0,    0.0,    0.0]],
    98  : [<span class="org-string">"NB4"</span>, 0.0,  0, 0, [0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [   0.0,   0.0,  0.0,    0.0,    0.0]],
    99  : [<span class="org-string">"NB5"</span>, 0.0,  0, 0, [0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [   0.0,   0.0,  0.0,    0.0,    0.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Scott &amp; Burgan 40:</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Grass (GR)</span>
    101 : [<span class="org-string">"GR1"</span>, 0.4, 15, 8, [0.0046, 0.0000, 0.0000, 0.0138, 0.0000], [2200.0, 109.0, 30.0, 2000.0,    0.0]],
    102 : [<span class="org-string">"GR2"</span>, 1.0, 15, 8, [0.0046, 0.0000, 0.0000, 0.0459, 0.0000], [2000.0, 109.0, 30.0, 1800.0,    0.0]],
    103 : [<span class="org-string">"GR3"</span>, 2.0, 30, 8, [0.0046, 0.0184, 0.0000, 0.0689, 0.0000], [1500.0, 109.0, 30.0, 1300.0,    0.0]],
    104 : [<span class="org-string">"GR4"</span>, 2.0, 15, 8, [0.0115, 0.0000, 0.0000, 0.0872, 0.0000], [2000.0, 109.0, 30.0, 1800.0,    0.0]],
    105 : [<span class="org-string">"GR5"</span>, 1.5, 40, 8, [0.0184, 0.0000, 0.0000, 0.1148, 0.0000], [1800.0, 109.0, 30.0, 1600.0,    0.0]],
    106 : [<span class="org-string">"GR6"</span>, 1.5, 40, 9, [0.0046, 0.0000, 0.0000, 0.1561, 0.0000], [2200.0, 109.0, 30.0, 2000.0,    0.0]],
    107 : [<span class="org-string">"GR7"</span>, 3.0, 15, 8, [0.0459, 0.0000, 0.0000, 0.2479, 0.0000], [2000.0, 109.0, 30.0, 1800.0,    0.0]],
    108 : [<span class="org-string">"GR8"</span>, 4.0, 30, 8, [0.0230, 0.0459, 0.0000, 0.3352, 0.0000], [1500.0, 109.0, 30.0, 1300.0,    0.0]],
    109 : [<span class="org-string">"GR9"</span>, 5.0, 40, 8, [0.0459, 0.0459, 0.0000, 0.4132, 0.0000], [1800.0, 109.0, 30.0, 1600.0,    0.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Grass-Shrub (GS)</span>
    121 : [<span class="org-string">"GS1"</span>, 0.9, 15, 8, [0.0092, 0.0000, 0.0000, 0.0230, 0.0298], [2000.0, 109.0, 30.0, 1800.0, 1800.0]],
    122 : [<span class="org-string">"GS2"</span>, 1.5, 15, 8, [0.0230, 0.0230, 0.0000, 0.0275, 0.0459], [2000.0, 109.0, 30.0, 1800.0, 1800.0]],
    123 : [<span class="org-string">"GS3"</span>, 1.8, 40, 8, [0.0138, 0.0115, 0.0000, 0.0666, 0.0574], [1800.0, 109.0, 30.0, 1600.0, 1600.0]],
    124 : [<span class="org-string">"GS4"</span>, 2.1, 40, 8, [0.0872, 0.0138, 0.0046, 0.1561, 0.3260], [1800.0, 109.0, 30.0, 1600.0, 1600.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Shrub (SH)</span>
    141 : [<span class="org-string">"SH1"</span>, 1.0, 15, 8, [0.0115, 0.0115, 0.0000, 0.0069, 0.0597], [2000.0, 109.0, 30.0, 1800.0, 1600.0]],
    142 : [<span class="org-string">"SH2"</span>, 1.0, 15, 8, [0.0620, 0.1102, 0.0344, 0.0000, 0.1768], [2000.0, 109.0, 30.0,    0.0, 1600.0]],
    143 : [<span class="org-string">"SH3"</span>, 2.4, 40, 8, [0.0207, 0.1377, 0.0000, 0.0000, 0.2847], [1600.0, 109.0, 30.0,    0.0, 1400.0]],
    144 : [<span class="org-string">"SH4"</span>, 3.0, 30, 8, [0.0390, 0.0528, 0.0092, 0.0000, 0.1171], [2000.0, 109.0, 30.0, 1800.0, 1600.0]],
    145 : [<span class="org-string">"SH5"</span>, 6.0, 15, 8, [0.1653, 0.0964, 0.0000, 0.0000, 0.1331], [ 750.0, 109.0, 30.0,    0.0, 1600.0]],
    146 : [<span class="org-string">"SH6"</span>, 2.0, 30, 8, [0.1331, 0.0666, 0.0000, 0.0000, 0.0643], [ 750.0, 109.0, 30.0,    0.0, 1600.0]],
    147 : [<span class="org-string">"SH7"</span>, 6.0, 15, 8, [0.1607, 0.2433, 0.1010, 0.0000, 0.1561], [ 750.0, 109.0, 30.0,    0.0, 1600.0]],
    148 : [<span class="org-string">"SH8"</span>, 3.0, 40, 8, [0.0941, 0.1561, 0.0390, 0.0000, 0.1997], [ 750.0, 109.0, 30.0,    0.0, 1600.0]],
    149 : [<span class="org-string">"SH9"</span>, 4.4, 40, 8, [0.2066, 0.1125, 0.0000, 0.0712, 0.3214], [ 750.0, 109.0, 30.0, 1800.0, 1500.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Timber-Understory (TU)</span>
    161 : [<span class="org-string">"TU1"</span>, 0.6, 20, 8, [0.0092, 0.0413, 0.0689, 0.0092, 0.0413], [2000.0, 109.0, 30.0, 1800.0, 1600.0]],
    162 : [<span class="org-string">"TU2"</span>, 1.0, 30, 8, [0.0436, 0.0826, 0.0574, 0.0000, 0.0092], [2000.0, 109.0, 30.0,    0.0, 1600.0]],
    163 : [<span class="org-string">"TU3"</span>, 1.3, 30, 8, [0.0505, 0.0069, 0.0115, 0.0298, 0.0505], [1800.0, 109.0, 30.0, 1600.0, 1400.0]],
    164 : [<span class="org-string">"TU4"</span>, 0.5, 12, 8, [0.2066, 0.0000, 0.0000, 0.0000, 0.0918], [2300.0, 109.0, 30.0,    0.0, 2000.0]],
    165 : [<span class="org-string">"TU5"</span>, 1.0, 25, 8, [0.1837, 0.1837, 0.1377, 0.0000, 0.1377], [1500.0, 109.0, 30.0,    0.0,  750.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Timber Litter (TL)</span>
    181 : [<span class="org-string">"TL1"</span>, 0.2, 30, 8, [0.0459, 0.1010, 0.1653, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    182 : [<span class="org-string">"TL2"</span>, 0.2, 25, 8, [0.0643, 0.1056, 0.1010, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    183 : [<span class="org-string">"TL3"</span>, 0.3, 20, 8, [0.0230, 0.1010, 0.1286, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    184 : [<span class="org-string">"TL4"</span>, 0.4, 25, 8, [0.0230, 0.0689, 0.1928, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    185 : [<span class="org-string">"TL5"</span>, 0.6, 25, 8, [0.0528, 0.1148, 0.2020, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0, 1600.0]],
    186 : [<span class="org-string">"TL6"</span>, 0.3, 25, 8, [0.1102, 0.0551, 0.0551, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    187 : [<span class="org-string">"TL7"</span>, 0.4, 25, 8, [0.0138, 0.0643, 0.3719, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    188 : [<span class="org-string">"TL8"</span>, 0.3, 35, 8, [0.2663, 0.0643, 0.0505, 0.0000, 0.0000], [1800.0, 109.0, 30.0,    0.0,    0.0]],
    189 : [<span class="org-string">"TL9"</span>, 0.6, 35, 8, [0.3053, 0.1515, 0.1905, 0.0000, 0.0000], [1800.0, 109.0, 30.0,    0.0, 1600.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Slash-Blowdown (SB)</span>
    201 : [<span class="org-string">"SB1"</span>, 1.0, 25, 8, [0.0689, 0.1377, 0.5051, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    202 : [<span class="org-string">"SB2"</span>, 1.0, 25, 8, [0.2066, 0.1951, 0.1837, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    203 : [<span class="org-string">"SB3"</span>, 1.2, 25, 8, [0.2525, 0.1263, 0.1377, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    204 : [<span class="org-string">"SB4"</span>, 2.7, 25, 8, [0.2410, 0.1607, 0.2410, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
}
</pre>
</div>

<p>
Although this compact data structure contains all the properties that
vary by fuel model (i.e., \(\delta\), \(w_o\), \(\sigma\),
\(M_{x-\text{dead}}\), \(h\)), several of their values need to be
multiplied by a coefficient to make their units match those listed in
Table <a href="#tab:fuel-model-properties">1</a>. We also need to add in the missing
\(\rho_p\), \(S_T\), and \(S_e\) values, which are constant across all of
these fuel models, and to expand those properties whose values may
vary by size class into lists with the following encoding:
</p>

<pre class="example" id="fuel-model-categories-and-size-classes">
[dead_1hr dead_10hr dead_100hr dead_herbaceous live_herbaceous live_woody]
</pre>

<p>
As a performance optimization, we set the dead herbaceous values that
don't depend on fuel moisture for the dynamic Scott &amp; Burgan 40 fuel
models. Finally, we add two boolean properties (<code>dynamic</code> and
<code>burnable</code>) to each fuel model for reference in later calculations.
</p>

<div class="org-src-container">
<pre class="src src-python" id="expand-compact-fuel-model-table"><span class="org-keyword">def</span> <span class="org-function-name">expand_compact_fuel_model</span>(fuel_model_number):
    [<span class="org-variable-name">name</span>, <span class="org-variable-name">delta</span>, <span class="org-variable-name">M_x_dead</span>, <span class="org-variable-name">h</span>, <span class="org-variable-name">w_o</span>, <span class="org-variable-name">sigma</span>] <span class="org-operator">=</span> fuel_model_compact_table[fuel_model_number]
    [<span class="org-variable-name">w_o_dead_1hr</span>, <span class="org-variable-name">w_o_dead_10hr</span>, <span class="org-variable-name">w_o_dead_100hr</span>, <span class="org-variable-name">w_o_live_herbaceous</span>, <span class="org-variable-name">w_o_live_woody</span>] <span class="org-operator">=</span> w_o
    [<span class="org-variable-name">sigma_dead_1hr</span>, <span class="org-variable-name">sigma_dead_10hr</span>, <span class="org-variable-name">sigma_dead_100hr</span>, <span class="org-variable-name">sigma_live_herbaceous</span>, <span class="org-variable-name">sigma_live_woody</span>] <span class="org-operator">=</span> sigma
    <span class="org-variable-name">M_x_dead</span> <span class="org-operator">=</span> M_x_dead <span class="org-operator">*</span> 0.01
    <span class="org-variable-name">h</span>        <span class="org-operator">=</span> h <span class="org-operator">*</span> 1000.0
    <span class="org-comment-delimiter"># </span><span class="org-comment">Conditionally set dead_herbaceous values</span>
    <span class="org-variable-name">dynamic</span>               <span class="org-operator">=</span> fuel_model_number <span class="org-operator">&gt;</span> 100 <span class="org-keyword">and</span> w_o_live_herbaceous <span class="org-operator">&gt;</span> 0.0
    <span class="org-variable-name">M_x_dead_herbaceous</span>   <span class="org-operator">=</span> M_x_dead              <span class="org-keyword">if</span> dynamic <span class="org-keyword">else</span> 0.0
    <span class="org-variable-name">sigma_dead_herbaceous</span> <span class="org-operator">=</span> sigma_live_herbaceous <span class="org-keyword">if</span> dynamic <span class="org-keyword">else</span> 0.0
    <span class="org-keyword">return</span> {
        <span class="org-string">"name"</span>    : name,
        <span class="org-string">"number"</span>  : fuel_model_number,
        <span class="org-string">"delta"</span>   : delta,
        <span class="org-string">"M_x"</span>     : [M_x_dead, M_x_dead, M_x_dead, M_x_dead_herbaceous, 0.0, 0.0],
        <span class="org-string">"w_o"</span>     : [w_o_dead_1hr, w_o_dead_10hr, w_o_dead_100hr, 0.0, w_o_live_herbaceous, w_o_live_woody],
        <span class="org-string">"sigma"</span>   : [sigma_dead_1hr, sigma_dead_10hr, sigma_dead_100hr, sigma_dead_herbaceous, sigma_live_herbaceous, sigma_live_woody],
        <span class="org-string">"h"</span>       : 6 <span class="org-operator">*</span> [h],
        <span class="org-string">"rho_p"</span>   : 6 <span class="org-operator">*</span> [32.0],
        <span class="org-string">"S_T"</span>     : 6 <span class="org-operator">*</span> [0.0555],
        <span class="org-string">"S_e"</span>     : 6 <span class="org-operator">*</span> [0.01],
        <span class="org-string">"dynamic"</span> : dynamic,
        <span class="org-string">"burnable"</span>: <span class="org-keyword">not</span> (91 <span class="org-operator">&lt;=</span> fuel_model_number <span class="org-operator">&lt;=</span> 99),
    }


<span class="org-variable-name">fuel_model_table</span> <span class="org-operator">=</span> {k: expand_compact_fuel_model(k) <span class="org-keyword">for</span> k <span class="org-keyword">in</span> fuel_model_compact_table.keys()}
</pre>
</div>
</div>
</div>
<div id="outline-container-fuel-categories-and-size-classes" class="outline-4">
<h4 id="fuel-categories-and-size-classes"><span class="section-number-4">4.1.3.</span> Fuel Categories and Size Classes</h4>
<div class="outline-text-4" id="text-fuel-categories-and-size-classes">
<p>
Each fuel model applies to a collection of burnable material that may
be live or dead and whose constituent elements may vary in size
considerably.
</p>

<p>
The two terms <b>category</b> and <b>size class</b> are used to describe this
heterogeneity within each fuel model.
</p>

<p>
In Pyretechnics, when we refer to a fuel category, we mean one of
these two values:
</p>

<ul class="org-ul">
<li>Dead</li>
<li>Live</li>
</ul>

<p>
When we refer to a fuel size class, we mean one of these six values:
</p>

<ul class="org-ul">
<li>Dead 1 hour (&lt; 1/4" diameter)</li>
<li>Dead 10 hour (1/4"-1" diameter)</li>
<li>Dead 100 hour (1"-3" diameter)</li>
<li>Dead herbaceous (dynamic fuel models only)</li>
<li>Live herbaceous</li>
<li>Live woody</li>
</ul>

<p>
In order to more easily encode mathematical operations over these fuel
categories and size classes, we define a collection of utility
functions that will later be used in both the fuel moisture and
surface fire equations.
</p>

<div class="org-src-container">
<pre class="src src-python" id="fuel-category-and-size-class-functions"><span class="org-keyword">def</span> <span class="org-function-name">map_category</span>(f):
    <span class="org-keyword">return</span> [f(0), f(1)]


<span class="org-keyword">def</span> <span class="org-function-name">map_size_class</span>(f):
    <span class="org-keyword">return</span> [f(0), f(1), f(2), f(3), f(4), f(5)]


<span class="org-keyword">def</span> <span class="org-function-name">category_sum</span>(f):
    <span class="org-keyword">return</span> f(0) <span class="org-operator">+</span> f(1)


<span class="org-keyword">def</span> <span class="org-function-name">size_class_sum</span>(f):
    <span class="org-keyword">return</span> [f(0) <span class="org-operator">+</span> f(1) <span class="org-operator">+</span> f(2) <span class="org-operator">+</span> f(3), f(4) <span class="org-operator">+</span> f(5)]
</pre>
</div>
</div>
</div>
<div id="outline-container-dynamic-fuel-loading" class="outline-4">
<h4 id="dynamic-fuel-loading"><span class="section-number-4">4.1.4.</span> Dynamic Fuel Loading</h4>
<div class="outline-text-4" id="text-dynamic-fuel-loading">
<p>
All of the Scott &amp; Burgan 40 fuel models with a live herbaceous
component are considered dynamic. In these models, a fraction of the
live herbaceous load is transferred to a new dead herbaceous category
as a function of live herbaceous moisture content (see equation
below).<sup><a id="fnr.7" class="footref" href="#fn.7" role="doc-backlink">7</a></sup> The dead herbaceous size class uses the dead 1
hour moisture content, dead moisture of extinction, and live
herbaceous surface-area-to-volume-ratio. In the following formula,
\(M_f^{lh}\) is the live herbaceous moisture content.
</p>

\begin{align}
  \text{FractionGreen} &= \left\{
    \begin{array}{lr}
      0 & M_f^{lh} \le 0.3 \\
      1 & M_f^{lh} \ge 1.2 \\
      M_f^{lh} / 0.9 - 1/3 & \text{else}
    \end{array}
  \right. \\
  \nonumber \\
  \text{FractionCured} &= 1 - \text{FractionGreen}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="add-dynamic-fuel-loading"><span class="org-keyword">def</span> <span class="org-function-name">add_dynamic_fuel_loading</span>(fuel_model, M_f):
    <span class="org-keyword">if</span> fuel_model[<span class="org-string">"dynamic"</span>]:
        <span class="org-comment-delimiter"># </span><span class="org-comment">dynamic fuel model</span>
        <span class="org-variable-name">w_o</span>                       <span class="org-operator">=</span> fuel_model[<span class="org-string">"w_o"</span>]
        <span class="org-variable-name">live_herbaceous_load</span>      <span class="org-operator">=</span> w_o[4]
        <span class="org-variable-name">live_herbaceous_moisture</span>  <span class="org-operator">=</span> M_f[4]
        <span class="org-variable-name">fraction_green</span>            <span class="org-operator">=</span> <span class="org-builtin">max</span>(0.0, <span class="org-builtin">min</span>(1.0, (live_herbaceous_moisture <span class="org-operator">/</span> 0.9) <span class="org-operator">-</span> 0.3333333333333333))
        <span class="org-variable-name">fraction_cured</span>            <span class="org-operator">=</span> 1.0 <span class="org-operator">-</span> fraction_green
        <span class="org-variable-name">dynamic_fuel_model</span>        <span class="org-operator">=</span> fuel_model.copy() <span class="org-comment-delimiter"># </span><span class="org-comment">shallow copy</span>
        <span class="org-variable-name">dynamic_fuel_model</span>[<span class="org-string">"M_f"</span>] <span class="org-operator">=</span> [
            M_f[0],
            M_f[1],
            M_f[2],
            M_f[0], <span class="org-comment-delimiter"># </span><span class="org-comment">set dead_herbaceous to dead_1hr</span>
            M_f[4],
            M_f[5],
        ]
        <span class="org-variable-name">dynamic_fuel_model</span>[<span class="org-string">"w_o"</span>] <span class="org-operator">=</span> [
            w_o[0],
            w_o[1],
            w_o[2],
            live_herbaceous_load <span class="org-operator">*</span> fraction_cured, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_herbaceous</span>
            live_herbaceous_load <span class="org-operator">*</span> fraction_green, <span class="org-comment-delimiter"># </span><span class="org-comment">live_herbaceous</span>
            w_o[5],
        ]
        <span class="org-keyword">return</span> dynamic_fuel_model
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">static fuel model</span>
        <span class="org-variable-name">static_fuel_model</span> <span class="org-operator">=</span> fuel_model.copy() <span class="org-comment-delimiter"># </span><span class="org-comment">shallow copy</span>
        <span class="org-variable-name">static_fuel_model</span>[<span class="org-string">"M_f"</span>] <span class="org-operator">=</span> M_f
        <span class="org-keyword">return</span> static_fuel_model
</pre>
</div>
</div>
</div>
<div id="outline-container-size-class-weighting-factors" class="outline-4">
<h4 id="size-class-weighting-factors"><span class="section-number-4">4.1.5.</span> Size Class Weighting Factors</h4>
<div class="outline-text-4" id="text-size-class-weighting-factors">
<p>
Once the dynamic fuel loading is applied, we can compute the size
class weighting factors expressed in equations 53-57 in Rothermel
1972<sup><a id="fnr.8" class="footref" href="#fn.8" role="doc-backlink">8</a></sup>. For brevity, these formulas are elided from
this text.
</p>

<div class="org-src-container">
<pre class="src src-python" id="add-weighting-factors"><span class="org-keyword">def</span> <span class="org-function-name">add_weighting_factors</span>(fuel_model):
    <span class="org-variable-name">w_o</span>                         <span class="org-operator">=</span> fuel_model[<span class="org-string">"w_o"</span>]
    <span class="org-variable-name">sigma</span>                       <span class="org-operator">=</span> fuel_model[<span class="org-string">"sigma"</span>]
    <span class="org-variable-name">rho_p</span>                       <span class="org-operator">=</span> fuel_model[<span class="org-string">"rho_p"</span>]
    <span class="org-variable-name">A_ij</span>                        <span class="org-operator">=</span> map_size_class(<span class="org-keyword">lambda</span> i: (sigma[i] <span class="org-operator">*</span> w_o[i]) <span class="org-operator">/</span> rho_p[i])
    <span class="org-variable-name">A_i</span>                         <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: A_ij[i])
    <span class="org-variable-name">A_T</span>                         <span class="org-operator">=</span> category_sum(<span class="org-keyword">lambda</span> i: A_i[i])
    <span class="org-variable-name">f_ij</span>                        <span class="org-operator">=</span> map_size_class(<span class="org-keyword">lambda</span> i: (<span class="org-keyword">lambda</span> A: (A_ij[i] <span class="org-operator">/</span> A) <span class="org-keyword">if</span> A <span class="org-operator">&gt;</span> 0.0 <span class="org-keyword">else</span> 0.0)(A_i[i<span class="org-operator">//</span>4]))
    <span class="org-variable-name">f_i</span>                         <span class="org-operator">=</span> map_category(<span class="org-keyword">lambda</span> i: (A_i[i] <span class="org-operator">/</span> A_T) <span class="org-keyword">if</span> A_T <span class="org-operator">&gt;</span> 0.0 <span class="org-keyword">else</span> 0.0)
    <span class="org-variable-name">firemod_size_classes</span>        <span class="org-operator">=</span> map_size_class(<span class="org-keyword">lambda</span> i: (<span class="org-keyword">lambda</span> s:
                                                            1 <span class="org-keyword">if</span> (s <span class="org-operator">&gt;=</span> 1200.0)
                                                            <span class="org-keyword">else</span> 2 <span class="org-keyword">if</span> (s <span class="org-operator">&gt;=</span> 192.0)
                                                            <span class="org-keyword">else</span> 3 <span class="org-keyword">if</span> (s <span class="org-operator">&gt;=</span> 96.0)
                                                            <span class="org-keyword">else</span> 4 <span class="org-keyword">if</span> (s <span class="org-operator">&gt;=</span> 48.0)
                                                            <span class="org-keyword">else</span> 5 <span class="org-keyword">if</span> (s <span class="org-operator">&gt;=</span> 16.0)
                                                            <span class="org-keyword">else</span> 6
                                                            )(sigma[i]))
    <span class="org-variable-name">g_ij</span>                        <span class="org-operator">=</span> map_size_class(<span class="org-keyword">lambda</span> i: (<span class="org-keyword">lambda</span> c:
                                                            ((f_ij[0] <span class="org-keyword">if</span> (c <span class="org-operator">==</span> firemod_size_classes[0]) <span class="org-keyword">else</span> 0.0)
                                                             <span class="org-operator">+</span> (f_ij[1] <span class="org-keyword">if</span> (c <span class="org-operator">==</span> firemod_size_classes[1]) <span class="org-keyword">else</span> 0.0)
                                                             <span class="org-operator">+</span> (f_ij[2] <span class="org-keyword">if</span> (c <span class="org-operator">==</span> firemod_size_classes[2]) <span class="org-keyword">else</span> 0.0)
                                                             <span class="org-operator">+</span> (f_ij[3] <span class="org-keyword">if</span> (c <span class="org-operator">==</span> firemod_size_classes[3]) <span class="org-keyword">else</span> 0.0))
                                                            <span class="org-keyword">if</span> (i <span class="org-operator">&lt;</span> 4) <span class="org-keyword">else</span>
                                                            ((f_ij[4] <span class="org-keyword">if</span> (c <span class="org-operator">==</span> firemod_size_classes[4]) <span class="org-keyword">else</span> 0.0)
                                                             <span class="org-operator">+</span> (f_ij[5] <span class="org-keyword">if</span> (c <span class="org-operator">==</span> firemod_size_classes[5]) <span class="org-keyword">else</span> 0.0))
                                                            )(firemod_size_classes[i]))
    <span class="org-variable-name">weighted_fuel_model</span>         <span class="org-operator">=</span> fuel_model.copy() <span class="org-comment-delimiter"># </span><span class="org-comment">shallow copy</span>
    <span class="org-variable-name">weighted_fuel_model</span>[<span class="org-string">"f_ij"</span>] <span class="org-operator">=</span> f_ij
    <span class="org-variable-name">weighted_fuel_model</span>[<span class="org-string">"f_i"</span>]  <span class="org-operator">=</span> f_i
    <span class="org-variable-name">weighted_fuel_model</span>[<span class="org-string">"g_ij"</span>] <span class="org-operator">=</span> g_ij
    <span class="org-keyword">return</span> weighted_fuel_model
</pre>
</div>
</div>
</div>
<div id="outline-container-live-moisture-of-extinction" class="outline-4">
<h4 id="live-moisture-of-extinction"><span class="section-number-4">4.1.6.</span> Live Moisture of Extinction</h4>
<div class="outline-text-4" id="text-live-moisture-of-extinction">
<p>
The live moisture of extinction for each fuel model is determined from
the dead fuel moisture content, the dead moisture of extinction, and
the ratio of dead fuel loading to live fuel loading using Equation 88
from Rothermel 1972, adjusted according to Albini 1976 Appendix III to
match the behavior of Albini's original FIREMODS
library.<sup><a id="fnr.9" class="footref" href="#fn.9" role="doc-backlink">9</a></sup><sup>, </sup><sup><a id="fnr.10" class="footref" href="#fn.10" role="doc-backlink">10</a></sup> Whenever the fuel moisture
content becomes greater than or equal to the moisture of extinction, a
fire will no longer spread through that fuel. Here are the formulas
referenced above:
</p>

\begin{align}
  M_x^l &= \max(M_x^d, 2.9 \, W' \, (1 - M_f^d / M_x^d) - 0.226) \\
  \nonumber \\
  W' &= \frac{\sum_{c \in D}{w_o^c \> e^{-138/\sigma^c}}}{\sum_{c \in L}{w_o^c \> e^{-500/\sigma^c}}} \\
  \nonumber \\
  M_f^d &= \frac{\sum_{c \in D}{w_o^c \> M_f^c \> e^{-138/\sigma^c}}}{\sum_{c \in D}{w_o^c \> e^{-138/\sigma^c}}}
\end{align}

<p>
where \(M_{x}^{l}\) is the live moisture of extinction, \(M_{x}^{d}\) is
the dead moisture of extinction, \(D\) is the set of dead fuel size
classes (1hr, 10hr, 100hr, herbaceous), \(L\) is the set of live fuel
size classes (herbaceous, woody), \(w_{o}^{c}\) is the dry weight
loading of size class \(c\), \(\sigma^{c}\) is the surface area to volume
ratio of size class \(c\), and \(M_{f}^{c}\) is the moisture content of
size class \(c\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="add-live-moisture-of-extinction"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> exp

<span class="org-keyword">def</span> <span class="org-function-name">add_live_moisture_of_extinction</span>(fuel_model):
    <span class="org-doc">"""</span>
<span class="org-doc">    Equation 88 from Rothermel 1972 adjusted by Albini 1976 Appendix III.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">w_o</span>                       <span class="org-operator">=</span> fuel_model[<span class="org-string">"w_o"</span>]
    <span class="org-variable-name">sigma</span>                     <span class="org-operator">=</span> fuel_model[<span class="org-string">"sigma"</span>]
    <span class="org-variable-name">M_f</span>                       <span class="org-operator">=</span> fuel_model[<span class="org-string">"M_f"</span>]
    <span class="org-variable-name">M_x</span>                       <span class="org-operator">=</span> fuel_model[<span class="org-string">"M_x"</span>]
    <span class="org-variable-name">loading_factors</span>           <span class="org-operator">=</span> map_size_class(<span class="org-keyword">lambda</span> i:
                                               (<span class="org-keyword">lambda</span> sigma_ij, A:
                                                w_o[i] <span class="org-operator">*</span> exp(A <span class="org-operator">/</span> sigma_ij) <span class="org-keyword">if</span> (sigma_ij <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 0.0
                                                )(sigma[i], <span class="org-operator">-</span>138.0 <span class="org-keyword">if</span> (i <span class="org-operator">&lt;</span> 4) <span class="org-keyword">else</span> <span class="org-operator">-</span>500.0))
    [dead_loading_factor,
     live_loading_factor]     <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: loading_factors[i])
    [<span class="org-variable-name">dead_moisture_factor</span>, <span class="org-variable-name">_</span>] <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: M_f[i] <span class="org-operator">*</span> loading_factors[i])
    <span class="org-variable-name">dead_to_live_ratio</span>        <span class="org-operator">=</span> (dead_loading_factor <span class="org-operator">/</span> live_loading_factor) <span class="org-keyword">if</span> (live_loading_factor <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> <span class="org-constant">None</span>
    <span class="org-variable-name">dead_fuel_moisture</span>        <span class="org-operator">=</span> (dead_moisture_factor <span class="org-operator">/</span> dead_loading_factor) <span class="org-keyword">if</span> (dead_loading_factor <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 0.0
    <span class="org-variable-name">M_x_dead</span>                  <span class="org-operator">=</span> M_x[0]
    <span class="org-variable-name">M_x_live</span>                  <span class="org-operator">=</span> <span class="org-builtin">max</span>(M_x_dead,
                                    (2.9 <span class="org-operator">*</span> dead_to_live_ratio <span class="org-operator">*</span> (1.0 <span class="org-operator">-</span> (dead_fuel_moisture <span class="org-operator">/</span> M_x_dead))) <span class="org-operator">-</span> 0.226
                                    ) <span class="org-keyword">if</span> (live_loading_factor <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> M_x_dead
    <span class="org-variable-name">moisturized_fuel_model</span>    <span class="org-operator">=</span> fuel_model.copy() <span class="org-comment-delimiter"># </span><span class="org-comment">shallow copy</span>
    <span class="org-variable-name">moisturized_fuel_model</span>[<span class="org-string">"M_x"</span>] <span class="org-operator">=</span> [
        M_x[0],
        M_x[1],
        M_x[2],
        M_x[3],
        M_x_live,
        M_x_live,
    ]
    <span class="org-keyword">return</span> moisturized_fuel_model
</pre>
</div>
</div>
</div>
<div id="outline-container-applying-fuel-moisture-to-a-fuel-model" class="outline-4">
<h4 id="applying-fuel-moisture-to-a-fuel-model"><span class="section-number-4">4.1.7.</span> Applying Fuel Moisture to a Fuel Model</h4>
<div class="outline-text-4" id="text-applying-fuel-moisture-to-a-fuel-model">
<p>
The preceding sections augmented the baseline fuel models by adding
dynamic fuel loading (section <a href="#dynamic-fuel-loading">4.1.4</a>), size class
weighting factors (section <a href="#size-class-weighting-factors">4.1.5</a>), and live
moisture of extinction (section <a href="#live-moisture-of-extinction">4.1.6</a>). In
typical usage, we will want to carry out all three of these steps when
applying fuel moisture to a fuel model. To simplify this task,
Pyretechnics provides the <code>moisturize</code> utility function.
</p>

<div class="org-src-container">
<pre class="src src-python" id="moisturize"><span class="org-comment-delimiter"># </span><span class="org-comment">TODO: If these functions aren't called anywhere else, create a copy</span>
<span class="org-comment-delimiter">#       </span><span class="org-comment">of the fuel model here and mutate it in the called functions.</span>
<span class="org-keyword">def</span> <span class="org-function-name">moisturize</span>(fuel_model, fuel_moisture):
    <span class="org-variable-name">dynamic_fuel_model</span>     <span class="org-operator">=</span> add_dynamic_fuel_loading(fuel_model, fuel_moisture)
    <span class="org-variable-name">weighted_fuel_model</span>    <span class="org-operator">=</span> add_weighting_factors(dynamic_fuel_model)
    <span class="org-variable-name">moisturized_fuel_model</span> <span class="org-operator">=</span> add_live_moisture_of_extinction(weighted_fuel_model)
    <span class="org-keyword">return</span> moisturized_fuel_model
</pre>
</div>

<p>
This concludes our coverage of fuel models and fuel moisture.
</p>
</div>
</div>
</div>
<div id="outline-container-for-users-fuel" class="outline-3">
<h3 id="for-users-fuel"><span class="section-number-3">4.2.</span> For Users</h3>
<div class="outline-text-3" id="text-for-users-fuel">
<p>
In the following sections, we will demonstrate how to access fuel
model properties by fuel model number both alone and combined with
fuel moisture.
</p>
</div>
<div id="outline-container-how-to-look-up-a-fuel-model's-properties" class="outline-4">
<h4 id="how-to-look-up-a-fuel-model's-properties"><span class="section-number-4">4.2.1.</span> How to Look Up a Fuel Model's Properties</h4>
<div class="outline-text-4" id="text-how-to-look-up-a-fuel-model's-properties">
<div class="org-src-container">
<pre class="src src-python" id="look-up-fuel-model-properties"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">from</span> pyretechnics.fuel_models <span class="org-keyword">import</span> fuel_model_table

<span class="org-variable-name">static_fuel_model_number</span>  <span class="org-operator">=</span> 1   <span class="org-comment-delimiter"># </span><span class="org-comment">R01</span>
<span class="org-variable-name">dynamic_fuel_model_number</span> <span class="org-operator">=</span> 101 <span class="org-comment-delimiter"># </span><span class="org-comment">GR1</span>

<span class="org-variable-name">static_fuel_model</span>  <span class="org-operator">=</span> fuel_model_table.get(static_fuel_model_number)
<span class="org-variable-name">dynamic_fuel_model</span> <span class="org-operator">=</span> fuel_model_table.get(dynamic_fuel_model_number)

<span class="org-builtin">print</span>(<span class="org-string">"Static Fuel Model: R01"</span>)
pprint(static_fuel_model)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Dynamic Fuel Model: GR1"</span>)
pprint(dynamic_fuel_model)
</pre>
</div>

<pre class="example" id="look-up-fuel-model-properties-results">
Static Fuel Model: R01
{'M_x': [0.12, 0.12, 0.12, 0.0, 0.0, 0.0],
 'S_T': [0.0555, 0.0555, 0.0555, 0.0555, 0.0555, 0.0555],
 'S_e': [0.01, 0.01, 0.01, 0.01, 0.01, 0.01],
 'burnable': True,
 'delta': 1.0,
 'dynamic': False,
 'h': [8000.0, 8000.0, 8000.0, 8000.0, 8000.0, 8000.0],
 'name': 'R01',
 'number': 1,
 'rho_p': [32.0, 32.0, 32.0, 32.0, 32.0, 32.0],
 'sigma': [3500.0, 0.0, 0.0, 0.0, 0.0, 0.0],
 'w_o': [0.034, 0.0, 0.0, 0.0, 0.0, 0.0]}

Dynamic Fuel Model: GR1
{'M_x': [0.15, 0.15, 0.15, 0.15, 0.0, 0.0],
 'S_T': [0.0555, 0.0555, 0.0555, 0.0555, 0.0555, 0.0555],
 'S_e': [0.01, 0.01, 0.01, 0.01, 0.01, 0.01],
 'burnable': True,
 'delta': 0.4,
 'dynamic': True,
 'h': [8000.0, 8000.0, 8000.0, 8000.0, 8000.0, 8000.0],
 'name': 'GR1',
 'number': 101,
 'rho_p': [32.0, 32.0, 32.0, 32.0, 32.0, 32.0],
 'sigma': [2200.0, 109.0, 30.0, 2000.0, 2000.0, 0.0],
 'w_o': [0.0046, 0.0, 0.0, 0.0, 0.0138, 0.0]}
</pre>
</div>
</div>
<div id="outline-container-how-to-apply-fuel-moisture-to-a-fuel-model" class="outline-4">
<h4 id="how-to-apply-fuel-moisture-to-a-fuel-model"><span class="section-number-4">4.2.2.</span> How to Apply Fuel Moisture to a Fuel Model</h4>
<div class="outline-text-4" id="text-how-to-apply-fuel-moisture-to-a-fuel-model">
<div class="org-src-container">
<pre class="src src-python" id="moisturize-fuel-model"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">from</span> pyretechnics.fuel_models <span class="org-keyword">import</span> fuel_model_table, moisturize

<span class="org-variable-name">static_fuel_model_number</span>  <span class="org-operator">=</span> 1   <span class="org-comment-delimiter"># </span><span class="org-comment">R01</span>
<span class="org-variable-name">dynamic_fuel_model_number</span> <span class="org-operator">=</span> 101 <span class="org-comment-delimiter"># </span><span class="org-comment">GR1</span>

<span class="org-variable-name">static_fuel_model</span>  <span class="org-operator">=</span> fuel_model_table.get(static_fuel_model_number)
<span class="org-variable-name">dynamic_fuel_model</span> <span class="org-operator">=</span> fuel_model_table.get(dynamic_fuel_model_number)

<span class="org-variable-name">fuel_moisture</span> <span class="org-operator">=</span> [
    0.05, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_1hr</span>
    0.10, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_10hr</span>
    0.15, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_100hr</span>
    0.00, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_herbaceous (will be set by moisturize for dynamic fuel models)</span>
    0.30, <span class="org-comment-delimiter"># </span><span class="org-comment">live_herbaceous</span>
    0.50, <span class="org-comment-delimiter"># </span><span class="org-comment">live_woody</span>
]

<span class="org-builtin">print</span>(<span class="org-string">"Moisturized Static Fuel Model: R01"</span>)
pprint(moisturize(static_fuel_model, fuel_moisture))

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Moisturized Dynamic Fuel Model: GR1"</span>)
pprint(moisturize(dynamic_fuel_model, fuel_moisture))
</pre>
</div>

<pre class="example" id="moisturize-fuel-model-results">
Moisturized Static Fuel Model: R01
{'M_f': [0.05, 0.1, 0.15, 0.0, 0.3, 0.5],
 'M_x': [0.12, 0.12, 0.12, 0.0, 0.12, 0.12],
 'S_T': [0.0555, 0.0555, 0.0555, 0.0555, 0.0555, 0.0555],
 'S_e': [0.01, 0.01, 0.01, 0.01, 0.01, 0.01],
 'burnable': True,
 'delta': 1.0,
 'dynamic': False,
 'f_i': [1.0, 0.0],
 'f_ij': [1.0, 0.0, 0.0, 0.0, 0.0, 0.0],
 'g_ij': [1.0, 0.0, 0.0, 0.0, 0.0, 0.0],
 'h': [8000.0, 8000.0, 8000.0, 8000.0, 8000.0, 8000.0],
 'name': 'R01',
 'number': 1,
 'rho_p': [32.0, 32.0, 32.0, 32.0, 32.0, 32.0],
 'sigma': [3500.0, 0.0, 0.0, 0.0, 0.0, 0.0],
 'w_o': [0.034, 0.0, 0.0, 0.0, 0.0, 0.0]}

Moisturized Dynamic Fuel Model: GR1
{'M_f': [0.05, 0.1, 0.15, 0.05, 0.3, 0.5],
 'M_x': [0.15, 0.15, 0.15, 0.15, 0.15, 0.15],
 'S_T': [0.0555, 0.0555, 0.0555, 0.0555, 0.0555, 0.0555],
 'S_e': [0.01, 0.01, 0.01, 0.01, 0.01, 0.01],
 'burnable': True,
 'delta': 0.4,
 'dynamic': True,
 'f_i': [1.0, 0.0],
 'f_ij': [0.26829268292682923, 0.0, 0.0, 0.7317073170731707, 0.0, 0.0],
 'g_ij': [1.0, 0.0, 0.0, 1.0, 0.0, 0.0],
 'h': [8000.0, 8000.0, 8000.0, 8000.0, 8000.0, 8000.0],
 'name': 'GR1',
 'number': 101,
 'rho_p': [32.0, 32.0, 32.0, 32.0, 32.0, 32.0],
 'sigma': [2200.0, 109.0, 30.0, 2000.0, 2000.0, 0.0],
 'w_o': [0.0046, 0.0, 0.0, 0.0138, 0.0, 0.0]}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-surface-fire-equations-(pyretechnics.surface_fire)" class="outline-2">
<h2 id="surface-fire-equations-(pyretechnics.surface_fire)"><span class="section-number-2">5.</span> Surface Fire Equations (pyretechnics.surface_fire)</h2>
<div class="outline-text-2" id="text-surface-fire-equations-(pyretechnics.surface_fire)">
</div>
<div id="outline-container-for-developers-surface" class="outline-3">
<h3 id="for-developers-surface"><span class="section-number-3">5.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-for-developers-surface">
<p>
The following sections define functions that calculate the spread rate
and intensity of a fire burning through surface fuels. These functions
combine fuel models and fuel moisture values (as defined in section
<a href="#fuel-model-and-moisture-definitions-(pyretechnics.fuel_models)">4</a>) with
wind and topography inputs to determine the maximum spread rate and
direction of a surface fire as well as its fireline intensity and
flame length.
</p>
</div>
<div id="outline-container-rothermel's-surface-fire-rate-of-spread-equation" class="outline-4">
<h4 id="rothermel's-surface-fire-rate-of-spread-equation"><span class="section-number-4">5.1.1.</span> Rothermel's Surface Fire Rate of Spread Equation</h4>
<div class="outline-text-4" id="text-rothermel's-surface-fire-rate-of-spread-equation">
<p>
To simulate fire behavior in as similar a way as possible to the US
government-sponsored fire models (e.g., FARSITE, FlamMap, FPA,
BehavePlus), Pyretechnics adopts the surface fire spread and reaction
intensity formulas from Rothermel's 1972 publication "A Mathematical
Model for Predicting Fire Spread in Wildland Fuels", adjusted
according to Albini 1976 Appendix III to match the behavior of
Albini's original FIREMODS library.<sup><a id="fnr.11" class="footref" href="#fn.11" role="doc-backlink">11</a></sup><sup>, </sup><sup><a id="fnr.12" class="footref" href="#fn.12" role="doc-backlink">12</a></sup>
This should align with the updated description provided in Patricia
Andrews' 2018 publication "The Rothermel Surface Fire Spread Model and
Associated Developments: A Comprehensive
Explanation".<sup><a id="fnr.13" class="footref" href="#fn.13" role="doc-backlink">13</a></sup>
</p>

<p>
Very briefly, the surface rate of spread of a fire's leading edge \(R\)
is described by the following formula:
</p>

\begin{align}
  R = \frac{I_R \, \xi \, (1 + \phi_W + \phi_S)}{\rho_b \, \epsilon \, Q_{ig}}
\end{align}

<p>
where these terms have the meanings shown in Table
<a href="#tab:fire-spread-inputs">2</a>.
</p>

<table id="tab:fire-spread-inputs">
<caption class="t-above"><span class="table-number">Table 2:</span> Inputs to Rothermel's surface fire rate of spread equation</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Term</th>
<th scope="col" class="org-left">Description</th>
<th scope="col" class="org-left">Units</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">\(R\)</td>
<td class="org-left">surface fire spread rate</td>
<td class="org-left">\(\text{ft}/\min\)</td>
</tr>

<tr>
<td class="org-left">\(I_R\)</td>
<td class="org-left">reaction intensity</td>
<td class="org-left">\(\text{Btu}/\text{ft}^2/\min\)</td>
</tr>

<tr>
<td class="org-left">\(\xi\)</td>
<td class="org-left">propagating flux ratio</td>
<td class="org-left">\(\text{unitless}\)</td>
</tr>

<tr>
<td class="org-left">\(\phi_W\)</td>
<td class="org-left">wind factor</td>
<td class="org-left">\(\text{unitless}\)</td>
</tr>

<tr>
<td class="org-left">\(\phi_S\)</td>
<td class="org-left">slope factor</td>
<td class="org-left">\(\text{unitless}\)</td>
</tr>

<tr>
<td class="org-left">\(\rho_b\)</td>
<td class="org-left">oven-dry fuel bed bulk density</td>
<td class="org-left">\(\text{lb}/\text{ft}^3\)</td>
</tr>

<tr>
<td class="org-left">\(\epsilon\)</td>
<td class="org-left">effective heating number</td>
<td class="org-left">\(\text{unitless}\)</td>
</tr>

<tr>
<td class="org-left">\(Q_{ig}\)</td>
<td class="org-left">heat of preignition</td>
<td class="org-left">\(\text{Btu}/\text{lb}\)</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-surface-fire-spread-rate-functions-(no-wind-no-slope)" class="outline-4">
<h4 id="surface-fire-spread-rate-functions-(no-wind-no-slope)"><span class="section-number-4">5.1.2.</span> Surface Fire Spread Rate Functions (No Wind No Slope)</h4>
<div class="outline-text-4" id="text-surface-fire-spread-rate-functions-(no-wind-no-slope)">
<p>
In this section, Rothermel's surface fire spread rate equation will be
computed without introducing the effects of wind or slope (i.e.,
\(\phi_W = \phi_S = 0\)). In this case, the only necessary input is a
moisturized fuel model (as created in section <a href="#applying-fuel-moisture-to-a-fuel-model">4.1.7</a>). Thus, the functions below will focus on the
no-wind-no-slope term \(R_0\) defined as follows:
</p>

\begin{align}
  R_0 &= \frac{I_R \, \xi}{\rho_b \, \epsilon \, Q_{ig}} \\
  \nonumber \\
  R &= R_0 \, (1 + \phi_W + \phi_S)
\end{align}

<p>
Each term will be defined in its own section, and finally they will be
combined together in a single function that computes \(R_0\).
</p>
</div>
<ol class="org-ol">
<li><a id="module-imports"></a>Module Imports<br>
<div class="outline-text-5" id="text-module-imports">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-imports"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> exp
<span class="org-keyword">from</span> pyretechnics.fuel_models <span class="org-keyword">import</span> map_category, map_size_class, category_sum, size_class_sum
</pre>
</div>
</div>
</li>
<li><a id="common-intermediate-calculations:-$\sigma',-\beta,-\beta_{op}$"></a>Common Intermediate Calculations: \(\sigma', \beta, \beta_{op}\)<br>
<div class="outline-text-5" id="text-common-intermediate-calculations:-$\sigma',-\beta,-\beta_{op}$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-common-intermediate-calculations"><span class="org-keyword">def</span> <span class="org-function-name">calc_surface_area_to_volume_ratio</span>(f_i, f_ij, sigma):
    <span class="org-variable-name">sigma_prime_i</span> <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: f_ij[i] <span class="org-operator">*</span> sigma[i])
    <span class="org-keyword">return</span> category_sum(<span class="org-keyword">lambda</span> i: f_i[i] <span class="org-operator">*</span> sigma_prime_i[i])


<span class="org-keyword">def</span> <span class="org-function-name">calc_packing_ratio</span>(w_o, rho_p, delta):
    <span class="org-keyword">if</span> (delta <span class="org-operator">&gt;</span> 0.0):
        <span class="org-variable-name">beta_i</span> <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: w_o[i] <span class="org-operator">/</span> rho_p[i])
        <span class="org-keyword">return</span> category_sum(<span class="org-keyword">lambda</span> i: beta_i[i]) <span class="org-operator">/</span> delta
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> 0.0


<span class="org-keyword">def</span> <span class="org-function-name">calc_optimum_packing_ratio</span>(sigma_prime):
    <span class="org-keyword">return</span> (3.348 <span class="org-operator">/</span> sigma_prime <span class="org-operator">**</span> 0.8189) <span class="org-keyword">if</span> (sigma_prime <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 1.0
</pre>
</div>
</div>
</li>
<li><a id="reaction-intensity:-$i_r$"></a>Reaction Intensity: \(I_R\)<br>
<div class="outline-text-5" id="text-reaction-intensity:-$i_r$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-reaction-intensity"><span class="org-keyword">def</span> <span class="org-function-name">calc_mineral_damping_coefficients</span>(f_ij, S_e):
    <span class="org-variable-name">S_e_i</span> <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: f_ij[i] <span class="org-operator">*</span> S_e[i])
    <span class="org-keyword">return</span> map_category(<span class="org-keyword">lambda</span> i:
                        (<span class="org-keyword">lambda</span> S_e_i:
                         0.174 <span class="org-operator">/</span> (S_e_i <span class="org-operator">**</span> 0.19) <span class="org-keyword">if</span> (S_e_i <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 1.0
                         )(S_e_i[i]))


<span class="org-keyword">def</span> <span class="org-function-name">calc_moisture_damping_coefficients</span>(f_ij, M_f, M_x):
    <span class="org-variable-name">M_f_i</span> <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: f_ij[i] <span class="org-operator">*</span> M_f[i])
    <span class="org-variable-name">M_x_i</span> <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: f_ij[i] <span class="org-operator">*</span> M_x[i])
    <span class="org-keyword">return</span> map_category(<span class="org-keyword">lambda</span> i:
                        (<span class="org-keyword">lambda</span> M_f, M_x:
                         (<span class="org-keyword">lambda</span> r_M:
                          1.0 <span class="org-operator">-</span> 2.59 <span class="org-operator">*</span> r_M <span class="org-operator">+</span> 5.11 <span class="org-operator">*</span> r_M <span class="org-operator">**</span> 2.0 <span class="org-operator">-</span> 3.52 <span class="org-operator">*</span> r_M <span class="org-operator">**</span> 3.0
                          )(<span class="org-builtin">min</span>(1.0, M_f <span class="org-operator">/</span> M_x) <span class="org-keyword">if</span> (M_x <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 1.0)
                         )(M_f_i[i], M_x_i[i]))


<span class="org-keyword">def</span> <span class="org-function-name">calc_low_heat_content</span>(f_ij, h):
    <span class="org-keyword">return</span> size_class_sum(<span class="org-keyword">lambda</span> i: f_ij[i] <span class="org-operator">*</span> h[i])


<span class="org-keyword">def</span> <span class="org-function-name">calc_net_fuel_loading</span>(g_ij, w_o, S_T):
    <span class="org-keyword">return</span> size_class_sum(<span class="org-keyword">lambda</span> i:
                          (<span class="org-keyword">lambda</span> g_ij, w_o, S_T:
                           g_ij <span class="org-operator">*</span> w_o <span class="org-operator">*</span> (1.0 <span class="org-operator">-</span> S_T)
                           )(g_ij[i], w_o[i], S_T[i]))


<span class="org-keyword">def</span> <span class="org-function-name">calc_heat_per_unit_area</span>(eta_S_i, eta_M_i, h_i, W_n_i):
    <span class="org-keyword">return</span> category_sum(<span class="org-keyword">lambda</span> i: W_n_i[i] <span class="org-operator">*</span> h_i[i] <span class="org-operator">*</span> eta_M_i[i] <span class="org-operator">*</span> eta_S_i[i])


<span class="org-keyword">def</span> <span class="org-function-name">calc_optimum_reaction_velocity</span>(sigma_prime, beta, beta_op):
    <span class="org-comment-delimiter"># </span><span class="org-comment">Albini 1976 replaces 1 / (4.774 * (sigma_prime ** 0.1) - 7.27)</span>
    <span class="org-variable-name">A</span>               <span class="org-operator">=</span> (133.0 <span class="org-operator">/</span> sigma_prime <span class="org-operator">**</span> 0.7913) <span class="org-keyword">if</span> (sigma_prime <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 0.0
    <span class="org-variable-name">B</span>               <span class="org-operator">=</span> sigma_prime <span class="org-operator">**</span> 1.5
    <span class="org-variable-name">C</span>               <span class="org-operator">=</span> beta <span class="org-operator">/</span> beta_op
    <span class="org-comment-delimiter"># </span><span class="org-comment">Maximum reaction velocity (1/min)</span>
    <span class="org-variable-name">Gamma_prime_max</span> <span class="org-operator">=</span> B <span class="org-operator">/</span> (495.0 <span class="org-operator">+</span> 0.0594 <span class="org-operator">*</span> B)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Optimum reaction velocity (1/min)</span>
    <span class="org-keyword">return</span> Gamma_prime_max <span class="org-operator">*</span> (C <span class="org-operator">**</span> A) <span class="org-operator">*</span> exp(A <span class="org-operator">*</span> (1.0 <span class="org-operator">-</span> C))


<span class="org-keyword">def</span> <span class="org-function-name">calc_reaction_intensity</span>(moisturized_fuel_model, sigma_prime, beta, beta_op):
    <span class="org-variable-name">w_o</span>         <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"w_o"</span>]
    <span class="org-variable-name">h</span>           <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"h"</span>]
    <span class="org-variable-name">S_T</span>         <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"S_T"</span>]
    <span class="org-variable-name">S_e</span>         <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"S_e"</span>]
    <span class="org-variable-name">M_x</span>         <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"M_x"</span>]
    <span class="org-variable-name">M_f</span>         <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"M_f"</span>]
    <span class="org-variable-name">f_ij</span>        <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"f_ij"</span>]
    <span class="org-variable-name">g_ij</span>        <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"g_ij"</span>]
    <span class="org-variable-name">eta_S_i</span>     <span class="org-operator">=</span> calc_mineral_damping_coefficients(f_ij, S_e)
    <span class="org-variable-name">eta_M_i</span>     <span class="org-operator">=</span> calc_moisture_damping_coefficients(f_ij, M_f, M_x)
    <span class="org-variable-name">h_i</span>         <span class="org-operator">=</span> calc_low_heat_content(f_ij, h)                             <span class="org-comment-delimiter"># </span><span class="org-comment">(Btu/lb)</span>
    <span class="org-variable-name">W_n_i</span>       <span class="org-operator">=</span> calc_net_fuel_loading(g_ij, w_o, S_T)                      <span class="org-comment-delimiter"># </span><span class="org-comment">(lb/ft^2)</span>
    <span class="org-variable-name">Btus</span>        <span class="org-operator">=</span> calc_heat_per_unit_area(eta_S_i, eta_M_i, h_i, W_n_i)      <span class="org-comment-delimiter"># </span><span class="org-comment">(Btu/ft^2)</span>
    <span class="org-variable-name">Gamma_prime</span> <span class="org-operator">=</span> calc_optimum_reaction_velocity(sigma_prime, beta, beta_op) <span class="org-comment-delimiter"># </span><span class="org-comment">(1/min)</span>
    <span class="org-keyword">return</span> Btus <span class="org-operator">*</span> Gamma_prime                                                <span class="org-comment-delimiter"># </span><span class="org-comment">(Btu/ft^2/min)</span>
</pre>
</div>
</div>
</li>
<li><a id="propagating-flux-ratio:-$\xi$"></a>Propagating Flux Ratio: \(\xi\)<br>
<div class="outline-text-5" id="text-propagating-flux-ratio:-$\xi$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-propagating-flux-ratio"><span class="org-keyword">def</span> <span class="org-function-name">calc_propagating_flux_ratio</span>(sigma_prime, beta):
    <span class="org-keyword">return</span> exp((0.792 <span class="org-operator">+</span> 0.681 <span class="org-operator">*</span> (sigma_prime <span class="org-operator">**</span> 0.5)) <span class="org-operator">*</span> (beta <span class="org-operator">+</span> 0.1)) <span class="org-operator">/</span> (192.0 <span class="org-operator">+</span> 0.2595 <span class="org-operator">*</span> sigma_prime)
</pre>
</div>
</div>
</li>
<li><a id="heat-source-(no-wind-no-slope):-$i_r-\,-\xi$"></a>Heat Source (No Wind No Slope): \(I_R \, \xi\)<br>
<div class="outline-text-5" id="text-heat-source-(no-wind-no-slope):-$i_r-\,-\xi$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-heat-source-no-wind-no-slope"><span class="org-keyword">def</span> <span class="org-function-name">calc_heat_source</span>(I_R, xi):
    <span class="org-keyword">return</span> I_R <span class="org-operator">*</span> xi
</pre>
</div>
</div>
</li>
<li><a id="oven-dry-fuel-bed-bulk-density:-!$\rho_b$"></a>Oven-Dry Fuel Bed Bulk Density: \(\rho_b\)<br>
<div class="outline-text-5" id="text-oven-dry-fuel-bed-bulk-density:-!$\rho_b$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-oven-dry-fuel-bed-bulk-density"><span class="org-keyword">def</span> <span class="org-function-name">calc_ovendry_bulk_density</span>(w_o, delta):
    <span class="org-keyword">if</span> (delta <span class="org-operator">&gt;</span> 0.0):
        <span class="org-variable-name">rho_b_i</span> <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: w_o[i])
        <span class="org-keyword">return</span> category_sum(<span class="org-keyword">lambda</span> i: rho_b_i[i]) <span class="org-operator">/</span> delta
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> 0.0
</pre>
</div>
</div>
</li>
<li><a id="effective-heating-number-distribution:-!$\epsilon_{ij}$"></a>Effective Heating Number Distribution: \(\epsilon_{ij}\)<br>
<div class="outline-text-5" id="text-effective-heating-number-distribution:-!$\epsilon_{ij}$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-effective-heating-number-distribution"><span class="org-keyword">def</span> <span class="org-function-name">calc_effective_heating_number_distribution</span>(sigma):
    <span class="org-keyword">return</span> map_size_class(<span class="org-keyword">lambda</span> i:
                          (<span class="org-keyword">lambda</span> sigma:
                           exp(<span class="org-operator">-</span>138.0 <span class="org-operator">/</span> sigma) <span class="org-keyword">if</span> (sigma <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 0.0
                           )(sigma[i]))
</pre>
</div>
</div>
</li>
<li><a id="heat-of-preignition-distribution:-!$(q_{ig})_{ij}$"></a>Heat of Preignition Distribution: \((Q_{ig})_{ij}\)<br>
<div class="outline-text-5" id="text-heat-of-preignition-distribution:-!$(q_{ig})_{ij}$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-heat-of-preignition-distribution"><span class="org-keyword">def</span> <span class="org-function-name">calc_heat_of_preignition_distribution</span>(M_f):
    <span class="org-keyword">return</span> map_size_class(<span class="org-keyword">lambda</span> i: 250.0 <span class="org-operator">+</span> 1116.0 <span class="org-operator">*</span> M_f[i])
</pre>
</div>
</div>
</li>
<li><a id="heat-sink:-$\rho_b-\,-\epsilon-\,-q_{ig}$"></a>Heat Sink: \(\rho_b \, \epsilon \, Q_{ig}\)<br>
<div class="outline-text-5" id="text-heat-sink:-$\rho_b-\,-\epsilon-\,-q_{ig}$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-heat-sink"><span class="org-keyword">def</span> <span class="org-function-name">calc_heat_sink</span>(f_i, f_ij, rho_b, epsilon_ij, Q_ig_ij):
    <span class="org-variable-name">effective_heat_of_preignition_i</span> <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: f_ij[i] <span class="org-operator">*</span> epsilon_ij[i] <span class="org-operator">*</span> Q_ig_ij[i])
    <span class="org-variable-name">effective_heat_of_preignition</span>   <span class="org-operator">=</span> category_sum(<span class="org-keyword">lambda</span> i: f_i[i] <span class="org-operator">*</span> effective_heat_of_preignition_i[i])
    <span class="org-keyword">return</span> rho_b <span class="org-operator">*</span> effective_heat_of_preignition
</pre>
</div>
</div>
</li>
<li><a id="spread-rate-(no-wind-no-slope):-!$r_0$"></a>Spread Rate (No Wind No Slope): \(R_0\)<br>
<div class="outline-text-5" id="text-spread-rate-(no-wind-no-slope):-!$r_0$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-spread-rate-no-wind-no-slope"><span class="org-keyword">def</span> <span class="org-function-name">calc_spread_rate</span>(heat_source, heat_sink):
    <span class="org-keyword">return</span> heat_source <span class="org-operator">/</span> heat_sink <span class="org-keyword">if</span> (heat_sink <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 0.0
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-surface-fire-intensity-functions" class="outline-4">
<h4 id="surface-fire-intensity-functions"><span class="section-number-4">5.1.3.</span> Surface Fire Intensity Functions</h4>
<div class="outline-text-4" id="text-surface-fire-intensity-functions">
<p>
Using the surface fire spread rate and reaction intensity values, we
can now calculate several surface fire intensity metrics by applying
Anderson's residence time and flame depth formulas, Byram's fireline
intensity and flame length equations, and Andrews &amp; Rothermel's heat
per unit area
equation:<sup><a id="fnr.14" class="footref" href="#fn.14" role="doc-backlink">14</a></sup><sup>, </sup><sup><a id="fnr.15" class="footref" href="#fn.15" role="doc-backlink">15</a></sup><sup>, </sup><sup><a id="fnr.16" class="footref" href="#fn.16" role="doc-backlink">16</a></sup>
</p>

\begin{align}
  t_{\text{res}} &= \frac{384}{\sigma'} \\
  \nonumber \\
  D_A &= R_s \, t_{\text{res}} \\
  \nonumber \\
  I_s &= \frac{I_R \, D_A}{60} \\
  \nonumber \\
  L_s &= 0.45 (I_s)^{0.46} \\
  \nonumber \\
  H_s &= I_R \, t_{\text{res}} = 60 \frac{I_s}{R_s} \\
\end{align}

<p>
where \(\sigma'\) is the weighted sum by size class of the fuel model's
surface area to volume ratio in \(\text{ft}^2/\text{ft}^3\),
\(t_{\text{res}}\) is the residence time in \(\text{minutes}\), \(R_s\) is
the surface fire spread rate in \(\text{ft}/\min\), \(D_A\) is the flame
depth in \(\text{ft}\), \(I_R\) is the reaction intensity in
\(\text{Btu}/\text{ft}^2/\min\), \(I_s\) is the fireline intensity in
\(\text{Btu}/\text{ft}/\text{s}\), \(L_s\) is the flame length in
\(\text{ft}\), and \(H_s\) is the heat per unit area in
\(\text{Btu}/\text{ft}^2\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="surface-fire-intensity-functions"><span class="org-keyword">def</span> <span class="org-function-name">calc_residence_time</span>(sigma_prime):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the residence time (total burning time) of fuel (min) given:</span>
<span class="org-doc">    - sigma_prime :: ft^2/ft^3 (surface area to volume ratio)</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> 384.0 <span class="org-operator">/</span> sigma_prime <span class="org-keyword">if</span> (sigma_prime <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 0.0


<span class="org-keyword">def</span> <span class="org-function-name">calc_flame_depth</span>(spread_rate, residence_time):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the depth, or front-to-back distance, of the actively flaming zone</span>
<span class="org-doc">    of a free-spreading fire (ft) given:</span>
<span class="org-doc">    - spread_rate    :: ft/min (orthogonal to the fireline)</span>
<span class="org-doc">    - residence_time :: min</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> spread_rate <span class="org-operator">*</span> residence_time


<span class="org-keyword">def</span> <span class="org-function-name">calc_fireline_intensity</span>(reaction_intensity, flame_depth):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the rate of heat release per unit of fire edge (Btu/ft/s) given:</span>
<span class="org-doc">    - reaction_intensity :: Btu/ft^2/min</span>
<span class="org-doc">    - flame_depth        :: ft</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> (reaction_intensity <span class="org-operator">*</span> flame_depth) <span class="org-operator">/</span> 60.0


<span class="org-keyword">def</span> <span class="org-function-name">calc_flame_length</span>(fireline_intensity):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the average flame length (m) given:</span>
<span class="org-doc">    - fireline_intensity :: kW/m</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> 0.07747042253266703 <span class="org-operator">*</span> (fireline_intensity <span class="org-operator">**</span> 0.46)


<span class="org-keyword">def</span> <span class="org-function-name">calc_areal_heat_output</span>(spread_rate, fireline_intensity):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the heat per unit area (kJ/m^2) given:</span>
<span class="org-doc">    - spread_rate        :: m/min</span>
<span class="org-doc">    - fireline_intensity :: kW/m</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> 60.0 <span class="org-operator">*</span> fireline_intensity <span class="org-operator">/</span> spread_rate <span class="org-keyword">if</span> spread_rate <span class="org-operator">&gt;</span> 0.0 <span class="org-keyword">else</span> 0.0
</pre>
</div>

<p>
Because of the linear relationship between spread rate, flame depth,
and fireline intensity, once we have calculated the no wind, no slope
fireline intensity, we can simply multiply it by the same combined
wind and slope factor that is applied to the no wind, no slope spread
rate in order to derive the maximum fireline intensity.
</p>

<p>
Since flame length's relationship to fireline intensity is non-linear,
we will need to wait until after any transformations are applied to
fireline intensity before calculating the associated flame length.
</p>
</div>
</div>
<div id="outline-container-wind-and-slope-factor-functions" class="outline-4">
<h4 id="wind-and-slope-factor-functions"><span class="section-number-4">5.1.4.</span> Wind and Slope Factor Functions</h4>
<div class="outline-text-4" id="text-wind-and-slope-factor-functions">
<p>
In order to compute the maximum spread rate, direction, and intensity
of the surface fire front, we will need to incorporate the effects of
wind and slope on the fire. However, we can precompute several
intermediate values and functions needed for this step based solely on
the fuel bed characteristics already available to us with just a
moisturized fuel model (see section <a href="#applying-fuel-moisture-to-a-fuel-model">4.1.7</a>).
</p>
</div>
<ol class="org-ol">
<li><a id="max-effective-wind-speed:-!$u_{\text{eff}}^{\max}$"></a>Max Effective Wind Speed: \(U_{\text{eff}}^{\max}\)<br>
<div class="outline-text-5" id="text-max-effective-wind-speed:-!$u_{\text{eff}}^{\max}$">
<p>
The midflame wind speed that would be required to produce the combined
spread rate in a no-slope scenario is termed the effective windspeed
\(U_{\text{eff}}\). Following the recommendations given in Appendix III
of Albini 1976, these midflame wind speeds are all limited by the
reaction intensity \(I_R\) as follows:<sup><a id="fnr.17" class="footref" href="#fn.17" role="doc-backlink">17</a></sup>
</p>

\begin{align}
  U_{\text{eff}}^{\max} = 0.9 \, I_R
\end{align}

<p>
where \(I_R\) is the reaction intensity in \(\text{Btu}/\text{ft}^2/\min\)
and \(U_{\text{eff}}^{\max}\) is the maximum effective wind speed in
\(\text{ft}/\min\)
</p>

<div class="org-src-container">
<pre class="src src-python" id="surface-fire-max-effective-wind-speed"><span class="org-keyword">def</span> <span class="org-function-name">calc_max_effective_wind_speed</span>(reaction_intensity):
    <span class="org-keyword">return</span> 0.9 <span class="org-operator">*</span> reaction_intensity
</pre>
</div>
</div>
</li>
<li><a id="slope-factor-function:-$\tan(\theta_s)-\mapsto-\phi_s$"></a>Slope Factor Function: \(\tan(\theta_S) \mapsto \phi_S\)<br>
<div class="outline-text-5" id="text-slope-factor-function:-$\tan(\theta_s)-\mapsto-\phi_s$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-slope-factor-function"><span class="org-keyword">def</span> <span class="org-function-name">get_phi_S_fn</span>(beta):
    <span class="org-keyword">if</span> (beta <span class="org-operator">&gt;</span> 0.0):
        <span class="org-variable-name">G</span> <span class="org-operator">=</span> 5.275 <span class="org-operator">*</span> beta <span class="org-operator">**</span> <span class="org-operator">-</span>0.3
        <span class="org-keyword">return</span> <span class="org-keyword">lambda</span> slope: (slope <span class="org-operator">**</span> 2.0) <span class="org-operator">*</span> G
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> <span class="org-keyword">lambda</span> _: 0.0
</pre>
</div>
</div>
</li>
<li><a id="wind-factor-function:-$u_{\text{mid}}-\mapsto-\phi_w$"></a>Wind Factor Function: \(U_{\text{mid}} \mapsto \phi_W\)<br>
<div class="outline-text-5" id="text-wind-factor-function:-$u_{\text{mid}}-\mapsto-\phi_w$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-wind-factor-function"><span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv


<span class="org-keyword">def</span> <span class="org-function-name">get_phi_W_fn</span>(B, C, F):
    <span class="org-keyword">if</span> (F <span class="org-operator">&gt;</span> 0.0):
        <span class="org-variable-name">C_over_F</span> <span class="org-operator">=</span> C <span class="org-operator">/</span> F
        <span class="org-keyword">return</span> <span class="org-keyword">lambda</span> midflame_wind_speed: (conv.m_to_ft(midflame_wind_speed) <span class="org-operator">**</span> B) <span class="org-operator">*</span> C_over_F
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> <span class="org-keyword">lambda</span> _: 0.0
</pre>
</div>
</div>
</li>
<li><a id="wind-speed-function:-$\phi_w-\mapsto-u_{\text{mid}}$"></a>Wind Speed Function: \(\phi_W \mapsto U_{\text{mid}}\)<br>
<div class="outline-text-5" id="text-wind-speed-function:-$\phi_w-\mapsto-u_{\text{mid}}$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-wind-speed-function"><span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv


<span class="org-keyword">def</span> <span class="org-function-name">get_wind_speed_fn</span>(B, C, F):
    <span class="org-keyword">if</span> (B <span class="org-operator">&gt;</span> 0.0):
        <span class="org-variable-name">F_over_C</span>  <span class="org-operator">=</span> F <span class="org-operator">/</span> C
        <span class="org-variable-name">B_inverse</span> <span class="org-operator">=</span> 1.0 <span class="org-operator">/</span> B
        <span class="org-keyword">return</span> <span class="org-keyword">lambda</span> phi_W: conv.ft_to_m((phi_W <span class="org-operator">*</span> F_over_C) <span class="org-operator">**</span> B_inverse)
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> <span class="org-keyword">lambda</span> _: 0.0
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-surface-fire-behavior-functions-(no-wind-no-slope)" class="outline-4">
<h4 id="surface-fire-behavior-functions-(no-wind-no-slope)"><span class="section-number-4">5.1.5.</span> Surface Fire Behavior Functions (No Wind No Slope)</h4>
<div class="outline-text-4" id="text-surface-fire-behavior-functions-(no-wind-no-slope)">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-behavior-no-wind-no-slope"><span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv


<span class="org-keyword">def</span> <span class="org-function-name">calc_surface_fire_behavior_no_wind_no_slope</span>(moisturized_fuel_model, spread_rate_adjustment<span class="org-operator">=</span>1.0):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - moisturized_fuel_model :: dictionary of fuel model and fuel moisture properties</span>
<span class="org-doc">      - delta :: ft                                        (fuel depth)</span>
<span class="org-doc">      - w_o   :: lb/ft^2                                   (ovendry fuel loading)</span>
<span class="org-doc">      - rho_p :: lb/ft^3                                   (ovendry particle density)</span>
<span class="org-doc">      - sigma :: ft^2/ft^3                                 (fuel particle surface-area-to-volume ratio)</span>
<span class="org-doc">      - h     :: Btu/lb                                    (fuel particle low heat content)</span>
<span class="org-doc">      - S_T   :: lb minerals/lb ovendry weight             (fuel particle total mineral content)</span>
<span class="org-doc">      - S_e   :: lb silica-free minerals/lb ovendry weight (fuel particle effective mineral content)</span>
<span class="org-doc">      - M_x   :: lb moisture/lb ovendry weight             (fuel particle moisture of extinction)</span>
<span class="org-doc">      - M_f   :: lb moisture/lb ovendry weight             (fuel particle moisture content)</span>
<span class="org-doc">      - f_ij  :: %                                         (percent load per size class)</span>
<span class="org-doc">      - f_i   :: %                                         (percent load per category)</span>
<span class="org-doc">      - g_ij  :: %                                         (percent load per size class - Albini_1976_FIREMOD, page 20)</span>
<span class="org-doc">    - spread_rate_adjustment :: unitless float (1.0 for no adjustment)</span>

<span class="org-doc">    return a dictionary containing these keys:</span>
<span class="org-doc">    - base_spread_rate         :: m/min</span>
<span class="org-doc">    - base_fireline_intensity  :: kW/m</span>
<span class="org-doc">    - max_effective_wind_speed :: m/min</span>
<span class="org-doc">    - get_phi_S                :: lambda: slope (rise/run) =&gt; phi_S (unitless)</span>
<span class="org-doc">    - get_phi_W                :: lambda: midflame_wind_speed (m/min) =&gt; phi_W (unitless)</span>
<span class="org-doc">    - get_wind_speed           :: lambda: phi_W (unitless) =&gt; midflame_wind_speed (m/min)</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack fuel model values</span>
    <span class="org-variable-name">delta</span>          <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"delta"</span>]
    <span class="org-variable-name">w_o</span>            <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"w_o"</span>]
    <span class="org-variable-name">rho_p</span>          <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"rho_p"</span>]
    <span class="org-variable-name">sigma</span>          <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"sigma"</span>]
    <span class="org-variable-name">M_f</span>            <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"M_f"</span>]
    <span class="org-variable-name">f_ij</span>           <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"f_ij"</span>]
    <span class="org-variable-name">f_i</span>            <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"f_i"</span>]
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate base spread rate (no wind, no slope)</span>
    <span class="org-variable-name">sigma_prime</span>    <span class="org-operator">=</span> calc_surface_area_to_volume_ratio(f_i, f_ij, sigma)
    <span class="org-variable-name">beta</span>           <span class="org-operator">=</span> calc_packing_ratio(w_o, rho_p, delta)
    <span class="org-variable-name">beta_op</span>        <span class="org-operator">=</span> calc_optimum_packing_ratio(sigma_prime)
    <span class="org-variable-name">I_R</span>            <span class="org-operator">=</span> calc_reaction_intensity(moisturized_fuel_model, sigma_prime, beta, beta_op) <span class="org-comment-delimiter"># </span><span class="org-comment">Btu/ft^2/min</span>
    <span class="org-variable-name">xi</span>             <span class="org-operator">=</span> calc_propagating_flux_ratio(sigma_prime, beta)
    <span class="org-variable-name">heat_source</span>    <span class="org-operator">=</span> calc_heat_source(I_R, xi)                                  <span class="org-comment-delimiter"># </span><span class="org-comment">Btu/ft^2/min</span>
    <span class="org-variable-name">rho_b</span>          <span class="org-operator">=</span> calc_ovendry_bulk_density(w_o, delta)                      <span class="org-comment-delimiter"># </span><span class="org-comment">lb/ft^3</span>
    <span class="org-variable-name">epsilon_ij</span>     <span class="org-operator">=</span> calc_effective_heating_number_distribution(sigma)
    <span class="org-variable-name">Q_ig_ij</span>        <span class="org-operator">=</span> calc_heat_of_preignition_distribution(M_f)                 <span class="org-comment-delimiter"># </span><span class="org-comment">Btu/lb</span>
    <span class="org-variable-name">heat_sink</span>      <span class="org-operator">=</span> calc_heat_sink(f_i, f_ij, rho_b, epsilon_ij, Q_ig_ij)      <span class="org-comment-delimiter"># </span><span class="org-comment">Btu/ft^3</span>
    <span class="org-variable-name">R0</span>             <span class="org-operator">=</span> calc_spread_rate(heat_source, heat_sink)                   <span class="org-comment-delimiter"># </span><span class="org-comment">ft/min</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate base fireline intensity (no wind, no slope)</span>
    <span class="org-variable-name">t_res</span>          <span class="org-operator">=</span> calc_residence_time(sigma_prime)                           <span class="org-comment-delimiter"># </span><span class="org-comment">min</span>
    <span class="org-variable-name">D_A</span>            <span class="org-operator">=</span> calc_flame_depth(R0, t_res)                                <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
    <span class="org-variable-name">I_s</span>            <span class="org-operator">=</span> calc_fireline_intensity(I_R, D_A)                          <span class="org-comment-delimiter"># </span><span class="org-comment">Btu/ft/s</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Pre-compute values related to wind and slope</span>
    <span class="org-variable-name">U_eff_max</span>      <span class="org-operator">=</span> calc_max_effective_wind_speed(I_R)                         <span class="org-comment-delimiter"># </span><span class="org-comment">ft/min</span>
    <span class="org-variable-name">B</span>              <span class="org-operator">=</span> 0.02526 <span class="org-operator">*</span> (sigma_prime <span class="org-operator">**</span> 0.54)
    <span class="org-variable-name">C</span>              <span class="org-operator">=</span> 7.47 <span class="org-operator">*</span> exp(<span class="org-operator">-</span>0.133 <span class="org-operator">*</span> (sigma_prime <span class="org-operator">**</span> 0.55))
    <span class="org-variable-name">E</span>              <span class="org-operator">=</span> 0.715 <span class="org-operator">*</span> exp(<span class="org-operator">-</span>3.59 <span class="org-operator">*</span> (sigma_prime <span class="org-operator">/</span> 10000.0))
    <span class="org-variable-name">F</span>              <span class="org-operator">=</span> (beta <span class="org-operator">/</span> beta_op) <span class="org-operator">**</span> E
    <span class="org-variable-name">get_phi_S</span>      <span class="org-operator">=</span> get_phi_S_fn(beta)
    <span class="org-variable-name">get_phi_W</span>      <span class="org-operator">=</span> get_phi_W_fn(B, C, F)
    <span class="org-variable-name">get_wind_speed</span> <span class="org-operator">=</span> get_wind_speed_fn(B, C, F)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Return no-wind-no-slope surface fire behavior values</span>
    <span class="org-keyword">return</span> {
        <span class="org-string">"base_spread_rate"</span>        : conv.ft_to_m(R0 <span class="org-operator">*</span> spread_rate_adjustment),
        <span class="org-string">"base_fireline_intensity"</span> : conv.Btu_ft_s_to_kW_m(I_s <span class="org-operator">*</span> spread_rate_adjustment),
        <span class="org-string">"max_effective_wind_speed"</span>: conv.ft_to_m(U_eff_max),
        <span class="org-string">"get_phi_S"</span>               : get_phi_S,
        <span class="org-string">"get_phi_W"</span>               : get_phi_W,
        <span class="org-string">"get_wind_speed"</span>          : get_wind_speed,
    }
</pre>
</div>
</div>
</div>
<div id="outline-container-midflame-wind-speed" class="outline-4">
<h4 id="midflame-wind-speed"><span class="section-number-4">5.1.6.</span> Midflame Wind Speed</h4>
<div class="outline-text-4" id="text-midflame-wind-speed">
<p>
Rothermel's formulas all expect a measure of midflame wind speed
\(U_{\text{mid}}\). However, wind speed data is often collected at a
height 20 feet (or 10 meters) above either unsheltered ground or a
tree canopy layer if present. To convert this 20-ft wind speed
\(U_{20}\) to the required midflame wind speed value, Pyretechnics uses
the wind adjustment factor formula from Albini &amp; Baughman 1979,
parameterized as in BehavePlus, FARSITE, FlamMap, FSPro, and FPA
according to Andrews 2012<sup><a id="fnr.18" class="footref" href="#fn.18" role="doc-backlink">18</a></sup><sup>, </sup><sup><a id="fnr.19" class="footref" href="#fn.19" role="doc-backlink">19</a></sup>.
</p>

\begin{align}
  \text{WAF} &= \left\{
    \begin{array}{lr}
      1.83 \ln(\frac{20.0 + 0.36 \text{FBD}}{0.13 \text{FBD}})^{-1} & CC = 0 \\
      0.555 [\sqrt{\text{CH} (\text{CC}/3.0)} \ln(\frac{20 + 0.36 \text{CH}}{0.13 \text{CH}})]^{-1} & CC > 0
    \end{array}
  \right. \\
  \nonumber \\
  U_{\text{mid}} &= U_{20} \, \text{WAF}
\end{align}

<p>
where \(\text{WAF}\) is the unitless wind adjustment factor,
\(\text{FBD}\) is the fuel bed depth in \(\text{ft}\), \(\text{CH}\) is the
canopy height in \(\text{ft}\), and \(\text{CC}\) is the canopy cover
fraction \((0-1)\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="midflame-wind-speed"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> log, sqrt


<span class="org-keyword">def</span> <span class="org-function-name">calc_wind_adjustment_factor</span>(fuel_bed_depth, canopy_height, canopy_cover):
    <span class="org-doc">"""</span>
<span class="org-doc">    Return the wind adjustment factor (unitless) given these inputs:</span>
<span class="org-doc">    - fuel_bed_depth :: ft</span>
<span class="org-doc">    - canopy_height  :: ft</span>
<span class="org-doc">    - canopy_cover   :: 0-1</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">if</span> (canopy_cover <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">and</span> (canopy_height <span class="org-operator">&gt;</span> 0.0):
        <span class="org-comment-delimiter"># </span><span class="org-comment">sheltered: equation 2 based on CC and CH, CR=1 (Andrews 2012)</span>
        <span class="org-variable-name">A</span> <span class="org-operator">=</span> sqrt((canopy_cover <span class="org-operator">/</span> 3.0) <span class="org-operator">*</span> canopy_height)
        <span class="org-variable-name">B</span> <span class="org-operator">=</span> log((20.0 <span class="org-operator">+</span> 0.36 <span class="org-operator">*</span> canopy_height) <span class="org-operator">/</span> (0.13 <span class="org-operator">*</span> canopy_height))
        <span class="org-keyword">return</span> 0.555 <span class="org-operator">/</span> (A <span class="org-operator">*</span> B)
    <span class="org-keyword">elif</span> (fuel_bed_depth <span class="org-operator">&gt;</span> 0.0):
        <span class="org-comment-delimiter"># </span><span class="org-comment">unsheltered: equation 6 H_F = H (Andrews 2012)</span>
        <span class="org-variable-name">A</span> <span class="org-operator">=</span> log((20.0 <span class="org-operator">+</span> 0.36 <span class="org-operator">*</span> fuel_bed_depth) <span class="org-operator">/</span> (0.13 <span class="org-operator">*</span> fuel_bed_depth))
        <span class="org-keyword">return</span> 1.83 <span class="org-operator">/</span> A <span class="org-comment-delimiter"># </span><span class="org-comment">1.83 truncated from 1.8328795184533409</span>
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">non-burnable fuel model</span>
        <span class="org-keyword">return</span> 0.0


<span class="org-keyword">def</span> <span class="org-function-name">calc_midflame_wind_speed</span>(wind_speed_20ft, fuel_bed_depth, canopy_height, canopy_cover):
    <span class="org-doc">"""</span>
<span class="org-doc">    Return the midflame wind speed (S) given these inputs:</span>
<span class="org-doc">    - wind_speed_20ft :: S</span>
<span class="org-doc">    - fuel_bed_depth  :: ft</span>
<span class="org-doc">    - canopy_height   :: ft</span>
<span class="org-doc">    - canopy_cover    :: 0-1</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">wind_adj_factor</span> <span class="org-operator">=</span> calc_wind_adjustment_factor(fuel_bed_depth, canopy_height, canopy_cover)
    <span class="org-keyword">return</span> wind_speed_20ft <span class="org-operator">*</span> wind_adj_factor
</pre>
</div>
</div>
</div>
<div id="outline-container-combining-wind-and-slope-vectors" class="outline-4">
<h4 id="combining-wind-and-slope-vectors"><span class="section-number-4">5.1.7.</span> Combining Wind and Slope Vectors</h4>
<div class="outline-text-4" id="text-combining-wind-and-slope-vectors">
<p>
On flat terrain and in the absence of wind, an idealized surface fire
will spread outward in a circle through homogeneous fuels. On sloped
terrain, a fire will spread more quickly upslope than downslope, and
when wind is present, a fire will spread more quickly in the direction
that the wind is blowing rather than against it. In the presence of
both sloped terrain and wind, the two forces combine to create a new
maximum spread rate and direction for the fire. Together, wind and
slope effects elongate otherwise circular fire perimeters into
ellipses, with the fastest moving edge known as the head fire.
</p>

<p>
Since Rothermel's original equations for computing the head fire
spread rate assume that the wind direction and upslope direction are
aligned, the effects of cross-slope winds must be taken into effect.
To accomplish this, Pyretechnics implements the vector addition
procedure defined in Rothermel 1983 that combines the wind and slope
vectors to calculate the maximum fire spread direction and
magnitude.<sup><a id="fnr.20" class="footref" href="#fn.20" role="doc-backlink">20</a></sup>
</p>

<p>
In order to address potential errors related to projecting the
horizontal wind and slope azimuth vectors to and from the
slope-tangential plane, upon which the equations from Rothermel 1983
are defined, we incorporate the three-dimensional vector combination
procedure provided by Waeselynck 2024.<sup><a id="fnr.21" class="footref" href="#fn.21" role="doc-backlink">21</a></sup>
</p>

<div class="org-src-container">
<pre class="src src-python" id="surface-fire-combine-wind-and-slope-vectors"><span class="org-keyword">import</span> cython
<span class="org-keyword">if</span> cython.compiled:
    <span class="org-keyword">from</span> cython.cimports.pyretechnics.cy_types <span class="org-keyword">import</span> vec_xy, vec_xyz
    <span class="org-keyword">from</span> cython.cimports.pyretechnics.conversion <span class="org-keyword">import</span> azimuthal_to_cartesian
    <span class="org-keyword">from</span> cython.cimports.pyretechnics.vector_utils <span class="org-keyword">import</span> vector_magnitude_3d, as_unit_vector_3d, to_slope_plane
<span class="org-keyword">else</span>:
    <span class="org-keyword">from</span> pyretechnics.py_types <span class="org-keyword">import</span> vec_xy, vec_xyz
    <span class="org-keyword">from</span> pyretechnics.conversion <span class="org-keyword">import</span> azimuthal_to_cartesian
    <span class="org-keyword">from</span> pyretechnics.vector_utils <span class="org-keyword">import</span> vector_magnitude_3d, as_unit_vector_3d, to_slope_plane


<span class="org-keyword">import</span> cython <span class="org-keyword">as</span> cy


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">project_wind_and_slope_vectors_3d</span>(wind_speed: cy.<span class="org-builtin">float</span>, downwind_direction: cy.<span class="org-builtin">float</span>,
                                      slope: cy.<span class="org-builtin">float</span>, upslope_direction: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> <span class="org-builtin">dict</span>[<span class="org-builtin">str</span>,vec_xyz]:
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - wind_speed         :: S</span>
<span class="org-doc">    - downwind_direction :: degrees clockwise from North</span>
<span class="org-doc">    - slope              :: rise/run</span>
<span class="org-doc">    - upslope_direction  :: degrees clockwise from North</span>

<span class="org-doc">    return a dictionary containing these keys:</span>
<span class="org-doc">    - wind_vector_3d  :: (x: S, y: S, z: S)</span>
<span class="org-doc">    - slope_vector_3d :: (x, y, z)</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Convert wind and slope vectors from azimuthal to cartesian coordinates</span>
    <span class="org-variable-name">wind_vector_2d</span> : vec_xy <span class="org-operator">=</span> azimuthal_to_cartesian(wind_speed, downwind_direction)
    <span class="org-variable-name">slope_vector_2d</span>: vec_xy <span class="org-operator">=</span> azimuthal_to_cartesian(slope, upslope_direction)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Project wind and slope vectors onto the slope-tangential plane</span>
    <span class="org-variable-name">wind_vector_3d</span> : vec_xyz <span class="org-operator">=</span> to_slope_plane(wind_vector_2d, slope_vector_2d)
    <span class="org-variable-name">slope_vector_3d</span>: vec_xyz <span class="org-operator">=</span> to_slope_plane(slope_vector_2d, slope_vector_2d)
    <span class="org-keyword">return</span> {
        <span class="org-string">"wind_vector_3d"</span> : wind_vector_3d,
        <span class="org-string">"slope_vector_3d"</span>: slope_vector_3d,
    }


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">get_phi_E</span>(wind_vector_3d: vec_xyz, slope_vector_3d: vec_xyz, phi_W: cy.<span class="org-builtin">float</span>, phi_S: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> <span class="org-builtin">dict</span>:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Convert wind and slope vectors to unit vectors on the slope-tangential plane</span>
    <span class="org-variable-name">w_S</span>: vec_xyz <span class="org-operator">=</span> as_unit_vector_3d(wind_vector_3d)  <span class="org-keyword">if</span> phi_W <span class="org-operator">&gt;</span> 0.0 <span class="org-keyword">else</span> wind_vector_3d
    <span class="org-variable-name">u_S</span>: vec_xyz <span class="org-operator">=</span> as_unit_vector_3d(slope_vector_3d) <span class="org-keyword">if</span> phi_S <span class="org-operator">&gt;</span> 0.0 <span class="org-keyword">else</span> slope_vector_3d
    <span class="org-comment-delimiter"># </span><span class="org-comment">Create the 3D slope-tangential phi_W, phi_S, and phi_E vectors</span>
    <span class="org-variable-name">phi_E_3d</span>: vec_xyz <span class="org-operator">=</span> (
        phi_W <span class="org-operator">*</span> w_S[0] <span class="org-operator">+</span> phi_S <span class="org-operator">*</span> u_S[0],
        phi_W <span class="org-operator">*</span> w_S[1] <span class="org-operator">+</span> phi_S <span class="org-operator">*</span> u_S[1],
        phi_W <span class="org-operator">*</span> w_S[2] <span class="org-operator">+</span> phi_S <span class="org-operator">*</span> u_S[2],
    )
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate phi_E</span>
    <span class="org-variable-name">phi_E</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vector_magnitude_3d(phi_E_3d)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Determine max spread direction and return results</span>
    <span class="org-keyword">if</span> phi_E <span class="org-operator">&gt;</span> 0.0:
        <span class="org-keyword">return</span> {
            <span class="org-string">"phi_E"</span>               : phi_E,
            <span class="org-string">"max_spread_direction"</span>: as_unit_vector_3d(phi_E_3d),
        }
    <span class="org-keyword">elif</span> phi_S <span class="org-operator">&gt;</span> 0.0:
        <span class="org-keyword">return</span> {
            <span class="org-string">"phi_E"</span>               : phi_E,
            <span class="org-string">"max_spread_direction"</span>: u_S,
        }
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> {
            <span class="org-string">"phi_E"</span>               : phi_E,
            <span class="org-string">"max_spread_direction"</span>: (0.0,1.0,0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">default: North</span>
        }
</pre>
</div>
</div>
</div>
<div id="outline-container-surface-elliptical-eccentricity" class="outline-4">
<h4 id="surface-elliptical-eccentricity"><span class="section-number-4">5.1.8.</span> Surface Elliptical Eccentricity</h4>
<div class="outline-text-4" id="text-surface-elliptical-eccentricity">
<p>
The effective wind speed \(U_{\text{eff}}\) is the wind speed that would
be required to produce the same spread rate in flat terrain as that
given by the combination of wind and sloped terrain as described in
section <a href="#combining-wind-and-slope-vectors">5.1.7</a>.
</p>

<p>
In order to project the one-dimensional surface fire spread rate
values calculated in earlier sections onto a two-dimensional plane,
\(U_{\text{eff}}\) is used to compute the length to width ratio
\(\frac{L}{W}\) of an ellipse that approximates the surface fire front.
This length to width ratio is then converted into an eccentricity
measure \(E\) of the ellipse using equation 8 from Albini and Chase
1980.<sup><a id="fnr.22" class="footref" href="#fn.22" role="doc-backlink">22</a></sup>
</p>

\begin{align}
  E = \frac{\sqrt{(\frac{L}{W})^2 - 1}}{\frac{L}{W}}
\end{align}

<p>
Currently Pyretechnics supports two different methods for computing
the length to width ratio \(\frac{L}{W}\):
</p>

<ol class="org-ol">
<li>Using equation 9 from Rothermel 1991.<sup><a id="fnr.23" class="footref" href="#fn.23" role="doc-backlink">23</a></sup></li>
</ol>

\begin{align}
  \frac{L}{W} = 1 + 0.25 \, U_{\text{eff}}
\end{align}

<p>
where \(U_{\text{eff}}\) is the effective wind speed in \(\text{mph}\).
</p>

<ol class="org-ol">
<li>Using the formula implemented in the Missoula Fire Lab's <code>behave</code> C++ library<sup><a id="fnr.24" class="footref" href="#fn.24" role="doc-backlink">24</a></sup></li>
</ol>

\begin{align}
  \frac{L}{W} = \min(8.0, 0.936 e^{(0.1147 U_{\text{eff}})} + 0.461 e^{(-0.0692 U_{\text{eff}})} - 0.397)
\end{align}

<p>
where \(U_{\text{eff}}\) is the effective wind speed in \(\text{mph}\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="surface-fire-eccentricity"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> exp, sqrt
<span class="org-keyword">from</span> pyretechnics.conversion <span class="org-keyword">import</span> m_min_to_mph


<span class="org-keyword">def</span> <span class="org-function-name">surface_length_to_width_ratio</span>(effective_wind_speed, model<span class="org-operator">=</span><span class="org-string">"rothermel"</span>):
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the length_to_width_ratio of the surface fire front given:</span>
<span class="org-doc">    - effective_wind_speed :: m/min (aligned with the slope-tangential plane)</span>
<span class="org-doc">    - model                :: "rothermel" or "behave" (Optional)</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">effective_wind_speed_mph</span> <span class="org-operator">=</span> m_min_to_mph(effective_wind_speed)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Select formula by model</span>
    <span class="org-keyword">if</span> model <span class="org-operator">==</span> <span class="org-string">"rothermel"</span>:
        <span class="org-keyword">return</span> 1.0 <span class="org-operator">+</span> 0.25 <span class="org-operator">*</span> effective_wind_speed_mph

    <span class="org-keyword">elif</span> model <span class="org-operator">==</span> <span class="org-string">"behave"</span>:
        <span class="org-keyword">return</span> <span class="org-builtin">min</span>(8.0,
                   0.936 <span class="org-operator">*</span> exp(0.1147 <span class="org-operator">*</span> effective_wind_speed_mph)
                   <span class="org-operator">+</span>
                   0.461 <span class="org-operator">*</span> exp(<span class="org-operator">-</span>0.0692 <span class="org-operator">*</span> effective_wind_speed_mph)
                   <span class="org-operator">-</span>
                   0.397)

    <span class="org-keyword">else</span>:
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"Invalid input: model must be 'rothermel' or 'behave'."</span>)


<span class="org-keyword">def</span> <span class="org-function-name">surface_fire_eccentricity</span>(length_to_width_ratio):
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the eccentricity (E) of the surface fire front using eq. 8 from</span>
<span class="org-doc">    Albini and Chase 1980 given:</span>
<span class="org-doc">    - L/W :: (1: circular spread, &gt; 1: elliptical spread)</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> sqrt(length_to_width_ratio <span class="org-operator">**</span> 2.0 <span class="org-operator">-</span> 1.0) <span class="org-operator">/</span> length_to_width_ratio
</pre>
</div>
</div>
</div>
<div id="outline-container-surface-fire-behavior-in-the-direction-of-maximum-spread" class="outline-4">
<h4 id="surface-fire-behavior-in-the-direction-of-maximum-spread"><span class="section-number-4">5.1.9.</span> Surface Fire Behavior in the Direction of Maximum Spread</h4>
<div class="outline-text-4" id="text-surface-fire-behavior-in-the-direction-of-maximum-spread">
<p>
This section introduces a function that applies the effects of wind
and slope to the no-wind-no-slope surface fire behavior values
produced in section <a href="#surface-fire-behavior-functions-(no-wind-no-slope)">5.1.5</a>, in order to compute the maximum surface fire behavior values
associated with a head fire.
</p>

<p>
A noteworthy decision for users is whether or not to limit the
effective wind speed \(U_{\text{eff}}\) in these calculations.
</p>

<p>
Rothermel 1972 defines a maximum effective wind speed, above which the
predicted spread rate and intensity remains constant. However, a 2013
publication by Andrews et al recommends instead that this wind speed
limit not be imposed, in order to avoid possible spread rate
underprediction.<sup><a id="fnr.25" class="footref" href="#fn.25" role="doc-backlink">25</a></sup><sup>, </sup><sup><a id="fnr.26" class="footref" href="#fn.26" role="doc-backlink">26</a></sup>
</p>

<p>
In order to support both use cases, the
<code>calc_surface_fire_behavior_max</code> function includes an optional
<code>use_wind_limit</code> argument that can be used to toggle this limit on or
off.
</p>

<div class="org-src-container">
<pre class="src src-python" id="surface-fire-behavior-max"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pyretechnics.conversion <span class="org-keyword">import</span> opposite_direction
<span class="org-keyword">from</span> pyretechnics.vector_utils <span class="org-keyword">import</span> vector_magnitude_3d


<span class="org-keyword">def</span> <span class="org-function-name">maybe_limit_wind_speed</span>(use_wind_limit, max_wind_speed, get_phi_W, get_wind_speed, phi_E_magnitude):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - use_wind_limit  :: boolean</span>
<span class="org-doc">    - max_wind_speed  :: m/min</span>
<span class="org-doc">    - get_phi_W       :: lambda: midflame_wind_speed (m/min) =&gt; phi_W (unitless)</span>
<span class="org-doc">    - get_wind_speed  :: lambda: phi_W (unitless) =&gt; midflame_wind_speed (m/min)</span>
<span class="org-doc">    - phi_E_magnitude :: unitless</span>

<span class="org-doc">    return a tuple with these fields:</span>
<span class="org-doc">    - limited_wind_speed :: m/min</span>
<span class="org-doc">    - limited_phi_E      :: unitless</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">effective_wind_speed</span> <span class="org-operator">=</span> get_wind_speed(phi_E_magnitude)
    <span class="org-keyword">if</span> (use_wind_limit <span class="org-keyword">and</span> effective_wind_speed <span class="org-operator">&gt;</span> max_wind_speed):
        <span class="org-keyword">return</span> (
            max_wind_speed,
            get_phi_W(max_wind_speed),
        )
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> (
            effective_wind_speed,
            phi_E_magnitude,
        )


<span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: No longer takes ellipse_adjustment_factor parameter</span>
<span class="org-keyword">def</span> <span class="org-function-name">calc_surface_fire_behavior_max</span>(surface_fire_min, midflame_wind_speed, upwind_direction,
                                   slope, aspect, use_wind_limit<span class="org-operator">=</span><span class="org-constant">True</span>, surface_lw_ratio_model<span class="org-operator">=</span><span class="org-string">"rothermel"</span>):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - surface_fire_min            :: dictionary of no-wind-no-slope surface fire behavior values</span>
<span class="org-doc">      - base_spread_rate             :: m/min</span>
<span class="org-doc">      - base_fireline_intensity      :: kW/m</span>
<span class="org-doc">      - max_effective_wind_speed     :: m/min</span>
<span class="org-doc">      - get_phi_S                    :: lambda: slope (rise/run) =&gt; phi_S (unitless)</span>
<span class="org-doc">      - get_phi_W                    :: lambda: midflame_wind_speed (m/min) =&gt; phi_W (unitless)</span>
<span class="org-doc">      - get_wind_speed               :: lambda: phi_W (unitless) =&gt; midflame_wind_speed (m/min)</span>
<span class="org-doc">    - midflame_wind_speed         :: m/min</span>
<span class="org-doc">    - upwind_direction            :: degrees clockwise from North</span>
<span class="org-doc">    - slope                       :: rise/run</span>
<span class="org-doc">    - aspect                      :: degrees clockwise from North</span>
<span class="org-doc">    - use_wind_limit              :: boolean (Optional)</span>
<span class="org-doc">    - surface_lw_ratio_model      :: "rothermel" or "behave" (Optional)</span>

<span class="org-doc">    return a dictionary containing these keys:</span>
<span class="org-doc">    - max_spread_rate        :: m/min</span>
<span class="org-doc">    - max_spread_direction   :: (x, y, z) unit vector</span>
<span class="org-doc">    - max_fireline_intensity :: kW/m</span>
<span class="org-doc">    - max_flame_length       :: m</span>
<span class="org-doc">    - length_to_width_ratio  :: unitless (1: circular spread, &gt; 1: elliptical spread)</span>
<span class="org-doc">    - eccentricity           :: unitless (0: circular spread, &gt; 0: elliptical spread)</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack no-wind-no-slope surface fire behavior values</span>
    <span class="org-variable-name">spread_rate</span>        <span class="org-operator">=</span> surface_fire_min[<span class="org-string">"base_spread_rate"</span>]
    <span class="org-variable-name">fireline_intensity</span> <span class="org-operator">=</span> surface_fire_min[<span class="org-string">"base_fireline_intensity"</span>]
    <span class="org-variable-name">max_wind_speed</span>     <span class="org-operator">=</span> surface_fire_min[<span class="org-string">"max_effective_wind_speed"</span>]
    <span class="org-variable-name">get_phi_W</span>          <span class="org-operator">=</span> surface_fire_min[<span class="org-string">"get_phi_W"</span>]
    <span class="org-variable-name">get_phi_S</span>          <span class="org-operator">=</span> surface_fire_min[<span class="org-string">"get_phi_S"</span>]
    <span class="org-variable-name">get_wind_speed</span>     <span class="org-operator">=</span> surface_fire_min[<span class="org-string">"get_wind_speed"</span>]
    <span class="org-comment-delimiter"># </span><span class="org-comment">Reverse the provided wind and slope directions</span>
    <span class="org-variable-name">downwind_direction</span> <span class="org-operator">=</span> opposite_direction(upwind_direction)
    <span class="org-variable-name">upslope_direction</span>  <span class="org-operator">=</span> opposite_direction(aspect)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Project wind and slope vectors onto the slope-tangential plane</span>
    <span class="org-variable-name">vectors</span> <span class="org-operator">=</span> project_wind_and_slope_vectors_3d(midflame_wind_speed, downwind_direction, slope, upslope_direction)
    <span class="org-variable-name">wind_vector_3d</span>  <span class="org-operator">=</span> vectors[<span class="org-string">"wind_vector_3d"</span>]  <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
    <span class="org-variable-name">slope_vector_3d</span> <span class="org-operator">=</span> vectors[<span class="org-string">"slope_vector_3d"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate phi_W and phi_S</span>
    <span class="org-variable-name">phi_W</span> <span class="org-operator">=</span> get_phi_W(vector_magnitude_3d(wind_vector_3d)) <span class="org-comment-delimiter"># </span><span class="org-comment">|wind_vector_3d| = slope-aligned midflame wind speed</span>
    <span class="org-variable-name">phi_S</span> <span class="org-operator">=</span> get_phi_S(slope)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate phi_E and the max_spread_direction</span>
    <span class="org-variable-name">result</span>               <span class="org-operator">=</span> get_phi_E(wind_vector_3d, slope_vector_3d, phi_W, phi_S)
    <span class="org-variable-name">phi_E</span>                <span class="org-operator">=</span> result[<span class="org-string">"phi_E"</span>]
    <span class="org-variable-name">max_spread_direction</span> <span class="org-operator">=</span> result[<span class="org-string">"max_spread_direction"</span>]
    <span class="org-comment-delimiter"># </span><span class="org-comment">Limit effective wind speed to max wind speed if use_wind_limit == True</span>
    (<span class="org-variable-name">limited_wind_speed</span>, <span class="org-variable-name">limited_phi_E</span>) <span class="org-operator">=</span> maybe_limit_wind_speed(use_wind_limit, max_wind_speed,
                                                                 get_phi_W, get_wind_speed, phi_E)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate and return max surface fire behavior values</span>
    <span class="org-variable-name">max_spread_rate</span>        <span class="org-operator">=</span> spread_rate <span class="org-operator">*</span> (1.0 <span class="org-operator">+</span> limited_phi_E)
    <span class="org-variable-name">max_fireline_intensity</span> <span class="org-operator">=</span> fireline_intensity <span class="org-operator">*</span> (1.0 <span class="org-operator">+</span> limited_phi_E)
    <span class="org-variable-name">length_to_width_ratio</span>  <span class="org-operator">=</span> surface_length_to_width_ratio(limited_wind_speed, surface_lw_ratio_model)
    <span class="org-keyword">return</span> {
        <span class="org-string">"max_spread_rate"</span>       : max_spread_rate,
        <span class="org-string">"max_spread_direction"</span>  : np.asarray(max_spread_direction), <span class="org-comment-delimiter"># </span><span class="org-comment">unit vector</span>
        <span class="org-string">"max_fireline_intensity"</span>: max_fireline_intensity,
        <span class="org-string">"max_flame_length"</span>      : calc_flame_length(max_fireline_intensity),
        <span class="org-string">"length_to_width_ratio"</span> : length_to_width_ratio,
        <span class="org-string">"eccentricity"</span>          : surface_fire_eccentricity(length_to_width_ratio),
    }
</pre>
</div>
</div>
</div>
<div id="outline-container-surface-fire-behavior-in-any-direction" class="outline-4">
<h4 id="surface-fire-behavior-in-any-direction"><span class="section-number-4">5.1.10.</span> Surface Fire Behavior in Any Direction</h4>
<div class="outline-text-4" id="text-surface-fire-behavior-in-any-direction">
<p>
Once we have calculated the maximum surface fire behavior values
associated with a head fire, we can use the elliptical eccentricity
\(E\) to project the maximum spread rate \(R_s\) and maximum fireline
intensity \(I_s\) to any point along the fire front as follows:
</p>

\begin{align}
  \eta &= \frac{1-E}{1-E\cos\omega} \\
  \nonumber \\
  R_s(\omega) &= R_s \, \eta \\
  \nonumber \\
  I_s(\omega) &= I_s \, \eta
\end{align}

<p>
where \(\omega\) is the angular offset from the direction of maximum
fire spread and \(R_s(\omega)\) and \(I_s(\omega)\) are the spread rate
and fireline intensity in this direction respectively.
</p>

<p>
Since the surface fire ellipse is defined on the slope-tangential
plane, we must represent spread directions with three dimensional unit
vectors aligned with this plane rather than with angles. Fortunately,
we can use the relationship between the dot product of two vectors and
the cosine of the angle between them to rewrite the \(\eta\) function
above as follows:
</p>

\begin{align}
  \eta = \frac{1-E}{1-E(\vec{u_{\max}} \cdot \vec{u_{\omega}})}
\end{align}

<p>
where \(\vec{u_{\max}}\) is the slope-tangential unit vector in the
direction of maximum spread and \(\vec{u_{\omega}}\) is the
slope-tangential unit vector rotated \(\omega\) degrees clockwise along
this plane from \(\vec{u_{\max}}\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="surface-fire-behavior-in-direction"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np


<span class="org-keyword">def</span> <span class="org-function-name">calc_surface_fire_behavior_in_direction</span>(surface_fire_max, spread_direction):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - surface_fire_max     :: dictionary of max surface fire behavior values</span>
<span class="org-doc">      - max_spread_rate        :: m/min</span>
<span class="org-doc">      - max_spread_direction   :: (x, y, z) unit vector</span>
<span class="org-doc">      - max_fireline_intensity :: kW/m</span>
<span class="org-doc">      - max_flame_length       :: m</span>
<span class="org-doc">      - length_to_width_ratio  :: unitless (1: circular spread, &gt; 1: elliptical spread)</span>
<span class="org-doc">      - eccentricity           :: unitless (0: circular spread, &gt; 0: elliptical spread)</span>
<span class="org-doc">    - spread_direction     :: 3D unit vector on the slope-tangential plane</span>

<span class="org-doc">    return a dictionary containing these keys:</span>
<span class="org-doc">    - fire_type          :: "surface"</span>
<span class="org-doc">    - spread_rate        :: m/min</span>
<span class="org-doc">    - spread_direction   :: (x, y, z) unit vector</span>
<span class="org-doc">    - fireline_intensity :: kW/m</span>
<span class="org-doc">    - flame_length       :: m</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack max surface fire behavior values</span>
    <span class="org-variable-name">max_spread_rate</span>        <span class="org-operator">=</span> surface_fire_max[<span class="org-string">"max_spread_rate"</span>]
    <span class="org-variable-name">max_spread_direction</span>   <span class="org-operator">=</span> surface_fire_max[<span class="org-string">"max_spread_direction"</span>]
    <span class="org-variable-name">max_fireline_intensity</span> <span class="org-operator">=</span> surface_fire_max[<span class="org-string">"max_fireline_intensity"</span>]
    <span class="org-variable-name">eccentricity</span>           <span class="org-operator">=</span> surface_fire_max[<span class="org-string">"eccentricity"</span>]
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate cos(w), where w is the offset angle between these unit vectors on the slope-tangential plane</span>
    <span class="org-variable-name">cos_w</span> <span class="org-operator">=</span> np.dot(max_spread_direction, spread_direction)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate adjustment due to the offset angle from the max spread direction</span>
    <span class="org-variable-name">adjustment</span> <span class="org-operator">=</span> (1.0 <span class="org-operator">-</span> eccentricity) <span class="org-operator">/</span> (1.0 <span class="org-operator">-</span> eccentricity <span class="org-operator">*</span> cos_w)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Update surface fire behavior values by the adjustment value</span>
    <span class="org-variable-name">fireline_intensity</span> <span class="org-operator">=</span> max_fireline_intensity <span class="org-operator">*</span> adjustment
    <span class="org-keyword">return</span> {
        <span class="org-string">"fire_type"</span>         : <span class="org-string">"surface"</span>,
        <span class="org-string">"spread_rate"</span>       : max_spread_rate <span class="org-operator">*</span> adjustment,
        <span class="org-string">"spread_direction"</span>  : np.asarray(spread_direction),
        <span class="org-string">"fireline_intensity"</span>: fireline_intensity,
        <span class="org-string">"flame_length"</span>      : calc_flame_length(fireline_intensity),
    }
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-for-users-surface" class="outline-3">
<h3 id="for-users-surface"><span class="section-number-3">5.2.</span> For Users</h3>
<div class="outline-text-3" id="text-for-users-surface">
<p>
In the following sections, we will demonstrate how to calculate the
surface fire behavior values given a fuel model and measurements of
fuel moisture, wind speed, wind direction, slope, and aspect. This
will be done first for the no-wind-no-slope case, followed by the max
spread direction case, and finally in any direction on the sloped
surface using both offset angles from the heading fire direction and
3D vectors specifying absolute directions.
</p>

<p>
Because wind speed and direction will often be provided from
measurements taken 10m or 20ft above the canopy and may be given in
either cartesion <code>(x,y)</code> or azimuthal <code>(r,azimuth)</code> coordinates, we
also demonstrate how to convert from cartesian to azimuthal
coordinates, from 10m to 20ft wind speeds, and from 20ft to midflame
wind speeds, given a fuel model and measurements of canopy height and
canopy cover.
</p>

<p>
See Appendix <a href="#units-conversion-functions-(pyretechnics.conversion)">10.1</a> for
the full list of available units conversion functions.
</p>

<p>
See Appendix <a href="#vector-utility-functions-(pyretechnics.vector_utils)">10.2</a> for
the full list of available vector manipulation functions.
</p>
</div>
<div id="outline-container-how-to-calculate-the-no-wind-no-slope-surface-fire-behavior" class="outline-4">
<h4 id="how-to-calculate-the-no-wind-no-slope-surface-fire-behavior"><span class="section-number-4">5.2.1.</span> How to Calculate the No-Wind-No-Slope Surface Fire Behavior</h4>
<div class="outline-text-4" id="text-how-to-calculate-the-no-wind-no-slope-surface-fire-behavior">
<div class="org-src-container">
<pre class="src src-python" id="compute-surface-fire-behavior-min"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.fuel_models <span class="org-keyword">as</span> fm
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf

<span class="org-comment-delimiter"># </span><span class="org-comment">Set input parameters</span>
<span class="org-variable-name">fuel_model</span>    <span class="org-operator">=</span> fm.fuel_model_table[101] <span class="org-comment-delimiter"># </span><span class="org-comment">GR1</span>
<span class="org-variable-name">fuel_moisture</span> <span class="org-operator">=</span> [
    0.05, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_1hr</span>
    0.10, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_10hr</span>
    0.15, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_100hr</span>
    0.00, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_herbaceous (will be set by moisturize for dynamic fuel models)</span>
    0.90, <span class="org-comment-delimiter"># </span><span class="org-comment">live_herbaceous</span>
    0.60, <span class="org-comment-delimiter"># </span><span class="org-comment">live_woody</span>
]

<span class="org-comment-delimiter"># </span><span class="org-comment">Apply fuel moisture to fuel model</span>
<span class="org-variable-name">moisturized_fuel_model</span> <span class="org-operator">=</span> fm.moisturize(fuel_model, fuel_moisture)

<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate no-wind-no-slope surface fire behavior</span>
<span class="org-variable-name">surface_fire_min</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model)

<span class="org-comment-delimiter"># </span><span class="org-comment">View results</span>
<span class="org-builtin">print</span>(<span class="org-string">"No-Wind-No-Slope Surface Fire Behavior for Fuel Model GR1 with Fuel Moisture = "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(moisturized_fuel_model[<span class="org-string">"M_f"</span>]))
pprint({k: surface_fire_min[k] <span class="org-keyword">for</span> k <span class="org-keyword">in</span> [<span class="org-string">"base_spread_rate"</span>, <span class="org-string">"base_fireline_intensity"</span>, <span class="org-string">"max_effective_wind_speed"</span>]})
</pre>
</div>

<pre class="example">
No-Wind-No-Slope Surface Fire Behavior for Fuel Model GR1 with Fuel Moisture = [0.05, 0.1, 0.15, 0.05, 0.9, 0.6]
{'base_fireline_intensity': 1.7899978160858154,
 'base_spread_rate': 0.12637238204479218,
 'max_effective_wind_speed': 109.7729263305664}
</pre>
</div>
</div>
<div id="outline-container-how-to-translate-the-10m-wind-speed-vector-into-the-midflame-wind-speed-vector" class="outline-4">
<h4 id="how-to-translate-the-10m-wind-speed-vector-into-the-midflame-wind-speed-vector"><span class="section-number-4">5.2.2.</span> How to Translate the 10m Wind Speed Vector into the Midflame Wind Speed Vector</h4>
<div class="outline-text-4" id="text-how-to-translate-the-10m-wind-speed-vector-into-the-midflame-wind-speed-vector">
<div class="org-src-container">
<pre class="src src-python" id="translate-10m-wind-to-midflame-wind"><span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv
<span class="org-keyword">import</span> pyretechnics.fuel_models <span class="org-keyword">as</span> fm
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf

<span class="org-comment-delimiter"># </span><span class="org-comment">Set input parameters</span>
<span class="org-variable-name">fuel_model</span>       <span class="org-operator">=</span> fm.fuel_model_table[101] <span class="org-comment-delimiter"># </span><span class="org-comment">GR1</span>
<span class="org-variable-name">canopy_height</span>    <span class="org-operator">=</span> 20                       <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
<span class="org-variable-name">canopy_cover</span>     <span class="org-operator">=</span> 0.6                      <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
<span class="org-variable-name">wind_speed_10m</span>   <span class="org-operator">=</span> 20                       <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
<span class="org-variable-name">upwind_direction</span> <span class="org-operator">=</span> 45.0                     <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 10m wind speed to 20ft wind speed</span>
<span class="org-variable-name">wind_speed_20ft</span> <span class="org-operator">=</span> conv.wind_speed_10m_to_wind_speed_20ft(wind_speed_10m) <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 20ft wind speed to midflame wind speed in m/min</span>
<span class="org-variable-name">midflame_wind_speed</span> <span class="org-operator">=</span> sf.calc_midflame_wind_speed(conv.km_hr_to_m_min(wind_speed_20ft), <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
                                                  fuel_model[<span class="org-string">"delta"</span>],                  <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                  conv.m_to_ft(canopy_height),          <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                  canopy_cover)                         <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">View results</span>
<span class="org-builtin">print</span>(<span class="org-string">"Midflame Wind Speed and Direction for 10m Wind Speed = 20 km/hr, Upwind Direction = 45.0</span><span class="org-constant">\n</span><span class="org-string">"</span>
      <span class="org-operator">+</span> <span class="org-string">" with Fuel Model GR1, Canopy Height = 20m, and Canopy Cover = 60%</span><span class="org-constant">\n</span><span class="org-string">"</span>
      <span class="org-operator">+</span> <span class="org-string">"- Speed: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(midflame_wind_speed) <span class="org-operator">+</span> <span class="org-string">" (m/min)</span><span class="org-constant">\n</span><span class="org-string">"</span>
      <span class="org-operator">+</span> <span class="org-string">"- Downwind Direction: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(conv.opposite_direction(upwind_direction)) <span class="org-operator">+</span> <span class="org-string">" (degrees clockwise from North)"</span>)
</pre>
</div>

<pre class="example">
Midflame Wind Speed and Direction for 10m Wind Speed = 20 km/hr, Upwind Direction = 45.0
 with Fuel Model GR1, Canopy Height = 20m, and Canopy Cover = 60%
- Speed: 27.22428573967944 (m/min)
- Downwind Direction: 225.0 (degrees clockwise from North)
</pre>
</div>
</div>
<div id="outline-container-how-to-calculate-the-surface-fire-behavior-in-the-direction-of-maximum-spread" class="outline-4">
<h4 id="how-to-calculate-the-surface-fire-behavior-in-the-direction-of-maximum-spread"><span class="section-number-4">5.2.3.</span> How to Calculate the Surface Fire Behavior in the Direction of Maximum Spread</h4>
<div class="outline-text-4" id="text-how-to-calculate-the-surface-fire-behavior-in-the-direction-of-maximum-spread">
<div class="org-src-container">
<pre class="src src-python" id="compute-surface-fire-behavior-max"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.fuel_models <span class="org-keyword">as</span> fm
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf

<span class="org-comment-delimiter"># </span><span class="org-comment">Set input parameters</span>
<span class="org-variable-name">fuel_model</span>    <span class="org-operator">=</span> fm.fuel_model_table[101] <span class="org-comment-delimiter"># </span><span class="org-comment">GR1</span>
<span class="org-variable-name">fuel_moisture</span> <span class="org-operator">=</span> [
    0.05, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_1hr</span>
    0.10, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_10hr</span>
    0.15, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_100hr</span>
    0.00, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_herbaceous (will be set by moisturize for dynamic fuel models)</span>
    0.90, <span class="org-comment-delimiter"># </span><span class="org-comment">live_herbaceous</span>
    0.60, <span class="org-comment-delimiter"># </span><span class="org-comment">live_woody</span>
]
<span class="org-variable-name">midflame_wind_speed</span> <span class="org-operator">=</span> 500.0 <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
<span class="org-variable-name">upwind_direction</span>    <span class="org-operator">=</span> 215.0 <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
<span class="org-variable-name">slope</span>               <span class="org-operator">=</span> 0.2   <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
<span class="org-variable-name">aspect</span>              <span class="org-operator">=</span> 270.0 <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Apply fuel moisture to fuel model</span>
<span class="org-variable-name">moisturized_fuel_model</span> <span class="org-operator">=</span> fm.moisturize(fuel_model, fuel_moisture)

<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate no-wind-no-slope surface fire behavior</span>
<span class="org-variable-name">surface_fire_min</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model)

<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread with effective wind speed limit</span>
<span class="org-variable-name">surface_fire_max</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_max(surface_fire_min,
                                                     midflame_wind_speed,
                                                     upwind_direction,
                                                     slope,
                                                     aspect)

<span class="org-comment-delimiter"># </span><span class="org-comment">View results</span>
<span class="org-builtin">print</span>(<span class="org-string">"Surface Fire Behavior Max (Limited) for Fuel Model GR1 with Fuel Moisture = "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(moisturized_fuel_model[<span class="org-string">"M_f"</span>]))
pprint(surface_fire_max)

<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread without effective wind speed limit</span>
<span class="org-variable-name">surface_fire_max_unlimited</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_max(surface_fire_min,
                                                               midflame_wind_speed,
                                                               upwind_direction,
                                                               slope,
                                                               aspect,
                                                               use_wind_limit<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-comment-delimiter"># </span><span class="org-comment">View results</span>
<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Surface Fire Behavior Max (Unlimited) for Fuel Model GR1 with Fuel Moisture = "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(moisturized_fuel_model[<span class="org-string">"M_f"</span>]))
pprint(surface_fire_max_unlimited)
</pre>
</div>

<pre class="example" id="compute-surface-fire-behavior-max-results">
Surface Fire Behavior Max (Limited) for Fuel Model GR1 with Fuel Moisture = [0.05, 0.1, 0.15, 0.05, 0.9, 0.6]
{'eccentricity': 0.8693098689345452,
 'length_to_width_ratio': 2.02319598197937,
 'max_fireline_intensity': 32.52824021555232,
 'max_flame_length': 0.384393279547724,
 'max_spread_direction': array([0.57514209, 0.80992591, 0.11502841]),
 'max_spread_rate': 2.2964671592467902}

Surface Fire Behavior Max (Unlimited) for Fuel Model GR1 with Fuel Moisture = [0.05, 0.1, 0.15, 0.05, 0.9, 0.6]
{'eccentricity': 0.9845208635180694,
 'length_to_width_ratio': 5.705566883087158,
 'max_fireline_intensity': 330.52327700735987,
 'max_flame_length': 1.116783188433671,
 'max_spread_direction': array([0.57514209, 0.80992591, 0.11502841]),
 'max_spread_rate': 23.334673071281713}
</pre>
</div>
</div>
<div id="outline-container-how-to-calculate-the-surface-fire-behavior-in-any-direction" class="outline-4">
<h4 id="how-to-calculate-the-surface-fire-behavior-in-any-direction"><span class="section-number-4">5.2.4.</span> How to Calculate the Surface Fire Behavior in Any Direction</h4>
<div class="outline-text-4" id="text-how-to-calculate-the-surface-fire-behavior-in-any-direction">
<div class="org-src-container">
<pre class="src src-python" id="compute-surface-fire-behavior-in-direction"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.fuel_models <span class="org-keyword">as</span> fm
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf
<span class="org-keyword">import</span> pyretechnics.vector_utils <span class="org-keyword">as</span> vu

<span class="org-comment-delimiter"># </span><span class="org-comment">Set input parameters</span>
<span class="org-variable-name">fuel_model</span>    <span class="org-operator">=</span> fm.fuel_model_table[101] <span class="org-comment-delimiter"># </span><span class="org-comment">GR1</span>
<span class="org-variable-name">fuel_moisture</span> <span class="org-operator">=</span> [
    0.05, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_1hr</span>
    0.10, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_10hr</span>
    0.15, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_100hr</span>
    0.00, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_herbaceous (will be set by moisturize for dynamic fuel models)</span>
    0.90, <span class="org-comment-delimiter"># </span><span class="org-comment">live_herbaceous</span>
    0.60, <span class="org-comment-delimiter"># </span><span class="org-comment">live_woody</span>
]
<span class="org-variable-name">midflame_wind_speed</span> <span class="org-operator">=</span> 500.0 <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
<span class="org-variable-name">upwind_direction</span>    <span class="org-operator">=</span> 215.0 <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
<span class="org-variable-name">slope</span>               <span class="org-operator">=</span> 0.2   <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
<span class="org-variable-name">aspect</span>              <span class="org-operator">=</span> 270.0 <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Apply fuel moisture to fuel model</span>
<span class="org-variable-name">moisturized_fuel_model</span> <span class="org-operator">=</span> fm.moisturize(fuel_model, fuel_moisture)

<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate no-wind-no-slope surface fire behavior</span>
<span class="org-variable-name">surface_fire_min</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model)

<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread with effective wind speed limit</span>
<span class="org-variable-name">surface_fire_max</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_max(surface_fire_min,
                                                     midflame_wind_speed,
                                                     upwind_direction,
                                                     slope,
                                                     aspect)

<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior for the heading, flanking, and backing fires</span>
<span class="org-variable-name">heading_fire_direction</span>  <span class="org-operator">=</span> surface_fire_max[<span class="org-string">"max_spread_direction"</span>]
<span class="org-variable-name">flanking_fire_direction</span> <span class="org-operator">=</span> vu.rotate_on_sloped_plane(heading_fire_direction, 90.0, slope, aspect)
<span class="org-variable-name">backing_fire_direction</span>  <span class="org-operator">=</span> <span class="org-operator">-</span>heading_fire_direction

<span class="org-variable-name">heading_fire_behavior</span>  <span class="org-operator">=</span> sf.calc_surface_fire_behavior_in_direction(surface_fire_max, heading_fire_direction)
<span class="org-variable-name">flanking_fire_behavior</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_in_direction(surface_fire_max, flanking_fire_direction)
<span class="org-variable-name">backing_fire_behavior</span>  <span class="org-operator">=</span> sf.calc_surface_fire_behavior_in_direction(surface_fire_max, backing_fire_direction)

<span class="org-comment-delimiter"># </span><span class="org-comment">View heading fire results</span>
<span class="org-builtin">print</span>(<span class="org-string">"Heading Fire Behavior for Fuel Model GR1 with Fuel Moisture = "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(moisturized_fuel_model[<span class="org-string">"M_f"</span>]))
pprint(heading_fire_behavior)

<span class="org-comment-delimiter"># </span><span class="org-comment">View flanking fire results</span>
<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Flanking Fire Behavior for Fuel Model GR1 with Fuel Moisture = "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(moisturized_fuel_model[<span class="org-string">"M_f"</span>]))
pprint(flanking_fire_behavior)

<span class="org-comment-delimiter"># </span><span class="org-comment">View backing fire results</span>
<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Backing Fire Behavior for Fuel Model GR1 with Fuel Moisture = "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(moisturized_fuel_model[<span class="org-string">"M_f"</span>]))
pprint(backing_fire_behavior)
</pre>
</div>

<pre class="example" id="compute-surface-fire-behavior-in-direction-results">
Heading Fire Behavior for Fuel Model GR1 with Fuel Moisture = [0.05, 0.1, 0.15, 0.05, 0.9, 0.6]
{'fire_type': 'surface',
 'fireline_intensity': 32.52822719177826,
 'flame_length': 0.38439320875152366,
 'spread_direction': array([0.57514209, 0.80992591, 0.11502841]),
 'spread_rate': 2.2964662397789914}

Flanking Fire Behavior for Fuel Model GR1 with Fuel Moisture = [0.05, 0.1, 0.15, 0.05, 0.9, 0.6]
{'fire_type': 'surface',
 'fireline_intensity': 4.251119815561932,
 'flame_length': 0.15074657845399453,
 'spread_direction': array([ 0.79419768, -0.58653219,  0.15883955]),
 'spread_rate': 0.3001255826250815}

Backing Fire Behavior for Fuel Model GR1 with Fuel Moisture = [0.05, 0.1, 0.15, 0.05, 0.9, 0.6]
{'fire_type': 'surface',
 'fireline_intensity': 2.2741655445924582,
 'flame_length': 0.11305091436966075,
 'spread_direction': array([-0.57514209, -0.80992591, -0.11502841]),
 'spread_rate': 0.16055422774915998}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-crown-fire-equations-(pyretechnics.crown_fire)" class="outline-2">
<h2 id="crown-fire-equations-(pyretechnics.crown_fire)"><span class="section-number-2">6.</span> Crown Fire Equations (pyretechnics.crown_fire)</h2>
<div class="outline-text-2" id="text-crown-fire-equations-(pyretechnics.crown_fire)">
</div>
<div id="outline-container-for-developers-crown" class="outline-3">
<h3 id="for-developers-crown"><span class="section-number-3">6.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-for-developers-crown">
<p>
The following sections define functions that calculate the spread rate
and intensity of a fire burning through tree canopy fuels. These
functions combine the surface fire behavior values calculated in
section <a href="#surface-fire-equations-(pyretechnics.surface_fire)">5</a> with
measurements of foliar moisture, dead 1 hour fuel moisture, canopy
cover, canopy height, canopy base height, and canopy bulk density to
determine whether a surface fire will spread into either a passive or
active crown fire. If so, they can then calculate the maximum spread
rate and direction of this crown fire as well as its fireline
intensity and flame length.
</p>
</div>
<div id="outline-container-crown-fire-initiation" class="outline-4">
<h4 id="crown-fire-initiation"><span class="section-number-4">6.1.1.</span> Crown Fire Initiation</h4>
<div class="outline-text-4" id="text-crown-fire-initiation">
<p>
In order to incorporate the effects of crown fire behavior,
Pyretechnics includes the crown fire initiation routine from Van
Wagner 1977.<sup><a id="fnr.27" class="footref" href="#fn.27" role="doc-backlink">27</a></sup> According to this approach, we begin
by calculating the <i>critical fireline intensity</i> as follows:
</p>

\begin{align}
  H &= 460 + 2600 M^f \\
  \nonumber \\
  I_s^* &= (0.01 \, Z_b \, H)^{1.5}
\end{align}

<p>
where \(H\) is the heat of ignition for the herbaceous material in the
canopy in \(\text{kJ/kg}\), \(M^f\) is the foliar moisture content in
\(\text{kg moisture/kg ovendry weight}\), \(Z_b\) is the canopy base
height in meters, and \(I_s^*\) is the critical fireline intensity in
\(\text{kW/m}\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="van-wagner-critical-fireline-intensity"><span class="org-keyword">def</span> <span class="org-function-name">van_wagner_critical_fireline_intensity</span>(canopy_base_height, foliar_moisture):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the critical fireline intensity (kW/m) given:</span>
<span class="org-doc">    - canopy_base_height :: m</span>
<span class="org-doc">    - foliar_moisture    :: kg moisture/kg ovendry weight</span>

<span class="org-doc">    Constants used:</span>
<span class="org-doc">    460.0 = heat-of-ignition :: kJ/kg</span>
<span class="org-doc">    0.01 = empirical estimate for C in Van Wagner 1977 (eq. 4)</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">H</span> <span class="org-operator">=</span> 460.0 <span class="org-operator">+</span> 2600.0 <span class="org-operator">*</span> foliar_moisture
    <span class="org-keyword">return</span> (0.01 <span class="org-operator">*</span> canopy_base_height <span class="org-operator">*</span> H) <span class="org-operator">**</span> 1.5
</pre>
</div>

<p>
If a surface fire is present, the canopy cover is greater than 40%,
and the surface fireline intensity \(I_s\) is greater than or equal to
the critical fireline intensity \(I_s^*\), then the surface fire
transitions to a crown fire.
</p>

<div class="org-src-container">
<pre class="src src-python" id="van-wagner-crown-fire-initiation"><span class="org-keyword">def</span> <span class="org-function-name">van_wagner_crown_fire_initiation</span>(surface_fireline_intensity, canopy_cover, canopy_base_height, foliar_moisture):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns True if the surface fire transitions to a crown fire or False otherwise given:</span>
<span class="org-doc">    - surface_fireline_intensity :: kW/m</span>
<span class="org-doc">    - canopy_cover               :: 0-1</span>
<span class="org-doc">    - canopy_base_height         :: m</span>
<span class="org-doc">    - foliar_moisture            :: kg moisture/kg ovendry weight</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> (
        surface_fireline_intensity <span class="org-operator">&gt;</span> 0.0
        <span class="org-keyword">and</span>
        canopy_cover <span class="org-operator">&gt;</span> 0.4
        <span class="org-keyword">and</span>
        surface_fireline_intensity <span class="org-operator">&gt;=</span> van_wagner_critical_fireline_intensity(canopy_base_height, foliar_moisture)
    )
</pre>
</div>
</div>
</div>
<div id="outline-container-passive-and-active-crown-fire-spread-rate-functions" class="outline-4">
<h4 id="passive-and-active-crown-fire-spread-rate-functions"><span class="section-number-4">6.1.2.</span> Passive and Active Crown Fire Spread Rate Functions</h4>
<div class="outline-text-4" id="text-passive-and-active-crown-fire-spread-rate-functions">
<p>
If crowning occurs, then the active crown fire spread rate is
calculated from the following formula given in Cruz
2005:<sup><a id="fnr.28" class="footref" href="#fn.28" role="doc-backlink">28</a></sup>
</p>

\begin{align}
  \text{CROS}_A = 11.02 \, U_{10\text{m}}^{0.90} \, B_m^{0.19} \, e^{-17 \, \text{EFFM}} \\
\end{align}

<p>
where \(\text{CROS}_A\) is the active crown fire spread rate in
\(\text{m}/\min\), \(U_{10\text{m}}\) is the 10 meter windspeed in
\(\text{km/hr}\), \(B_m\) is the canopy bulk density in \(\text{kg/m}^3\),
and \(\text{EFFM}\) is the estimated fine fuel moisture in \(\text{kg moisture/kg ovendry weight}\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="cruz-active-crown-fire-spread-rate"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> exp


<span class="org-keyword">def</span> <span class="org-function-name">cruz_active_crown_fire_spread_rate</span>(wind_speed_10m, canopy_bulk_density, estimated_fine_fuel_moisture):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the active crown fire spread rate (m/min) given:</span>
<span class="org-doc">    - wind_speed_10m                                   :: km/hr</span>
<span class="org-doc">    - canopy_bulk_density                              :: kg/m^3</span>
<span class="org-doc">    - estimated_fine_fuel_moisture (M_f[0] "dead-1hr") :: kg moisture/kg ovendry weight</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> (11.02
            <span class="org-operator">*</span> wind_speed_10m <span class="org-operator">**</span> 0.90
            <span class="org-operator">*</span> canopy_bulk_density <span class="org-operator">**</span> 0.19
            <span class="org-operator">*</span> exp(<span class="org-operator">-</span>17.0 <span class="org-operator">*</span> estimated_fine_fuel_moisture))
</pre>
</div>

<p>
Next, we need to calculate the <i>critical spread rate</i> from Van Wagner
1977<sup><a id="fnr.29" class="footref" href="#fn.29" role="doc-backlink">29</a></sup> as follows:
</p>

\begin{align}
  R^* = \frac{3.0}{B_m}
\end{align}

<p>
where \(R^*\) is the critical spread rate in \(\text{m}/\min\) and \(B_m\)
is the canopy bulk density in \(\text{kg/m}^3\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="van-wagner-critical-spread-rate"><span class="org-keyword">def</span> <span class="org-function-name">van_wagner_critical_spread_rate</span>(canopy_bulk_density):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the critical spread rate (m/min) given:</span>
<span class="org-doc">    - canopy_bulk_density :: kg/m^3</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> 3.0 <span class="org-operator">/</span> canopy_bulk_density
</pre>
</div>

<p>
If the active crown fire spread rate \(\text{CROS}_A\) is greater than
the critical spread rate \(R^*\), then the crown fire will be active,
otherwise passive. In the event of a passive crown fire, its spread
rate is calculated using the following formula from Cruz
2005:<sup><a id="fnr.30" class="footref" href="#fn.30" role="doc-backlink">30</a></sup>
</p>

\begin{align}
  \text{CROS}_P = \text{CROS}_A \, e^{-\text{CROS}_A / R^*}
\end{align}

<p>
where \(\text{CROS}_P\) is the passive crown fire spread rate in
\(\text{m}/\min\), \(\text{CROS}_A\) is the active crown fire spread rate
in \(\text{m}/\min\), and \(R^*\) is the critical spread rate in
\(\text{m}/\min\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="cruz-passive-crown-fire-spread-rate"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> exp


<span class="org-keyword">def</span> <span class="org-function-name">cruz_passive_crown_fire_spread_rate</span>(active_spread_rate, critical_spread_rate):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the passive crown fire spread rate (m/min) given:</span>
<span class="org-doc">    - active_spread_rate   :: m/min</span>
<span class="org-doc">    - critical_spread_rate :: m/min</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> active_spread_rate <span class="org-operator">*</span> exp(<span class="org-operator">-</span>active_spread_rate <span class="org-operator">/</span> critical_spread_rate)
</pre>
</div>

<p>
Putting it all together, the following function calculates the
critical spread rate, whether a crown fire will become passive or
active, and its associated passive or active spread rate.
</p>

<div class="org-src-container">
<pre class="src src-python" id="cruz-crown-fire-spread-info"><span class="org-keyword">def</span> <span class="org-function-name">cruz_crown_fire_spread_info</span>(wind_speed_10m, canopy_bulk_density, estimated_fine_fuel_moisture):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - wind_speed_10m                                   :: km/hr</span>
<span class="org-doc">    - canopy_bulk_density                              :: kg/m^3</span>
<span class="org-doc">    - estimated_fine_fuel_moisture (M_f[0] "dead-1hr") :: kg moisture/kg ovendry weight</span>

<span class="org-doc">    return a dictionary containing these keys:</span>
<span class="org-doc">    - fire_type            :: "passive_crown" or "active_crown"</span>
<span class="org-doc">    - spread_rate          :: m/min</span>
<span class="org-doc">    - critical_spread_rate :: m/min</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">active_spread_rate</span>   <span class="org-operator">=</span> cruz_active_crown_fire_spread_rate(wind_speed_10m,
                                                              canopy_bulk_density,
                                                              estimated_fine_fuel_moisture) <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
    <span class="org-variable-name">critical_spread_rate</span> <span class="org-operator">=</span> van_wagner_critical_spread_rate(canopy_bulk_density) <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
    <span class="org-keyword">if</span> (active_spread_rate <span class="org-operator">&gt;</span> critical_spread_rate):
        <span class="org-keyword">return</span> {
            <span class="org-string">"fire_type"</span>           : <span class="org-string">"active_crown"</span>,
            <span class="org-string">"spread_rate"</span>         : active_spread_rate,
            <span class="org-string">"critical_spread_rate"</span>: critical_spread_rate,
        }
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> {
            <span class="org-string">"fire_type"</span>           : <span class="org-string">"passive_crown"</span>,
            <span class="org-string">"spread_rate"</span>         : cruz_passive_crown_fire_spread_rate(active_spread_rate, critical_spread_rate),
            <span class="org-string">"critical_spread_rate"</span>: critical_spread_rate,
        }
</pre>
</div>
</div>
</div>
<div id="outline-container-crown-fire-intensity-functions" class="outline-4">
<h4 id="crown-fire-intensity-functions"><span class="section-number-4">6.1.3.</span> Crown Fire Intensity Functions</h4>
<div class="outline-text-4" id="text-crown-fire-intensity-functions">
<p>
Once the crown fire spread rate is determined, the crown fireline
intensity may be calculated using the following formula:
</p>

\begin{align}
  I_c = \frac{R_c \, B \, (Z - Z_b) \, h}{60}
\end{align}

<p>
where \(I_c\) is the crown fireline intensity in \(\text{Btu/ft/s}\),
\(R_c\) is the crown fire spread rate (either \(\text{CROS}_A\) or
\(\text{CROS}_P\)) in \(\text{ft}/\min\), \(B\) is the canopy bulk density
in \(\text{lb/ft}^3\), \(Z\) is the canopy height in \(\text{ft}\), \(Z_b\) is
the canopy base height in \(\text{ft}\), and \(h\) is the fuel model heat
of combustion (generally 8000 \(\text{Btu/lb}\)).
</p>

<p>
Note that \(I_c\) is only the fireline intensity generated by the canopy
fuels under the influence of the crown fire spread rate \(R_c\).
However, crown fires are typically coupled with the surface fires that
ignited them, and so the combined surface and crown fireline intensity
\(I_{s+c}\) is typically the value that should be reported in most
analyses along with the combined surface and crown flame length
\(L_{s+c}\). These terms are defined in section <a href="#combining-surface-and-crown-fire-behavior">6.1.7</a>.
</p>

<div class="org-src-container">
<pre class="src src-python" id="crown-fireline-intensity"><span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: heat_of_combustion is h from the fuel models (generally 8000 Btu/lb)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: ELMFIRE hard-codes heat_of_combustion to 18000 kJ/kg = 7738.6 Btu/lb</span>
<span class="org-keyword">def</span> <span class="org-function-name">calc_crown_fireline_intensity</span>(crown_spread_rate, canopy_bulk_density, canopy_height,
                                  canopy_base_height, heat_of_combustion):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the crown fireline intensity (Btu/ft/s OR kW/m) given:</span>
<span class="org-doc">    - crown_spread_rate                                             :: ft/min  OR m/min</span>
<span class="org-doc">    - canopy_bulk_density                                           :: lb/ft^3 OR kg/m^3</span>
<span class="org-doc">    - canopy_height                                                 :: ft      OR m</span>
<span class="org-doc">    - canopy_base_height                                            :: ft      OR m</span>
<span class="org-doc">    - heat_of_combustion                                            :: Btu/lb  OR kJ/kg</span>

<span class="org-doc">    (ft/min * lb/ft^3 * ft * Btu/lb)/60 = (Btu/ft/min)/60 = Btu/ft/s</span>
<span class="org-doc">    OR</span>
<span class="org-doc">    (m/min * kg/m^3 * m * kJ/kg)/60 = (kJ/m*min)/60 = kJ/m*s = kW/m</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">canopy_height_difference</span> <span class="org-operator">=</span> canopy_height <span class="org-operator">-</span> canopy_base_height
    <span class="org-keyword">return</span> (crown_spread_rate <span class="org-operator">*</span> canopy_bulk_density <span class="org-operator">*</span> canopy_height_difference <span class="org-operator">*</span> heat_of_combustion) <span class="org-operator">/</span> 60.0
</pre>
</div>
</div>
</div>
<div id="outline-container-crown-elliptical-eccentricity" class="outline-4">
<h4 id="crown-elliptical-eccentricity"><span class="section-number-4">6.1.4.</span> Crown Elliptical Eccentricity</h4>
<div class="outline-text-4" id="text-crown-elliptical-eccentricity">
<p>
As with surface fire spread, the wind speed (this time the 20-ft wind
speed \(U_{20}\)) is used to compute the length to width ratio
\(\frac{L}{W}\) of an ellipse that approximates the crown fire front
using equation 10 from Rothermel 1991.<sup><a id="fnr.31" class="footref" href="#fn.31" role="doc-backlink">31</a></sup> This length
to width ratio is then converted into an eccentricity measure of the
ellipse using equation 8 from Albini and Chase 1980.<sup><a id="fnr.32" class="footref" href="#fn.32" role="doc-backlink">32</a></sup>
Here are the formulas used:
</p>

\begin{align}
  \frac{L}{W} &= 1 + 0.125 \, U_{20} \\
  \nonumber \\
  E &= \frac{\sqrt{(\frac{L}{W})^2 - 1}}{\frac{L}{W}}
\end{align}

<p>
where \(U_{20}\) is the 20-ft wind speed in \(\text{mph}\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="crown-fire-eccentricity"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> sqrt
<span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv


<span class="org-keyword">def</span> <span class="org-function-name">crown_length_to_width_ratio</span>(wind_speed_10m, max_length_to_width_ratio<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the length_to_width_ratio of the crown fire front using eq. 9 from</span>
<span class="org-doc">    Rothermel 1991 given:</span>
<span class="org-doc">    - wind_speed_10m            :: km/hr (aligned with the slope-tangential plane)</span>
<span class="org-doc">    - max_length_to_width_ratio :: float &gt; 0.0 (Optional)</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">wind_speed_20ft_mph</span>   <span class="org-operator">=</span> conv.km_hr_to_mph(conv.wind_speed_10m_to_wind_speed_20ft(wind_speed_10m)) <span class="org-comment-delimiter"># </span><span class="org-comment">mph</span>
    <span class="org-variable-name">length_to_width_ratio</span> <span class="org-operator">=</span> 1.0 <span class="org-operator">+</span> 0.125 <span class="org-operator">*</span> wind_speed_20ft_mph
    <span class="org-keyword">if</span> max_length_to_width_ratio:
        <span class="org-keyword">return</span> <span class="org-builtin">min</span>(length_to_width_ratio, max_length_to_width_ratio)
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> length_to_width_ratio


<span class="org-keyword">def</span> <span class="org-function-name">crown_fire_eccentricity</span>(length_to_width_ratio):
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the eccentricity (E) of the crown fire front using eq. 8 from</span>
<span class="org-doc">    Albini and Chase 1980 given:</span>
<span class="org-doc">    - L/W :: (1: circular spread, &gt; 1: elliptical spread)</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> sqrt(length_to_width_ratio <span class="org-operator">**</span> 2.0 <span class="org-operator">-</span> 1.0) <span class="org-operator">/</span> length_to_width_ratio
</pre>
</div>
</div>
</div>
<div id="outline-container-crown-fire-behavior-in-the-direction-of-maximum-spread" class="outline-4">
<h4 id="crown-fire-behavior-in-the-direction-of-maximum-spread"><span class="section-number-4">6.1.5.</span> Crown Fire Behavior in the Direction of Maximum Spread</h4>
<div class="outline-text-4" id="text-crown-fire-behavior-in-the-direction-of-maximum-spread">
<p>
This section introduces a function that computes all of the crown fire
behavior values described in the previous sections. In order to
accurately compare the crown fire behavior values from this section
with the surface fire behavior values from section <a href="#surface-fire-behavior-in-the-direction-of-maximum-spread">5.1.9</a>, the 10 meter wind vector
must be projected onto the slope-tangential plane (using Waeselynck
2024<sup><a id="fnr.33" class="footref" href="#fn.33" role="doc-backlink">33</a></sup>) before the crown fire's maximum spread rate
and associated elliptical parameters are calculated. This ensures that
both the surface fire and crown fire ellipses are aligned with the
slope-tangential plane for later comparison in section <a href="#combining-surface-and-crown-fire-behavior">6.1.7</a>.
</p>

<div class="org-src-container">
<pre class="src src-python" id="crown-fire-behavior-max"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf
<span class="org-keyword">import</span> pyretechnics.vector_utils <span class="org-keyword">as</span> vu


<span class="org-keyword">def</span> <span class="org-function-name">calc_crown_fire_behavior_max</span>(canopy_height, canopy_base_height, canopy_bulk_density, heat_of_combustion,
                                 estimated_fine_fuel_moisture, wind_speed_10m, upwind_direction,
                                 slope, aspect, crown_max_lw_ratio<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - canopy_height                                    :: m</span>
<span class="org-doc">    - canopy_base_height                               :: m</span>
<span class="org-doc">    - canopy_bulk_density                              :: kg/m^3</span>
<span class="org-doc">    - heat_of_combustion                               :: kJ/kg</span>
<span class="org-doc">    - estimated_fine_fuel_moisture (M_f[0] "dead-1hr") :: kg moisture/kg ovendry weight</span>
<span class="org-doc">    - wind_speed_10m                                   :: km/hr</span>
<span class="org-doc">    - upwind_direction                                 :: degrees clockwise from North</span>
<span class="org-doc">    - slope                                            :: rise/run</span>
<span class="org-doc">    - aspect                                           :: degrees clockwise from North</span>
<span class="org-doc">    - crown_max_lw_ratio                               :: float &gt; 0.0 (Optional)</span>

<span class="org-doc">    return a dictionary containing these keys:</span>
<span class="org-doc">    - max_fire_type          :: "passive_crown" or "active_crown"</span>
<span class="org-doc">    - max_spread_rate        :: m/min</span>
<span class="org-doc">    - max_spread_direction   :: (x, y, z) unit vector</span>
<span class="org-doc">    - max_fireline_intensity :: kW/m</span>
<span class="org-doc">    - length_to_width_ratio  :: unitless (1: circular spread, &gt; 1: elliptical spread)</span>
<span class="org-doc">    - eccentricity           :: unitless (0: circular spread, &gt; 0: elliptical spread)</span>
<span class="org-doc">    - critical_spread_rate   :: m/min</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Reverse the provided wind and slope directions</span>
    <span class="org-variable-name">downwind_direction</span> <span class="org-operator">=</span> conv.opposite_direction(upwind_direction)
    <span class="org-variable-name">upslope_direction</span>  <span class="org-operator">=</span> conv.opposite_direction(aspect)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Project wind and slope vectors onto the slope-tangential plane</span>
    <span class="org-variable-name">vectors</span> <span class="org-operator">=</span> sf.project_wind_and_slope_vectors_3d(wind_speed_10m, downwind_direction, slope, upslope_direction)
    <span class="org-variable-name">wind_vector_3d</span>  <span class="org-operator">=</span> vectors[<span class="org-string">"wind_vector_3d"</span>]  <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-variable-name">slope_vector_3d</span> <span class="org-operator">=</span> vectors[<span class="org-string">"slope_vector_3d"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Determine the max spread direction</span>
    <span class="org-variable-name">wind_speed_10m_3d</span>    <span class="org-operator">=</span> vu.vector_magnitude_3d(wind_vector_3d)      <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-variable-name">max_spread_direction</span> <span class="org-operator">=</span> (vu.as_unit_vector_3d(wind_vector_3d)       <span class="org-comment-delimiter"># </span><span class="org-comment">unit vector in the 3D downwind direction</span>
                            <span class="org-keyword">if</span> wind_speed_10m_3d <span class="org-operator">&gt;</span> 0.0
                            <span class="org-keyword">else</span> vu.as_unit_vector_3d(slope_vector_3d) <span class="org-comment-delimiter"># </span><span class="org-comment">unit vector in the 3D upslope direction</span>
                            <span class="org-keyword">if</span> slope <span class="org-operator">&gt;</span> 0.0
                            <span class="org-keyword">else</span> (0.0,1.0,0.0))                        <span class="org-comment-delimiter"># </span><span class="org-comment">default: North</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the crown fire behavior in the max spread direction</span>
    <span class="org-variable-name">spread_info</span>           <span class="org-operator">=</span> cruz_crown_fire_spread_info(wind_speed_10m_3d, canopy_bulk_density,
                                                        estimated_fine_fuel_moisture)
    <span class="org-variable-name">spread_rate</span>           <span class="org-operator">=</span> spread_info[<span class="org-string">"spread_rate"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
    <span class="org-variable-name">fireline_intensity</span>    <span class="org-operator">=</span> calc_crown_fireline_intensity(spread_rate, canopy_bulk_density, canopy_height,
                                                          canopy_base_height, heat_of_combustion) <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
    <span class="org-variable-name">length_to_width_ratio</span> <span class="org-operator">=</span> crown_length_to_width_ratio(wind_speed_10m_3d, crown_max_lw_ratio) <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
    <span class="org-variable-name">eccentricity</span>          <span class="org-operator">=</span> crown_fire_eccentricity(length_to_width_ratio) <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
    <span class="org-keyword">return</span> {
        <span class="org-string">"max_fire_type"</span>         : spread_info[<span class="org-string">"fire_type"</span>],
        <span class="org-string">"max_spread_rate"</span>       : spread_rate,
        <span class="org-string">"max_spread_direction"</span>  : np.asarray(max_spread_direction), <span class="org-comment-delimiter"># </span><span class="org-comment">unit vector</span>
        <span class="org-string">"max_fireline_intensity"</span>: fireline_intensity,
        <span class="org-string">"length_to_width_ratio"</span> : length_to_width_ratio,
        <span class="org-string">"eccentricity"</span>          : eccentricity,
        <span class="org-string">"critical_spread_rate"</span>  : spread_info[<span class="org-string">"critical_spread_rate"</span>],
    }
</pre>
</div>
</div>
</div>
<div id="outline-container-crown-fire-behavior-in-any-direction" class="outline-4">
<h4 id="crown-fire-behavior-in-any-direction"><span class="section-number-4">6.1.6.</span> Crown Fire Behavior in Any Direction</h4>
<div class="outline-text-4" id="text-crown-fire-behavior-in-any-direction">
<p>
Once we have calculated the maximum crown fire behavior values
associated with a head fire, we can use the elliptical eccentricity
\(E\) to project the maximum spread rate \(R_c\) and maximum fireline
intensity \(I_c\) to any point along the fire front as follows:
</p>

\begin{align}
  \eta &= \frac{1-E}{1-E\cos\omega} \\
  \nonumber \\
  R_c(\omega) &= R_c \, \eta \\
  \nonumber \\
  I_c(\omega) &= I_c \, \eta
\end{align}

<p>
where \(\omega\) is the angular offset from the direction of maximum
fire spread and \(R_c(\omega)\) and \(I_c(\omega)\) are the spread rate
and fireline intensity in this direction respectively.
</p>

<p>
Since the crown fire ellipse is defined on the slope-tangential plane,
we must represent spread directions with three dimensional unit
vectors aligned with this plane rather than with angles. Fortunately,
we can use the relationship between the dot product of two vectors and
the cosine of the angle between them to rewrite the \(\eta\) function
above as follows:
</p>

\begin{align}
  \eta = \frac{1-E}{1-E(\vec{u_{\max}} \cdot \vec{u_{\omega}})}
\end{align}

<p>
where \(\vec{u_{\max}}\) is the slope-tangential unit vector in the
direction of maximum spread and \(\vec{u_{\omega}}\) is the
slope-tangential unit vector rotated \(\omega\) degrees clockwise along
this plane from \(\vec{u_{\max}}\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="crown-fire-behavior-in-direction"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np


<span class="org-keyword">def</span> <span class="org-function-name">calc_crown_fire_behavior_in_direction</span>(crown_fire_max, spread_direction):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - crown_fire_max     :: dictionary of max crown fire behavior values</span>
<span class="org-doc">      - max_fire_type          :: "passive_crown" or "active_crown"</span>
<span class="org-doc">      - max_spread_rate        :: m/min</span>
<span class="org-doc">      - max_spread_direction   :: (x, y, z) unit vector</span>
<span class="org-doc">      - max_fireline_intensity :: kW/m</span>
<span class="org-doc">      - length_to_width_ratio  :: unitless (1: circular spread, &gt; 1: elliptical spread)</span>
<span class="org-doc">      - eccentricity           :: unitless (0: circular spread, &gt; 0: elliptical spread)</span>
<span class="org-doc">      - critical_spread_rate   :: m/min</span>
<span class="org-doc">    - spread_direction   :: 3D unit vector on the slope-tangential plane</span>

<span class="org-doc">    return a dictionary containing these keys:</span>
<span class="org-doc">    - fire_type          :: "passive_crown" or "active_crown"</span>
<span class="org-doc">    - spread_rate        :: m/min</span>
<span class="org-doc">    - spread_direction   :: (x, y, z) unit vector</span>
<span class="org-doc">    - fireline_intensity :: kW/m</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack max crown fire behavior values</span>
    <span class="org-variable-name">max_fire_type</span>          <span class="org-operator">=</span> crown_fire_max[<span class="org-string">"max_fire_type"</span>]
    <span class="org-variable-name">max_spread_rate</span>        <span class="org-operator">=</span> crown_fire_max[<span class="org-string">"max_spread_rate"</span>]
    <span class="org-variable-name">max_spread_direction</span>   <span class="org-operator">=</span> crown_fire_max[<span class="org-string">"max_spread_direction"</span>]
    <span class="org-variable-name">max_fireline_intensity</span> <span class="org-operator">=</span> crown_fire_max[<span class="org-string">"max_fireline_intensity"</span>]
    <span class="org-variable-name">eccentricity</span>           <span class="org-operator">=</span> crown_fire_max[<span class="org-string">"eccentricity"</span>]
    <span class="org-variable-name">critical_spread_rate</span>   <span class="org-operator">=</span> crown_fire_max[<span class="org-string">"critical_spread_rate"</span>]
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate cos(w), where w is the offset angle between these unit vectors on the slope-tangential plane</span>
    <span class="org-variable-name">cos_w</span> <span class="org-operator">=</span> np.dot(max_spread_direction, spread_direction)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate adjustment due to the offset angle from the max spread direction</span>
    <span class="org-variable-name">adjustment</span> <span class="org-operator">=</span> (1.0 <span class="org-operator">-</span> eccentricity) <span class="org-operator">/</span> (1.0 <span class="org-operator">-</span> eccentricity <span class="org-operator">*</span> cos_w)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Adjust the spread rate (possibly switching from an active to passive crown fire)</span>
    <span class="org-variable-name">spread_rate</span> <span class="org-operator">=</span> max_spread_rate <span class="org-operator">*</span> adjustment
    <span class="org-keyword">if</span> spread_rate <span class="org-operator">&gt;</span> critical_spread_rate:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Max spread rate was active and directional spread rate remains active</span>
        <span class="org-keyword">return</span> {
            <span class="org-string">"fire_type"</span>         : <span class="org-string">"active_crown"</span>,
            <span class="org-string">"spread_rate"</span>       : spread_rate,
            <span class="org-string">"spread_direction"</span>  : np.asarray(spread_direction),
            <span class="org-string">"fireline_intensity"</span>: max_fireline_intensity <span class="org-operator">*</span> adjustment,
        }
    <span class="org-keyword">elif</span> max_fire_type <span class="org-operator">==</span> <span class="org-string">"passive_crown"</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Max spread rate was passive and directional spread rate remains passive</span>
        <span class="org-keyword">return</span> {
            <span class="org-string">"fire_type"</span>         : <span class="org-string">"passive_crown"</span>,
            <span class="org-string">"spread_rate"</span>       : spread_rate,
            <span class="org-string">"spread_direction"</span>  : np.asarray(spread_direction),
            <span class="org-string">"fireline_intensity"</span>: max_fireline_intensity <span class="org-operator">*</span> adjustment,
        }
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Max spread rate was active and directional spread rate has become passive</span>
        <span class="org-keyword">return</span> {
            <span class="org-string">"fire_type"</span>         : <span class="org-string">"passive_crown"</span>,
            <span class="org-string">"spread_rate"</span>       : cruz_passive_crown_fire_spread_rate(spread_rate, critical_spread_rate),
            <span class="org-string">"spread_direction"</span>  : np.asarray(spread_direction),
            <span class="org-string">"fireline_intensity"</span>: max_fireline_intensity <span class="org-operator">*</span> adjustment,
        }
</pre>
</div>
</div>
</div>
<div id="outline-container-combining-surface-and-crown-fire-behavior" class="outline-4">
<h4 id="combining-surface-and-crown-fire-behavior"><span class="section-number-4">6.1.7.</span> Combining Surface and Crown Fire Behavior</h4>
<div class="outline-text-4" id="text-combining-surface-and-crown-fire-behavior">
<p>
When both surface fire and crown fire are present in the same
location, their combined behavior determines the fire type, spread
rate and direction, fireline intensity, and flame length values
associated with this location.
</p>

<p>
<b>Note:</b> Since the surface fire and crown fire each define separate
fire spread ellipses with potentially different maximum spread
directions, their relative spread rates and intensities should only be
compared in a given absolute direction in the slope-tangential plane.
In most applications, this will be the direction normal to the fire
front.
</p>
</div>
<ol class="org-ol">
<li><a id="combined-fire-type"></a>Combined Fire Type<br>
<div class="outline-text-5" id="text-combined-fire-type">
<p>
The fire type associated with the combined fire is the crown fire
type, either "passive_crown" or "active_crown".
</p>
</div>
</li>
<li><a id="combined-spread-rate-and-direction"></a>Combined Spread Rate and Direction<br>
<div class="outline-text-5" id="text-combined-spread-rate-and-direction">
<p>
The combined spread rate \(R_{s+c}\) (in \(\text{m}/\text{min}\)) is
defined to be the maximum of the surface spread rate \(R_s\) and the
crown spread rate \(R_c\) as follows:
</p>

\begin{align}
  R_{s+c} = \max(R_s, R_c)
\end{align}

<p>
The combined spread direction is the spread direction associated with
whichever fire front has the fastest spread rate.
</p>
</div>
</li>
<li><a id="combined-fireline-intensity"></a>Combined Fireline Intensity<br>
<div class="outline-text-5" id="text-combined-fireline-intensity">
<p>
Combining surface and crown fireline intensities is slightly more
complicated. From section <a href="#surface-fire-intensity-functions">5.1.3</a>, we can see
the following relationship between the surface fire spread rate \(R_s\)
(in \(\text{m}/\text{min}\)), the surface fireline intensity \(I_s\) (in
\(\text{kW}/\text{m}\)), and the heat per unit area of the burning
surface fuel \(H_s\) (in \(\text{kJ}/\text{m}^2\)), which we here
generalize to calculate the heat per unit area of a crown fire \(H_c\)
and a combined surface and crown fire \(H_{s+c}\):
</p>

\begin{align}
  H_s &= 60 \frac{I_s}{R_s} \\
  \nonumber \\
  H_c &= 60 \frac{I_c}{R_c} \\
  \nonumber \\
  H_{s+c} &= 60 \frac{I_{s+c}}{R_{s+c}} \\
\end{align}

<p>
When surface and canopy fuels both burn in the same area, their
combined heat per unit area \(H_{s+c}\) is their sum:
</p>

\begin{align}
  H_{s+c} = H_s + H_c = 60 \left(\frac{I_s}{R_s} + \frac{I_c}{R_c}\right)
\end{align}

<p>
Equating the two definitions for \(H_{s+c}\) above gives us the
following definition for the combined fireline intensity \(I_{s+c}\) (in
\(\text{kW}/\text{m}\)):
</p>

\begin{align}
  I_{s+c} = R_{s+c} \left(\frac{I_s}{R_s} + \frac{I_c}{R_c}\right)
\end{align}

<p>
Substituting in the definition of \(R_{s+c}\) gives us this piecewise
formula:
</p>

\begin{align}
  I_{s+c} &= \left\{
    \begin{array}{lr}
      I_s + I_c \frac{R_s}{R_c} & \text{when}\ R_s > R_c \\
      I_s \frac{R_c}{R_s} + I_c & \text{when}\  R_s < R_c \\
      I_s + I_c & \text{when}\ R_s = R_c \\
    \end{array}
  \right. \\
\end{align}

<p>
Some fire behavior models have calculated the combined fireline
intensity by simply adding the surface and crown fireline intensities
together as we do in the \(R_s = R_c\) case above. However, that would
misrepresent the physical behavior of the combined fire whenever \(R_s
\neq R_c\). For example, when the crown fire makes the fire front
spread faster, then the surface fireline intensity is amplified due to
more surface fuel burning simultaneously (i.e., greater flame depth).
Similarly, if the surface fire outpaces the crown fire, then it can
ignite a longer span of canopy fuels as it progresses, thereby
increasing the flame depth and fireline intensity of the crown fire in
the direction normal to the fire perimeter. The piecewise definition
of \(I_{s+c}\) above accounts for this co-amplification behavior.
</p>
</div>
</li>
<li><a id="combined-flame-length"></a>Combined Flame Length<br>
<div class="outline-text-5" id="text-combined-flame-length">
<p>
The combined flame length \(L_{s+c}\) (in meters) is the flame length of
the combined fireline intensity \(I_{s+c}\) (in \(\text{kW}/\text{m}\)) as
follows:
</p>

\begin{align}
  L_{s+c} = 0.07747042253266703 (I_{s+c})^{0.46}
\end{align}
</div>
</li>
<li><a id="combined-fire-behavior-implementation"></a>Combined Fire Behavior Implementation<br>
<div class="outline-text-5" id="text-combined-fire-behavior-implementation">
<div class="org-src-container">
<pre class="src src-python" id="combined-fire-behavior"><span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf


<span class="org-keyword">def</span> <span class="org-function-name">calc_combined_fire_behavior</span>(surface_fire_behavior, crown_fire_behavior):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - surface_fire_behavior :: dictionary of surface fire behavior values</span>
<span class="org-doc">      - fire_type              :: "surface"</span>
<span class="org-doc">      - spread_rate            :: m/min</span>
<span class="org-doc">      - spread_direction       :: (x, y, z) unit vector</span>
<span class="org-doc">      - fireline_intensity     :: kW/m</span>
<span class="org-doc">      - flame_length           :: m</span>
<span class="org-doc">    - crown_fire_behavior   :: dictionary of crown fire behavior values</span>
<span class="org-doc">      - fire_type              :: "passive_crown" or "active_crown"</span>
<span class="org-doc">      - spread_rate            :: m/min</span>
<span class="org-doc">      - spread_direction       :: (x, y, z) unit vector</span>
<span class="org-doc">      - fireline_intensity     :: kW/m</span>

<span class="org-doc">    return a dictionary containing these keys:</span>
<span class="org-doc">    - fire_type          :: "surface", "passive_crown", or "active_crown"</span>
<span class="org-doc">    - spread_rate        :: m/min</span>
<span class="org-doc">    - spread_direction   :: (x, y, z) unit vector</span>
<span class="org-doc">    - fireline_intensity :: kW/m</span>
<span class="org-doc">    - flame_length       :: m</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack the surface fire behavior values</span>
    <span class="org-variable-name">surface_spread_rate</span>        <span class="org-operator">=</span> surface_fire_behavior[<span class="org-string">"spread_rate"</span>]        <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
    <span class="org-variable-name">surface_spread_direction</span>   <span class="org-operator">=</span> surface_fire_behavior[<span class="org-string">"spread_direction"</span>]   <span class="org-comment-delimiter"># </span><span class="org-comment">(x, y, z) unit vector</span>
    <span class="org-variable-name">surface_fireline_intensity</span> <span class="org-operator">=</span> surface_fire_behavior[<span class="org-string">"fireline_intensity"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack the crown fire behavior values</span>
    <span class="org-variable-name">crown_fire_type</span>          <span class="org-operator">=</span> crown_fire_behavior[<span class="org-string">"fire_type"</span>]          <span class="org-comment-delimiter"># </span><span class="org-comment">"passive_crown" or "active_crown"</span>
    <span class="org-variable-name">crown_spread_rate</span>        <span class="org-operator">=</span> crown_fire_behavior[<span class="org-string">"spread_rate"</span>]        <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
    <span class="org-variable-name">crown_spread_direction</span>   <span class="org-operator">=</span> crown_fire_behavior[<span class="org-string">"spread_direction"</span>]   <span class="org-comment-delimiter"># </span><span class="org-comment">(x, y, z) unit vector</span>
    <span class="org-variable-name">crown_fireline_intensity</span> <span class="org-operator">=</span> crown_fire_behavior[<span class="org-string">"fireline_intensity"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Determine whether the surface or crown fire has the fastest spread rate</span>
    <span class="org-keyword">if</span> surface_spread_rate <span class="org-operator">==</span> 0.0:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Independent crown fire (This is probably user error.)</span>
        <span class="org-keyword">return</span> crown_fire_behavior
    <span class="org-keyword">elif</span> crown_spread_rate <span class="org-operator">==</span> 0.0:
        <span class="org-comment-delimiter"># </span><span class="org-comment">No crown fire</span>
        <span class="org-keyword">return</span> surface_fire_behavior
    <span class="org-keyword">elif</span> surface_spread_rate <span class="org-operator">&gt;</span> crown_spread_rate:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Surface fire spreads faster</span>
        <span class="org-variable-name">combined_fireline_intensity</span> <span class="org-operator">=</span> (surface_fireline_intensity
                                       <span class="org-operator">+</span> crown_fireline_intensity <span class="org-operator">*</span> surface_spread_rate <span class="org-operator">/</span> crown_spread_rate)
        <span class="org-keyword">return</span> {
            <span class="org-string">"fire_type"</span>         : crown_fire_type,
            <span class="org-string">"spread_rate"</span>       : surface_spread_rate,
            <span class="org-string">"spread_direction"</span>  : surface_spread_direction,
            <span class="org-string">"fireline_intensity"</span>: combined_fireline_intensity,
            <span class="org-string">"flame_length"</span>      : sf.calc_flame_length(combined_fireline_intensity),
        }
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Crown fire spreads faster</span>
        <span class="org-variable-name">combined_fireline_intensity</span> <span class="org-operator">=</span> (surface_fireline_intensity <span class="org-operator">*</span> crown_spread_rate <span class="org-operator">/</span> surface_spread_rate
                                       <span class="org-operator">+</span> crown_fireline_intensity)
        <span class="org-keyword">return</span> {
            <span class="org-string">"fire_type"</span>         : crown_fire_type,
            <span class="org-string">"spread_rate"</span>       : crown_spread_rate,
            <span class="org-string">"spread_direction"</span>  : crown_spread_direction,
            <span class="org-string">"fireline_intensity"</span>: combined_fireline_intensity,
            <span class="org-string">"flame_length"</span>      : sf.calc_flame_length(combined_fireline_intensity),
        }
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-for-users-crown" class="outline-3">
<h3 id="for-users-crown"><span class="section-number-3">6.2.</span> For Users</h3>
<div class="outline-text-3" id="text-for-users-crown">
<p>
In the following sections, we will demonstrate how to calculate the
crown fire behavior values given a surface fire line intensity and
measurements of foliar moisture, fine fuel moisture, tree canopy
characteristics, wind speed, wind direction, slope, and aspect. This
will be done first for the max spread direction case and then in any
direction on the sloped surface using 3D vectors to specify absolute
directions.
</p>

<p>
Because wind speed and direction will often be provided from
measurements taken 10m or 20ft above the canopy and may be given in
either cartesion <code>(x,y)</code> or azimuthal <code>(r,azimuth)</code> coordinates, we
also demonstrate how to convert from cartesian to azimuthal
coordinates and from 10m to 20ft wind speeds.
</p>

<p>
See Appendix <a href="#units-conversion-functions-(pyretechnics.conversion)">10.1</a> for
the full list of available units conversion functions.
</p>

<p>
See Appendix <a href="#vector-utility-functions-(pyretechnics.vector_utils)">10.2</a> for
the full list of available vector manipulation functions.
</p>
</div>
<div id="outline-container-how-to-determine-whether-a-surface-fire-transitions-to-a-crown-fire" class="outline-4">
<h4 id="how-to-determine-whether-a-surface-fire-transitions-to-a-crown-fire"><span class="section-number-4">6.2.1.</span> How to Determine Whether a Surface Fire Transitions to a Crown Fire</h4>
<div class="outline-text-4" id="text-how-to-determine-whether-a-surface-fire-transitions-to-a-crown-fire">
<div class="org-src-container">
<pre class="src src-python" id="check-crown-fire-initiation"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.crown_fire <span class="org-keyword">as</span> cf

<span class="org-comment-delimiter"># </span><span class="org-comment">Set tree canopy characteristics</span>
<span class="org-variable-name">canopy_cover_low</span>   <span class="org-operator">=</span> 0.3 <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
<span class="org-variable-name">canopy_cover_high</span>  <span class="org-operator">=</span> 0.8 <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
<span class="org-variable-name">canopy_base_height</span> <span class="org-operator">=</span> 3.0 <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
<span class="org-variable-name">foliar_moisture</span>    <span class="org-operator">=</span> 1.0 <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Specify some surface fireline intensity values to check</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">These would normally be calculated by the functions in pyretechnics.surface_fire</span>
<span class="org-variable-name">surface_fireline_intensity_low</span>  <span class="org-operator">=</span> 500.0  <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
<span class="org-variable-name">surface_fireline_intensity_high</span> <span class="org-operator">=</span> 5000.0 <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">=================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Check for crown fire with canopy_cover_low and surface_fireline_intensity_low</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"Low Canopy Cover and Low Surface Fireline Intensity</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)

<span class="org-keyword">if</span> cf.van_wagner_crown_fire_initiation(surface_fireline_intensity_low,
                                       canopy_cover_low,
                                       canopy_base_height,
                                       foliar_moisture):
    <span class="org-comment-delimiter"># </span><span class="org-comment">Crown Fire</span>
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">A crown fire occurs with these input parameters:"</span>)
    pprint({
        <span class="org-string">"surface_fireline_intensity"</span>: surface_fireline_intensity_low,
        <span class="org-string">"canopy_cover"</span>              : canopy_cover_low,
        <span class="org-string">"canopy_base_height"</span>        : canopy_base_height,
        <span class="org-string">"foliar_moisture"</span>           : foliar_moisture,
    })
<span class="org-keyword">else</span>:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Surface Fire</span>
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">A surface fire occurs with these input parameters:"</span>)
    pprint({
        <span class="org-string">"surface_fireline_intensity"</span>: surface_fireline_intensity_low,
        <span class="org-string">"canopy_cover"</span>              : canopy_cover_low,
        <span class="org-string">"canopy_base_height"</span>        : canopy_base_height,
        <span class="org-string">"foliar_moisture"</span>           : foliar_moisture,
    })

<span class="org-comment-delimiter">#</span><span class="org-comment">=================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Check for crown fire with canopy_cover_low and surface_fireline_intensity_high</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Low Canopy Cover and High Surface Fireline Intensity</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)

<span class="org-keyword">if</span> cf.van_wagner_crown_fire_initiation(surface_fireline_intensity_high,
                                       canopy_cover_low,
                                       canopy_base_height,
                                       foliar_moisture):
    <span class="org-comment-delimiter"># </span><span class="org-comment">Crown Fire</span>
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">A crown fire occurs with these input parameters:"</span>)
    pprint({
        <span class="org-string">"surface_fireline_intensity"</span>: surface_fireline_intensity_high,
        <span class="org-string">"canopy_cover"</span>              : canopy_cover_low,
        <span class="org-string">"canopy_base_height"</span>        : canopy_base_height,
        <span class="org-string">"foliar_moisture"</span>           : foliar_moisture,
    })
<span class="org-keyword">else</span>:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Surface Fire</span>
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">A surface fire occurs with these input parameters:"</span>)
    pprint({
        <span class="org-string">"surface_fireline_intensity"</span>: surface_fireline_intensity_high,
        <span class="org-string">"canopy_cover"</span>              : canopy_cover_low,
        <span class="org-string">"canopy_base_height"</span>        : canopy_base_height,
        <span class="org-string">"foliar_moisture"</span>           : foliar_moisture,
    })

<span class="org-comment-delimiter">#</span><span class="org-comment">=================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Check for crown fire with canopy_cover_high and surface_fireline_intensity_low</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">High Canopy Cover and Low Surface Fireline Intensity</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)

<span class="org-keyword">if</span> cf.van_wagner_crown_fire_initiation(surface_fireline_intensity_low,
                                       canopy_cover_high,
                                       canopy_base_height,
                                       foliar_moisture):
    <span class="org-comment-delimiter"># </span><span class="org-comment">Crown Fire</span>
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">A crown fire occurs with these input parameters:"</span>)
    pprint({
        <span class="org-string">"surface_fireline_intensity"</span>: surface_fireline_intensity_low,
        <span class="org-string">"canopy_cover"</span>              : canopy_cover_high,
        <span class="org-string">"canopy_base_height"</span>        : canopy_base_height,
        <span class="org-string">"foliar_moisture"</span>           : foliar_moisture,
    })
<span class="org-keyword">else</span>:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Surface Fire</span>
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">A surface fire occurs with these input parameters:"</span>)
    pprint({
        <span class="org-string">"surface_fireline_intensity"</span>: surface_fireline_intensity_low,
        <span class="org-string">"canopy_cover"</span>              : canopy_cover_high,
        <span class="org-string">"canopy_base_height"</span>        : canopy_base_height,
        <span class="org-string">"foliar_moisture"</span>           : foliar_moisture,
    })

<span class="org-comment-delimiter">#</span><span class="org-comment">=================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Check for crown fire with canopy_cover_high and surface_fireline_intensity_high</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">High Canopy Cover and High Surface Fireline Intensity</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)

<span class="org-keyword">if</span> cf.van_wagner_crown_fire_initiation(surface_fireline_intensity_high,
                                       canopy_cover_high,
                                       canopy_base_height,
                                       foliar_moisture):
    <span class="org-comment-delimiter"># </span><span class="org-comment">Crown Fire</span>
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">A crown fire occurs with these input parameters:"</span>)
    pprint({
        <span class="org-string">"surface_fireline_intensity"</span>: surface_fireline_intensity_high,
        <span class="org-string">"canopy_cover"</span>              : canopy_cover_high,
        <span class="org-string">"canopy_base_height"</span>        : canopy_base_height,
        <span class="org-string">"foliar_moisture"</span>           : foliar_moisture,
    })
<span class="org-keyword">else</span>:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Surface Fire</span>
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">A surface fire occurs with these input parameters:"</span>)
    pprint({
        <span class="org-string">"surface_fireline_intensity"</span>: surface_fireline_intensity_high,
        <span class="org-string">"canopy_cover"</span>              : canopy_cover_high,
        <span class="org-string">"canopy_base_height"</span>        : canopy_base_height,
        <span class="org-string">"foliar_moisture"</span>           : foliar_moisture,
    })
</pre>
</div>

<pre class="example" id="check-crown-fire-initiation-results">
Low Canopy Cover and Low Surface Fireline Intensity
============================================================

A surface fire occurs with these input parameters:
{'canopy_base_height': 3.0,
 'canopy_cover': 0.3,
 'foliar_moisture': 1.0,
 'surface_fireline_intensity': 500.0}

Low Canopy Cover and High Surface Fireline Intensity
============================================================

A surface fire occurs with these input parameters:
{'canopy_base_height': 3.0,
 'canopy_cover': 0.3,
 'foliar_moisture': 1.0,
 'surface_fireline_intensity': 5000.0}

High Canopy Cover and Low Surface Fireline Intensity
============================================================

A surface fire occurs with these input parameters:
{'canopy_base_height': 3.0,
 'canopy_cover': 0.8,
 'foliar_moisture': 1.0,
 'surface_fireline_intensity': 500.0}

High Canopy Cover and High Surface Fireline Intensity
============================================================

A crown fire occurs with these input parameters:
{'canopy_base_height': 3.0,
 'canopy_cover': 0.8,
 'foliar_moisture': 1.0,
 'surface_fireline_intensity': 5000.0}
</pre>
</div>
</div>
<div id="outline-container-how-to-calculate-the-crown-fire-behavior-in-the-direction-of-maximum-spread" class="outline-4">
<h4 id="how-to-calculate-the-crown-fire-behavior-in-the-direction-of-maximum-spread"><span class="section-number-4">6.2.2.</span> How to Calculate the Crown Fire Behavior in the Direction of Maximum Spread</h4>
<div class="outline-text-4" id="text-how-to-calculate-the-crown-fire-behavior-in-the-direction-of-maximum-spread">
<div class="org-src-container">
<pre class="src src-python" id="compute-crown-fire-behavior-max"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.crown_fire <span class="org-keyword">as</span> cf

<span class="org-comment-delimiter"># </span><span class="org-comment">Set input parameters</span>
<span class="org-variable-name">canopy_height</span>                <span class="org-operator">=</span> 30.0    <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
<span class="org-variable-name">canopy_base_height</span>           <span class="org-operator">=</span> 3.0     <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
<span class="org-variable-name">canopy_bulk_density</span>          <span class="org-operator">=</span> 0.3     <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>
<span class="org-variable-name">heat_of_combustion</span>           <span class="org-operator">=</span> 18608.0 <span class="org-comment-delimiter"># </span><span class="org-comment">kJ/kg</span>
<span class="org-variable-name">estimated_fine_fuel_moisture</span> <span class="org-operator">=</span> 0.05    <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
<span class="org-variable-name">wind_speed_10m</span>               <span class="org-operator">=</span> 10.0    <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
<span class="org-variable-name">upwind_direction</span>             <span class="org-operator">=</span> 180.0   <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
<span class="org-variable-name">slope</span>                        <span class="org-operator">=</span> 0.5     <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
<span class="org-variable-name">aspect_parallel_to_wind</span>      <span class="org-operator">=</span> 180.0   <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
<span class="org-variable-name">aspect_perpendicular_to_wind</span> <span class="org-operator">=</span> 270.0   <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction of maximum spread with slope and wind aligned</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">====================================================================================================</span>

<span class="org-variable-name">crown_fire_max_aligned</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_max(canopy_height, canopy_base_height,
                                                         canopy_bulk_density, heat_of_combustion,
                                                         estimated_fine_fuel_moisture,
                                                         wind_speed_10m, upwind_direction,
                                                         slope, aspect_parallel_to_wind)

<span class="org-comment-delimiter"># </span><span class="org-comment">View results</span>
<span class="org-builtin">print</span>(<span class="org-string">"Crown Fire Behavior Max with Wind and Slope Aligned</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Inputs:"</span>)
pprint({
    <span class="org-string">"canopy_height"</span>               : canopy_height,
    <span class="org-string">"canopy_base_height"</span>          : canopy_base_height,
    <span class="org-string">"canopy_bulk_density"</span>         : canopy_bulk_density,
    <span class="org-string">"heat_of_combustion"</span>          : heat_of_combustion,
    <span class="org-string">"estimated_fine_fuel_moisture"</span>: estimated_fine_fuel_moisture,
    <span class="org-string">"wind_speed_10m"</span>              : wind_speed_10m,
    <span class="org-string">"upwind_direction"</span>            : upwind_direction,
    <span class="org-string">"slope"</span>                       : slope,
    <span class="org-string">"aspect"</span>                      : aspect_parallel_to_wind,
})

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Outputs:"</span>)
pprint(crown_fire_max_aligned)

<span class="org-comment-delimiter">#</span><span class="org-comment">====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction of maximum spread with slope and wind perpendicular</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">====================================================================================================</span>

<span class="org-variable-name">crown_fire_max_perpendicular</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_max(canopy_height, canopy_base_height,
                                                               canopy_bulk_density, heat_of_combustion,
                                                               estimated_fine_fuel_moisture,
                                                               wind_speed_10m, upwind_direction,
                                                               slope, aspect_perpendicular_to_wind)

<span class="org-comment-delimiter"># </span><span class="org-comment">View results</span>
<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Crown Fire Behavior Max with Wind and Slope Perpendicular</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Inputs:"</span>)
pprint({
    <span class="org-string">"canopy_height"</span>               : canopy_height,
    <span class="org-string">"canopy_base_height"</span>          : canopy_base_height,
    <span class="org-string">"canopy_bulk_density"</span>         : canopy_bulk_density,
    <span class="org-string">"heat_of_combustion"</span>          : heat_of_combustion,
    <span class="org-string">"estimated_fine_fuel_moisture"</span>: estimated_fine_fuel_moisture,
    <span class="org-string">"wind_speed_10m"</span>              : wind_speed_10m,
    <span class="org-string">"upwind_direction"</span>            : upwind_direction,
    <span class="org-string">"slope"</span>                       : slope,
    <span class="org-string">"aspect"</span>                      : aspect_perpendicular_to_wind,
})

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Outputs:"</span>)
pprint(crown_fire_max_perpendicular)
</pre>
</div>

<pre class="example" id="compute-crown-fire-behavior-max-results">
Crown Fire Behavior Max with Wind and Slope Aligned
============================================================

Inputs:
{'aspect': 180.0,
 'canopy_base_height': 3.0,
 'canopy_bulk_density': 0.3,
 'canopy_height': 30.0,
 'estimated_fine_fuel_moisture': 0.05,
 'heat_of_combustion': 18608.0,
 'slope': 0.5,
 'upwind_direction': 180.0,
 'wind_speed_10m': 10.0}

Outputs:
{'critical_spread_rate': 10.0,
 'eccentricity': 0.821895863285579,
 'length_to_width_ratio': 1.7555015683174133,
 'max_fire_type': 'active_crown',
 'max_fireline_intensity': 82666.07018304318,
 'max_spread_direction': array([0.        , 0.89442718, 0.44721359]),
 'max_spread_rate': 32.90741942256743}

Crown Fire Behavior Max with Wind and Slope Perpendicular
============================================================

Inputs:
{'aspect': 270.0,
 'canopy_base_height': 3.0,
 'canopy_bulk_density': 0.3,
 'canopy_height': 30.0,
 'estimated_fine_fuel_moisture': 0.05,
 'heat_of_combustion': 18608.0,
 'slope': 0.5,
 'upwind_direction': 180.0,
 'wind_speed_10m': 10.0}

Outputs:
{'critical_spread_rate': 10.0,
 'eccentricity': 0.8024265608222492,
 'length_to_width_ratio': 1.6757411360740662,
 'max_fire_type': 'active_crown',
 'max_fireline_intensity': 74768.3487091958,
 'max_spread_direction': array([ 0.00000000e+00,  1.00000000e+00, -2.18556941e-08]),
 'max_spread_rate': 29.763522144675242}
</pre>
</div>
</div>
<div id="outline-container-how-to-calculate-the-crown-fire-behavior-in-any-direction" class="outline-4">
<h4 id="how-to-calculate-the-crown-fire-behavior-in-any-direction"><span class="section-number-4">6.2.3.</span> How to Calculate the Crown Fire Behavior in Any Direction</h4>
<div class="outline-text-4" id="text-how-to-calculate-the-crown-fire-behavior-in-any-direction">
<div class="org-src-container">
<pre class="src src-python" id="compute-crown-fire-behavior-in-direction"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.crown_fire <span class="org-keyword">as</span> cf
<span class="org-keyword">import</span> pyretechnics.vector_utils <span class="org-keyword">as</span> vu

<span class="org-comment-delimiter"># </span><span class="org-comment">Set input parameters</span>
<span class="org-variable-name">canopy_height</span>                <span class="org-operator">=</span> 30.0    <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
<span class="org-variable-name">canopy_base_height</span>           <span class="org-operator">=</span> 3.0     <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
<span class="org-variable-name">canopy_bulk_density</span>          <span class="org-operator">=</span> 0.3     <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>
<span class="org-variable-name">heat_of_combustion</span>           <span class="org-operator">=</span> 18608.0 <span class="org-comment-delimiter"># </span><span class="org-comment">kJ/kg</span>
<span class="org-variable-name">estimated_fine_fuel_moisture</span> <span class="org-operator">=</span> 0.05    <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
<span class="org-variable-name">wind_speed_10m</span>               <span class="org-operator">=</span> 10.0    <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
<span class="org-variable-name">upwind_direction</span>             <span class="org-operator">=</span> 180.0   <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
<span class="org-variable-name">slope</span>                        <span class="org-operator">=</span> 0.5     <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
<span class="org-variable-name">aspect</span>                       <span class="org-operator">=</span> 225.0   <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction of maximum spread</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

<span class="org-variable-name">crown_fire_max</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_max(canopy_height, canopy_base_height,
                                                 canopy_bulk_density, heat_of_combustion,
                                                 estimated_fine_fuel_moisture,
                                                 wind_speed_10m, upwind_direction,
                                                 slope, aspect)

<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior for the heading, flanking, and backing fires</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

<span class="org-variable-name">heading_fire_direction</span>  <span class="org-operator">=</span> crown_fire_max[<span class="org-string">"max_spread_direction"</span>]
<span class="org-variable-name">flanking_fire_direction</span> <span class="org-operator">=</span> vu.rotate_on_sloped_plane(heading_fire_direction, 90.0, slope, aspect)
<span class="org-variable-name">backing_fire_direction</span>  <span class="org-operator">=</span> <span class="org-operator">-</span>heading_fire_direction

<span class="org-variable-name">heading_fire_behavior</span>  <span class="org-operator">=</span> cf.calc_crown_fire_behavior_in_direction(crown_fire_max, heading_fire_direction)
<span class="org-variable-name">flanking_fire_behavior</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_in_direction(crown_fire_max, flanking_fire_direction)
<span class="org-variable-name">backing_fire_behavior</span>  <span class="org-operator">=</span> cf.calc_crown_fire_behavior_in_direction(crown_fire_max, backing_fire_direction)

<span class="org-comment-delimiter"># </span><span class="org-comment">View heading fire results</span>
<span class="org-builtin">print</span>(<span class="org-string">"Heading Fire Behavior</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)
pprint(heading_fire_behavior)

<span class="org-comment-delimiter"># </span><span class="org-comment">View flanking fire results</span>
<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Flanking Fire Behavior</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)
pprint(flanking_fire_behavior)

<span class="org-comment-delimiter"># </span><span class="org-comment">View backing fire results</span>
<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Backing Fire Behavior</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)
pprint(backing_fire_behavior)
</pre>
</div>

<pre class="example" id="compute-crown-fire-behavior-in-direction-results">
Heading Fire Behavior
============================================================
{'fire_type': 'active_crown',
 'fireline_intensity': 78838.15458910078,
 'spread_direction': array([0.        , 0.94280905, 0.33333334]),
 'spread_rate': 31.383616202151522}

Flanking Fire Behavior
============================================================
{'fire_type': 'passive_crown',
 'fireline_intensity': 14756.204692934614,
 'spread_direction': array([ 0.94868329, -0.1054093 ,  0.29814238]),
 'spread_rate': 3.264617919639856}

Backing Fire Behavior
============================================================
{'fire_type': 'passive_crown',
 'fireline_intensity': 8139.876447202802,
 'spread_direction': array([-0.        , -0.94280905, -0.33333334]),
 'spread_rate': 2.343474267882084}
</pre>
</div>
</div>
<div id="outline-container-how-to-calculate-the-combined-surface-and-crown-fire-behavior-in-any-direction" class="outline-4">
<h4 id="how-to-calculate-the-combined-surface-and-crown-fire-behavior-in-any-direction"><span class="section-number-4">6.2.4.</span> How to Calculate the Combined Surface and Crown Fire Behavior in Any Direction</h4>
<div class="outline-text-4" id="text-how-to-calculate-the-combined-surface-and-crown-fire-behavior-in-any-direction">
<div class="org-src-container">
<pre class="src src-python" id="compute-combined-fire-behavior-in-direction"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv
<span class="org-keyword">import</span> pyretechnics.crown_fire <span class="org-keyword">as</span> cf
<span class="org-keyword">import</span> pyretechnics.fuel_models <span class="org-keyword">as</span> fm
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf
<span class="org-keyword">import</span> pyretechnics.vector_utils <span class="org-keyword">as</span> vu

<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Set input parameters</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Landscape</span>
<span class="org-variable-name">fuel_model</span>          <span class="org-operator">=</span> fm.fuel_model_table[101] <span class="org-comment-delimiter"># </span><span class="org-comment">GR1</span>
<span class="org-variable-name">canopy_cover</span>        <span class="org-operator">=</span> 0.6                      <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
<span class="org-variable-name">canopy_height</span>       <span class="org-operator">=</span> 30.0                     <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
<span class="org-variable-name">canopy_base_height</span>  <span class="org-operator">=</span> 3.0                      <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
<span class="org-variable-name">canopy_bulk_density</span> <span class="org-operator">=</span> 0.3                      <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>
<span class="org-variable-name">slope</span>               <span class="org-operator">=</span> 0.8                      <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
<span class="org-variable-name">aspect</span>              <span class="org-operator">=</span> 225.0                    <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Weather</span>
<span class="org-variable-name">fuel_moisture</span>    <span class="org-operator">=</span> [
    0.05, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_1hr</span>
    0.10, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_10hr</span>
    0.15, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_100hr</span>
    0.00, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_herbaceous (will be set by moisturize for dynamic fuel models)</span>
    0.90, <span class="org-comment-delimiter"># </span><span class="org-comment">live_herbaceous</span>
    0.60, <span class="org-comment-delimiter"># </span><span class="org-comment">live_woody</span>
]                        <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
<span class="org-variable-name">foliar_moisture</span>  <span class="org-operator">=</span> 0.9   <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
<span class="org-variable-name">wind_speed_10m</span>   <span class="org-operator">=</span> 30.0  <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
<span class="org-variable-name">upwind_direction</span> <span class="org-operator">=</span> 180.0 <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Derived Parameters</span>
<span class="org-variable-name">fuel_bed_depth</span>               <span class="org-operator">=</span> fuel_model[<span class="org-string">"delta"</span>]                      <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
<span class="org-variable-name">heat_of_combustion</span>           <span class="org-operator">=</span> conv.Btu_lb_to_kJ_kg(fuel_model[<span class="org-string">"h"</span>][0]) <span class="org-comment-delimiter"># </span><span class="org-comment">kJ/kg</span>
<span class="org-variable-name">estimated_fine_fuel_moisture</span> <span class="org-operator">=</span> fuel_moisture[0]                         <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Fire Perimeter Normal Vector</span>
<span class="org-variable-name">fire_perimeter_normal_vector_2d</span> <span class="org-operator">=</span> (1.0, 0.0) <span class="org-comment-delimiter"># </span><span class="org-comment">(x,y) unit vector pointing East</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Project the 2D fire perimeter normal vector onto the slope-tangential plane</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

<span class="org-variable-name">upslope_direction</span>               <span class="org-operator">=</span> conv.opposite_direction(aspect)
<span class="org-variable-name">slope_vector_2d</span>                 <span class="org-operator">=</span> conv.azimuthal_to_cartesian(slope, upslope_direction)
<span class="org-variable-name">fire_perimeter_normal_vector_3d</span> <span class="org-operator">=</span> vu.as_unit_vector_3d(vu.to_slope_plane(fire_perimeter_normal_vector_2d,
                                                                         slope_vector_2d))

<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate midflame wind speed</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 10m wind speed to 20ft wind speed</span>
<span class="org-variable-name">wind_speed_20ft</span> <span class="org-operator">=</span> conv.wind_speed_10m_to_wind_speed_20ft(wind_speed_10m) <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Convert 20ft wind speed from km/hr to m/min</span>
<span class="org-variable-name">wind_speed_20ft_m_min</span> <span class="org-operator">=</span> conv.km_hr_to_m_min(wind_speed_20ft) <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 20ft wind speed to midflame wind speed in m/min</span>
<span class="org-variable-name">midflame_wind_speed</span> <span class="org-operator">=</span> sf.calc_midflame_wind_speed(wind_speed_20ft_m_min,       <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
                                                  fuel_bed_depth,              <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                  conv.m_to_ft(canopy_height), <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                  canopy_cover)                <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Apply fuel moisture to fuel model</span>
<span class="org-variable-name">moisturized_fuel_model</span> <span class="org-operator">=</span> fm.moisturize(fuel_model, fuel_moisture)

<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate no-wind-no-slope surface fire behavior</span>
<span class="org-variable-name">surface_fire_min</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model)

<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread with effective wind speed limit</span>
<span class="org-variable-name">surface_fire_max</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_max(surface_fire_min,
                                                     midflame_wind_speed,
                                                     upwind_direction,
                                                     slope,
                                                     aspect)

<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction normal to the fire perimeter</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

<span class="org-variable-name">surface_fire_normal</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_in_direction(surface_fire_max, fire_perimeter_normal_vector_3d)

<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Determine whether the surface fire transitions to a crown fire</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

<span class="org-keyword">if</span> cf.van_wagner_crown_fire_initiation(surface_fire_normal[<span class="org-string">"fireline_intensity"</span>],
                                       canopy_cover,
                                       canopy_base_height,
                                       foliar_moisture):

    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction of maximum spread</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

    <span class="org-variable-name">crown_fire_max</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_max(canopy_height, canopy_base_height,
                                                     canopy_bulk_density, heat_of_combustion,
                                                     estimated_fine_fuel_moisture,
                                                     wind_speed_10m, upwind_direction,
                                                     slope, aspect)

    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction normal to the fire perimeter</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

    <span class="org-variable-name">crown_fire_normal</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_in_direction(crown_fire_max, fire_perimeter_normal_vector_3d)

    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate combined fire behavior in the direction normal to the fire perimeter</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

    <span class="org-variable-name">combined_fire_normal</span> <span class="org-operator">=</span> cf.calc_combined_fire_behavior(surface_fire_normal, crown_fire_normal)

    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Display the combined fire behavior normal to the fire perimeter</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

    <span class="org-builtin">print</span>(<span class="org-string">"Fire Behavior from Combined Surface and Crown Fire</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)
    pprint(combined_fire_normal)

<span class="org-keyword">else</span>:

    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Display the surface fire behavior normal to the fire perimeter</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

    <span class="org-builtin">print</span>(<span class="org-string">"Fire Behavior from Surface Fire (No Crown Fire Occurred)</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)
    pprint(surface_fire_normal)
</pre>
</div>

<pre class="example">
Fire Behavior from Surface Fire (No Crown Fire Occurred)
============================================================
{'fire_type': 'surface',
 'fireline_intensity': 11.637273243704481,
 'flame_length': 0.23956727406332143,
 'spread_direction': array([0.87038827, 0.        , 0.49236599]),
 'spread_rate': 0.8215819746243512}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-spot-fire-equations-(pyretechnics.spot_fire)" class="outline-2">
<h2 id="spot-fire-equations-(pyretechnics.spot_fire)"><span class="section-number-2">7.</span> Spot Fire Equations (pyretechnics.spot_fire)</h2>
<div class="outline-text-2" id="text-spot-fire-equations-(pyretechnics.spot_fire)">
</div>
<div id="outline-container-for-developers-spot" class="outline-3">
<h3 id="for-developers-spot"><span class="section-number-3">7.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-for-developers-spot">
<p>
Whether a fire is spreading through surface or canopy fuels, it is
possible that small pieces of the burning fuels may be lofted by winds
ahead of the fire front. When these burning firebrands land in
sufficiently dry fuels, they may ignite new fires under the right
conditions. Fires created in this way are called "spot fires" and are
the subject of this chapter. The following sections provide functions
for calculating the probability and rate of firebrand generation from
burning fuels, the lofting distance and direction of these firebrands,
their likelihood of surviving their flight until landing, their
likelihood of igniting spot fires once deposited, and the time to grow
from a spark to a fire capable of spreading on its own.
</p>
</div>
<div id="outline-container-expected-firebrand-production" class="outline-4">
<h4 id="expected-firebrand-production"><span class="section-number-4">7.1.1.</span> Expected Firebrand Production</h4>
<div class="outline-text-4" id="text-expected-firebrand-production">
<p>
When surface or canopy fuels burn, they emit a certain amount of heat
\(H_C\) (in \(\text{kJ}\)) before burning out as a function of their fuel
model and moisture values. In this section, we provide a function that
relates this total heat output per cell to the number of firebrands
that our spotting model will cast from that cell when it burns.
</p>

<p>
From section <a href="#surface-fire-intensity-functions">5.1.3</a>, we can see the
following relationship between a fire's spread rate \(R\) (in
\(\text{m}/\text{min}\)), fireline intensity \(I\) (in
\(\text{kW}/\text{m}\)), and heat per unit area \(H\) (in
\(\text{kJ}/\text{m}^2\)):
</p>

\begin{align}
  H = 60 \frac{I}{R}
\end{align}

<p>
We can calculate the total heat emitted by a cell on a gridded
landscape \(H_C\) by multiplying its \(H\) value by the slope-adjusted
area of the cell \(A_C\) (in \(\text{m}^2\)) as follows:
</p>

\begin{align}
  A_C &= \Delta x \, \Delta y \left[1 + \left(\frac{\partial z}{\partial x}\right)^2 + \left(\frac{\partial z}{\partial y}\right)^2 \right] \\
  \nonumber \\
  H_C &= H \, A_C
\end{align}

<p>
where \(\Delta x\) is the cell width (in \(\text{m}\)), \(\Delta y\) is the
cell height (in \(\text{m}\)), and \((\frac{\partial z}{\partial x}\),
\(\frac{\partial z}{\partial y})\) is the elevation gradient of the
cell.
</p>

<p>
A user-provided coefficient \(F_H\) ("firebrands_per_unit_heat" in
\(\text{firebrands}/\text{kJ}\)) is then combined with the total heat
per cell \(H_C\) (in \(\text{kJ}\)) to calculate the number of firebrands
to cast per cell \(F_C\):
</p>

\begin{align}
  F_C = F_H \, H_C
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="expected-firebrand-production"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> sqrt
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf


<span class="org-keyword">def</span> <span class="org-function-name">expected_firebrand_production</span>(fire_behavior, elevation_gradient, cube_resolution, firebrands_per_unit_heat<span class="org-operator">=</span>1e<span class="org-operator">-</span>6):
    <span class="org-doc">"""</span>
<span class="org-doc">    Return the expected number of firebrands produced by an entire cell when it burns given:</span>
<span class="org-doc">    - fire_behavior            :: dictionary of surface or crown fire behavior values</span>
<span class="org-doc">      - fire_type                 :: "unburned", "surface", "passive_crown", or "active_crown"</span>
<span class="org-doc">      - spread_rate               :: m/min</span>
<span class="org-doc">      - spread_direction          :: (x, y, z) unit vector on the slope-tangential plane</span>
<span class="org-doc">      - fireline_intensity        :: kW/m</span>
<span class="org-doc">      - flame_length              :: m</span>
<span class="org-doc">    - elevation_gradient       :: tuple with these fields</span>
<span class="org-doc">      - dz_dx                     :: rise/run</span>
<span class="org-doc">      - dz_dy                     :: rise/run</span>
<span class="org-doc">    - cube_resolution          :: tuple with these fields</span>
<span class="org-doc">      - band_duration             :: minutes</span>
<span class="org-doc">      - cell_height               :: meters</span>
<span class="org-doc">      - cell_width                :: meters</span>
<span class="org-doc">    - firebrands_per_unit_heat :: firebrands/kJ</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">if</span> fire_behavior[<span class="org-string">"spread_rate"</span>] <span class="org-operator">==</span> 0.0:
        <span class="org-keyword">return</span> 0.0
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the heat output per unit area</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

        <span class="org-variable-name">spread_rate</span>          <span class="org-operator">=</span> fire_behavior[<span class="org-string">"spread_rate"</span>]                               <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
        <span class="org-variable-name">fireline_intensity</span>   <span class="org-operator">=</span> fire_behavior[<span class="org-string">"fireline_intensity"</span>]                        <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
        <span class="org-variable-name">heat_output_per_area</span> <span class="org-operator">=</span> sf.calc_areal_heat_output(spread_rate, fireline_intensity) <span class="org-comment-delimiter"># </span><span class="org-comment">kJ/m^2</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the slope-adjusted cell area</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

        (<span class="org-variable-name">dz_dx</span>, <span class="org-variable-name">dz_dy</span>) <span class="org-operator">=</span> elevation_gradient                      <span class="org-comment-delimiter"># </span><span class="org-comment">(rise/run, rise/run)</span>
        <span class="org-variable-name">slope_factor</span>   <span class="org-operator">=</span> sqrt(1.0 <span class="org-operator">+</span> dz_dx <span class="org-operator">**</span> 2.0 <span class="org-operator">+</span> dz_dy <span class="org-operator">**</span> 2.0) <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
        <span class="org-variable-name">cell_height</span>    <span class="org-operator">=</span> cube_resolution[1]                      <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
        <span class="org-variable-name">cell_width</span>     <span class="org-operator">=</span> cube_resolution[2]                      <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
        <span class="org-variable-name">cell_area</span>      <span class="org-operator">=</span> cell_height <span class="org-operator">*</span> cell_width <span class="org-operator">*</span> slope_factor <span class="org-comment-delimiter"># </span><span class="org-comment">m^2</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the expected number of firebrands produced in this cell</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

        <span class="org-variable-name">cell_heat_output</span> <span class="org-operator">=</span> heat_output_per_area <span class="org-operator">*</span> cell_area            <span class="org-comment-delimiter"># </span><span class="org-comment">kJ</span>
        <span class="org-variable-name">firebrand_count</span>  <span class="org-operator">=</span> firebrands_per_unit_heat <span class="org-operator">*</span> cell_heat_output <span class="org-comment-delimiter"># </span><span class="org-comment">number of firebrands</span>
        <span class="org-keyword">return</span> firebrand_count
</pre>
</div>
</div>
</div>
<div id="outline-container-firebrand-dispersal-model" class="outline-4">
<h4 id="firebrand-dispersal-model"><span class="section-number-4">7.1.2.</span> Firebrand Dispersal Model</h4>
<div class="outline-text-4" id="text-firebrand-dispersal-model">
<p>
The Firebrand Dispersal model describes the distributions of
firebrands relative to the wind direction. The location where the
firebrand lands is represented by the random vector \(\vec{\Delta}\)
from the location of origin:
</p>

\begin{align}
  \vec{\Delta} := \Delta_X.\vec{w} + \Delta_Y.\vec{w}_\perp
\end{align}

<p>
in which \(\vec{w}, \vec{w}_\perp\) are unit vectors respectively
parallel and perpendicular to the wind direction, and \(\Delta_X,
\Delta_Y\) are the random variables for coordinates.
</p>

<p>
Following Perryman 2012, Sardoy 2008, and Himoto 2005, we model
\(\Delta_X\) and \(\Delta_Y\) to be independent, with \(\Delta_X\) following
a log-normal distribution, and \(\Delta_Y\) following a zero-mean normal
distribution, conditional on the fire behavior \(\Phi\) at the cell of
origin:<sup><a id="fnr.34" class="footref" href="#fn.34" role="doc-backlink">34</a></sup><sup>, </sup><sup><a id="fnr.35" class="footref" href="#fn.35" role="doc-backlink">35</a></sup><sup>, </sup><sup><a id="fnr.36" class="footref" href="#fn.36" role="doc-backlink">36</a></sup>
</p>

\begin{align}
  \ln (\Delta_X / \text{1m}) | \Phi \sim & \text{Normal}(\mu = \mu_X(\Phi), \sigma = \sigma_X(\Phi)) & \\
  \nonumber \\
  \Delta_Y | \Phi \sim & \text{Normal}(\mu = 0, \sigma = \sigma_Y(\Phi)) &
\end{align}

<p>
where \(\text{Normal}(\mu, \sigma)\) denotes a one-dimensional Gaussian
distribution with mean \(\mu\) and standard deviation \(\sigma\). Note
that \(\mu_X\) and \(\sigma_X\) are in log-space, therefore dimensionless.
For the sake of light notation, the conditioning on \(\Phi\) will be
implicit from now on, e.g. we will write \(\Delta_X\) instead of
\(\Delta_X | \Phi\).
</p>

<p>
Since the results are distance deltas relative to the wind direction,
we must convert this to deltas in our coordinate plane. We can convert
these deltas by using trigonometric functions.
</p>

<div class="org-src-container">
<pre class="src src-python" id="convert-deltas"><span class="org-keyword">def</span> <span class="org-function-name">delta_to_grid_dx</span>(cos_wdir, sin_wdir, delta_x, delta_y):
    <span class="org-doc">"""</span>
<span class="org-doc">    Computes the grid-aligned x coordinate of the delta vector, given the wind-aligned [&#916;X &#916;Y] coordinates.</span>
<span class="org-doc">    Returns a signed distance (same unit as &#916;X and &#916;Y).</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">wdir_x</span>      <span class="org-operator">=</span> sin_wdir
    <span class="org-variable-name">wdir_perp_x</span> <span class="org-operator">=</span> cos_wdir
    <span class="org-keyword">return</span> delta_x <span class="org-operator">*</span> wdir_x <span class="org-operator">+</span> delta_y <span class="org-operator">*</span> wdir_perp_x


<span class="org-keyword">def</span> <span class="org-function-name">delta_to_grid_dy</span>(cos_wdir, sin_wdir, delta_x, delta_y):
    <span class="org-doc">"""</span>
<span class="org-doc">    Computes the grid-aligned y coordinate of the delta vector, given the wind-aligned [&#916;X &#916;Y] coordinates.</span>
<span class="org-doc">    Returns a signed distance (same unit as &#916;X and &#916;Y).</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">wdir_y</span>      <span class="org-operator">=</span> cos_wdir  <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Should this be negative or positive?</span>
    <span class="org-variable-name">wdir_perp_y</span> <span class="org-operator">=</span> sin_wdir
    <span class="org-keyword">return</span> delta_x <span class="org-operator">*</span> wdir_y <span class="org-operator">+</span> delta_y <span class="org-operator">*</span> wdir_perp_y


<span class="org-keyword">def</span> <span class="org-function-name">distance_to_n_cells</span>(distance, cell_size):
    <span class="org-doc">"""</span>
<span class="org-doc">    Converts a delta expressed as a signed distance to one expressed as a number of grid cells.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> <span class="org-builtin">round</span>(distance <span class="org-operator">/</span> cell_size)
</pre>
</div>
</div>
</div>
<div id="outline-container-resolution-of-log-normal-parameters" class="outline-4">
<h4 id="resolution-of-log-normal-parameters"><span class="section-number-4">7.1.3.</span> Resolution of Log-Normal Parameters</h4>
<div class="outline-text-4" id="text-resolution-of-log-normal-parameters">
<p>
We now need to define the functions \(\mu_X(\Phi)\) and
\(\sigma_X(\Phi)\). Here we depart from Sardoy 2008<sup><a id="fnr.37" class="footref" href="#fn.37" role="doc-backlink">37</a></sup> and
reproduce the model of ELMFIRE<sup><a id="fnr.38" class="footref" href="#fn.38" role="doc-backlink">38</a></sup>, which models
that dependency using the following relationships between the moments
of the distribution and the fireline intensity \(I\) and wind speed \(U\):
</p>

\begin{align}
  \mathbb{E}[\Delta_X] = & \Delta_1 \left(\frac{I}{\text{1 kW/m}}\right)^{e_I} \left(\frac{U}{\text{1 m/s}}\right)^{e_U} & \\
  \nonumber \\
  \text{Var}[\Delta_X] = & r_\frac{V}{E} \mathbb{E}[\Delta_X] &
\end{align}

<p>
in which \(\Delta_1, e_I, e_U, r_\frac{V}{E}\) are configured by the
keys shown in table <a href="#tab:spotting-elmfire-params">3</a>.
</p>

<table id="tab:spotting-elmfire-params">
<caption class="t-above"><span class="table-number">Table 3:</span> Spotting parameters for the downwind distribution per the ELMFIRE model</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Parameter</th>
<th scope="col" class="org-left">Unit</th>
<th scope="col" class="org-left">Description</th>
<th scope="col" class="org-left">Configuration Key</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">\(\Delta_1\)</td>
<td class="org-left">m</td>
<td class="org-left">Mean landing distance in unit conditions</td>
<td class="org-left">downwind_distance_mean</td>
</tr>

<tr>
<td class="org-left">\(e_I\)</td>
<td class="org-left">-</td>
<td class="org-left">Fireline intensity exponent</td>
<td class="org-left">fireline_intensity_exponent</td>
</tr>

<tr>
<td class="org-left">\(e_U\)</td>
<td class="org-left">-</td>
<td class="org-left">Wind speed exponent</td>
<td class="org-left">wind_speed_exponent</td>
</tr>

<tr>
<td class="org-left">\(r_\frac{V}{E}\)</td>
<td class="org-left">m</td>
<td class="org-left">Variance-over-Mean ratio</td>
<td class="org-left">downwind_variance_mean_ratio</td>
</tr>
</tbody>
</table>

<p>
<b>Note:</b> One potential way in which this model can misbehave is that
the variance is proportional to the expected value, and therefore the
coefficient of variation is driven to zero as the expected value goes
to infinity, making the distribution less and less dispersed around
its mean. This means that, in high-wind/high-intensity conditions, all
the firebrands will tend to land at approximately the same (large)
distance, following a narrow near-normal distribution.
</p>

<p>
From the above moments, \(\mu_X\) and \(\sigma_X\) can be obtained using
the properties of the log-normal distribution:
</p>

\begin{align}
  \sigma_X^2 = & \ln \left(1 + \frac{\text{Var}[\Delta_X]}{\mathbb{E}[\Delta_X]^2}\right) & \\
  \nonumber \\
  \mu_X = & \ln \frac{\mathbb{E}[\Delta_X]^2}{\sqrt{\text{Var}[\Delta_X] + \mathbb{E}[\Delta_X]^2}} &
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="resolve-spotting-lognormal-elmfire"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> log, sqrt


<span class="org-keyword">def</span> <span class="org-function-name">resolve_exp_delta_x</span>(spot_config, fireline_intensity, wind_speed_20ft):
    <span class="org-doc">"""</span>
<span class="org-doc">    Computes the expected value E[&#916;X] (in meters) of the downwind spotting distance &#916;X given:</span>
<span class="org-doc">    - spot_config        :: a map of spotting parameters</span>
<span class="org-doc">    - fireline_intensity :: kW/m</span>
<span class="org-doc">    - wind_speed_20ft    :: m/s</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">downwind_distance_mean</span>      <span class="org-operator">=</span> spot_config[<span class="org-string">"downwind_distance_mean"</span>]
    <span class="org-variable-name">fireline_intensity_exponent</span> <span class="org-operator">=</span> spot_config[<span class="org-string">"fireline_intensity_exponent"</span>]
    <span class="org-variable-name">wind_speed_exponent</span>         <span class="org-operator">=</span> spot_config[<span class="org-string">"wind_speed_exponent"</span>]
    <span class="org-keyword">return</span> (downwind_distance_mean
            <span class="org-operator">*</span> (fireline_intensity <span class="org-operator">**</span> fireline_intensity_exponent)
            <span class="org-operator">*</span> (wind_speed_20ft <span class="org-operator">**</span> wind_speed_exponent))


<span class="org-keyword">def</span> <span class="org-function-name">resolve_var_delta_x</span>(spot_config, exp_delta_x):
    <span class="org-doc">"""</span>
<span class="org-doc">    Computes the variance Var[&#916;X] (in m^2) of the downwind spotting distance &#916;X given:</span>
<span class="org-doc">    - spot_config :: a map of spotting parameters</span>
<span class="org-doc">    - exp_delta_x :: meters (E[&#916;X])</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> spot_config[<span class="org-string">"downwind_variance_mean_ratio"</span>] <span class="org-operator">*</span> exp_delta_x


<span class="org-keyword">def</span> <span class="org-function-name">lognormal_mu_from_moments</span>(mean, variance):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">m2</span> <span class="org-operator">=</span> mean <span class="org-operator">**</span> 2.0
    <span class="org-keyword">return</span> log(m2 <span class="org-operator">/</span> sqrt(m2 <span class="org-operator">+</span> variance))


<span class="org-keyword">def</span> <span class="org-function-name">lognormal_sigma_from_moments</span>(mean, variance):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> sqrt(log(1.0 <span class="org-operator">+</span> variance <span class="org-operator">/</span> (mean <span class="org-operator">**</span> 2.0)))


<span class="org-keyword">def</span> <span class="org-function-name">resolve_lognormal_params</span>(spot_config, fireline_intensity, wind_speed_20ft):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">exp_delta_x</span> <span class="org-operator">=</span> resolve_exp_delta_x(spot_config, fireline_intensity, wind_speed_20ft)
    <span class="org-variable-name">var_delta_x</span> <span class="org-operator">=</span> resolve_var_delta_x(spot_config, exp_delta_x)
    <span class="org-keyword">return</span> {
        <span class="org-string">"prob.lognormal.mu"</span>   : lognormal_mu_from_moments(exp_delta_x, var_delta_x),
        <span class="org-string">"prob.lognormal.sigma"</span>: lognormal_sigma_from_moments(exp_delta_x, var_delta_x),
    }
</pre>
</div>
</div>
</div>
<div id="outline-container-wind-perpendicular-dispersal" class="outline-4">
<h4 id="wind-perpendicular-dispersal"><span class="section-number-4">7.1.4.</span> Wind-Perpendicular Dispersal</h4>
<div class="outline-text-4" id="text-wind-perpendicular-dispersal">
<p>
For \(\sigma_Y\), we either let the user specify an explicit value with
key <b>crosswind_distance_stdev</b> (in meters), which makes it equivalent
to the model of Perryman 2012<sup><a id="fnr.39" class="footref" href="#fn.39" role="doc-backlink">39</a></sup>, or we default to
deriving them from equation (28) of Himoto 2005<sup><a id="fnr.40" class="footref" href="#fn.40" role="doc-backlink">40</a></sup>, which
is equivalent to:
</p>

\begin{align}
  \sigma_Y = 0.92 D = 0.92 \frac{0.47}{0.88^2}\frac{\text{Var}[\Delta_X]}{\mathbb{E}[\Delta_X]}
\end{align}

<p>
\(\text{Var}[\Delta_X]\) and \(\mathbb{E}[\Delta_X]\) can be calculated
from the properties of the log-normal distribution:
</p>

\begin{align}
  \mathbb{E}[\Delta_X] = \text{1m} \times \exp \left(\mu_X + \frac{1}{2}\sigma_X^2 \right) \\
  \nonumber \\
  \text{Var}[\Delta_X] = \mathbb{E}[\Delta_X]^2 \left(e^{\sigma_X^2} - 1\right)
\end{align}

<p>
Combining the above equations and applying some algebra yields a
formula for \(\sigma_Y\):
</p>

\begin{align}
  \sigma_Y = 0.92 D = \text{1m} \times 0.5584 \times e^{\mu_X} \times e^{\frac{1}{2}\sigma_X^2} \left(e^{\frac{1}{2}\sigma_X^2} - 1\right) \left(e^{\frac{1}{2}\sigma_X^2} + 1\right)
\end{align}

<p>
Typical values are shown in table <a href="#tab:himoto2005-example-values">4</a>.
</p>

<table id="tab:himoto2005-example-values">
<caption class="t-above"><span class="table-number">Table 4:</span> Typical values for \(\vec{\Delta}\) distribution characteristics derived from Himoto2005</caption>

<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(B^*\)</th>
<th scope="col" class="org-right">\(\text{CV}[\Delta_X]\)</th>
<th scope="col" class="org-right">\(\sigma_X\)</th>
<th scope="col" class="org-right">\(\sigma_Y/\mathbb{E}[\Delta_X]\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">20</td>
<td class="org-right">69%</td>
<td class="org-right">0.72</td>
<td class="org-right">0.27</td>
</tr>

<tr>
<td class="org-right">50</td>
<td class="org-right">51%</td>
<td class="org-right">0.64</td>
<td class="org-right">0.14</td>
</tr>

<tr>
<td class="org-right">100</td>
<td class="org-right">40%</td>
<td class="org-right">0.58</td>
<td class="org-right">0.09</td>
</tr>

<tr>
<td class="org-right">150</td>
<td class="org-right">35%</td>
<td class="org-right">0.55</td>
<td class="org-right">0.07</td>
</tr>

<tr>
<td class="org-right">200</td>
<td class="org-right">32%</td>
<td class="org-right">0.53</td>
<td class="org-right">0.06</td>
</tr>
</tbody>
</table>

<p>
See section <a href="#how-to-estimate-typical-ranges-for-the-$\vec{\delta}$-distribution-characteristics">7.2.3</a> for more information on how these values
were obtained.
</p>

<p>
<b>CAUTION:</b> (FIXME REVIEW) We have found the above formula to be
problematic when applied to the parameters values found in Sardoy
2008<sup><a id="fnr.41" class="footref" href="#fn.41" role="doc-backlink">41</a></sup> because it tends to yield nonsensical \(\sigma_Y >
\mathbb{E}[\Delta_X]\). In fact, it can be seen that \(\sigma_Y > s
\mathbb{E}[\Delta_X]\) if and only if \(\sigma_X > \sqrt{\ln \left(1 +
\frac{.88^2}{.92 \times .47} s \right)}\), in particular \(\sigma_X >
1.013\) for \(s = 1\), which is unfortunately the case with the range of
\(\sigma_X\) values in Sardoy 2008<sup><a id="fnr.42" class="footref" href="#fn.42" role="doc-backlink">42</a></sup>. This reflects a
divergence between Himoto 2005<sup><a id="fnr.43" class="footref" href="#fn.43" role="doc-backlink">43</a></sup> and Sardoy
2008<sup><a id="fnr.44" class="footref" href="#fn.44" role="doc-backlink">44</a></sup>, the latter allowing for more dispersed
\(\Delta_X\) distributions (higher coefficient of variation
\(\text{Var}[\Delta_X]^{\frac{1}{2}}/\mathbb{E}[\Delta_X] =
\sqrt{e^{\sigma_X^2} - 1}\)), whereas the former typically predicts a
low coefficient of variation, as is perceptible in figure 6 of Himoto
2005<sup><a id="fnr.45" class="footref" href="#fn.45" role="doc-backlink">45</a></sup>. Figure 10 of Sardoy 2008<sup><a id="fnr.46" class="footref" href="#fn.46" role="doc-backlink">46</a></sup>
suggests coefficients of variation ranging from 95% to 210%, whereas
Figure 6 of Himoto 2005<sup><a id="fnr.47" class="footref" href="#fn.47" role="doc-backlink">47</a></sup> suggests coefficients of
variation ranging from 30% to 70%. For this reason, we <b>strongly
recommend to supply \(\sigma_Y\) directly</b> through the configuration key
<b>crosswind_distance_stdev</b>.
</p>
</div>
</div>
<div id="outline-container-sampling-firebrand-casting-distances" class="outline-4">
<h4 id="sampling-firebrand-casting-distances"><span class="section-number-4">7.1.5.</span> Sampling Firebrand Casting Distances</h4>
<div class="outline-text-4" id="text-sampling-firebrand-casting-distances">
<p>
Having computed the \(\mu_X\), \(\sigma_X\) and \(\sigma_Y\) parameters, it
remains to draw values of \(\Delta_X\) and \(\Delta_Y\) by sampling from
log-normal and normal distributions. This can be done by sampling from
a standard normal distribution, then transforming by affine and
exponential functions:
</p>

<div class="org-src-container">
<pre class="src src-python" id="sardoy-firebrand-dispersal"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> exp, sqrt, log
<span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv


<span class="org-keyword">def</span> <span class="org-function-name">sample_normal</span>(random_generator, mu, sd):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns sample from normal/gaussian distribution given mu and sd.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> random_generator.normal(mu, sd)


<span class="org-keyword">def</span> <span class="org-function-name">sample_lognormal</span>(random_generator, mu, sd):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns sample from log-normal distribution given mu and sd.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> random_generator.lognormal(mu, sd)


<span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: unused</span>
<span class="org-keyword">def</span> <span class="org-function-name">deltax_expected_value</span>(mu_x, sigma_x):
    <span class="org-keyword">return</span> conv.m_to_ft(exp(mu_x <span class="org-operator">+</span> (sigma_x <span class="org-operator">**</span> 2.0) <span class="org-operator">/</span> 2.0))


<span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: unused</span>
<span class="org-keyword">def</span> <span class="org-function-name">deltax_coefficient_of_variation</span>(sigma_x):
    <span class="org-keyword">return</span> sqrt(exp(sigma_x <span class="org-operator">**</span> 2.0) <span class="org-operator">-</span> 1.0)


<span class="org-keyword">def</span> <span class="org-function-name">delta_x_sampler</span>(spot_config, fireline_intensity, wind_speed_20ft):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns a function for randomly sampling &#916;X, the spotting jump along the wind direction (in meters).</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">ln_params</span> <span class="org-operator">=</span> resolve_lognormal_params(spot_config, fireline_intensity, wind_speed_20ft)
    <span class="org-variable-name">mu_x</span>      <span class="org-operator">=</span> ln_params[<span class="org-string">"prob.lognormal.mu"</span>]    <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
    <span class="org-variable-name">sigma_x</span>   <span class="org-operator">=</span> ln_params[<span class="org-string">"prob.lognormal.sigma"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
    <span class="org-keyword">return</span> <span class="org-keyword">lambda</span> random_generator: sample_lognormal(random_generator, mu_x, sigma_x) <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>


<span class="org-comment-delimiter"># </span><span class="org-comment">When will we have the default sigma_Y &gt; E[&#916;X]?</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">It can be seen that this nonsensical situation</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">happens iff sigma_X exceeds the following number:</span>
<span class="org-comment-delimiter">#</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">sqrt(log(1.0 + (0.88 ** 2.0) / (0.92 * 0.47))</span>
<span class="org-comment-delimiter">#</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">=&gt; 1.0131023746492023</span>
<span class="org-variable-name">sigma_y_scalar_m</span> <span class="org-operator">=</span> 0.92 <span class="org-operator">*</span> 0.47 <span class="org-operator">/</span> (0.88 <span class="org-operator">**</span> 2.0)


<span class="org-keyword">def</span> <span class="org-function-name">himoto_resolve_default_sigma_y_from_lognormal_params</span>(mu_x, sigma_x):
    <span class="org-variable-name">es2h</span>       <span class="org-operator">=</span> exp((sigma_x <span class="org-operator">**</span> 2.0) <span class="org-operator">/</span> 2.0)
    <span class="org-variable-name">avg_deltax</span> <span class="org-operator">=</span> exp(mu_x) <span class="org-operator">*</span> es2h
    <span class="org-keyword">return</span> sigma_y_scalar_m <span class="org-operator">*</span> avg_deltax <span class="org-operator">*</span> (es2h <span class="org-operator">+</span> 1.0) <span class="org-operator">*</span> (es2h <span class="org-operator">-</span> 1.0) <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>


<span class="org-keyword">def</span> <span class="org-function-name">himoto_resolve_default_sigma_y</span>(spot_config, fireline_intensity, wind_speed_20ft):
    <span class="org-variable-name">ln_params</span> <span class="org-operator">=</span> resolve_lognormal_params(spot_config, fireline_intensity, wind_speed_20ft)
    <span class="org-variable-name">mu_x</span>      <span class="org-operator">=</span> ln_params[<span class="org-string">"prob.lognormal.mu"</span>]    <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
    <span class="org-variable-name">sigma_x</span>   <span class="org-operator">=</span> ln_params[<span class="org-string">"prob.lognormal.sigma"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
    <span class="org-keyword">return</span> himoto_resolve_default_sigma_y_from_lognormal_params(mu_x, sigma_x) <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>


<span class="org-keyword">def</span> <span class="org-function-name">resolve_crosswind_distance_stdev</span>(spot_config, fireline_intensity, wind_speed_20ft):
    <span class="org-variable-name">crosswind_distance_stdev</span> <span class="org-operator">=</span> spot_config.get(<span class="org-string">"crosswind_distance_stdev"</span>)
    <span class="org-keyword">if</span> crosswind_distance_stdev <span class="org-operator">!=</span> <span class="org-constant">None</span>:
        <span class="org-keyword">return</span> crosswind_distance_stdev <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> himoto_resolve_default_sigma_y(spot_config, fireline_intensity, wind_speed_20ft) <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>


<span class="org-keyword">def</span> <span class="org-function-name">delta_y_sampler</span>(spot_config, fireline_intensity, wind_speed_20ft):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns a function for randomly sampling &#916;Y, the spotting jump perpendicular to the wind direction (in meters).</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">sigma_y</span> <span class="org-operator">=</span> resolve_crosswind_distance_stdev(spot_config, fireline_intensity, wind_speed_20ft) <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
    <span class="org-keyword">return</span> <span class="org-keyword">lambda</span> random_generator: sample_normal(random_generator, 0.0, sigma_y) <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-spotting-probability-and-number-of-firebrands" class="outline-4">
<h4 id="spotting-probability-and-number-of-firebrands"><span class="section-number-4">7.1.6.</span> Spotting Probability and Number of Firebrands</h4>
<div class="outline-text-4" id="text-spotting-probability-and-number-of-firebrands">
<p>
Whether or not a cell emits firebrands is determined by a spotting
probability. Pyretechnics lets users configure separate spotting
probabilities for crown fires (<b>crown_fire_spotting_percent</b>) and for
surface fires under certain conditions
(<b>surface_fire_spotting_percent</b>). Note that these configuration keys
have misleading names (the values must be between 0 and 1).
</p>

<p>
Surface fire spotting can only happen when the fireline intensity
exceeds a certain threshold (configured with
<b>critical_fireline_intensity</b>). Both that threshold and the spotting
probability can be configured per fuel model.
</p>

<div class="org-src-container">
<pre class="src src-python" id="sample-number-of-firebrands"><span class="org-keyword">def</span> <span class="org-function-name">sample_poisson</span>(random_generator, mu):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns sample from poisson distribution given mu.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> random_generator.poisson(mu)


<span class="org-keyword">def</span> <span class="org-function-name">sample_number_of_firebrands</span>(random_generator, expected_firebrand_count):
    <span class="org-keyword">return</span> sample_poisson(random_generator, expected_firebrand_count)
</pre>
</div>

<p>
If spotting occurs at a cell, the number of firebrands is randomly
drawn from a Poisson distribution, the mean of which is configured
with key <b>num_firebrands</b>. As such, non-integer values are allowed for
<b>num_firebrands</b>. The use of a Poisson distribution can help make the
behavior robust to changes in simulation resolution. That being said,
note that <b>num_firebrands</b> and/or the spotting probabilities will need
to be adjusted if you change the simulation resolution, the essential
invariant being the average number of firebrands per unit area. What's
more, it may be sensible to set the spotting probability to 1 and
compensate with a low Poisson mean.
</p>
</div>
</div>
<div id="outline-container-spot-ignition-model" class="outline-4">
<h4 id="spot-ignition-model"><span class="section-number-4">7.1.7.</span> Spot Ignition Model</h4>
<div class="outline-text-4" id="text-spot-ignition-model">
<p>
The Spot Ignition model describes the probability of a spot ignition
as well as when the spot ignition should occur. Perryman 2012 uses the
method described in Schroeder 1969 but adjusts the result to take into
account the distance a firebrand lands from the source tree (using
Albini 1979) and the number of firebrands that land in a cell (using
Stauffer
2008).<sup><a id="fnr.48" class="footref" href="#fn.48" role="doc-backlink">48</a></sup><sup>, </sup><sup><a id="fnr.49" class="footref" href="#fn.49" role="doc-backlink">49</a></sup><sup>, </sup><sup><a id="fnr.50" class="footref" href="#fn.50" role="doc-backlink">50</a></sup><sup>, </sup><sup><a id="fnr.51" class="footref" href="#fn.51" role="doc-backlink">51</a></sup>
</p>

\begin{align}
  P(I)_l = P(I)\exp(-\lambda_s l) \\
  \nonumber \\
  P(I)_l^{FB} = 1 - (1 - P(I)_l)^{n_b}
\end{align}

<p>
where \(\lambda_s\) is a positive number representing the decay
constant, \(l\) is the firebrand's landing distance away from the source
cell. \(P(I)_l\) is the probability of spot ignition taking into
consideration \(l\). \(P(I)_l^{FB}\) is the probability of spot fire
ignition taking into consideration \(n_b\), the number of firebrands
landing in a cell.
</p>

<p>
We observe that the second formula is equivalent to a model where the
firebrands are i.i.d causes of ignition (this is consistent with the
goal of making the model insensitive to grid resolution). Therefore,
Pyretechnics will simply draw an independent Bernoulli trial for each
firebrand rather than apply the above formula.
</p>

<p>
The first formula simply says that the per-firebrand probability
decays exponentially with distance (i.e. adding \(1/\lambda_s\) to the
distance divides the probability by \(e\), or equivalently \(l \mapsto
P(I)_l\) has derivative \(\lambda_s P(I)_l\)). Yet another way to say
this is that, if \(\lambda_s = \text{0.005 m}^{-1}\), then each added
meter decreases \(P(I)_l\) by 0.5%.
</p>

<div class="org-src-container">
<pre class="src src-python" id="firebrand-ignition-probability"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> exp


<span class="org-keyword">def</span> <span class="org-function-name">firebrand_flight_survival_probability</span>(spotting_distance, decay_distance):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the probability that a firebrand will survive its flight (Perryman 2012) given:</span>
<span class="org-doc">    - spotting_distance :: meters (d)</span>
<span class="org-doc">    - decay_distance    :: meters (1/lambda)</span>

<span class="org-doc">    P(Survival) = exp(-d * lambda)</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> exp(<span class="org-operator">-</span>spotting_distance <span class="org-operator">/</span> decay_distance)


<span class="org-keyword">def</span> <span class="org-function-name">heat_of_preignition</span>(temperature, fine_fuel_moisture):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns heat of preignition given:</span>
<span class="org-doc">    - temperature        :: degrees Celsius</span>
<span class="org-doc">    - fine_fuel_moisture :: 0-1</span>

<span class="org-doc">    Q_ig = 144.512 - 0.266 * T_o - 0.00058 * (T_o)^2 - T_o * M + 18.54 * (1 - exp(-15.1 * M)) + 640 * M (eq. 10)</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">T_o</span> <span class="org-operator">=</span> temperature
    <span class="org-variable-name">M</span>   <span class="org-operator">=</span> fine_fuel_moisture
    <span class="org-comment-delimiter"># </span><span class="org-comment">Heat required to reach ignition temperature</span>
    <span class="org-variable-name">Q_a</span> <span class="org-operator">=</span> 144.512 <span class="org-operator">-</span> 0.266 <span class="org-operator">*</span> T_o <span class="org-operator">-</span> 0.00058 <span class="org-operator">*</span> (T_o <span class="org-operator">**</span> 2.0)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Heat required to raise moisture to the boiling point</span>
    <span class="org-variable-name">Q_b</span> <span class="org-operator">=</span> <span class="org-operator">-</span>T_o <span class="org-operator">*</span> M
    <span class="org-comment-delimiter"># </span><span class="org-comment">Heat of desorption</span>
    <span class="org-variable-name">Q_c</span> <span class="org-operator">=</span> 18.54 <span class="org-operator">*</span> (1.0 <span class="org-operator">-</span> exp(<span class="org-operator">-</span>15.1 <span class="org-operator">*</span> M))
    <span class="org-comment-delimiter"># </span><span class="org-comment">Heat required to vaporize moisture</span>
    <span class="org-variable-name">Q_d</span> <span class="org-operator">=</span> 640.0 <span class="org-operator">*</span> M
    <span class="org-keyword">return</span> Q_a <span class="org-operator">+</span> Q_b <span class="org-operator">+</span> Q_c <span class="org-operator">+</span> Q_d


<span class="org-keyword">def</span> <span class="org-function-name">schroeder_ignition_probability</span>(temperature, fine_fuel_moisture):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the probability of spot fire ignition (Schroeder 1969) given:</span>
<span class="org-doc">    - temperature        :: degrees Celsius</span>
<span class="org-doc">    - fine_fuel_moisture :: 0-1</span>

<span class="org-doc">    X           = (400 - Q_ig) / 10</span>
<span class="org-doc">    P(Ignition) = (0.000048 * X^4.3) / 50 (pg. 15)</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">Q_ig</span>        <span class="org-operator">=</span> heat_of_preignition(temperature, fine_fuel_moisture)
    <span class="org-variable-name">X</span>           <span class="org-operator">=</span> <span class="org-builtin">max</span>(0.0, 400.0 <span class="org-operator">-</span> Q_ig) <span class="org-operator">/</span> 10.0
    <span class="org-variable-name">P_Ignition</span>  <span class="org-operator">=</span> 0.000048 <span class="org-operator">*</span> (X <span class="org-operator">**</span> 4.3) <span class="org-operator">/</span> 50.0
    <span class="org-keyword">return</span> <span class="org-builtin">min</span>(P_Ignition, 1.0)
</pre>
</div>

<p>
A firebrand will cause an unburned cell to transition to a burned
state if the cell receives at least one firebrand and the cell's
probability of ignition as calculated by the above equations is
greater than a randomly generated uniform number.
</p>
</div>
</div>
<div id="outline-container-time-to-spot-ignition" class="outline-4">
<h4 id="time-to-spot-ignition"><span class="section-number-4">7.1.8.</span> Time to Spot Ignition</h4>
<div class="outline-text-4" id="text-time-to-spot-ignition">
<p>
Once a cell has been determined to ignite, then the time until
ignition is calculated. The time until ignition is a sum of three time
intervals: the amount of time required for the firebrand to reach its
maximum vertical height \(t_v\), the amount of time required for the
firebrand to descend from the maximum vertical height to the forest
floor \(t_g\), and the amount of time required for a spot fire to ignite
and build up to the steady-state \(t_I\). Perryman
2012<sup><a id="fnr.52" class="footref" href="#fn.52" role="doc-backlink">52</a></sup> assumes \(t_v\) and \(t_g\) to be equal and used
the formula from Albini 1979<sup><a id="fnr.53" class="footref" href="#fn.53" role="doc-backlink">53</a></sup> to calculate it.
\(t_I\) is also assumed to be 20 min as used in McAlpine
1991<sup><a id="fnr.54" class="footref" href="#fn.54" role="doc-backlink">54</a></sup>.
</p>

<p>
By Albini 1979<sup><a id="fnr.55" class="footref" href="#fn.55" role="doc-backlink">55</a></sup>, the time \(t_v\) for a firebrand to
reach height \(z\) when the flame length is \(z_F\) is given by:
</p>

\begin{align}
  t_v &= \frac{2 z_F}{w_F} \left(1.2 + \frac{a}{3} \left[ \left(\frac{b + (z/z_F)}{a}\right)^\frac{3}{2} - 1 \right] \right) & \\
  \nonumber \\
  w_F &= 2.3 \text{ m/s} \sqrt{\frac{z_F}{1 \text{ m}}} & \\
  \nonumber \\
  a   &= 5.963 & \\
  \nonumber \\
  b   &=  a - 1.4 & \\
\end{align}

<p>
In the notation of Albini 1979<sup><a id="fnr.56" class="footref" href="#fn.56" role="doc-backlink">56</a></sup>, we would have \(t_v
= \frac{2 z_F}{w_F}(t_T - t_o)\).
</p>

<p>
Albini 1979<sup><a id="fnr.57" class="footref" href="#fn.57" role="doc-backlink">57</a></sup> also provides a formula - (D44) - for
the maximum height \(z_\text{max}\) that a firebrand can reach while
still glowing when it hits the ground, as a function of the firebrand
diameter \(D\) in a cylinder model:
</p>

\begin{align}
  z_\text{max} = D \times 0.39 \times 10^5
\end{align}

<p>
To estimate firebrand travel time, Pyretechnics makes the assumption
that each firebrand will reach \(z_\text{max}\), where \(z_\text{max}\) is
computed for \(D = 3\text{mm}\), yielding \(z_\text{max} = 117 \text{m}\).
</p>

<p>
To make the above formulas more tangible, observe that when the flame
length is small enough that \(z_F \ll z_\text{max}\), the above formulas
simplify into the following approximation:
</p>

\begin{align}
  t_v \underset{z_F \ll z_\text{max}}{\approx} \frac{2}{3 \sqrt{a}} \frac{\sqrt{z_\text{max} \times 1Â \text{m}}}{2.3 \text{m/s}}\frac{z_\text{max}}{z_F}
\end{align}

<p>
Plugging in Pyretechnics' choice of \(z_\text{max} = 117 \text{m}\)
yields:
</p>

\begin{align}
  t_v \underset{z_F \ll z_\text{max}}{\approx} 1.28 \text{s} \times \frac{117 \text{m}}{z_F}
\end{align}

<p>
In other words, in the limit of small-enough flame lengths, the
firebrand is assumed to elevate at a constant vertical speed
\((z_F/1.28 \text{s})\) which is proportional to the flame length, until
it reaches \(z_\text{max} = 117 \text{m}\). For example, if the flame
length is 1.17m (100x smaller than \(z_\text{max}\)), \(t_v\) is about
128s.
</p>

<div class="org-src-container">
<pre class="src src-python" id="firebrands-time-of-ignition"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> sqrt
<span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv


<span class="org-keyword">def</span> <span class="org-function-name">albini_firebrand_maximum_height</span>(firebrand_diameter):
    <span class="org-keyword">return</span> 0.39e5 <span class="org-operator">*</span> firebrand_diameter


<span class="org-keyword">def</span> <span class="org-function-name">albini_t_max</span>(flame_length):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the time of spot ignition using Albini1979spot in minutes given:</span>
<span class="org-doc">    - flame_length :: meters [z_F]</span>

<span class="org-doc">    a           = 5.963                                                             (D33)</span>
<span class="org-doc">    b           = a - 1.4                                                           (D34)</span>
<span class="org-doc">    D           = 0.003</span>
<span class="org-doc">    z           = 0.39 * D * 10^5</span>
<span class="org-doc">    w_F         = 2.3 * z_F^0.5                                                     (A58)</span>
<span class="org-doc">    t_c         = 1</span>
<span class="org-doc">    t_o         = t_c / (2 * z_F / w_F)</span>
<span class="org-doc">    travel_time = t_1 + t_2 + t_3 = 1.2 + (a / 3) * (((b + (z/z_F)) / a)^3/2 - 1)   (D43)</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">a</span>           <span class="org-operator">=</span> 5.963  <span class="org-comment-delimiter"># </span><span class="org-comment">dimensionless constant from (D33)</span>
    <span class="org-variable-name">b</span>           <span class="org-operator">=</span> 4.563  <span class="org-comment-delimiter"># </span><span class="org-comment">dimensionless constant from (D34)</span>
    <span class="org-variable-name">z</span>           <span class="org-operator">=</span> 117.0  <span class="org-comment-delimiter"># </span><span class="org-comment">maximum altitude of firebrands in meters [derived for (D44) in (Albini1979spot)]</span>
    <span class="org-variable-name">z_F</span>         <span class="org-operator">=</span> flame_length                      <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-variable-name">w_F</span>         <span class="org-operator">=</span> 2.3 <span class="org-operator">*</span> sqrt(flame_length)          <span class="org-comment-delimiter"># </span><span class="org-comment">m/s</span>
    <span class="org-variable-name">charact_t</span>   <span class="org-operator">=</span> conv.sec_to_min(2.0 <span class="org-operator">*</span> z_F <span class="org-operator">/</span> w_F)  <span class="org-comment-delimiter"># </span><span class="org-comment">min</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">The following dimensionless factor is equal to t_T - t_o, with t_T defined by (D43) in Albini1979spot.</span>
    <span class="org-variable-name">travel_time</span> <span class="org-operator">=</span> 1.2 <span class="org-operator">+</span> (a <span class="org-operator">/</span> 3.0) <span class="org-operator">*</span> (((b <span class="org-operator">+</span> z <span class="org-operator">/</span> z_F) <span class="org-operator">/</span> a) <span class="org-operator">**</span> 1.5 <span class="org-operator">-</span> 1.0)
    <span class="org-keyword">return</span> charact_t <span class="org-operator">*</span> travel_time


<span class="org-keyword">def</span> <span class="org-function-name">spot_ignition_time</span>(time_of_arrival, flame_length):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the time of spot ignition using Albini 1979 and Perryman 2012 in minutes given:</span>
<span class="org-doc">    - time_of_arrival :: minutes</span>
<span class="org-doc">    - flame_length    :: meters</span>

<span class="org-doc">    t_spot = time_of_arrival + (2 * t_max) + t_ss</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">t_max</span>          <span class="org-operator">=</span> albini_t_max(flame_length)
    <span class="org-variable-name">t_steady_state</span> <span class="org-operator">=</span> 20.0 <span class="org-comment-delimiter"># </span><span class="org-comment">period of building up to steady state from ignition (min)</span>
    <span class="org-keyword">return</span> time_of_arrival <span class="org-operator">+</span> 2.0 <span class="org-operator">*</span> t_max <span class="org-operator">+</span> t_steady_state
</pre>
</div>
</div>
</div>
<div id="outline-container-spreading-firebrands" class="outline-4">
<h4 id="spreading-firebrands"><span class="section-number-4">7.1.9.</span> Spreading Firebrands</h4>
<div class="outline-text-4" id="text-spreading-firebrands">
<p>
Once the locations, ignition probabilities, and times of ignition have
been calculated for each of the firebrands, a tuple of
<b>(spot_ignition_time, ignition_locations)</b> are returned, to be
processed in the fire spread algorithm (see section <a href="#fire-spread-algorithm:-eulerian-level-set-method-(pyretechnics.eulerian_level_set)">9</a>), where <b>spot_ignition_time</b> is the
ignition time of the spot fire in minutes, and <b>ignition_locations</b> is
a list of <b>(y,x)</b> grid coordinates in which spot fires will be
ignited.
</p>


<div class="org-src-container">
<pre class="src src-python" id="spread-firebrands"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> sin, cos, hypot, radians
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv
<span class="org-keyword">import</span> pyretechnics.fuel_models <span class="org-keyword">as</span> fm


<span class="org-keyword">def</span> <span class="org-function-name">is_in_bounds</span>(y, x, rows, cols):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns True if the grid coordinate (y,x) lies within the bounds [0,rows) by [0,cols).</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> (y <span class="org-operator">&gt;=</span> 0) <span class="org-keyword">and</span> (x <span class="org-operator">&gt;=</span> 0) <span class="org-keyword">and</span> (y <span class="org-operator">&lt;</span> rows) <span class="org-keyword">and</span> (x <span class="org-operator">&lt;</span> cols)


<span class="org-keyword">def</span> <span class="org-function-name">is_burnable_cell</span>(fuel_model_cube, t, y, x):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns True if the space-time coordinate (t,y,x) contains a burnable fuel model.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">fuel_model_number</span> <span class="org-operator">=</span> fuel_model_cube.get(t,y,x)
    <span class="org-variable-name">fuel_model</span>        <span class="org-operator">=</span> fm.fuel_model_table.get(fuel_model_number)
    <span class="org-keyword">return</span> fuel_model <span class="org-keyword">and</span> fuel_model[<span class="org-string">"burnable"</span>]


<span class="org-keyword">def</span> <span class="org-function-name">cast_firebrand</span>(random_generator,
                   fuel_model_cube,
                   temperature_cube,
                   fuel_moisture_dead_1hr_cube,
                   fire_type_matrix,
                   firebrand_count_matrix, <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: May be None</span>
                   rows,
                   cols,
                   cell_height,
                   cell_width,
                   source_t,
                   source_y,
                   source_x,
                   decay_distance,
                   cos_wdir,
                   sin_wdir,
                   sample_delta_y_fn,
                   sample_delta_x_fn):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    Draws a random [&#916;X, &#916;Y] pair of signed distances (in meters) from</span>
<span class="org-doc">    the supplied cell, representing the coordinates of the spotting jump in the directions</span>
<span class="org-doc">    parallel and perpendicular to the wind. &#916;X will typically be positive (downwind),</span>
<span class="org-doc">    and positive &#916;Y means to the right of the downwind direction.</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Determine where the firebrand will land</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>

    <span class="org-variable-name">delta_y</span>  <span class="org-operator">=</span> sample_delta_y_fn(random_generator)                    <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
    <span class="org-variable-name">delta_x</span>  <span class="org-operator">=</span> sample_delta_x_fn(random_generator)                    <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
    <span class="org-variable-name">grid_dy</span>  <span class="org-operator">=</span> delta_to_grid_dy(cos_wdir, sin_wdir, delta_x, delta_y) <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
    <span class="org-variable-name">grid_dx</span>  <span class="org-operator">=</span> delta_to_grid_dx(cos_wdir, sin_wdir, delta_x, delta_y) <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
    <span class="org-variable-name">target_y</span> <span class="org-operator">=</span> source_y <span class="org-operator">+</span> distance_to_n_cells(grid_dy, cell_height)
    <span class="org-variable-name">target_x</span> <span class="org-operator">=</span> source_x <span class="org-operator">+</span> distance_to_n_cells(grid_dx, cell_width)

    <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Determine whether the firebrand will start a fire or fizzle out</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>

    <span class="org-keyword">if</span> is_in_bounds(target_y, target_x, rows, cols) <span class="org-keyword">and</span> fire_type_matrix[target_y,target_x] <span class="org-operator">==</span> 0:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Firebrand landed on the grid in an unburned cell, so record it in firebrand_count_matrix (if provided)</span>
        <span class="org-keyword">if</span> <span class="org-builtin">isinstance</span>(firebrand_count_matrix, np.ndarray):
            <span class="org-variable-name">firebrand_count_matrix</span>[<span class="org-variable-name">target_y</span>,<span class="org-variable-name">target_x</span>] <span class="org-operator">+=</span> 1

        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the probability that the firebrand survived its flight and landed while still burning</span>
        <span class="org-variable-name">spotting_distance</span>           <span class="org-operator">=</span> hypot(grid_dx, grid_dy) <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
        <span class="org-variable-name">flight_survival_probability</span> <span class="org-operator">=</span> firebrand_flight_survival_probability(spotting_distance, decay_distance)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Roll the dice</span>
        <span class="org-variable-name">uniform_sample</span> <span class="org-operator">=</span> random_generator.uniform(0.0, 1.0)

        <span class="org-keyword">if</span> (uniform_sample <span class="org-operator">&lt;=</span> flight_survival_probability
            <span class="org-keyword">and</span> is_burnable_cell(fuel_model_cube, source_t, target_y, target_x)):
            <span class="org-comment-delimiter"># </span><span class="org-comment">Firebrand landed in a cell with a burnable fuel model, so calculate its ignition probability</span>
            <span class="org-variable-name">temperature</span>          <span class="org-operator">=</span> temperature_cube.get(source_t, target_y, target_x)            <span class="org-comment-delimiter"># </span><span class="org-comment">degrees Celsius</span>
            <span class="org-variable-name">fine_fuel_moisture</span>   <span class="org-operator">=</span> fuel_moisture_dead_1hr_cube.get(source_t, target_y, target_x) <span class="org-comment-delimiter"># </span><span class="org-comment">kg/kg</span>
            <span class="org-variable-name">ignition_probability</span> <span class="org-operator">=</span> schroeder_ignition_probability(temperature, fine_fuel_moisture)

            <span class="org-keyword">if</span> uniform_sample <span class="org-operator">&lt;=</span> flight_survival_probability <span class="org-operator">*</span> ignition_probability:
                <span class="org-comment-delimiter"># </span><span class="org-comment">Firebrand ignited the target cell, so return its coordinates for later processing</span>
                <span class="org-keyword">return</span> (target_y, target_x)


<span class="org-keyword">def</span> <span class="org-function-name">spread_firebrands</span>(space_time_cubes, output_matrices, cube_resolution, space_time_coordinate,
                      random_generator, expected_firebrand_count, spot_config):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - space_time_cubes          :: dictionary of (Lazy)SpaceTimeCube objects with these cell types</span>
<span class="org-doc">      - fuel_model                    :: integer index in fm.fuel_model_table</span>
<span class="org-doc">      - temperature                   :: degrees Celsius</span>
<span class="org-doc">      - wind_speed_10m                :: km/hr</span>
<span class="org-doc">      - upwind_direction              :: degrees clockwise from North</span>
<span class="org-doc">      - fuel_moisture_dead_1hr        :: kg moisture/kg ovendry weight</span>
<span class="org-doc">    - output_matrices           :: dictionary of 2D Numpy arrays whose spatial dimensions match the space_time_cubes</span>
<span class="org-doc">      - fire_type                     :: 2D byte array (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)</span>
<span class="org-doc">      - fireline_intensity            :: 2D float array (kW/m)</span>
<span class="org-doc">      - flame_length                  :: 2D float array (m)</span>
<span class="org-doc">      - time_of_arrival               :: 2D float array (min)</span>
<span class="org-doc">      - firebrand_count               :: 2D integer array (number of firebrands) (Optional)</span>
<span class="org-doc">    - cube_resolution           :: tuple with these fields</span>
<span class="org-doc">      - band_duration                 :: minutes</span>
<span class="org-doc">      - cell_height                   :: meters</span>
<span class="org-doc">      - cell_width                    :: meters</span>
<span class="org-doc">    - space_time_coordinate     :: (t,y,x) coordinate in which the source cell burns</span>
<span class="org-doc">    - random_generator          :: numpy.random.Generator</span>
<span class="org-doc">    - expected_firebrand_count  :: expected number of firebrands to cast</span>
<span class="org-doc">    - spot_config               :: dictionary of spotting parameters</span>
<span class="org-doc">      - downwind_distance_mean        :: meters</span>
<span class="org-doc">      - fireline_intensity_exponent   :: downwind_distance_mean multiplier [I^fireline_intensity_exponent]</span>
<span class="org-doc">      - wind_speed_exponent           :: downwind_distance_mean multiplier [U^wind_speed_exponent]</span>
<span class="org-doc">      - downwind_variance_mean_ratio  :: meters^2 / meter [downwind_variance_mean_ratio = Var(X) / E(X)]</span>
<span class="org-doc">      - crosswind_distance_stdev      :: meters</span>
<span class="org-doc">      - decay_distance                :: meters</span>

<span class="org-doc">    samples a number of firebrands from a Poisson distribution parameterized by expected_firebrand_count,</span>
<span class="org-doc">    casts these from the space_time_coordinate into grid cells in the space-time cube, records their landing</span>
<span class="org-doc">    locations in output_matrices["firebrand_count"] (if provided), filters out all of the firebrands that</span>
<span class="org-doc">    fizzle out in either burnable or non-burnable fuels, and returns any that ignite new spot fires in</span>
<span class="org-doc">    a tuple with these fields:</span>

<span class="org-doc">    - ignition_time :: minutes</span>
<span class="org-doc">    - ignited_cells :: set of (y,x) grid coordinates</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Sample the number of firebrands to cast from the source cell</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>

    <span class="org-variable-name">num_firebrands</span> <span class="org-operator">=</span> sample_number_of_firebrands(random_generator, expected_firebrand_count)

    <span class="org-keyword">if</span> num_firebrands <span class="org-operator">&gt;</span> 0:

        <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that there is wind to transport the firebrands</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>

        (<span class="org-variable-name">t</span>, <span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>)      <span class="org-operator">=</span> space_time_coordinate
        <span class="org-variable-name">wind_speed_10m</span> <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"wind_speed_10m"</span>].get(t,y,x) <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>

        <span class="org-keyword">if</span> wind_speed_10m <span class="org-operator">&gt;</span> 0.0:

            <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack all firebrand-related features of the source cell</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>

            <span class="org-variable-name">fuel_model_cube</span>              <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_model"</span>]
            <span class="org-variable-name">temperature_cube</span>             <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"temperature"</span>]
            <span class="org-variable-name">fuel_moisture_dead_1hr_cube</span>  <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_dead_1hr"</span>]
            <span class="org-variable-name">fire_type_matrix</span>             <span class="org-operator">=</span> output_matrices[<span class="org-string">"fire_type"</span>]
            <span class="org-variable-name">firebrand_count_matrix</span>       <span class="org-operator">=</span> output_matrices.get(<span class="org-string">"firebrand_count"</span>)
            (<span class="org-variable-name">_</span>, <span class="org-variable-name">rows</span>, <span class="org-variable-name">cols</span>)              <span class="org-operator">=</span> fuel_model_cube.shape
            (<span class="org-variable-name">_</span>, <span class="org-variable-name">cell_height</span>, <span class="org-variable-name">cell_width</span>) <span class="org-operator">=</span> cube_resolution
            <span class="org-variable-name">decay_distance</span>               <span class="org-operator">=</span> spot_config[<span class="org-string">"decay_distance"</span>]
            <span class="org-variable-name">upwind_direction</span>             <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"upwind_direction"</span>].get(t,y,x)
            <span class="org-variable-name">downwind_direction</span>           <span class="org-operator">=</span> radians(conv.opposite_direction(upwind_direction))
            <span class="org-variable-name">cos_wdir</span>                     <span class="org-operator">=</span> cos(downwind_direction)
            <span class="org-variable-name">sin_wdir</span>                     <span class="org-operator">=</span> sin(downwind_direction)
            <span class="org-variable-name">fireline_intensity</span>           <span class="org-operator">=</span> output_matrices[<span class="org-string">"fireline_intensity"</span>][y,x]             <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
            <span class="org-variable-name">wind_speed_20ft</span>              <span class="org-operator">=</span> conv.wind_speed_10m_to_wind_speed_20ft(wind_speed_10m) <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
            <span class="org-variable-name">wind_speed_20ft_mps</span>          <span class="org-operator">=</span> conv.km_hr_to_mps(wind_speed_20ft)                     <span class="org-comment-delimiter"># </span><span class="org-comment">m/s</span>
            <span class="org-variable-name">sample_delta_y_fn</span>            <span class="org-operator">=</span> delta_y_sampler(spot_config, fireline_intensity, wind_speed_20ft_mps)
            <span class="org-variable-name">sample_delta_x_fn</span>            <span class="org-operator">=</span> delta_x_sampler(spot_config, fireline_intensity, wind_speed_20ft_mps)

            <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Cast each firebrand, update firebrand_count_matrix, and accumulate any ignited cells</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>

            <span class="org-variable-name">ignited_cells</span> <span class="org-operator">=</span> {ignited_cell <span class="org-keyword">for</span> _i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(num_firebrands)
                             <span class="org-keyword">if</span> (ignited_cell :<span class="org-operator">=</span> cast_firebrand(random_generator,
                                                                fuel_model_cube,
                                                                temperature_cube,
                                                                fuel_moisture_dead_1hr_cube,
                                                                fire_type_matrix,
                                                                firebrand_count_matrix,
                                                                rows,
                                                                cols,
                                                                cell_height,
                                                                cell_width,
                                                                t,
                                                                y,
                                                                x,
                                                                decay_distance,
                                                                cos_wdir,
                                                                sin_wdir,
                                                                sample_delta_y_fn,
                                                                sample_delta_x_fn))
                             <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>}

            <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Return any cells ignited by firebrands along with their time of ignition</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>

            <span class="org-keyword">if</span> <span class="org-builtin">len</span>(ignited_cells) <span class="org-operator">&gt;</span> 0:
                <span class="org-variable-name">time_of_arrival</span> <span class="org-operator">=</span> output_matrices[<span class="org-string">"time_of_arrival"</span>][y,x]           <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>
                <span class="org-variable-name">flame_length</span>    <span class="org-operator">=</span> output_matrices[<span class="org-string">"flame_length"</span>][y,x]              <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
                <span class="org-variable-name">ignition_time</span>   <span class="org-operator">=</span> spot_ignition_time(time_of_arrival, flame_length) <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>

                <span class="org-keyword">return</span> (ignition_time, ignited_cells)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-for-users-spot" class="outline-3">
<h3 id="for-users-spot"><span class="section-number-3">7.2.</span> For Users</h3>
<div class="outline-text-3" id="text-for-users-spot">
</div>
<div id="outline-container-how-to-estimate-the-areal-heat-output-for-all-surface-fuel-models" class="outline-4">
<h4 id="how-to-estimate-the-areal-heat-output-for-all-surface-fuel-models"><span class="section-number-4">7.2.1.</span> How to Estimate the Areal Heat Output for All Surface Fuel Models</h4>
<div class="outline-text-4" id="text-how-to-estimate-the-areal-heat-output-for-all-surface-fuel-models">
<div class="org-src-container">
<pre class="src src-python" id="estimate-areal-heat-output"><span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.fuel_models <span class="org-keyword">as</span> fm
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf

<span class="org-keyword">def</span> <span class="org-function-name">calc_areal_heat_output_from_fuel_model</span>(moisturized_fuel_model):
    <span class="org-variable-name">fire_behavior</span>      <span class="org-operator">=</span> sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model)
    <span class="org-variable-name">spread_rate</span>        <span class="org-operator">=</span> fire_behavior[<span class="org-string">"base_spread_rate"</span>]            <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
    <span class="org-variable-name">fireline_intensity</span> <span class="org-operator">=</span> fire_behavior[<span class="org-string">"base_fireline_intensity"</span>]     <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
    <span class="org-keyword">return</span> sf.calc_areal_heat_output(spread_rate, fireline_intensity) <span class="org-comment-delimiter"># </span><span class="org-comment">kJ/m^2</span>

<span class="org-keyword">def</span> <span class="org-function-name">save_areal_heat_output_as_histogram</span>(areal_heat_output, moisture_category):
    plt.hist(areal_heat_output[moisture_category],
             <span class="org-builtin">range</span><span class="org-operator">=</span>(0, 60000),
             bins<span class="org-operator">=</span>12,
             density<span class="org-operator">=</span><span class="org-constant">True</span>,
             histtype<span class="org-operator">=</span><span class="org-string">"bar"</span>,
             color<span class="org-operator">=</span><span class="org-string">"darkred"</span>,
             edgecolor<span class="org-operator">=</span><span class="org-string">"black"</span>)
    plt.title(<span class="org-string">"Areal Heat Output for All Surface Fuel Models - "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>.capitalize(moisture_category) <span class="org-operator">+</span> <span class="org-string">" Conditions"</span>)
    plt.xlabel(<span class="org-string">"Areal Heat Output (kJ/m^2)"</span>)
    plt.ylabel(<span class="org-string">"Probability Density"</span>)
    plt.savefig(<span class="org-string">"pics/fm_areal_heat_output_"</span> <span class="org-operator">+</span> moisture_category <span class="org-operator">+</span> <span class="org-string">".png"</span>)
    plt.close(<span class="org-string">"all"</span>)

<span class="org-variable-name">fuel_moisture_dry</span> <span class="org-operator">=</span> [
    0.025, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_1hr</span>
    0.050, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_10hr</span>
    0.075, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_100hr</span>
    0.00, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_herbaceous (will be set by moisturize for dynamic fuel models)</span>
    0.45, <span class="org-comment-delimiter"># </span><span class="org-comment">live_herbaceous</span>
    0.30, <span class="org-comment-delimiter"># </span><span class="org-comment">live_woody</span>
]

<span class="org-variable-name">fuel_moisture_mod</span> <span class="org-operator">=</span> [
    0.05, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_1hr</span>
    0.10, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_10hr</span>
    0.15, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_100hr</span>
    0.00, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_herbaceous (will be set by moisturize for dynamic fuel models)</span>
    0.90, <span class="org-comment-delimiter"># </span><span class="org-comment">live_herbaceous</span>
    0.60, <span class="org-comment-delimiter"># </span><span class="org-comment">live_woody</span>
]

<span class="org-variable-name">fuel_moisture_wet</span> <span class="org-operator">=</span> [
    0.10, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_1hr</span>
    0.20, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_10hr</span>
    0.30, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_100hr</span>
    0.00, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_herbaceous (will be set by moisturize for dynamic fuel models)</span>
    1.80, <span class="org-comment-delimiter"># </span><span class="org-comment">live_herbaceous</span>
    1.20, <span class="org-comment-delimiter"># </span><span class="org-comment">live_woody</span>
]

<span class="org-variable-name">areal_heat_output</span> <span class="org-operator">=</span> {
    <span class="org-string">"dry"</span>: [calc_areal_heat_output_from_fuel_model(fm.moisturize(v, fuel_moisture_dry))
            <span class="org-keyword">for</span> v <span class="org-keyword">in</span> fm.fuel_model_table.values()],
    <span class="org-string">"mod"</span>: [calc_areal_heat_output_from_fuel_model(fm.moisturize(v, fuel_moisture_mod))
            <span class="org-keyword">for</span> v <span class="org-keyword">in</span> fm.fuel_model_table.values()],
    <span class="org-string">"wet"</span>: [calc_areal_heat_output_from_fuel_model(fm.moisturize(v, fuel_moisture_wet))
            <span class="org-keyword">for</span> v <span class="org-keyword">in</span> fm.fuel_model_table.values()],
}

<span class="org-keyword">for</span> moisture_category <span class="org-keyword">in</span> [<span class="org-string">"dry"</span>, <span class="org-string">"mod"</span>, <span class="org-string">"wet"</span>]:
    save_areal_heat_output_as_histogram(areal_heat_output, moisture_category)

<span class="org-builtin">print</span>(<span class="org-string">"Median Areal Heat Output (kJ/m^2) for All Surface Fuel Models</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 80)
pprint({
    <span class="org-string">"dry"</span>: np.median(areal_heat_output[<span class="org-string">"dry"</span>]),
    <span class="org-string">"mod"</span>: np.median(areal_heat_output[<span class="org-string">"mod"</span>]),
    <span class="org-string">"wet"</span>: np.median(areal_heat_output[<span class="org-string">"wet"</span>]),
})

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Mean Areal Heat Output (kJ/m^2) for All Surface Fuel Models</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 80)
pprint({
    <span class="org-string">"dry"</span>: np.mean(areal_heat_output[<span class="org-string">"dry"</span>]),
    <span class="org-string">"mod"</span>: np.mean(areal_heat_output[<span class="org-string">"mod"</span>]),
    <span class="org-string">"wet"</span>: np.mean(areal_heat_output[<span class="org-string">"wet"</span>]),
})

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Max Areal Heat Output (kJ/m^2) for All Surface Fuel Models</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 80)
pprint({
    <span class="org-string">"dry"</span>: np.<span class="org-builtin">max</span>(areal_heat_output[<span class="org-string">"dry"</span>]),
    <span class="org-string">"mod"</span>: np.<span class="org-builtin">max</span>(areal_heat_output[<span class="org-string">"mod"</span>]),
    <span class="org-string">"wet"</span>: np.<span class="org-builtin">max</span>(areal_heat_output[<span class="org-string">"wet"</span>]),
})
</pre>
</div>

<pre class="example" id="run-estimate-areal-heat-output">
Median Areal Heat Output (kJ/m^2) for All Surface Fuel Models
================================================================================
{'dry': 9517.751889162279, 'mod': 7050.1670422893385, 'wet': 3533.8201824045955}

Mean Areal Heat Output (kJ/m^2) for All Surface Fuel Models
================================================================================
{'dry': 14270.339217272918,
 'mod': 10954.330808704475,
 'wet': 5705.4111616613945}

Max Areal Heat Output (kJ/m^2) for All Surface Fuel Models
================================================================================
{'dry': 54285.275558317175, 'mod': 45108.6289738327, 'wet': 32325.037970995523}
</pre>


<div id="areal-heat-output-all-fm-dry" class="figure">
<p><img src="pics/fm_areal_heat_output_dry.png" alt="fm_areal_heat_output_dry.png">
</p>
<p><span class="figure-number">Figure 1: </span>Areal Heat Output for All Surface Fuel Models - Dry Conditions</p>
</div>


<div id="areal-heat-output-all-fm-mod" class="figure">
<p><img src="pics/fm_areal_heat_output_mod.png" alt="fm_areal_heat_output_mod.png">
</p>
<p><span class="figure-number">Figure 2: </span>Areal Heat Output for All Surface Fuel Models - Mod Conditions</p>
</div>


<div id="areal-heat-output-all-fm-wet" class="figure">
<p><img src="pics/fm_areal_heat_output_wet.png" alt="fm_areal_heat_output_wet.png">
</p>
<p><span class="figure-number">Figure 3: </span>Areal Heat Output for All Surface Fuel Models - Wet Conditions</p>
</div>
</div>
</div>
<div id="outline-container-how-to-estimate-the-number-of-firebrands-cast-per-burned-cell" class="outline-4">
<h4 id="how-to-estimate-the-number-of-firebrands-cast-per-burned-cell"><span class="section-number-4">7.2.2.</span> How to Estimate the Number of Firebrands Cast per Burned Cell</h4>
<div class="outline-text-4" id="text-how-to-estimate-the-number-of-firebrands-cast-per-burned-cell">
<p>
Several spotting parameters can be adjusted by the user:
</p>

<table id="tab:spotting-parameters">
<caption class="t-above"><span class="table-number">Table 5:</span> User adjustable spotting parameters</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Parameter</th>
<th scope="col" class="org-left">Units</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">random_seed</td>
<td class="org-left">\(\text{integer}\) or \(\text{Generator}\)</td>
<td class="org-left">seed for a numpy.random.Generator object</td>
</tr>

<tr>
<td class="org-left">firebrands_per_unit_heat</td>
<td class="org-left">\(\text{firebrands}/\text{kJ}\)</td>
<td class="org-left">number of firebrands to emit per kilojoule</td>
</tr>

<tr>
<td class="org-left">downwind_distance_mean</td>
<td class="org-left">\(\text{m}\)</td>
<td class="org-left">normal distribution mean underpinning lognormal distribution</td>
</tr>

<tr>
<td class="org-left">fireline_intensity_exponent</td>
<td class="org-left">\(\text{-}\)</td>
<td class="org-left">downwind_distance_mean multiplier [I^fireline_intensity_exponent]</td>
</tr>

<tr>
<td class="org-left">wind_speed_exponent</td>
<td class="org-left">\(\text{-}\)</td>
<td class="org-left">downwind_distance_mean multiplier [U^wind_speed_exponent]</td>
</tr>

<tr>
<td class="org-left">downwind_variance_mean_ratio</td>
<td class="org-left">\(\text{m}^2/\text{m}\)</td>
<td class="org-left">normal distribution variance divided by expected value [Var(X) / E(X)]</td>
</tr>

<tr>
<td class="org-left">crosswind_distance_stdev</td>
<td class="org-left">\(\text{m}\)</td>
<td class="org-left">crosswind normal distribution standard deviation (mean = 0)</td>
</tr>

<tr>
<td class="org-left">decay_distance</td>
<td class="org-left">\(\text{m}\)</td>
<td class="org-left">spotting distance at which ignition probability is divided by \(e\)</td>
</tr>
</tbody>
</table>

<p>
In this section, we will look at <b>firebrands_per_unit_heat</b> and
<b>decay_distance</b> specifically as they have the most direct bearing on
the number of firebrands produced from each burning cell as well as
how many of these will ignite new spot fires rather than fizzle out.
</p>

<p>
From section <a href="#how-to-estimate-the-areal-heat-output-for-all-surface-fuel-models">7.2.1</a>, we can see that heat outputs across all surface fuel
models under moderately dry conditions range from about 0-45,000
\(\text{kJ}/\text{m}^2\).
</p>

<p>
Here, we will calculate some representative ignition probabilities and
expected spot fire counts per burning cell given the following input
variable ranges:
</p>

<ul class="org-ul">
<li><b>heat output per area</b>: 0-45,000 \(\text{kJ}/\text{m}^2\)</li>
<li><b>heat per firebrand</b>: 500,000-2,000,000 \(\text{kJ}/\text{firebrand}\)</li>
<li><b>spotting distance from burning cell</b>: 30-900 meters (e.g., 1-30 cells @ 30m resolution)</li>
<li><b>decay distance</b>: 30-900 meters (e.g., 1-30 cells @ 30m resolution)</li>
<li><b>temperature at target cell</b>: 20-40 degrees Celsius</li>
<li><b>fine fuel moisture at target cell</b>: 5-20%</li>
</ul>

<p>
In this example, we will assume a flat landscape (no slope) with 30
meter resolution grid cells. This gives us a cell area of 900 \(\text{m}^2\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="estimate-spot-fire-ignition-probability"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.spot_fire <span class="org-keyword">as</span> spot


<span class="org-variable-name">cell_area</span> <span class="org-operator">=</span> 900 <span class="org-comment-delimiter"># </span><span class="org-comment">m^2</span>


<span class="org-variable-name">firebrand_counts</span> <span class="org-operator">=</span> <span class="org-builtin">sorted</span>([heat_output_per_area <span class="org-operator">*</span> cell_area <span class="org-operator">*</span> firebrands_per_unit_heat
                           <span class="org-keyword">for</span> heat_output_per_area <span class="org-keyword">in</span> <span class="org-builtin">range</span>(0, 45001, 5000)
                           <span class="org-keyword">for</span> firebrands_per_unit_heat <span class="org-keyword">in</span> <span class="org-builtin">map</span>(<span class="org-keyword">lambda</span> x: 1<span class="org-operator">/</span>x, <span class="org-builtin">range</span>(<span class="org-builtin">int</span>(5e5), <span class="org-builtin">int</span>(2e6)<span class="org-operator">+</span>1, <span class="org-builtin">int</span>(5e5)))])


<span class="org-variable-name">distance_penalties</span> <span class="org-operator">=</span> <span class="org-builtin">sorted</span>([spot.firebrand_flight_survival_probability(spotting_distance, decay_distance)
                             <span class="org-keyword">for</span> spotting_distance <span class="org-keyword">in</span> <span class="org-builtin">range</span>(30, 901, 30)
                             <span class="org-keyword">for</span> decay_distance <span class="org-keyword">in</span> <span class="org-builtin">range</span>(30, 901, 30)])


<span class="org-variable-name">schroeder_probs</span> <span class="org-operator">=</span> <span class="org-builtin">sorted</span>([spot.schroeder_ignition_probability(temperature, moisture <span class="org-operator">/</span> 100)
                          <span class="org-keyword">for</span> temperature <span class="org-keyword">in</span> <span class="org-builtin">range</span>(20, 41, 5)
                          <span class="org-keyword">for</span> moisture <span class="org-keyword">in</span> <span class="org-builtin">range</span>(5, 21, 5)])


<span class="org-variable-name">ignition_probs</span> <span class="org-operator">=</span> <span class="org-builtin">sorted</span>([dp <span class="org-operator">*</span> sp
                         <span class="org-keyword">for</span> dp <span class="org-keyword">in</span> distance_penalties
                         <span class="org-keyword">for</span> sp <span class="org-keyword">in</span> schroeder_probs])


<span class="org-variable-name">spot_fire_counts</span> <span class="org-operator">=</span> <span class="org-builtin">sorted</span>([fb <span class="org-operator">*</span> ip
                           <span class="org-keyword">for</span> fb <span class="org-keyword">in</span> firebrand_counts
                           <span class="org-keyword">for</span> ip <span class="org-keyword">in</span> ignition_probs])


<span class="org-keyword">def</span> <span class="org-function-name">percentile_indices</span>(coll):
    <span class="org-doc">"""</span>
<span class="org-doc">    Return the 0th, 25th, 50th, 75th, and 100th percentile indices for coll.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">max_index</span> <span class="org-operator">=</span> <span class="org-builtin">len</span>(coll) <span class="org-operator">-</span> 1
    <span class="org-keyword">return</span> <span class="org-builtin">map</span>(<span class="org-keyword">lambda</span> p: (p, <span class="org-builtin">int</span>(p <span class="org-operator">*</span> max_index)),
               [0.0, 0.25, 0.5, 0.75, 1.0])


<span class="org-variable-name">firebrand_count_percs</span> <span class="org-operator">=</span> {<span class="org-builtin">int</span>(100 <span class="org-operator">*</span> p_v[0]): firebrand_counts[p_v[1]]
                         <span class="org-keyword">for</span> p_v <span class="org-keyword">in</span> percentile_indices(firebrand_counts)}


<span class="org-variable-name">distance_penalty_percs</span> <span class="org-operator">=</span> {<span class="org-builtin">int</span>(100 <span class="org-operator">*</span> p_v[0]): distance_penalties[p_v[1]]
                          <span class="org-keyword">for</span> p_v <span class="org-keyword">in</span> percentile_indices(distance_penalties)}


<span class="org-variable-name">schroeder_prob_percs</span> <span class="org-operator">=</span> {<span class="org-builtin">int</span>(100 <span class="org-operator">*</span> p_v[0]): schroeder_probs[p_v[1]]
                        <span class="org-keyword">for</span> p_v <span class="org-keyword">in</span> percentile_indices(schroeder_probs)}


<span class="org-variable-name">ignition_prob_percs</span> <span class="org-operator">=</span> {<span class="org-builtin">int</span>(100 <span class="org-operator">*</span> p_v[0]): ignition_probs[p_v[1]]
                       <span class="org-keyword">for</span> p_v <span class="org-keyword">in</span> percentile_indices(ignition_probs)}


<span class="org-variable-name">spot_fire_count_percs</span> <span class="org-operator">=</span> {<span class="org-builtin">int</span>(100 <span class="org-operator">*</span> p_v[0]): spot_fire_counts[p_v[1]]
                         <span class="org-keyword">for</span> p_v <span class="org-keyword">in</span> percentile_indices(spot_fire_counts)}


pprint({
    <span class="org-string">"firebrand_count_percentiles"</span>               : firebrand_count_percs,
    <span class="org-string">"flight_distance_penalty_percentiles"</span>       : distance_penalty_percs,
    <span class="org-string">"schroeder_ignition_probability_percentiles"</span>: schroeder_prob_percs,
    <span class="org-string">"spot_ignition_probability_percentiles"</span>     : ignition_prob_percs,
    <span class="org-string">"spot_fire_count_percentiles"</span>               : spot_fire_count_percs,
}, sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)
</pre>
</div>

<pre class="example" id="estimate-spot-fire-ignition-probability-results">
{'firebrand_count_percentiles': {0: 0.0,
                                 25: 6.75,
                                 50: 15.75,
                                 75: 27.0,
                                 100: 81.0},
 'flight_distance_penalty_percentiles': {0: 9.357622968840175e-14,
                                         25: 0.1353352832366127,
                                         50: 0.36787944117144233,
                                         75: 0.5961628688829711,
                                         100: 0.9672161004820059},
 'schroeder_ignition_probability_percentiles': {0: 0.0410643084416302,
                                                25: 0.05806152126033939,
                                                50: 0.1462606114856146,
                                                75: 0.32092711244047045,
                                                100: 0.6532412198970651},
 'spot_ignition_probability_percentiles': {0: 3.842643158729363e-15,
                                           25: 0.016675322729050666,
                                           50: 0.05110365673058294,
                                           75: 0.1456615550998886,
                                           100: 0.6318254253829478},
 'spot_fire_count_percentiles': {0: 0.0,
                                 25: 0.09538065053197298,
                                 50: 0.6628202779508812,
                                 75: 2.3768372423970905,
                                 100: 51.17785945601877}}
</pre>

<p>
We can see that depending on the surface fuel model and weather
conditions at the cells receiving firebrands, we can get anywhere from
0-51 spot fires ignited by one burning cell per timestep using the
ranges for <b>firebrands_per_unit_heat</b> and <b>decay_distance</b> provided
above.
</p>
</div>
</div>
<div id="outline-container-how-to-estimate-typical-ranges-for-the-$\vec{\delta}$-distribution-characteristics" class="outline-4">
<h4 id="how-to-estimate-typical-ranges-for-the-$\vec{\delta}$-distribution-characteristics"><span class="section-number-4">7.2.3.</span> How to Estimate Typical Ranges for the \(\vec{\Delta}\) Distribution Characteristics</h4>
<div class="outline-text-4" id="text-how-to-estimate-typical-ranges-for-the-$\vec{\delta}$-distribution-characteristics">
<div class="org-src-container">
<pre class="src src-python" id="himoto-typical-ranges"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> sqrt, log

<span class="org-keyword">def</span> <span class="org-function-name">himoto_eq_28_values</span>(B_star):
    <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: The following value for D seems absurdly low, and so does</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">the predicted E[&#916;X]. I suspect a typo in the Himoto2005 paper.</span>
    <span class="org-variable-name">D</span>                  <span class="org-operator">=</span> 0.08
    <span class="org-variable-name">std_delta_x_over_D</span> <span class="org-operator">=</span> 0.88 <span class="org-operator">*</span> (B_star <span class="org-operator">**</span> (1.0 <span class="org-operator">/</span> 3.0))
    <span class="org-variable-name">exp_delta_x_over_D</span> <span class="org-operator">=</span> 0.47 <span class="org-operator">*</span> (B_star <span class="org-operator">**</span> (2.0 <span class="org-operator">/</span> 3.0))
    <span class="org-variable-name">cv_delta_x</span>         <span class="org-operator">=</span> std_delta_x_over_D <span class="org-operator">/</span> exp_delta_x_over_D
    <span class="org-variable-name">sigma_x</span>            <span class="org-operator">=</span> sqrt(log(1.0 <span class="org-operator">+</span> cv_delta_x))
    <span class="org-variable-name">exp_delta_x</span>        <span class="org-operator">=</span> exp_delta_x_over_D <span class="org-operator">*</span> D
    <span class="org-variable-name">mu_x</span>               <span class="org-operator">=</span> log(exp_delta_x) <span class="org-operator">-</span> (sigma_x <span class="org-operator">**</span> 2.0) <span class="org-operator">/</span> 2.0
    <span class="org-variable-name">sigma_y</span>            <span class="org-operator">=</span> D <span class="org-operator">*</span> 0.92
    <span class="org-keyword">return</span> {
        <span class="org-string">"$B^*$"</span>                             : B_star,
        <span class="org-string">"$</span><span class="org-constant">\\</span><span class="org-string">text{CV}[</span><span class="org-constant">\\</span><span class="org-string">Delta_X]$"</span>           : <span class="org-string">"{:.0f}%"</span>.<span class="org-builtin">format</span>(100.0 <span class="org-operator">*</span> cv_delta_x),
        <span class="org-string">"$</span><span class="org-constant">\\</span><span class="org-string">sigma_X$"</span>                       : <span class="org-string">"{:.2f}"</span>.<span class="org-builtin">format</span>(sigma_x),
        <span class="org-string">"$</span><span class="org-constant">\\</span><span class="org-string">sigma_Y/</span><span class="org-constant">\\</span><span class="org-string">mathbb{E}[</span><span class="org-constant">\\</span><span class="org-string">Delta_X]$"</span>: <span class="org-string">"{:.2f}"</span>.<span class="org-builtin">format</span>(sigma_y <span class="org-operator">/</span> exp_delta_x),
        <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE the following ended up being nonsensical:</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">"E[&#916;X] (m)" exp_delta_x</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">"&#956;_X"       mu_x</span>
    }

<span class="org-variable-name">himoto_typical_ranges</span> <span class="org-operator">=</span> [himoto_eq_28_values(B_star) <span class="org-keyword">for</span> B_star <span class="org-keyword">in</span> [20, 50, 100, 150, 200]]
<span class="org-variable-name">table_header</span>          <span class="org-operator">=</span> <span class="org-builtin">list</span>(himoto_typical_ranges[0].keys())
<span class="org-variable-name">table_rows</span>            <span class="org-operator">=</span> [<span class="org-builtin">list</span>(d.values()) <span class="org-keyword">for</span> d <span class="org-keyword">in</span> himoto_typical_ranges]

<span class="org-builtin">print</span>([table_header, <span class="org-operator">*</span>table_rows])
</pre>
</div>

<table id="run-himoto-typical-ranges">


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-right">\(B^*\)</td>
<td class="org-right">\(\text{CV}[\Delta_X]\)</td>
<td class="org-right">\(\sigma_X\)</td>
<td class="org-right">\(\sigma_Y/\mathbb{E}[\Delta_X]\)</td>
</tr>

<tr>
<td class="org-right">20</td>
<td class="org-right">69%</td>
<td class="org-right">0.72</td>
<td class="org-right">0.27</td>
</tr>

<tr>
<td class="org-right">50</td>
<td class="org-right">51%</td>
<td class="org-right">0.64</td>
<td class="org-right">0.14</td>
</tr>

<tr>
<td class="org-right">100</td>
<td class="org-right">40%</td>
<td class="org-right">0.58</td>
<td class="org-right">0.09</td>
</tr>

<tr>
<td class="org-right">150</td>
<td class="org-right">35%</td>
<td class="org-right">0.55</td>
<td class="org-right">0.07</td>
</tr>

<tr>
<td class="org-right">200</td>
<td class="org-right">32%</td>
<td class="org-right">0.53</td>
<td class="org-right">0.06</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="outline-container-burning-cells-on-a-grid-(pyretechnics.burn_cells)" class="outline-2">
<h2 id="burning-cells-on-a-grid-(pyretechnics.burn_cells)"><span class="section-number-2">8.</span> Burning Cells on a Grid (pyretechnics.burn_cells)</h2>
<div class="outline-text-2" id="text-burning-cells-on-a-grid-(pyretechnics.burn_cells)">
</div>
<div id="outline-container-for-developers-burn-cells" class="outline-3">
<h3 id="for-developers-burn-cells"><span class="section-number-3">8.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-for-developers-burn-cells">
<p>
This module provides convenience functions that apply the fuel model
and moisture definitions from section <a href="#fuel-model-and-moisture-definitions-(pyretechnics.fuel_models)">4</a>, surface fire equations from
section <a href="#surface-fire-equations-(pyretechnics.surface_fire)">5</a>, and crown
fire equations from section <a href="#crown-fire-equations-(pyretechnics.crown_fire)">6</a> to cells within a space-time cube, returning
their combined surface and crown fire behavior.
</p>
</div>
<div id="outline-container-burn-cell-as-a-head-fire" class="outline-4">
<h4 id="burn-cell-as-a-head-fire"><span class="section-number-4">8.1.1.</span> Burn Cell as a Head Fire</h4>
<div class="outline-text-4" id="text-burn-cell-as-a-head-fire">
<p>
Sometimes the goal of a fire behavior analysis is to determine the
most extreme behavior to be expected, given static measurements of
surface fuels, tree canopy characteristics, topography, wind, and
moisture. The following function computes the maximum surface fire
behavior and checks to see whether its maximum surface fireline
intensity causes a crown fire. If so, the maximum crown fire behavior
is computed and combined with the maximum surface fire behavior as per
section <a href="#combining-surface-and-crown-fire-behavior">6.1.7</a>. If not, the maximum
surface fire behavior is returned.
</p>

<div class="org-src-container">
<pre class="src src-python" id="burn-cell-as-head-fire"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv
<span class="org-keyword">import</span> pyretechnics.crown_fire <span class="org-keyword">as</span> cf
<span class="org-keyword">import</span> pyretechnics.fuel_models <span class="org-keyword">as</span> fm
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf
<span class="org-keyword">import</span> pyretechnics.vector_utils <span class="org-keyword">as</span> vu


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Create a version of this function that runs efficiently over a space_time_region</span>
<span class="org-keyword">def</span> <span class="org-function-name">burn_cell_as_head_fire</span>(space_time_cubes, space_time_coordinate, use_wind_limit<span class="org-operator">=</span><span class="org-constant">True</span>,
                           surface_lw_ratio_model<span class="org-operator">=</span><span class="org-string">"rothermel"</span>, crown_max_lw_ratio<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - space_time_cubes             :: dictionary of (Lazy)SpaceTimeCube objects with these cell types</span>
<span class="org-doc">      - slope                         :: rise/run</span>
<span class="org-doc">      - aspect                        :: degrees clockwise from North</span>
<span class="org-doc">      - fuel_model                    :: integer index in fm.fuel_model_table</span>
<span class="org-doc">      - canopy_cover                  :: 0-1</span>
<span class="org-doc">      - canopy_height                 :: m</span>
<span class="org-doc">      - canopy_base_height            :: m</span>
<span class="org-doc">      - canopy_bulk_density           :: kg/m^3</span>
<span class="org-doc">      - wind_speed_10m                :: km/hr</span>
<span class="org-doc">      - upwind_direction              :: degrees clockwise from North</span>
<span class="org-doc">      - fuel_moisture_dead_1hr        :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_dead_10hr       :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_dead_100hr      :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_live_herbaceous :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_live_woody      :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - foliar_moisture               :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_spread_adjustment        :: float &gt;= 0.0 (Optional: defaults to 1.0)</span>
<span class="org-doc">      - weather_spread_adjustment     :: float &gt;= 0.0 (Optional: defaults to 1.0)</span>
<span class="org-doc">    - space_time_coordinate        :: (t,y,x)</span>
<span class="org-doc">    - use_wind_limit               :: boolean (Optional)</span>
<span class="org-doc">    - surface_lw_ratio_model       :: "rothermel" or "behave" (Optional)</span>
<span class="org-doc">    - crown_max_lw_ratio           :: float &gt; 0.0 (Optional)</span>

<span class="org-doc">    return a dictionary with these fire behavior values for the space-time coordinate (t,y,x):</span>
<span class="org-doc">    - fire_type          :: "unburned", "surface", "passive_crown", or "active_crown"</span>
<span class="org-doc">    - spread_rate        :: m/min</span>
<span class="org-doc">    - spread_direction   :: (x, y, z) unit vector on the slope-tangential plane</span>
<span class="org-doc">    - fireline_intensity :: kW/m</span>
<span class="org-doc">    - flame_length       :: m</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the space_time_coordinate</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    (<span class="org-variable-name">t</span>, <span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>) <span class="org-operator">=</span> space_time_coordinate

    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack the space_time_cubes dictionary</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Topography, Fuel Model, and Vegetation</span>
    <span class="org-variable-name">slope</span>               <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"slope"</span>].get(t,y,x)               <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-variable-name">aspect</span>              <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"aspect"</span>].get(t,y,x)              <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-variable-name">fuel_model_number</span>   <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_model"</span>].get(t,y,x)          <span class="org-comment-delimiter"># </span><span class="org-comment">integer index in fm.fuel_model_table</span>
    <span class="org-variable-name">canopy_cover</span>        <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"canopy_cover"</span>].get(t,y,x)        <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
    <span class="org-variable-name">canopy_height</span>       <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"canopy_height"</span>].get(t,y,x)       <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-variable-name">canopy_base_height</span>  <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"canopy_base_height"</span>].get(t,y,x)  <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-variable-name">canopy_bulk_density</span> <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"canopy_bulk_density"</span>].get(t,y,x) <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Wind, Surface Moisture, and Foliar Moisture</span>
    <span class="org-variable-name">wind_speed_10m</span>                <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"wind_speed_10m"</span>].get(t,y,x)                <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-variable-name">upwind_direction</span>              <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"upwind_direction"</span>].get(t,y,x)              <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-variable-name">fuel_moisture_dead_1hr</span>        <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_dead_1hr"</span>].get(t,y,x)        <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_dead_10hr</span>       <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_dead_10hr"</span>].get(t,y,x)       <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_dead_100hr</span>      <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_dead_100hr"</span>].get(t,y,x)      <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_live_herbaceous</span> <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_live_herbaceous"</span>].get(t,y,x) <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_live_woody</span>      <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_live_woody"</span>].get(t,y,x)      <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">foliar_moisture</span>               <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"foliar_moisture"</span>].get(t,y,x)               <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Spread Rate Adjustments (Optional)</span>
    <span class="org-variable-name">fuel_spread_adjustment</span>    <span class="org-operator">=</span> (space_time_cubes[<span class="org-string">"fuel_spread_adjustment"</span>].get(t,y,x)
                                 <span class="org-keyword">if</span> <span class="org-string">"fuel_spread_adjustment"</span> <span class="org-keyword">in</span> space_time_cubes
                                 <span class="org-keyword">else</span> 1.0)                                         <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>
    <span class="org-variable-name">weather_spread_adjustment</span> <span class="org-operator">=</span> (space_time_cubes[<span class="org-string">"weather_spread_adjustment"</span>].get(t,y,x)
                                 <span class="org-keyword">if</span> <span class="org-string">"weather_spread_adjustment"</span> <span class="org-keyword">in</span> space_time_cubes
                                 <span class="org-keyword">else</span> 1.0)                                         <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>
    <span class="org-variable-name">spread_rate_adjustment</span>    <span class="org-operator">=</span> fuel_spread_adjustment <span class="org-operator">*</span> weather_spread_adjustment <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>

    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Check whether cell is burnable</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    <span class="org-variable-name">fuel_model</span> <span class="org-operator">=</span> fm.fuel_model_table.get(fuel_model_number)

    <span class="org-keyword">if</span> <span class="org-keyword">not</span> (fuel_model <span class="org-keyword">and</span> fuel_model[<span class="org-string">"burnable"</span>]):
        <span class="org-comment-delimiter"># </span><span class="org-comment">Encountered unknown or non-burnable fuel model</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Create a 3D unit vector pointing upslope on the slope-tangential plane</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

        <span class="org-variable-name">upslope_direction</span> <span class="org-operator">=</span> conv.opposite_direction(aspect)
        <span class="org-variable-name">slope_vector_2d</span>   <span class="org-operator">=</span> conv.azimuthal_to_cartesian(slope, upslope_direction)
        <span class="org-variable-name">slope_vector_3d</span>   <span class="org-operator">=</span> vu.to_slope_plane(slope_vector_2d, slope_vector_2d)
        <span class="org-variable-name">spread_direction</span>  <span class="org-operator">=</span> vu.as_unit_vector_3d(slope_vector_3d) <span class="org-keyword">if</span> slope <span class="org-operator">&gt;</span> 0.0 <span class="org-keyword">else</span> (0.0,1.0,0.0) <span class="org-comment-delimiter"># </span><span class="org-comment">default: North</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Return zero surface fire behavior</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-keyword">return</span> {
            <span class="org-string">"fire_type"</span>         : <span class="org-string">"unburned"</span>,
            <span class="org-string">"spread_rate"</span>       : 0.0,
            <span class="org-string">"spread_direction"</span>  : np.asarray(spread_direction),
            <span class="org-string">"fireline_intensity"</span>: 0.0,
            <span class="org-string">"flame_length"</span>      : 0.0,
        }

    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Encountered burnable fuel model</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Compute derived parameters</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-variable-name">fuel_moisture</span>                <span class="org-operator">=</span> [fuel_moisture_dead_1hr,
                                        fuel_moisture_dead_10hr,
                                        fuel_moisture_dead_100hr,
                                        0.0, <span class="org-comment-delimiter"># </span><span class="org-comment">fuel_moisture_dead_herbaceous</span>
                                        fuel_moisture_live_herbaceous,
                                        fuel_moisture_live_woody]               <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
        <span class="org-variable-name">fuel_bed_depth</span>               <span class="org-operator">=</span> fuel_model[<span class="org-string">"delta"</span>]                      <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
        <span class="org-variable-name">heat_of_combustion</span>           <span class="org-operator">=</span> conv.Btu_lb_to_kJ_kg(fuel_model[<span class="org-string">"h"</span>][0]) <span class="org-comment-delimiter"># </span><span class="org-comment">kJ/kg</span>
        <span class="org-variable-name">estimated_fine_fuel_moisture</span> <span class="org-operator">=</span> fuel_moisture_dead_1hr                   <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate midflame wind speed</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 10m wind speed to 20ft wind speed</span>
        <span class="org-variable-name">wind_speed_20ft</span> <span class="org-operator">=</span> conv.wind_speed_10m_to_wind_speed_20ft(wind_speed_10m) <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Convert 20ft wind speed from km/hr to m/min</span>
        <span class="org-variable-name">wind_speed_20ft_m_min</span> <span class="org-operator">=</span> conv.km_hr_to_m_min(wind_speed_20ft) <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 20ft wind speed to midflame wind speed in m/min</span>
        <span class="org-variable-name">midflame_wind_speed</span> <span class="org-operator">=</span> sf.calc_midflame_wind_speed(wind_speed_20ft_m_min,       <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
                                                          fuel_bed_depth,              <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                          conv.m_to_ft(canopy_height), <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                          canopy_cover)                <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Apply fuel moisture to fuel model</span>
        <span class="org-variable-name">moisturized_fuel_model</span> <span class="org-operator">=</span> fm.moisturize(fuel_model, fuel_moisture)

        <span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Memoize calc_surface_fire_behavior_no_wind_no_slope</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate no-wind-no-slope surface fire behavior</span>
        <span class="org-variable-name">surface_fire_min</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model,
                                                                          spread_rate_adjustment)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread</span>
        <span class="org-variable-name">surface_fire_max</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_max(surface_fire_min,
                                                             midflame_wind_speed,
                                                             upwind_direction,
                                                             slope,
                                                             aspect,
                                                             use_wind_limit,
                                                             surface_lw_ratio_model)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Simplify the surface fire behavior fields for future comparison/combination with the crown fire behavior values</span>
        <span class="org-variable-name">surface_fire_max_simple</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_in_direction(surface_fire_max,
                                                                             surface_fire_max[<span class="org-string">"max_spread_direction"</span>])

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Determine whether the surface fire transitions to a crown fire</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-keyword">if</span> cf.van_wagner_crown_fire_initiation(surface_fire_max_simple[<span class="org-string">"fireline_intensity"</span>],
                                               canopy_cover,
                                               canopy_base_height,
                                               foliar_moisture):

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction of maximum spread</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction of maximum spread</span>
            <span class="org-variable-name">crown_fire_max</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_max(canopy_height, canopy_base_height,
                                                             canopy_bulk_density, heat_of_combustion,
                                                             estimated_fine_fuel_moisture,
                                                             wind_speed_10m, upwind_direction,
                                                             slope, aspect, crown_max_lw_ratio)

            <span class="org-comment-delimiter"># </span><span class="org-comment">Simplify the crown fire behavior fields for future comparison/combination with the surface fire behavior values</span>
            <span class="org-variable-name">crown_fire_max_simple</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_in_direction(crown_fire_max,
                                                                             crown_fire_max[<span class="org-string">"max_spread_direction"</span>])

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate combined fire behavior in the direction of maximum spread</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-variable-name">combined_fire_max</span> <span class="org-operator">=</span> cf.calc_combined_fire_behavior(surface_fire_max_simple, crown_fire_max_simple)

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Return the combined fire behavior in the direction of maximum spread</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-keyword">return</span> combined_fire_max

        <span class="org-keyword">else</span>:

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Return the surface fire behavior in the direction of maximum spread</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-keyword">return</span> surface_fire_max_simple
</pre>
</div>
</div>
</div>
<div id="outline-container-burn-cell-in-any-direction" class="outline-4">
<h4 id="burn-cell-in-any-direction"><span class="section-number-4">8.1.2.</span> Burn Cell in Any Direction</h4>
<div class="outline-text-4" id="text-burn-cell-in-any-direction">
<p>
When the goal of a fire behavior analysis is to evolve a burn scar
from its point of ignition into a generally conical shape in
space-time, then it is necessary to evaluate the combined surface and
crown fire behavior in the direction normal to the fire front. In
order to facilitate this calculation, the following function takes an
azimuth (degrees clockwise from North), meant to represent the spatial
direction in which the fire front is spreading from a given grid cell.
It first projects this 2D direction onto the local slope-tangential
plane and computes the surface fire behavior in this direction. If a
crown fire occurs, the crown fire behavior is also calculated in the
azimuth direction, and the combined surface and crown fire behavior
(as per section <a href="#combining-surface-and-crown-fire-behavior">6.1.7</a>) is
returned. If no crown fire occurs, the surface fire behavior in the
azimuth direction is returned.
</p>

<div class="org-src-container">
<pre class="src src-python" id="burn-cell-toward-azimuth"><span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv
<span class="org-keyword">import</span> pyretechnics.crown_fire <span class="org-keyword">as</span> cf
<span class="org-keyword">import</span> pyretechnics.fuel_models <span class="org-keyword">as</span> fm
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf
<span class="org-keyword">import</span> pyretechnics.vector_utils <span class="org-keyword">as</span> vu


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Create a version of this function that runs efficiently over a space_time_region</span>
<span class="org-keyword">def</span> <span class="org-function-name">burn_cell_toward_azimuth</span>(space_time_cubes, space_time_coordinate, azimuth, use_wind_limit<span class="org-operator">=</span><span class="org-constant">True</span>,
                             surface_lw_ratio_model<span class="org-operator">=</span><span class="org-string">"rothermel"</span>, crown_max_lw_ratio<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - space_time_cubes             :: dictionary of (Lazy)SpaceTimeCube objects with these cell types</span>
<span class="org-doc">      - slope                         :: rise/run</span>
<span class="org-doc">      - aspect                        :: degrees clockwise from North</span>
<span class="org-doc">      - fuel_model                    :: integer index in fm.fuel_model_table</span>
<span class="org-doc">      - canopy_cover                  :: 0-1</span>
<span class="org-doc">      - canopy_height                 :: m</span>
<span class="org-doc">      - canopy_base_height            :: m</span>
<span class="org-doc">      - canopy_bulk_density           :: kg/m^3</span>
<span class="org-doc">      - wind_speed_10m                :: km/hr</span>
<span class="org-doc">      - upwind_direction              :: degrees clockwise from North</span>
<span class="org-doc">      - fuel_moisture_dead_1hr        :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_dead_10hr       :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_dead_100hr      :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_live_herbaceous :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_live_woody      :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - foliar_moisture               :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_spread_adjustment        :: float &gt;= 0.0 (Optional: defaults to 1.0)</span>
<span class="org-doc">      - weather_spread_adjustment     :: float &gt;= 0.0 (Optional: defaults to 1.0)</span>
<span class="org-doc">    - space_time_coordinate        :: (t,y,x)</span>
<span class="org-doc">    - azimuth                      :: degrees clockwise from North on the horizontal plane</span>
<span class="org-doc">    - use_wind_limit               :: boolean (Optional)</span>
<span class="org-doc">    - surface_lw_ratio_model       :: "rothermel" or "behave" (Optional)</span>
<span class="org-doc">    - crown_max_lw_ratio           :: float &gt; 0.0 (Optional)</span>

<span class="org-doc">    return a dictionary with these fire behavior values for the space-time coordinate (t,y,x):</span>
<span class="org-doc">    - fire_type          :: "unburned", "surface", "passive_crown", or "active_crown"</span>
<span class="org-doc">    - spread_rate        :: m/min</span>
<span class="org-doc">    - spread_direction   :: (x, y, z) unit vector on the slope-tangential plane</span>
<span class="org-doc">    - fireline_intensity :: kW/m</span>
<span class="org-doc">    - flame_length       :: m</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the space_time_coordinate</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    (<span class="org-variable-name">t</span>, <span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>) <span class="org-operator">=</span> space_time_coordinate

    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack the space_time_cubes dictionary</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Topography, Fuel Model, and Vegetation</span>
    <span class="org-variable-name">slope</span>               <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"slope"</span>].get(t,y,x)               <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-variable-name">aspect</span>              <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"aspect"</span>].get(t,y,x)              <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-variable-name">fuel_model_number</span>   <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_model"</span>].get(t,y,x)          <span class="org-comment-delimiter"># </span><span class="org-comment">integer index in fm.fuel_model_table</span>
    <span class="org-variable-name">canopy_cover</span>        <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"canopy_cover"</span>].get(t,y,x)        <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
    <span class="org-variable-name">canopy_height</span>       <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"canopy_height"</span>].get(t,y,x)       <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-variable-name">canopy_base_height</span>  <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"canopy_base_height"</span>].get(t,y,x)  <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-variable-name">canopy_bulk_density</span> <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"canopy_bulk_density"</span>].get(t,y,x) <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Wind, Surface Moisture, and Foliar Moisture</span>
    <span class="org-variable-name">wind_speed_10m</span>                <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"wind_speed_10m"</span>].get(t,y,x)                <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-variable-name">upwind_direction</span>              <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"upwind_direction"</span>].get(t,y,x)              <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-variable-name">fuel_moisture_dead_1hr</span>        <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_dead_1hr"</span>].get(t,y,x)        <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_dead_10hr</span>       <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_dead_10hr"</span>].get(t,y,x)       <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_dead_100hr</span>      <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_dead_100hr"</span>].get(t,y,x)      <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_live_herbaceous</span> <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_live_herbaceous"</span>].get(t,y,x) <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_live_woody</span>      <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_live_woody"</span>].get(t,y,x)      <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">foliar_moisture</span>               <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"foliar_moisture"</span>].get(t,y,x)               <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Spread Rate Adjustments (Optional)</span>
    <span class="org-variable-name">fuel_spread_adjustment</span>    <span class="org-operator">=</span> (space_time_cubes[<span class="org-string">"fuel_spread_adjustment"</span>].get(t,y,x)
                                 <span class="org-keyword">if</span> <span class="org-string">"fuel_spread_adjustment"</span> <span class="org-keyword">in</span> space_time_cubes
                                 <span class="org-keyword">else</span> 1.0)                                         <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>
    <span class="org-variable-name">weather_spread_adjustment</span> <span class="org-operator">=</span> (space_time_cubes[<span class="org-string">"weather_spread_adjustment"</span>].get(t,y,x)
                                 <span class="org-keyword">if</span> <span class="org-string">"weather_spread_adjustment"</span> <span class="org-keyword">in</span> space_time_cubes
                                 <span class="org-keyword">else</span> 1.0)                                         <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>
    <span class="org-variable-name">spread_rate_adjustment</span>    <span class="org-operator">=</span> fuel_spread_adjustment <span class="org-operator">*</span> weather_spread_adjustment <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>

    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Project a 2D unit vector pointing toward the azimuth onto the slope-tangential plane</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    <span class="org-variable-name">upslope_direction</span> <span class="org-operator">=</span> conv.opposite_direction(aspect)
    <span class="org-variable-name">slope_vector_2d</span>   <span class="org-operator">=</span> conv.azimuthal_to_cartesian(slope, upslope_direction)
    <span class="org-variable-name">azimuth_vector_2d</span> <span class="org-operator">=</span> conv.azimuthal_to_cartesian(1.0, azimuth)
    <span class="org-variable-name">spread_direction</span>  <span class="org-operator">=</span> vu.as_unit_vector_3d(vu.to_slope_plane(azimuth_vector_2d, slope_vector_2d))

    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Check whether cell is burnable</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    <span class="org-variable-name">fuel_model</span> <span class="org-operator">=</span> fm.fuel_model_table.get(fuel_model_number)

    <span class="org-keyword">if</span> <span class="org-keyword">not</span> (fuel_model <span class="org-keyword">and</span> fuel_model[<span class="org-string">"burnable"</span>]):
        <span class="org-comment-delimiter"># </span><span class="org-comment">Encountered unknown or non-burnable fuel model</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Return zero surface fire behavior in the direction of the azimuth vector</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-keyword">return</span> {
            <span class="org-string">"fire_type"</span>         : <span class="org-string">"unburned"</span>,
            <span class="org-string">"spread_rate"</span>       : 0.0,
            <span class="org-string">"spread_direction"</span>  : np.asarray(spread_direction),
            <span class="org-string">"fireline_intensity"</span>: 0.0,
            <span class="org-string">"flame_length"</span>      : 0.0,
        }

    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Encountered burnable fuel model</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Compute derived parameters</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-variable-name">fuel_moisture</span>                <span class="org-operator">=</span> [fuel_moisture_dead_1hr,
                                        fuel_moisture_dead_10hr,
                                        fuel_moisture_dead_100hr,
                                        0.0, <span class="org-comment-delimiter"># </span><span class="org-comment">fuel_moisture_dead_herbaceous</span>
                                        fuel_moisture_live_herbaceous,
                                        fuel_moisture_live_woody]               <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
        <span class="org-variable-name">fuel_bed_depth</span>               <span class="org-operator">=</span> fuel_model[<span class="org-string">"delta"</span>]                      <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
        <span class="org-variable-name">heat_of_combustion</span>           <span class="org-operator">=</span> conv.Btu_lb_to_kJ_kg(fuel_model[<span class="org-string">"h"</span>][0]) <span class="org-comment-delimiter"># </span><span class="org-comment">kJ/kg</span>
        <span class="org-variable-name">estimated_fine_fuel_moisture</span> <span class="org-operator">=</span> fuel_moisture_dead_1hr                   <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate midflame wind speed</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 10m wind speed to 20ft wind speed</span>
        <span class="org-variable-name">wind_speed_20ft</span> <span class="org-operator">=</span> conv.wind_speed_10m_to_wind_speed_20ft(wind_speed_10m) <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Convert 20ft wind speed from km/hr to m/min</span>
        <span class="org-variable-name">wind_speed_20ft_m_min</span> <span class="org-operator">=</span> conv.km_hr_to_m_min(wind_speed_20ft) <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 20ft wind speed to midflame wind speed in m/min</span>
        <span class="org-variable-name">midflame_wind_speed</span> <span class="org-operator">=</span> sf.calc_midflame_wind_speed(wind_speed_20ft_m_min,       <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
                                                          fuel_bed_depth,              <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                          conv.m_to_ft(canopy_height), <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                          canopy_cover)                <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Apply fuel moisture to fuel model</span>
        <span class="org-variable-name">moisturized_fuel_model</span> <span class="org-operator">=</span> fm.moisturize(fuel_model, fuel_moisture)

        <span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Memoize calc_surface_fire_behavior_no_wind_no_slope</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate no-wind-no-slope surface fire behavior</span>
        <span class="org-variable-name">surface_fire_min</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model,
                                                                          spread_rate_adjustment)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread</span>
        <span class="org-variable-name">surface_fire_max</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_max(surface_fire_min,
                                                             midflame_wind_speed,
                                                             upwind_direction,
                                                             slope,
                                                             aspect,
                                                             use_wind_limit,
                                                             surface_lw_ratio_model)

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of the azimuth vector</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-variable-name">surface_fire_azimuth</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_in_direction(surface_fire_max, spread_direction)

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Determine whether the surface fire transitions to a crown fire</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-keyword">if</span> cf.van_wagner_crown_fire_initiation(surface_fire_azimuth[<span class="org-string">"fireline_intensity"</span>],
                                               canopy_cover,
                                               canopy_base_height,
                                               foliar_moisture):

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction of maximum spread</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-variable-name">crown_fire_max</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_max(canopy_height, canopy_base_height,
                                                             canopy_bulk_density, heat_of_combustion,
                                                             estimated_fine_fuel_moisture,
                                                             wind_speed_10m, upwind_direction,
                                                             slope, aspect, crown_max_lw_ratio)

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction of the azimuth vector</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-variable-name">crown_fire_azimuth</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_in_direction(crown_fire_max, spread_direction)

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate combined fire behavior in the direction of the azimuth vector</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-variable-name">combined_fire_azimuth</span> <span class="org-operator">=</span> cf.calc_combined_fire_behavior(surface_fire_azimuth, crown_fire_azimuth)

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Return the combined fire behavior in the direction of the azimuth vector</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-keyword">return</span> combined_fire_azimuth

        <span class="org-keyword">else</span>:

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Return the surface fire behavior in the direction of the azimuth vector</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-keyword">return</span> surface_fire_azimuth
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-for-users-burn-cells" class="outline-3">
<h3 id="for-users-burn-cells"><span class="section-number-3">8.2.</span> For Users</h3>
<div class="outline-text-3" id="text-for-users-burn-cells">
<p>
In the following sections, we will demonstrate how to calculate the
combined surface and crown fire behavior first in the direction of
maximum spread and then in any direction.
</p>
</div>
<div id="outline-container-how-to-burn-a-cell-as-a-head-fire" class="outline-4">
<h4 id="how-to-burn-a-cell-as-a-head-fire"><span class="section-number-4">8.2.1.</span> How to Burn a Cell as a Head Fire</h4>
<div class="outline-text-4" id="text-how-to-burn-a-cell-as-a-head-fire">
<div class="org-src-container">
<pre class="src src-python" id="run-burn-cell-as-head-fire"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.burn_cells <span class="org-keyword">as</span> bc
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (
    240,  <span class="org-comment-delimiter"># </span><span class="org-comment">bands: 10 days @ 1 hour/band</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">rows:  30 km @ 30 meters/row</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">cols:  30 km @ 30 meters/col</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Create an input dictionary of SpaceTimeCubes (using constant data for this example)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">space_time_cubes</span> <span class="org-operator">=</span> {
    <span class="org-string">"slope"</span>                        : SpaceTimeCube(cube_shape, 0.8),   <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-string">"aspect"</span>                       : SpaceTimeCube(cube_shape, 225.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_model"</span>                   : SpaceTimeCube(cube_shape, 101),   <span class="org-comment-delimiter"># </span><span class="org-comment">integer index in fm.fuel_model_table</span>
    <span class="org-string">"canopy_cover"</span>                 : SpaceTimeCube(cube_shape, 0.6),   <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
    <span class="org-string">"canopy_height"</span>                : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_base_height"</span>           : SpaceTimeCube(cube_shape, 3.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_bulk_density"</span>          : SpaceTimeCube(cube_shape, 0.3),   <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>
    <span class="org-string">"wind_speed_10m"</span>               : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-string">"upwind_direction"</span>             : SpaceTimeCube(cube_shape, 180.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_moisture_dead_1hr"</span>       : SpaceTimeCube(cube_shape, 0.05),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_10hr"</span>      : SpaceTimeCube(cube_shape, 0.10),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_100hr"</span>     : SpaceTimeCube(cube_shape, 0.15),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_herbaceous"</span>: SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_woody"</span>     : SpaceTimeCube(cube_shape, 0.60),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"foliar_moisture"</span>              : SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_spread_adjustment"</span>       : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
    <span class="org-string">"weather_spread_adjustment"</span>    : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
}

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify a space-time coordinate (t,y,x) within the extent of the SpaceTimeCube dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">space_time_coordinate</span> <span class="org-operator">=</span> (24, 100, 100)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate combined fire behavior in the direction of maximum spread (with wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">combined_behavior_limited</span> <span class="org-operator">=</span> bc.burn_cell_as_head_fire(space_time_cubes, space_time_coordinate)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate combined fire behavior in the direction of maximum spread (without wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">combined_behavior_unlimited</span> <span class="org-operator">=</span> bc.burn_cell_as_head_fire(space_time_cubes, space_time_coordinate,
                                                        use_wind_limit<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Display combined fire behavior in the direction of maximum spread (with wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"Fire Behavior from Combined Surface and Crown Fire (with Wind Limit) at Coordinate "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(space_time_coordinate) <span class="org-operator">+</span> <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 100)
pprint(combined_behavior_limited)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Display combined fire behavior in the direction of maximum spread (without wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Fire Behavior from Combined Surface and Crown Fire (without Wind Limit) at Coordinate "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(space_time_coordinate) <span class="org-operator">+</span> <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 100)
pprint(combined_behavior_unlimited)
</pre>
</div>

<pre class="example" id="run-burn-cell-as-head-fire-results">
Fire Behavior from Combined Surface and Crown Fire (with Wind Limit) at Coordinate (24, 100, 100)
====================================================================================================
{'fire_type': 'surface',
 'fireline_intensity': 32.528250853562525,
 'flame_length': 0.38439333737509035,
 'spread_direction': array([0.48686895, 0.61304247, 0.62220383]),
 'spread_rate': 2.2964679102816112}

Fire Behavior from Combined Surface and Crown Fire (without Wind Limit) at Coordinate (24, 100, 100)
====================================================================================================
{'fire_type': 'surface',
 'fireline_intensity': 50.61292548195906,
 'flame_length': 0.47108164985334633,
 'spread_direction': array([0.48686895, 0.61304247, 0.62220383]),
 'spread_rate': 3.5732311503021905}
</pre>
</div>
</div>
<div id="outline-container-how-to-burn-a-cell-in-any-direction" class="outline-4">
<h4 id="how-to-burn-a-cell-in-any-direction"><span class="section-number-4">8.2.2.</span> How to Burn a Cell in Any Direction</h4>
<div class="outline-text-4" id="text-how-to-burn-a-cell-in-any-direction">
<div class="org-src-container">
<pre class="src src-python" id="run-burn-cell-toward-azimuth"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.burn_cells <span class="org-keyword">as</span> bc
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (
    240,  <span class="org-comment-delimiter"># </span><span class="org-comment">bands: 10 days @ 1 hour/band</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">rows:  30 km @ 30 meters/row</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">cols:  30 km @ 30 meters/col</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Create an input dictionary of SpaceTimeCubes (using constant data for this example)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">space_time_cubes</span> <span class="org-operator">=</span> {
    <span class="org-string">"slope"</span>                        : SpaceTimeCube(cube_shape, 0.8),   <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-string">"aspect"</span>                       : SpaceTimeCube(cube_shape, 225.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_model"</span>                   : SpaceTimeCube(cube_shape, 101),   <span class="org-comment-delimiter"># </span><span class="org-comment">integer index in fm.fuel_model_table</span>
    <span class="org-string">"canopy_cover"</span>                 : SpaceTimeCube(cube_shape, 0.6),   <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
    <span class="org-string">"canopy_height"</span>                : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_base_height"</span>           : SpaceTimeCube(cube_shape, 3.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_bulk_density"</span>          : SpaceTimeCube(cube_shape, 0.3),   <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>
    <span class="org-string">"wind_speed_10m"</span>               : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-string">"upwind_direction"</span>             : SpaceTimeCube(cube_shape, 180.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_moisture_dead_1hr"</span>       : SpaceTimeCube(cube_shape, 0.05),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_10hr"</span>      : SpaceTimeCube(cube_shape, 0.10),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_100hr"</span>     : SpaceTimeCube(cube_shape, 0.15),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_herbaceous"</span>: SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_woody"</span>     : SpaceTimeCube(cube_shape, 0.60),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"foliar_moisture"</span>              : SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_spread_adjustment"</span>       : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
    <span class="org-string">"weather_spread_adjustment"</span>    : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
}

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify a space-time coordinate (t,y,x) within the extent of the SpaceTimeCube dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">space_time_coordinate</span> <span class="org-operator">=</span> (24, 100, 100)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify an azimuth to spread the fire towards</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">spread_azimuth</span> <span class="org-operator">=</span> 90.0 <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North on the horizontal plane</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate combined fire behavior in the direction of the azimuth (with wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">combined_behavior_limited</span> <span class="org-operator">=</span> bc.burn_cell_toward_azimuth(space_time_cubes, space_time_coordinate, spread_azimuth)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate combined fire behavior in the direction of the azimuth (without wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">combined_behavior_unlimited</span> <span class="org-operator">=</span> bc.burn_cell_toward_azimuth(space_time_cubes, space_time_coordinate, spread_azimuth,
                                                          use_wind_limit<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Display combined fire behavior in the direction of the azimuth (with wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"Fire Behavior from Combined Surface and Crown Fire (with Wind Limit) at Coordinate "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(space_time_coordinate) <span class="org-operator">+</span> <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 100)
pprint(combined_behavior_limited)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Display combined fire behavior in the direction of the azimuth (without wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Fire Behavior from Combined Surface and Crown Fire (without Wind Limit) at Coordinate "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(space_time_coordinate) <span class="org-operator">+</span> <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 100)
pprint(combined_behavior_unlimited)
</pre>
</div>

<pre class="example" id="run-burn-cell-toward-azimuth-results">
Fire Behavior from Combined Surface and Crown Fire (with Wind Limit) at Coordinate (24, 100, 100)
====================================================================================================
{'fire_type': 'surface',
 'fireline_intensity': 11.637272597794672,
 'flame_length': 0.23956726794677918,
 'spread_direction': array([ 8.70388269e-01, -3.80458793e-08,  4.92365986e-01]),
 'spread_rate': 0.8215819290236468}

Fire Behavior from Combined Surface and Crown Fire (without Wind Limit) at Coordinate (24, 100, 100)
====================================================================================================
{'fire_type': 'surface',
 'fireline_intensity': 13.89820197455359,
 'flame_length': 0.2599542303459697,
 'spread_direction': array([ 8.70388269e-01, -3.80458793e-08,  4.92365986e-01]),
 'spread_rate': 0.9812016941476362}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-fire-spread-algorithm:-eulerian-level-set-method-(pyretechnics.eulerian_level_set)" class="outline-2">
<h2 id="fire-spread-algorithm:-eulerian-level-set-method-(pyretechnics.eulerian_level_set)"><span class="section-number-2">9.</span> Fire Spread Algorithm: Eulerian Level Set Method (ELMFIRE) (pyretechnics.eulerian_level_set)</h2>
<div class="outline-text-2" id="text-fire-spread-algorithm:-eulerian-level-set-method-(pyretechnics.eulerian_level_set)">
</div>
<div id="outline-container-for-developers-fire-spread" class="outline-3">
<h3 id="for-developers-fire-spread"><span class="section-number-3">9.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-for-developers-fire-spread">
<p>
In order to simulate the spread of a fire from a starting point or
perimeter, we will need to implement a model that projects the
one-dimensional spread and intensity equations presented in sections
<a href="#surface-fire-equations-(pyretechnics.surface_fire)">5</a> and <a href="#crown-fire-equations-(pyretechnics.crown_fire)">6</a> into the three-dimensional
space-time cube introduced in section <a href="#data-model">2</a>.
</p>

<p>
This section introduces the equations used in the Eulerian level set
method of fire spread, operationalized in Chris Lautenberger's ELMFIRE
model<sup><a id="fnr.58" class="footref" href="#fn.58" role="doc-backlink">58</a></sup>.
</p>
</div>
<div id="outline-container-the-$\phi$-field" class="outline-4">
<h4 id="the-$\phi$-field"><span class="section-number-4">9.1.1.</span> The \(\phi\) Field</h4>
<div class="outline-text-4" id="text-the-$\phi$-field">
<p>
In this model, a continuous field called \(\phi\) fills the simulation
space and is used to track the progression of the fire front through
space and time. Within Pyretechnics, the \(\phi\) field is discretized
into grid cells and initialized with the following values:
</p>

<ul class="org-ul">
<li>-1 for cells that have already been burned and are inside the fire perimeter</li>
<li>1 for cells that have not been burned and are outside the fire perimeter</li>
</ul>

<p>
If a fire is being simulated starting from an actively burning
perimeter, the \(\phi\) grid cells indicate the initially burning region.
If a point fire is being simulated, then a single \(\phi\) cell will be
set to -1 and the remaining cells will have the value 1.
</p>
</div>
</div>
<div id="outline-container-fire-front-normal-vector" class="outline-4">
<h4 id="fire-front-normal-vector"><span class="section-number-4">9.1.2.</span> Fire Front Normal Vector</h4>
<div class="outline-text-4" id="text-fire-front-normal-vector">
<p>
In this fire spread algorithm, the fire front only propagates normal
to itself. Given a \(\phi\) raster, we can calculate the normal vector to
the \(\phi\) field by using the following formula:
</p>

\begin{align}
  \hat{n} &= n_x\hat{i} + n_y\hat{j} = \frac{1}{|\nabla\phi|}\left(\frac{\partial \phi}{\partial x}\hat{i} + \frac{\partial \phi}{\partial y}\hat{j}\right) \\
  \nonumber \\
  |\nabla\phi| &= \sqrt{\left(\frac{\partial \phi}{\partial x}\right)^2 + \left(\frac{\partial \phi}{\partial y}\right)^2}
\end{align}

<p>
We begin by approximating the spatial gradients of the \(\phi\) field with
node-centered central differences, represented by the values in the
\(\phi\) raster's grid cells.
</p>

\begin{align}
  \left(\frac{\partial \phi}{\partial x}\right)_{i,j} &\approx \frac{\phi_{i+1,j} - \phi_{i-1,j}}{2 \Delta x} \\
  \nonumber \\
  \left(\frac{\partial \phi}{\partial y}\right)_{i,j} &\approx \frac{\phi_{i,j+1} - \phi_{i,j-1}}{2 \Delta y}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="phi-field-spatial-gradients-approx"><span class="org-comment-delimiter"># </span><span class="org-comment">cython: profile=False</span>
<span class="org-keyword">import</span> cython
<span class="org-keyword">if</span> cython.compiled:
    <span class="org-keyword">from</span> cython.cimports.pyretechnics.math <span class="org-keyword">import</span> sqrt, atan
    <span class="org-keyword">from</span> cython.cimports.pyretechnics.cy_types <span class="org-keyword">import</span> pyidx, vec_xy, vec_xyz, coord_yx, coord_tyx
    <span class="org-keyword">from</span> cython.cimports.pyretechnics.conversion <span class="org-keyword">import</span> \
        rad_to_deg, opposite_direction, azimuthal_to_cartesian, wind_speed_10m_to_wind_speed_20ft, \
        Btu_lb_to_kJ_kg, km_hr_to_m_min, m_to_ft
    <span class="org-keyword">from</span> cython.cimports.pyretechnics.vector_utils <span class="org-keyword">import</span> \
        vector_magnitude_2d, vector_magnitude_3d, as_unit_vector_2d, as_unit_vector_3d, dot_2d, dot_3d, \
        get_slope_normal_vector, to_slope_plane, spread_direction_vector_to_angle
<span class="org-keyword">else</span>:
    <span class="org-keyword">from</span> math <span class="org-keyword">import</span> sqrt, atan
    <span class="org-keyword">from</span> pyretechnics.py_types <span class="org-keyword">import</span> pyidx, vec_xy, vec_xyz, coord_yx, coord_tyx
    <span class="org-keyword">from</span> pyretechnics.conversion <span class="org-keyword">import</span> \
        rad_to_deg, opposite_direction, azimuthal_to_cartesian, wind_speed_10m_to_wind_speed_20ft, \
        Btu_lb_to_kJ_kg, km_hr_to_m_min, m_to_ft
    <span class="org-keyword">from</span> pyretechnics.vector_utils <span class="org-keyword">import</span> \
        vector_magnitude_2d, vector_magnitude_3d, as_unit_vector_2d, as_unit_vector_3d, dot_2d, dot_3d, \
        get_slope_normal_vector, to_slope_plane, spread_direction_vector_to_angle


<span class="org-keyword">import</span> cython <span class="org-keyword">as</span> cy
<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: cimport all of the modules below</span>
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> pyretechnics.crown_fire <span class="org-keyword">as</span> cf
<span class="org-keyword">import</span> pyretechnics.fuel_models <span class="org-keyword">as</span> fm
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube, LazySpaceTimeCube
<span class="org-keyword">import</span> pyretechnics.spot_fire <span class="org-keyword">as</span> spot
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf


<span class="org-variable-name">PI</span> <span class="org-operator">=</span> cy.declare(cy.double, 3.14159265358979323846)


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(65504.0)
<span class="org-type">@cy.wraparound</span>(<span class="org-constant">False</span>)
<span class="org-type">@cy.boundscheck</span>(<span class="org-constant">False</span>)
<span class="org-type">@cy.cdivision</span>(<span class="org-constant">True</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_dphi_dx_approx</span>(phi: cy.<span class="org-builtin">float</span>[:,:], dx: cy.<span class="org-builtin">float</span>, x: pyidx, y: pyidx, cols: pyidx) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the spatial gradient of the phi raster in the x (west-&gt;east)</span>
<span class="org-doc">    direction at grid cell (x,y) given the cell width dx.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">east_x</span>: pyidx <span class="org-operator">=</span> x <span class="org-operator">+</span> 1
    <span class="org-variable-name">west_x</span>: pyidx <span class="org-operator">=</span> x <span class="org-operator">-</span> 1
    <span class="org-keyword">if</span> east_x <span class="org-operator">&lt;</span> cols:
        <span class="org-keyword">if</span> west_x <span class="org-operator">&gt;=</span> 0:
            <span class="org-keyword">return</span> (phi[y][east_x] <span class="org-operator">-</span> phi[y][west_x]) <span class="org-operator">/</span> (2.0 <span class="org-operator">*</span> dx)
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> (phi[y][east_x] <span class="org-operator">-</span> phi[y][x]) <span class="org-operator">/</span> dx
    <span class="org-keyword">else</span>:
        <span class="org-keyword">if</span> west_x <span class="org-operator">&gt;=</span> 0:
            <span class="org-keyword">return</span> (phi[y][x] <span class="org-operator">-</span> phi[y][west_x]) <span class="org-operator">/</span> dx
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> 0.0


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(65504.0)
<span class="org-type">@cy.wraparound</span>(<span class="org-constant">False</span>)
<span class="org-type">@cy.boundscheck</span>(<span class="org-constant">False</span>)
<span class="org-type">@cy.cdivision</span>(<span class="org-constant">True</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_dphi_dy_approx</span>(phi: cy.<span class="org-builtin">float</span>[:,:], dy: cy.<span class="org-builtin">float</span>, x: pyidx, y: pyidx, rows: pyidx) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the spatial gradient of the phi raster in the y (south-&gt;north)</span>
<span class="org-doc">    direction at grid cell (x,y) given the cell height dy.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">north_y</span>: pyidx <span class="org-operator">=</span> y <span class="org-operator">+</span> 1
    <span class="org-variable-name">south_y</span>: pyidx <span class="org-operator">=</span> y <span class="org-operator">-</span> 1
    <span class="org-keyword">if</span> north_y <span class="org-operator">&lt;</span> rows:
        <span class="org-keyword">if</span> south_y <span class="org-operator">&gt;=</span> 0:
            <span class="org-keyword">return</span> (phi[north_y][x] <span class="org-operator">-</span> phi[south_y][x]) <span class="org-operator">/</span> (2.0 <span class="org-operator">*</span> dy)
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> (phi[north_y][x] <span class="org-operator">-</span> phi[y][x]) <span class="org-operator">/</span> dy
    <span class="org-keyword">else</span>:
        <span class="org-keyword">if</span> south_y <span class="org-operator">&gt;=</span> 0:
            <span class="org-keyword">return</span> (phi[y][x] <span class="org-operator">-</span> phi[south_y][x]) <span class="org-operator">/</span> dy
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> 0.0


<span class="org-type">@cy.cfunc</span>
<span class="org-keyword">def</span> <span class="org-function-name">calc_phi_gradient_approx</span>(phi: cy.<span class="org-builtin">float</span>[:,:], dx: cy.<span class="org-builtin">float</span>, dy: cy.<span class="org-builtin">float</span>, x: pyidx, y: pyidx,
                             rows: pyidx, cols: pyidx) <span class="org-operator">-&gt;</span> vec_xy:
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the spatial gradient of the phi raster at grid cell (x,y)</span>
<span class="org-doc">    given the cell width dx and the cell height dy.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">dphi_dx</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_dphi_dx_approx(phi, dx, x, y, cols)
    <span class="org-variable-name">dphi_dy</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_dphi_dy_approx(phi, dy, x, y, rows)
    <span class="org-keyword">return</span> (dphi_dx, dphi_dy)
</pre>
</div>

<p>
We can now combine these spatial gradients with the magnitude of the
gradient of the \(\phi\) field at any location on the grid to compute
the fire front normal vector as follows:
</p>

<div class="org-src-container">
<pre class="src src-python" id="phi-field-normal-vector"><span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Remove unused function</span>
<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">calc_phi_normal_vector</span>(phi: cy.<span class="org-builtin">float</span>[:,:], dx: cy.<span class="org-builtin">float</span>, dy: cy.<span class="org-builtin">float</span>, x: pyidx, y: pyidx) <span class="org-operator">-&gt;</span> vec_xy:
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the phi field normal vector in the x and y dimensions.</span>

<span class="org-doc">    - n_x: eastward component of the unit normal vector</span>
<span class="org-doc">    - n_y: northward component of the unit normal vector</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">rows</span>        : pyidx  <span class="org-operator">=</span> phi.shape[0]
    <span class="org-variable-name">cols</span>        : pyidx  <span class="org-operator">=</span> phi.shape[1]
    <span class="org-variable-name">phi_gradient</span>: vec_xy <span class="org-operator">=</span> calc_phi_gradient_approx(phi, dx, dy, x, y, rows, cols)
    <span class="org-keyword">if</span> phi_gradient[0] <span class="org-operator">==</span> 0.0 <span class="org-keyword">and</span> phi_gradient[1] <span class="org-operator">==</span> 0.0:
        <span class="org-keyword">return</span> phi_gradient <span class="org-comment-delimiter"># </span><span class="org-comment">(n_x, n_y)</span>
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> as_unit_vector_2d(phi_gradient) <span class="org-comment-delimiter"># </span><span class="org-comment">(n_x, n_y)</span>
</pre>
</div>

<p>
Next, we can use the following geometrical relations to calculate the
angle \(\theta_n\) (measured clockwise from North) to which the normal
vector points:
</p>

\begin{equation}
  \theta_n =
  \begin{cases}
    \frac{1}{2}\pi - \tan^{-1}(\frac{n_y}{n_x}) & \text{for}\ n_x > 0 & \text{and}\ n_y \geq 0 \\
    \frac{1}{2}\pi + \tan^{-1}(\frac{|n_y|}{n_x}) & \text{for}\ n_x > 0 & \text{and}\ n_y < 0 \\
    \frac{3}{2}\pi + \tan^{-1}(\frac{n_y}{|n_x|}) & \text{for}\ n_x < 0 & \text{and}\ n_y \geq 0 \\
    \frac{3}{2}\pi - \tan^{-1}(\frac{n_y}{n_x}) & \text{for}\ n_x < 0 & \text{and}\ n_y < 0 \\
    0 & \text{for}\ n_x = 0 & \text{and}\ n_y \geq 0 \\
    \pi & \text{for}\ n_x = 0 & \text{and}\ n_y < 0
  \end{cases}
\end{equation}

<div class="org-src-container">
<pre class="src src-python" id="phi-field-normal-vector-angle"><span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Remove unused function</span>
<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.cdivision</span>(<span class="org-constant">True</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_phi_normal_azimuth</span>(phi_normal_vector: vec_xy) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the angle (measured in degrees clockwise from North)</span>
<span class="org-doc">    to which the phi field's normal vector points.</span>
<span class="org-doc">    """</span>
    (<span class="org-variable-name">n_x</span>, <span class="org-variable-name">n_y</span>) <span class="org-operator">=</span> phi_normal_vector
    angle: cy.<span class="org-builtin">float</span>
    <span class="org-keyword">if</span> n_x <span class="org-operator">&gt;</span> 0.0:
        <span class="org-keyword">if</span> n_y <span class="org-operator">&gt;=</span> 0.0:
            <span class="org-variable-name">angle</span> <span class="org-operator">=</span> 0.5 <span class="org-operator">*</span> PI <span class="org-operator">-</span> atan(n_y <span class="org-operator">/</span> n_x)
        <span class="org-keyword">elif</span> n_y <span class="org-operator">&lt;</span> 0.0:
            <span class="org-variable-name">angle</span> <span class="org-operator">=</span> 0.5 <span class="org-operator">*</span> PI <span class="org-operator">+</span> atan(<span class="org-builtin">abs</span>(n_y) <span class="org-operator">/</span> n_x)
    <span class="org-keyword">elif</span> n_x <span class="org-operator">&lt;</span> 0.0:
        <span class="org-keyword">if</span> n_y <span class="org-operator">&gt;=</span> 0.0:
            <span class="org-variable-name">angle</span> <span class="org-operator">=</span> 1.5 <span class="org-operator">*</span> PI <span class="org-operator">+</span> atan(n_y <span class="org-operator">/</span> <span class="org-builtin">abs</span>(n_x))
        <span class="org-keyword">elif</span> n_y <span class="org-operator">&lt;</span> 0.0:
            <span class="org-variable-name">angle</span> <span class="org-operator">=</span> 1.5 <span class="org-operator">*</span> PI <span class="org-operator">-</span> atan(n_y <span class="org-operator">/</span> n_x)
    <span class="org-keyword">else</span>:
        <span class="org-keyword">if</span> n_y <span class="org-operator">&gt;=</span> 0.0:
            <span class="org-variable-name">angle</span> <span class="org-operator">=</span> 0.0
        <span class="org-keyword">elif</span> n_y <span class="org-operator">&lt;</span> 0.0:
            <span class="org-variable-name">angle</span> <span class="org-operator">=</span> PI
    <span class="org-keyword">return</span> rad_to_deg(angle)
</pre>
</div>

<p>
Now that we can compute the fire front normal vector, we can find the
spread rate in this direction by combining this vector with the
maximum spread rate vector and elliptical eccentricity values
calculated for each grid cell, using the approaches described in
sections <a href="#surface-fire-equations-(pyretechnics.surface_fire)">5</a> and <a href="#crown-fire-equations-(pyretechnics.crown_fire)">6</a>.
</p>

<p>
We will refer to the spread rate vector normal to the fire front in
the following sections as \(U\) with spatial components \(U_x\) and \(U_y\).
</p>
</div>
</div>
<div id="outline-container-numerical-solution-of-the-$\phi$-field-equation" class="outline-4">
<h4 id="numerical-solution-of-the-$\phi$-field-equation"><span class="section-number-4">9.1.3.</span> Numerical Solution of the \(\phi\) Field Equation</h4>
<div class="outline-text-4" id="text-numerical-solution-of-the-$\phi$-field-equation">
<p>
In order to evolve the \(\phi\) field through time and space, we must
solve the following hyperbolic differential equation for the scalar
variable \(\phi\).
</p>

\begin{align}
  \frac{\partial \phi}{\partial t} + U_x \frac{\partial \phi}{\partial x} + U_y \frac{\partial \phi}{\partial y} = 0
\end{align}

<p>
This is accomplished after applying a flux limiter to the convective
terms, in order to ensure solution monotonicity and prevent spurious
oscillations that can be induced in its absence.
</p>

<p>
First, we define the parameter \(r\) and the Superbee flux limiter
\(B(r)\) as follows:
</p>

\begin{align}
  r &= \frac{\delta\phi_{\text{up}}}{\delta\phi_{\text{loc}}} \\
  \nonumber \\
  B(r) &= \max(0, \min(2r, 1), \min(r, 2))
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="superbee-flux-limiter"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(65504.0)
<span class="org-keyword">def</span> <span class="org-function-name">calc_superbee_flux_limiter</span>(dphi_up: cy.<span class="org-builtin">float</span>, dphi_loc: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">if</span> dphi_loc <span class="org-operator">==</span> 0.0:
        <span class="org-keyword">return</span> 0.0
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">r</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> dphi_up <span class="org-operator">/</span> dphi_loc
        <span class="org-keyword">return</span> <span class="org-builtin">max</span>(0.0,
                   <span class="org-builtin">min</span>(2.0 <span class="org-operator">*</span> r, 1.0),
                   <span class="org-builtin">min</span>(r, 2.0))
</pre>
</div>

<p>
To compute the inputs to this function, we build up the partial
derivatives of the \(\phi\) field in terms of "east", "west", "north",
and "south" values as follows:
</p>

\begin{align}
  \frac{\partial \phi}{\partial x} &\approx \frac{\phi_{\text{east}} - \phi_{\text{west}}}{\Delta x} \\
  \nonumber \\
  \frac{\partial \phi}{\partial y} &\approx \frac{\phi_{\text{north}} - \phi_{\text{south}}}{\Delta y}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="phi-field-spatial-gradients"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(65504.0)
<span class="org-keyword">def</span> <span class="org-function-name">calc_dphi_dx</span>(phi: cy.<span class="org-builtin">float</span>[:,:], u_x: cy.<span class="org-builtin">float</span>, dx: cy.<span class="org-builtin">float</span>, x: pyidx, y: pyidx, cols: pyidx) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the spatial gradient of the phi raster in the x (west-&gt;east)</span>
<span class="org-doc">    direction at grid cell (x,y) given:</span>
<span class="org-doc">    - phi  :: 2D float array of values in [-1,1]</span>
<span class="org-doc">    - u_x  :: m/min</span>
<span class="org-doc">    - dx   :: meters</span>
<span class="org-doc">    - x    :: integer column index in phi</span>
<span class="org-doc">    - y    :: integer row index in phi</span>
<span class="org-doc">    - cols :: integer number of columns in the phi matrix</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">phi_east</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_phi_east(phi, u_x, x, y, cols)
    <span class="org-variable-name">phi_west</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_phi_west(phi, u_x, x, y, cols)
    <span class="org-keyword">return</span> (phi_east <span class="org-operator">-</span> phi_west) <span class="org-operator">/</span> dx


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(65504.0)
<span class="org-keyword">def</span> <span class="org-function-name">calc_dphi_dy</span>(phi: cy.<span class="org-builtin">float</span>[:,:], u_y: cy.<span class="org-builtin">float</span>, dy: cy.<span class="org-builtin">float</span>, x: pyidx, y: pyidx, rows: pyidx) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the spatial gradient of the phi raster in the y (south-&gt;north)</span>
<span class="org-doc">    direction at grid cell (x,y) given:</span>
<span class="org-doc">    - phi  :: 2D float array of values in [-1,1]</span>
<span class="org-doc">    - u_y  :: m/min</span>
<span class="org-doc">    - dy   :: meters</span>
<span class="org-doc">    - x    :: integer column index in phi</span>
<span class="org-doc">    - y    :: integer row index in phi</span>
<span class="org-doc">    - rows :: integer number of rows in the phi matrix</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">phi_north</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_phi_north(phi, u_y, x, y, rows)
    <span class="org-variable-name">phi_south</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_phi_south(phi, u_y, x, y, rows)
    <span class="org-keyword">return</span> (phi_north <span class="org-operator">-</span> phi_south) <span class="org-operator">/</span> dy


<span class="org-type">@cy.cfunc</span>
<span class="org-keyword">def</span> <span class="org-function-name">calc_phi_gradient</span>(phi: cy.<span class="org-builtin">float</span>[:,:], u_x: cy.<span class="org-builtin">float</span>, u_y: cy.<span class="org-builtin">float</span>, dx: cy.<span class="org-builtin">float</span>, dy: cy.<span class="org-builtin">float</span>,
                      x: pyidx, y: pyidx, rows: pyidx, cols: pyidx) <span class="org-operator">-&gt;</span> vec_xy:
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the spatial gradient of the phi raster at grid cell (x,y) given:</span>
<span class="org-doc">    - phi  :: 2D float array of values in [-1,1]</span>
<span class="org-doc">    - u_x  :: m/min</span>
<span class="org-doc">    - u_y  :: m/min</span>
<span class="org-doc">    - dx   :: meters</span>
<span class="org-doc">    - dy   :: meters</span>
<span class="org-doc">    - x    :: integer column index in phi</span>
<span class="org-doc">    - y    :: integer row index in phi</span>
<span class="org-doc">    - rows :: row count in phi matrix</span>
<span class="org-doc">    - cols :: column count in phi matrix</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">dphi_dx</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_dphi_dx(phi, u_x, dx, x, y, cols)
    <span class="org-variable-name">dphi_dy</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_dphi_dy(phi, u_y, dy, x, y, rows)
    <span class="org-keyword">return</span> (dphi_dx, dphi_dy)
</pre>
</div>

<p>
For the east face:
</p>

\begin{align}
  \delta\phi_{\text{loc}} &= \phi_{i+1,j} - \phi{i,j} \\
  \nonumber \\
  \delta\phi_{\text{up}} &= \begin{cases}
                              \phi_{i,j} - \phi_{i-1,j} & \text{for}\ u_{x,i,j} \ge 0 \\
                              \phi_{i+2,j} - \phi_{i+1,j} & \text{for}\ u_{x,i,j} < 0
                            \end{cases} \\
  \nonumber \\
  \phi_{\text{east}} &= \begin{cases}
                          \phi_{i,j} + \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{x,i,j} \ge 0 \\
                          \phi_{i+1,j} - \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{x,i,j} < 0
                        \end{cases}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="phi-east"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(65504.0)
<span class="org-type">@cy.wraparound</span>(<span class="org-constant">False</span>)
<span class="org-type">@cy.boundscheck</span>(<span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_phi_east</span>(phi: cy.<span class="org-builtin">float</span>[:,:], u_x: cy.<span class="org-builtin">float</span>, x: pyidx, y: pyidx, cols: pyidx) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the spatial gradient of the phi raster in the x (west-&gt;east)</span>
<span class="org-doc">    direction at grid cell (x,y) given:</span>
<span class="org-doc">    - phi  :: 2D float array of values in [-1,1]</span>
<span class="org-doc">    - u_x  :: m/min</span>
<span class="org-doc">    - x    :: integer column index in phi</span>
<span class="org-doc">    - y    :: integer row index in phi</span>
<span class="org-doc">    - cols :: integer number of columns in the phi matrix</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">very_east_x</span>: pyidx <span class="org-operator">=</span> <span class="org-builtin">min</span>(x<span class="org-operator">+</span>2, cols<span class="org-operator">-</span>1)
    <span class="org-variable-name">east_x</span>     : pyidx <span class="org-operator">=</span> <span class="org-builtin">min</span>(x<span class="org-operator">+</span>1, cols<span class="org-operator">-</span>1)
    <span class="org-variable-name">west_x</span>     : pyidx <span class="org-operator">=</span> <span class="org-builtin">max</span>(x<span class="org-operator">-</span>1, 0)

    <span class="org-variable-name">dphi_loc</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi[y][east_x] <span class="org-operator">-</span> phi[y][x]
    <span class="org-keyword">if</span> u_x <span class="org-operator">&gt;=</span> 0.0:
        <span class="org-variable-name">dphi_up</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi[y][x] <span class="org-operator">-</span> phi[y][west_x]
        <span class="org-variable-name">B</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span class="org-keyword">return</span> phi[y][x] <span class="org-operator">+</span> 0.5 <span class="org-operator">*</span> B <span class="org-operator">*</span> dphi_loc
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">dphi_up</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi[y][very_east_x] <span class="org-operator">-</span> phi[y][east_x]
        <span class="org-variable-name">B</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span class="org-keyword">return</span> phi[y][east_x] <span class="org-operator">-</span> 0.5 <span class="org-operator">*</span> B <span class="org-operator">*</span> dphi_loc
</pre>
</div>

<p>
For the west face:
</p>

\begin{align}
  \delta\phi_{\text{loc}} &= \phi_{i-1,j} - \phi{i,j} \\
  \nonumber \\
  \delta\phi_{\text{up}} &= \begin{cases}
                              \phi_{i-2,j} - \phi_{i-1,j} & \text{for}\ u_{x,i,j} \ge 0 \\
                              \phi_{i,j} - \phi_{i+1,j} & \text{for}\ u_{x,i,j} < 0
                            \end{cases} \\
  \nonumber \\
  \phi_{\text{west}} &= \begin{cases}
                          \phi_{i-1,j} - \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{x,i,j} \ge 0 \\
                          \phi_{i,j} + \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{x,i,j} < 0
                        \end{cases}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="phi-west"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(65504.0)
<span class="org-type">@cy.wraparound</span>(<span class="org-constant">False</span>)
<span class="org-type">@cy.boundscheck</span>(<span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_phi_west</span>(phi: cy.<span class="org-builtin">float</span>[:,:], u_x: cy.<span class="org-builtin">float</span>, x: pyidx, y: pyidx, cols: pyidx) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the spatial gradient of the phi raster in the -x (east-&gt;west)</span>
<span class="org-doc">    direction at grid cell (x,y) given:</span>
<span class="org-doc">    - phi  :: 2D float array of values in [-1,1]</span>
<span class="org-doc">    - u_x  :: m/min</span>
<span class="org-doc">    - x    :: integer column index in phi</span>
<span class="org-doc">    - y    :: integer row index in phi</span>
<span class="org-doc">    - cols :: integer number of columns in the phi matrix</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">east_x</span>     : pyidx <span class="org-operator">=</span> <span class="org-builtin">min</span>(x<span class="org-operator">+</span>1, cols<span class="org-operator">-</span>1)
    <span class="org-variable-name">west_x</span>     : pyidx <span class="org-operator">=</span> <span class="org-builtin">max</span>(x<span class="org-operator">-</span>1, 0)
    <span class="org-variable-name">very_west_x</span>: pyidx <span class="org-operator">=</span> <span class="org-builtin">max</span>(x<span class="org-operator">-</span>2, 0)

    <span class="org-variable-name">dphi_loc</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi[y][west_x] <span class="org-operator">-</span> phi[y][x]
    <span class="org-keyword">if</span> u_x <span class="org-operator">&gt;=</span> 0.0:
        <span class="org-variable-name">dphi_up</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi[y][very_west_x] <span class="org-operator">-</span> phi[y][west_x]
        <span class="org-variable-name">B</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span class="org-keyword">return</span> phi[y][west_x] <span class="org-operator">-</span> 0.5 <span class="org-operator">*</span> B <span class="org-operator">*</span> dphi_loc
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">dphi_up</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi[y][x] <span class="org-operator">-</span> phi[y][east_x]
        <span class="org-variable-name">B</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span class="org-keyword">return</span> phi[y][x] <span class="org-operator">+</span> 0.5 <span class="org-operator">*</span> B <span class="org-operator">*</span> dphi_loc
</pre>
</div>

<p>
For the north face:
</p>

\begin{align}
  \delta\phi_{\text{loc}} &= \phi_{i,j+1} - \phi{i,j} \\
  \nonumber \\
  \delta\phi_{\text{up}} &= \begin{cases}
                              \phi_{i,j} - \phi_{i,j-1} & \text{for}\ u_{y,i,j} \ge 0 \\
                              \phi_{i,j+2} - \phi_{i,j+1} & \text{for}\ u_{y,i,j} < 0
                            \end{cases} \\
  \nonumber \\
  \phi_{\text{north}} &= \begin{cases}
                           \phi_{i,j} + \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{y,i,j} \ge 0 \\
                           \phi_{i,j+1} - \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{y,i,j} < 0
                         \end{cases}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="phi-north"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(65504.0)
<span class="org-type">@cy.wraparound</span>(<span class="org-constant">False</span>)
<span class="org-type">@cy.boundscheck</span>(<span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_phi_north</span>(phi: cy.<span class="org-builtin">float</span>[:,:], u_y: cy.<span class="org-builtin">float</span>, x: pyidx, y: pyidx, rows: pyidx) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the spatial gradient of the phi raster in the y (south-&gt;north)</span>
<span class="org-doc">    direction at grid cell (x,y) given:</span>
<span class="org-doc">    - phi  :: 2D float array of values in [-1,1]</span>
<span class="org-doc">    - u_y  :: m/min</span>
<span class="org-doc">    - x    :: integer column index in phi</span>
<span class="org-doc">    - y    :: integer row index in phi</span>
<span class="org-doc">    - rows :: integer number of rows in the phi matrix</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">very_north_y</span>: pyidx <span class="org-operator">=</span> <span class="org-builtin">min</span>(y<span class="org-operator">+</span>2, rows<span class="org-operator">-</span>1)
    <span class="org-variable-name">north_y</span>     : pyidx <span class="org-operator">=</span> <span class="org-builtin">min</span>(y<span class="org-operator">+</span>1, rows<span class="org-operator">-</span>1)
    <span class="org-variable-name">south_y</span>     : pyidx <span class="org-operator">=</span> <span class="org-builtin">max</span>(y<span class="org-operator">-</span>1, 0)

    <span class="org-variable-name">dphi_loc</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi[north_y][x] <span class="org-operator">-</span> phi[y][x]
    <span class="org-keyword">if</span> u_y <span class="org-operator">&gt;=</span> 0.0:
        <span class="org-variable-name">dphi_up</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi[y][x] <span class="org-operator">-</span> phi[south_y][x]
        <span class="org-variable-name">B</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span class="org-keyword">return</span> phi[y][x] <span class="org-operator">+</span> 0.5 <span class="org-operator">*</span> B <span class="org-operator">*</span> dphi_loc
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">dphi_up</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi[very_north_y][x] <span class="org-operator">-</span> phi[north_y][x]
        <span class="org-variable-name">B</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span class="org-keyword">return</span> phi[north_y][x] <span class="org-operator">-</span> 0.5 <span class="org-operator">*</span> B <span class="org-operator">*</span> dphi_loc
</pre>
</div>

<p>
For the south face:
</p>

\begin{align}
  \delta\phi_{\text{loc}} &= \phi_{i,j-1} - \phi{i,j} \\
  \nonumber \\
  \delta\phi_{\text{up}} &= \begin{cases}
                              \phi_{i,j-2} - \phi_{i,j-1} & \text{for}\ u_{y,i,j} \ge 0 \\
                              \phi_{i,j} - \phi_{i,j+1} & \text{for}\ u_{y,i,j} < 0
                            \end{cases} \\
  \nonumber \\
  \phi_{\text{south}} &= \begin{cases}
                           \phi_{i,j-1} - \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{y,i,j} \ge 0 \\
                           \phi_{i,j} + \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{y,i,j} < 0
                         \end{cases}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="phi-south"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(65504.0)
<span class="org-type">@cy.wraparound</span>(<span class="org-constant">False</span>)
<span class="org-type">@cy.boundscheck</span>(<span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_phi_south</span>(phi: cy.<span class="org-builtin">float</span>[:,:], u_y: cy.<span class="org-builtin">float</span>, x: pyidx, y: pyidx, rows: pyidx) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the spatial gradient of the phi raster in the -y (north-&gt;south)</span>
<span class="org-doc">    direction at grid cell (x,y) given:</span>
<span class="org-doc">    - phi  :: 2D float array of values in [-1,1]</span>
<span class="org-doc">    - u_y  :: m/min</span>
<span class="org-doc">    - x    :: integer column index in phi</span>
<span class="org-doc">    - y    :: integer row index in phi</span>
<span class="org-doc">    - rows :: integer number of rows in the phi matrix</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">north_y</span>     : pyidx <span class="org-operator">=</span> <span class="org-builtin">min</span>(y<span class="org-operator">+</span>1, rows<span class="org-operator">-</span>1)
    <span class="org-variable-name">south_y</span>     : pyidx <span class="org-operator">=</span> <span class="org-builtin">max</span>(y<span class="org-operator">-</span>1, 0)
    <span class="org-variable-name">very_south_y</span>: pyidx <span class="org-operator">=</span> <span class="org-builtin">max</span>(y<span class="org-operator">-</span>2, 0)

    <span class="org-variable-name">dphi_loc</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi[south_y][x] <span class="org-operator">-</span> phi[y][x]
    <span class="org-keyword">if</span> u_y <span class="org-operator">&gt;=</span> 0.0:
        <span class="org-variable-name">dphi_up</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi[very_south_y][x] <span class="org-operator">-</span> phi[south_y][x]
        <span class="org-variable-name">B</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span class="org-keyword">return</span> phi[south_y][x] <span class="org-operator">-</span> 0.5 <span class="org-operator">*</span> B <span class="org-operator">*</span> dphi_loc
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">dphi_up</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi[y][x] <span class="org-operator">-</span> phi[north_y][x]
        <span class="org-variable-name">B</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span class="org-keyword">return</span> phi[y][x] <span class="org-operator">+</span> 0.5 <span class="org-operator">*</span> B <span class="org-operator">*</span> dphi_loc
</pre>
</div>

<p>
Once the various spatial partial derivatives have been calculated, we
can march the \(\phi\) field solution forward in time using a second
order Runge Kutta method as follows:
</p>

\begin{align}
  \phi^* &= \phi^t - \Delta t \left(U_x \frac{\phi^t_{\text{east}} - \phi^t_{\text{west}}}{\Delta x} + U_y \frac{\phi^t_{\text{north}} - \phi^t_{\text{south}}}{\Delta y} \right) \\
  \nonumber \\
  \phi^{t + \Delta t} &= \frac{1}{2}\phi^t + \frac{1}{2} \left( \phi^* - \Delta t \left(U_x \frac{\phi^*_{\text{east}} - \phi^*_{\text{west}}}{\Delta x} + U_y \frac{\phi^*_{\text{north}} - \phi^*_{\text{south}}}{\Delta y} \right) \right)
\end{align}

<p>
In the above equations, timestep (\(\Delta t\)) is constrained by the
Courant-Friedrichs-Lewy (CFL) condition. The location of the fire
perimeter is determined by interpolation of the \(\phi\) field as the
level set corresponding to \(\phi = 0\).
</p>
</div>
</div>
<div id="outline-container-calculate-the-surface/crown-fireline-normal-behavior" class="outline-4">
<h4 id="calculate-the-surface/crown-fireline-normal-behavior"><span class="section-number-4">9.1.4.</span> Calculate the Surface/Crown Fireline Normal Behavior</h4>
<div class="outline-text-4" id="text-calculate-the-surface/crown-fireline-normal-behavior">
<p>
Since the fire front only propagates normal to itself in this fire
spread algorithm, we need a method to translate the surface and/or
crown fire behavior associated with a heading fire into the surface
and/or crown fire behavior normal to the fire front. This process is
illustrated below.
</p>

<div class="org-src-container">
<pre class="src src-python" id="calc-fireline-normal-behavior"><span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Move this to pyretechnics.vector_utils and use throughout the literate program</span>
<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">calc_elevation_gradient</span>(slope: cy.<span class="org-builtin">float</span>, aspect: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> vec_xy:
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the elevation gradient (dz_dx: rise/run, dz_dy: rise/run) given:</span>
<span class="org-doc">    - slope  :: rise/run</span>
<span class="org-doc">    - aspect :: degrees clockwise from North</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> azimuthal_to_cartesian(slope, opposite_direction(aspect))


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">calc_phi_gradient_on_slope</span>(phi_gradient_xy: vec_xy, elevation_gradient: vec_xy) <span class="org-operator">-&gt;</span> vec_xyz:
    <span class="org-doc">"""</span>
<span class="org-doc">    Return the gradient of phi projected onto the slope-tangential plane as a 3D (x,y,z) vector (in phi/m) given:</span>
<span class="org-doc">    - phi_gradient_xy    :: (dphi_dx: phi/m, dphi_dy: phi/m) 2D vector on the horizontal plane</span>
<span class="org-doc">    - elevation_gradient :: (dz_dx: rise/run, dz_dy: rise/run)</span>
<span class="org-doc">    """</span>
    (<span class="org-variable-name">dphi_dx</span>, <span class="org-variable-name">dphi_dy</span>)        <span class="org-operator">=</span> phi_gradient_xy
    <span class="org-variable-name">phi_gradient_xyz</span>: vec_xyz <span class="org-operator">=</span> (dphi_dx, dphi_dy, 0.0)
    <span class="org-keyword">if</span> vector_magnitude_2d(elevation_gradient) <span class="org-operator">==</span> 0.0:
        <span class="org-keyword">return</span> phi_gradient_xyz
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">slope_normal_vector</span>: vec_xyz  <span class="org-operator">=</span> get_slope_normal_vector(elevation_gradient) <span class="org-comment-delimiter"># </span><span class="org-comment">(x,y,z) unit vector</span>
        <span class="org-variable-name">phi_slope_agreement</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> dot_3d(phi_gradient_xyz, slope_normal_vector)
        <span class="org-variable-name">dphi_dx_on_slope</span>   : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi_gradient_xyz[0] <span class="org-operator">-</span> phi_slope_agreement <span class="org-operator">*</span> slope_normal_vector[0]
        <span class="org-variable-name">dphi_dy_on_slope</span>   : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi_gradient_xyz[1] <span class="org-operator">-</span> phi_slope_agreement <span class="org-operator">*</span> slope_normal_vector[1]
        <span class="org-variable-name">dphi_dz_on_slope</span>   : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi_gradient_xyz[2] <span class="org-operator">-</span> phi_slope_agreement <span class="org-operator">*</span> slope_normal_vector[2]
        <span class="org-keyword">return</span> (dphi_dx_on_slope, dphi_dy_on_slope, dphi_dz_on_slope)


<span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Do I switch to cruz_passive_crown_fire_spread_rate() if the normal_spread_rate &lt; critical_spread_rate?</span>
<span class="org-comment-delimiter">#        </span><span class="org-comment">Did I do this correctly in calc_crown_fire_behavior_in_direction?</span>
<span class="org-type">@cy.profile</span>(<span class="org-constant">True</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_fireline_normal_behavior</span>(fire_behavior_max, phi_gradient):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - fire_behavior_max  :: dictionary of max surface or crown fire behavior values</span>
<span class="org-doc">      - max_fire_type          :: "passive_crown" or "active_crown" (Required for crown fires only)</span>
<span class="org-doc">      - max_spread_rate        :: m/min</span>
<span class="org-doc">      - max_spread_direction   :: (x, y, z) unit vector</span>
<span class="org-doc">      - max_fireline_intensity :: kW/m</span>
<span class="org-doc">      - max_flame_length       :: m</span>
<span class="org-doc">      - length_to_width_ratio  :: unitless (1: circular spread, &gt; 1: elliptical spread)</span>
<span class="org-doc">      - eccentricity           :: unitless (0: circular spread, &gt; 0: elliptical spread)</span>
<span class="org-doc">      - critical_spread_rate   :: m/min (Required for crown fires only)</span>
<span class="org-doc">    - phi_gradient       :: (dphi_dx: phi/m, dphi_dy: phi/m, dphi_dz: phi/m) 3D vector on the slope-tangential plane</span>

<span class="org-doc">    return a dictionary containing these keys:</span>
<span class="org-doc">    - dphi_dt            :: phi/min (on the slope-tangential plane)</span>
<span class="org-doc">    - fire_type          :: "unburned", "surface", "passive_crown", or "active_crown"</span>
<span class="org-doc">    - spread_rate        :: m/min</span>
<span class="org-doc">    - spread_direction   :: (x, y, z) unit vector</span>
<span class="org-doc">    - fireline_intensity :: kW/m</span>
<span class="org-doc">    - flame_length       :: m</span>

<span class="org-doc">    Note: This function should work for surface or crown fires interchangeably.</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the magnitude of the phi gradient</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    <span class="org-variable-name">phi_magnitude</span> <span class="org-operator">=</span> vector_magnitude_3d(phi_gradient) <span class="org-comment-delimiter"># </span><span class="org-comment">phi/m</span>

    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Check whether cell is on the fire perimeter and burning</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    <span class="org-keyword">if</span> (phi_magnitude <span class="org-operator">==</span> 0.0 <span class="org-keyword">or</span> fire_behavior_max[<span class="org-string">"max_spread_rate"</span>] <span class="org-operator">==</span> 0.0):
        <span class="org-comment-delimiter"># </span><span class="org-comment">This location is not on the fire perimeter and/or is not burning</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Set the spread direction to the phi gradient direction, max spread direction, upslope, or North</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

        <span class="org-variable-name">spread_direction</span> <span class="org-operator">=</span> (np.asarray(phi_gradient) <span class="org-operator">/</span> phi_magnitude <span class="org-keyword">if</span> phi_magnitude <span class="org-operator">&gt;</span> 0.0
                            <span class="org-keyword">else</span> fire_behavior_max[<span class="org-string">"max_spread_direction"</span>])

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Return zero surface/crown fire behavior</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-keyword">return</span> {
            <span class="org-string">"dphi_dt"</span>           : 0.0,
            <span class="org-string">"fire_type"</span>         : <span class="org-string">"unburned"</span>,
            <span class="org-string">"spread_rate"</span>       : 0.0,
            <span class="org-string">"spread_direction"</span>  : spread_direction,
            <span class="org-string">"fireline_intensity"</span>: 0.0,
            <span class="org-string">"flame_length"</span>      : 0.0,
        }

    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">This location is on the fire perimeter and is burning</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack the fire_behavior_max dictionary</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-variable-name">heading_fire_type</span>          <span class="org-operator">=</span> fire_behavior_max.get(<span class="org-string">"max_fire_type"</span>, <span class="org-string">"surface"</span>)
        <span class="org-variable-name">heading_spread_rate</span>        <span class="org-operator">=</span> fire_behavior_max[<span class="org-string">"max_spread_rate"</span>]               <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
        <span class="org-variable-name">heading_spread_direction</span>   <span class="org-operator">=</span> fire_behavior_max[<span class="org-string">"max_spread_direction"</span>]          <span class="org-comment-delimiter"># </span><span class="org-comment">(x,y,z) unit vector</span>
        <span class="org-variable-name">heading_spread_vector</span>      <span class="org-operator">=</span> heading_spread_rate <span class="org-operator">*</span> heading_spread_direction     <span class="org-comment-delimiter"># </span><span class="org-comment">(x,y,z) m/min vector</span>
        <span class="org-variable-name">heading_fireline_intensity</span> <span class="org-operator">=</span> fire_behavior_max[<span class="org-string">"max_fireline_intensity"</span>]        <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
        <span class="org-variable-name">length_to_width_ratio</span>      <span class="org-operator">=</span> fire_behavior_max[<span class="org-string">"length_to_width_ratio"</span>]         <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
        <span class="org-variable-name">eccentricity</span>               <span class="org-operator">=</span> fire_behavior_max[<span class="org-string">"eccentricity"</span>]                  <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
        <span class="org-variable-name">critical_spread_rate</span>       <span class="org-operator">=</span> fire_behavior_max.get(<span class="org-string">"critical_spread_rate"</span>, 0.0) <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the backing and flanking fire spread rates</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-variable-name">backing_adjustment</span>   <span class="org-operator">=</span> (1.0 <span class="org-operator">-</span> eccentricity) <span class="org-operator">/</span> (1.0 <span class="org-operator">+</span> eccentricity)                                 <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
        <span class="org-variable-name">backing_spread_rate</span>  <span class="org-operator">=</span> heading_spread_rate <span class="org-operator">*</span> backing_adjustment                                    <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
        <span class="org-variable-name">flanking_spread_rate</span> <span class="org-operator">=</span> (heading_spread_rate <span class="org-operator">+</span> backing_spread_rate) <span class="org-operator">/</span> (2.0 <span class="org-operator">*</span> length_to_width_ratio) <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate dphi/dt</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-variable-name">A</span>       <span class="org-operator">=</span> (heading_spread_rate <span class="org-operator">-</span> backing_spread_rate) <span class="org-operator">/</span> (2 <span class="org-operator">*</span> heading_spread_rate) <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
        <span class="org-variable-name">B</span>       <span class="org-operator">=</span> np.dot(heading_spread_vector, phi_gradient)                             <span class="org-comment-delimiter"># </span><span class="org-comment">phi/min</span>
        <span class="org-variable-name">C</span>       <span class="org-operator">=</span> flanking_spread_rate <span class="org-operator">/</span> heading_spread_rate                              <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
        <span class="org-variable-name">D</span>       <span class="org-operator">=</span> (heading_spread_rate <span class="org-operator">*</span> phi_magnitude) <span class="org-operator">**</span> 2.0                            <span class="org-comment-delimiter"># </span><span class="org-comment">(phi/min)^2</span>
        <span class="org-variable-name">E</span>       <span class="org-operator">=</span> (length_to_width_ratio <span class="org-operator">**</span> 2.0 <span class="org-operator">-</span> 1.0) <span class="org-operator">*</span> (B <span class="org-operator">**</span> 2.0)                       <span class="org-comment-delimiter"># </span><span class="org-comment">(phi/min)^2</span>
        <span class="org-variable-name">dphi_dt</span> <span class="org-operator">=</span> <span class="org-operator">-</span>(A <span class="org-operator">*</span> B <span class="org-operator">+</span> C <span class="org-operator">*</span> sqrt(D <span class="org-operator">+</span> E))                                              <span class="org-comment-delimiter"># </span><span class="org-comment">phi/min</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate fire behavior normal to the fire perimeter</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-variable-name">normal_spread_rate</span>        <span class="org-operator">=</span> <span class="org-operator">-</span>dphi_dt <span class="org-operator">/</span> phi_magnitude                        <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
        <span class="org-variable-name">normal_direction</span>          <span class="org-operator">=</span> np.asarray(phi_gradient) <span class="org-operator">/</span> phi_magnitude        <span class="org-comment-delimiter"># </span><span class="org-comment">(x,y,z) unit vector</span>
        <span class="org-variable-name">normal_adjustment</span>         <span class="org-operator">=</span> normal_spread_rate <span class="org-operator">/</span> heading_spread_rate        <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
        <span class="org-variable-name">normal_fireline_intensity</span> <span class="org-operator">=</span> heading_fireline_intensity <span class="org-operator">*</span> normal_adjustment  <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
        <span class="org-variable-name">normal_flame_length</span>       <span class="org-operator">=</span> sf.calc_flame_length(normal_fireline_intensity) <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
        <span class="org-variable-name">normal_fire_type</span>          <span class="org-operator">=</span> (<span class="org-string">"surface"</span> <span class="org-keyword">if</span> heading_fire_type <span class="org-operator">==</span> <span class="org-string">"surface"</span>
                                     <span class="org-keyword">else</span> <span class="org-string">"active_crown"</span> <span class="org-keyword">if</span> normal_spread_rate <span class="org-operator">&gt;</span> critical_spread_rate
                                     <span class="org-keyword">else</span> <span class="org-string">"passive_crown"</span>)

        <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Return the surface/crown fire behavior normal to the fire perimeter</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

        <span class="org-keyword">return</span> {
            <span class="org-string">"dphi_dt"</span>           : dphi_dt,                   <span class="org-comment-delimiter"># </span><span class="org-comment">phi/min</span>
            <span class="org-string">"fire_type"</span>         : normal_fire_type,          <span class="org-comment-delimiter"># </span><span class="org-comment">surface, passive_crown, or active_crown</span>
            <span class="org-string">"spread_rate"</span>       : normal_spread_rate,        <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
            <span class="org-string">"spread_direction"</span>  : normal_direction,          <span class="org-comment-delimiter"># </span><span class="org-comment">(x,y,z) unit vector</span>
            <span class="org-string">"fireline_intensity"</span>: normal_fireline_intensity, <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
            <span class="org-string">"flame_length"</span>      : normal_flame_length,       <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
        }
</pre>
</div>
</div>
</div>
<div id="outline-container-burn-cell-normal-to-the-fire-perimeter" class="outline-4">
<h4 id="burn-cell-normal-to-the-fire-perimeter"><span class="section-number-4">9.1.5.</span> Burn Cell Normal to the Fire Perimeter</h4>
<div class="outline-text-4" id="text-burn-cell-normal-to-the-fire-perimeter">
<p>
When the goal of a fire behavior analysis is to evolve a burn scar
from its point of ignition into a generally conical shape in
space-time, then it is necessary to evaluate the combined surface and
crown fire behavior in the direction normal to the fire front. In
order to facilitate this calculation, the following function uses the
horizontal \(\phi\) gradient, which denotes the maximum rate of change
in the \(\phi\) field at each grid cell in the horizontal (spatial)
plane. This 2D vector is first projected onto the 3D local
slope-tangential plane and used to compute the surface fire behavior
in this direction. If a crown fire occurs, the crown fire behavior is
also calculated in the direction of the 3D \(\phi\) gradient, and the
combined surface and crown fire behavior (as per section <a href="#combining-surface-and-crown-fire-behavior">6.1.7</a>) is returned. If no crown fire occurs,
the surface fire behavior in the direction of the 3D \(\phi\) gradient
is returned.
</p>

<div class="org-src-container">
<pre class="src src-python" id="burn-cell-toward-phi-gradient"><span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Create a version of this function that runs efficiently over a space_time_region</span>
<span class="org-type">@cy.profile</span>(<span class="org-constant">True</span>)
<span class="org-keyword">def</span> <span class="org-function-name">burn_cell_toward_phi_gradient</span>(space_time_cubes, space_time_coordinate, phi_gradient_xy, use_wind_limit<span class="org-operator">=</span><span class="org-constant">True</span>,
                                  surface_lw_ratio_model<span class="org-operator">=</span><span class="org-string">"rothermel"</span>, crown_max_lw_ratio<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - space_time_cubes             :: dictionary of (Lazy)SpaceTimeCube objects with these cell types</span>
<span class="org-doc">      - slope                         :: rise/run</span>
<span class="org-doc">      - aspect                        :: degrees clockwise from North</span>
<span class="org-doc">      - fuel_model                    :: integer index in fm.fuel_model_table</span>
<span class="org-doc">      - canopy_cover                  :: 0-1</span>
<span class="org-doc">      - canopy_height                 :: m</span>
<span class="org-doc">      - canopy_base_height            :: m</span>
<span class="org-doc">      - canopy_bulk_density           :: kg/m^3</span>
<span class="org-doc">      - wind_speed_10m                :: km/hr</span>
<span class="org-doc">      - upwind_direction              :: degrees clockwise from North</span>
<span class="org-doc">      - fuel_moisture_dead_1hr        :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_dead_10hr       :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_dead_100hr      :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_live_herbaceous :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_live_woody      :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - foliar_moisture               :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_spread_adjustment        :: float &gt;= 0.0 (Optional: defaults to 1.0)</span>
<span class="org-doc">      - weather_spread_adjustment     :: float &gt;= 0.0 (Optional: defaults to 1.0)</span>
<span class="org-doc">    - space_time_coordinate        :: (t,y,x)</span>
<span class="org-doc">    - phi_gradient_xy              :: (dphi_dx: phi/m, dphi_dy: phi/m) 2D vector on the horizontal plane</span>
<span class="org-doc">    - use_wind_limit               :: boolean (Optional)</span>
<span class="org-doc">    - surface_lw_ratio_model       :: "rothermel" or "behave" (Optional)</span>
<span class="org-doc">    - crown_max_lw_ratio           :: float &gt; 0.0 (Optional)</span>

<span class="org-doc">    return a dictionary with these fire behavior values for the space-time coordinate (t,y,x):</span>
<span class="org-doc">    - dphi_dt            :: phi/min (on the slope-tangential plane)</span>
<span class="org-doc">    - fire_type          :: "unburned", "surface", "passive_crown", or "active_crown"</span>
<span class="org-doc">    - spread_rate        :: m/min</span>
<span class="org-doc">    - spread_direction   :: (x, y, z) unit vector on the slope-tangential plane</span>
<span class="org-doc">    - fireline_intensity :: kW/m</span>
<span class="org-doc">    - flame_length       :: m</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the space_time_coordinate</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    (<span class="org-variable-name">t</span>, <span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>) <span class="org-operator">=</span> space_time_coordinate

    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack the space_time_cubes dictionary</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Topography, Fuel Model, and Vegetation</span>
    <span class="org-variable-name">slope</span>               <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"slope"</span>].get(t,y,x)               <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-variable-name">aspect</span>              <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"aspect"</span>].get(t,y,x)              <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-variable-name">fuel_model_number</span>   <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_model"</span>].get(t,y,x)          <span class="org-comment-delimiter"># </span><span class="org-comment">integer index in fm.fuel_model_table</span>
    <span class="org-variable-name">canopy_cover</span>        <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"canopy_cover"</span>].get(t,y,x)        <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
    <span class="org-variable-name">canopy_height</span>       <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"canopy_height"</span>].get(t,y,x)       <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-variable-name">canopy_base_height</span>  <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"canopy_base_height"</span>].get(t,y,x)  <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-variable-name">canopy_bulk_density</span> <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"canopy_bulk_density"</span>].get(t,y,x) <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Wind, Surface Moisture, and Foliar Moisture</span>
    <span class="org-variable-name">wind_speed_10m</span>                <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"wind_speed_10m"</span>].get(t,y,x)                <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-variable-name">upwind_direction</span>              <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"upwind_direction"</span>].get(t,y,x)              <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-variable-name">fuel_moisture_dead_1hr</span>        <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_dead_1hr"</span>].get(t,y,x)        <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_dead_10hr</span>       <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_dead_10hr"</span>].get(t,y,x)       <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_dead_100hr</span>      <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_dead_100hr"</span>].get(t,y,x)      <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_live_herbaceous</span> <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_live_herbaceous"</span>].get(t,y,x) <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_live_woody</span>      <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_live_woody"</span>].get(t,y,x)      <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">foliar_moisture</span>               <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"foliar_moisture"</span>].get(t,y,x)               <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Spread Rate Adjustments (Optional)</span>
    <span class="org-variable-name">fuel_spread_adjustment</span>    <span class="org-operator">=</span> (space_time_cubes[<span class="org-string">"fuel_spread_adjustment"</span>].get(t,y,x)
                                 <span class="org-keyword">if</span> <span class="org-string">"fuel_spread_adjustment"</span> <span class="org-keyword">in</span> space_time_cubes
                                 <span class="org-keyword">else</span> 1.0)                                         <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>
    <span class="org-variable-name">weather_spread_adjustment</span> <span class="org-operator">=</span> (space_time_cubes[<span class="org-string">"weather_spread_adjustment"</span>].get(t,y,x)
                                 <span class="org-keyword">if</span> <span class="org-string">"weather_spread_adjustment"</span> <span class="org-keyword">in</span> space_time_cubes
                                 <span class="org-keyword">else</span> 1.0)                                         <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>
    <span class="org-variable-name">spread_rate_adjustment</span>    <span class="org-operator">=</span> fuel_spread_adjustment <span class="org-operator">*</span> weather_spread_adjustment <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>

    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the elevation gradient</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    <span class="org-variable-name">elevation_gradient</span> <span class="org-operator">=</span> calc_elevation_gradient(slope, aspect)

    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Project the horizontal phi gradient onto the slope-tangential plane</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

    <span class="org-variable-name">phi_gradient</span> <span class="org-operator">=</span> calc_phi_gradient_on_slope(phi_gradient_xy, elevation_gradient)

    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the magnitude of the phi gradient</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    <span class="org-variable-name">phi_magnitude</span> <span class="org-operator">=</span> vector_magnitude_3d(phi_gradient) <span class="org-comment-delimiter"># </span><span class="org-comment">phi/m</span>

    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Check whether cell is on the fire perimeter and burnable</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    <span class="org-variable-name">fuel_model</span> <span class="org-operator">=</span> fm.fuel_model_table.get(fuel_model_number)

    <span class="org-keyword">if</span> <span class="org-keyword">not</span> (phi_magnitude <span class="org-operator">&gt;</span> 0.0 <span class="org-keyword">and</span> fuel_model <span class="org-keyword">and</span> fuel_model[<span class="org-string">"burnable"</span>]):
        <span class="org-comment-delimiter"># </span><span class="org-comment">Cell is not on the fire perimeter and/or contains an unknown or non-burnable fuel model</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Set the spread direction to the phi gradient direction, upslope, or North</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

        <span class="org-keyword">if</span> phi_magnitude <span class="org-operator">&gt;</span> 0.0:
            <span class="org-variable-name">spread_direction</span> <span class="org-operator">=</span> np.asarray(phi_gradient) <span class="org-operator">/</span> phi_magnitude
        <span class="org-keyword">elif</span> slope <span class="org-operator">&gt;</span> 0.0:
            <span class="org-variable-name">slope_vector_3d</span>  <span class="org-operator">=</span> to_slope_plane(elevation_gradient, elevation_gradient)
            <span class="org-variable-name">spread_direction</span> <span class="org-operator">=</span> np.asarray(as_unit_vector_3d(slope_vector_3d))
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">spread_direction</span> <span class="org-operator">=</span> np.asarray((0.0,1.0,0.0)) <span class="org-comment-delimiter"># </span><span class="org-comment">default: North</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Return zero surface fire behavior</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-keyword">return</span> {
            <span class="org-string">"dphi_dt"</span>           : 0.0,
            <span class="org-string">"fire_type"</span>         : <span class="org-string">"unburned"</span>,
            <span class="org-string">"spread_rate"</span>       : 0.0,
            <span class="org-string">"spread_direction"</span>  : spread_direction,
            <span class="org-string">"fireline_intensity"</span>: 0.0,
            <span class="org-string">"flame_length"</span>      : 0.0,
        }

    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Cell is on the fire perimeter and contains a burnable fuel model</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Compute derived parameters</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-variable-name">fuel_moisture</span>                <span class="org-operator">=</span> [fuel_moisture_dead_1hr,
                                        fuel_moisture_dead_10hr,
                                        fuel_moisture_dead_100hr,
                                        0.0, <span class="org-comment-delimiter"># </span><span class="org-comment">fuel_moisture_dead_herbaceous</span>
                                        fuel_moisture_live_herbaceous,
                                        fuel_moisture_live_woody]          <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
        <span class="org-variable-name">fuel_bed_depth</span>               <span class="org-operator">=</span> fuel_model[<span class="org-string">"delta"</span>]                 <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
        <span class="org-variable-name">heat_of_combustion</span>           <span class="org-operator">=</span> Btu_lb_to_kJ_kg(fuel_model[<span class="org-string">"h"</span>][0]) <span class="org-comment-delimiter"># </span><span class="org-comment">kJ/kg</span>
        <span class="org-variable-name">estimated_fine_fuel_moisture</span> <span class="org-operator">=</span> fuel_moisture_dead_1hr              <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate midflame wind speed</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 10m wind speed to 20ft wind speed</span>
        <span class="org-variable-name">wind_speed_20ft</span> <span class="org-operator">=</span> wind_speed_10m_to_wind_speed_20ft(wind_speed_10m) <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Convert 20ft wind speed from km/hr to m/min</span>
        <span class="org-variable-name">wind_speed_20ft_m_min</span> <span class="org-operator">=</span> km_hr_to_m_min(wind_speed_20ft) <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 20ft wind speed to midflame wind speed in m/min</span>
        <span class="org-variable-name">midflame_wind_speed</span> <span class="org-operator">=</span> sf.calc_midflame_wind_speed(wind_speed_20ft_m_min,  <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
                                                          fuel_bed_depth,         <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                          m_to_ft(canopy_height), <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                          canopy_cover)           <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Apply fuel moisture to fuel model</span>
        <span class="org-variable-name">moisturized_fuel_model</span> <span class="org-operator">=</span> fm.moisturize(fuel_model, fuel_moisture)

        <span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Memoize calc_surface_fire_behavior_no_wind_no_slope</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate no-wind-no-slope surface fire behavior</span>
        <span class="org-variable-name">surface_fire_min</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model,
                                                                          spread_rate_adjustment)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread</span>
        <span class="org-variable-name">surface_fire_max</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_max(surface_fire_min,
                                                             midflame_wind_speed,
                                                             upwind_direction,
                                                             slope,
                                                             aspect,
                                                             use_wind_limit,
                                                             surface_lw_ratio_model)

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior normal to the fire perimeter</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-variable-name">surface_fire_normal</span> <span class="org-operator">=</span> calc_fireline_normal_behavior(surface_fire_max, phi_gradient)

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Determine whether the surface fire transitions to a crown fire</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-keyword">if</span> cf.van_wagner_crown_fire_initiation(surface_fire_normal[<span class="org-string">"fireline_intensity"</span>],
                                               canopy_cover,
                                               canopy_base_height,
                                               foliar_moisture):

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction of maximum spread</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-variable-name">crown_fire_max</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_max(canopy_height, canopy_base_height,
                                                             canopy_bulk_density, heat_of_combustion,
                                                             estimated_fine_fuel_moisture,
                                                             wind_speed_10m, upwind_direction,
                                                             slope, aspect, crown_max_lw_ratio)

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior normal to the fire perimeter</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-variable-name">crown_fire_normal</span> <span class="org-operator">=</span> calc_fireline_normal_behavior(crown_fire_max, phi_gradient)

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate combined fire behavior normal to the fire perimeter</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-variable-name">combined_fire_normal</span> <span class="org-operator">=</span> cf.calc_combined_fire_behavior(surface_fire_normal, crown_fire_normal)
            <span class="org-variable-name">surface_dphi_dt</span>      <span class="org-operator">=</span> surface_fire_normal[<span class="org-string">"dphi_dt"</span>]
            <span class="org-variable-name">crown_dphi_dt</span>        <span class="org-operator">=</span> crown_fire_normal[<span class="org-string">"dphi_dt"</span>]
            <span class="org-variable-name">combined_dphi_dt</span>     <span class="org-operator">=</span> surface_dphi_dt <span class="org-keyword">if</span> <span class="org-builtin">abs</span>(surface_dphi_dt) <span class="org-operator">&gt;</span> <span class="org-builtin">abs</span>(crown_dphi_dt) <span class="org-keyword">else</span> crown_dphi_dt
            <span class="org-variable-name">combined_fire_normal</span>[<span class="org-string">"dphi_dt"</span>] <span class="org-operator">=</span> combined_dphi_dt

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Return the combined fire behavior normal to the fire perimeter</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-keyword">return</span> combined_fire_normal

        <span class="org-keyword">else</span>:

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Return the surface fire behavior normal to the fire perimeter</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-keyword">return</span> surface_fire_normal
</pre>
</div>
</div>
</div>
<div id="outline-container-identify-cells-near-the-fire-perimeter-($\phi-=-0$)" class="outline-4">
<h4 id="identify-cells-near-the-fire-perimeter-($\phi-=-0$)"><span class="section-number-4">9.1.6.</span> Identify Cells Near the Fire Perimeter (\(\phi = 0\))</h4>
<div class="outline-text-4" id="text-identify-cells-near-the-fire-perimeter-($\phi-=-0$)">
</div>
<ol class="org-ol">
<li><a id="a-proposed-algorithm-for-narrow-band-tracking"></a>A proposed algorithm for narrow band tracking<br>
<div class="outline-text-5" id="text-a-proposed-algorithm-for-narrow-band-tracking">
</div>
<ol class="org-ol">
<li><a id="problem-statement"></a>Problem statement<br>
<div class="outline-text-6" id="text-problem-statement">
<p>
To make the level-set method efficient, an important optimization
consists of updating only those cells in a narrow band around the fire
front (e.g., within a width of 3 cells). This way fire behavior gets
computed (and \(\phi\) gets updated) only on a sparse subset of the
landscape at each timestep.
</p>
</div>
</li>
<li><a id="definitions"></a>Definitions<br>
<div class="outline-text-6" id="text-definitions">
<p>
At a given time step:
</p>

<ol class="org-ol">
<li>a <span class="underline">frontier</span> cell is a cell that has a neighbor of opposite \(\phi\)
sign.</li>

<li>a <span class="underline">tracked</span> cell is a cell for which we will compute the fire
behavior and update the \(\phi\) field.</li>
</ol>
</div>
</li>
<li><a id="suggested-algorithm"></a>Suggested algorithm<br>
<div class="outline-text-6" id="text-suggested-algorithm">
<dl class="org-dl">
<dt>Detecting Frontier Cells</dt><dd>iterate through cell pairs (N/S, E/W),
computing the products of their \(\phi\) values and match when these
are negative.</dd>

<dt>Invariant</dt><dd>at each time step, the set of tracked cells is the set
of cells within 3 cells of a frontier cell using the Chebyshev
distance.</dd>

<dt>State</dt><dd>we maintain a "reference counting" map, mapping each
tracked cell to the number of frontier cells to which it is near
(<span class="underline">near</span> means "within 3 cells" using the Chebyshev distance). In
particular, the keyset of this map is the set of tracked cells.</dd>

<dt>Iteration</dt><dd>at the end of timestep \(t\), we know the values of
\(\phi(t)\) and \(\phi(t+\Delta t)\) for all tracked cells. We now must
compute the new set of tracked cells, which involves updating the
reference-counting map. We do so by taking the following steps:

<ol class="org-ol">
<li>Scan the set of tracked cells, and compute two subsets of them:
(A) those that have become frontier cells and (B) those that are
no longer frontier cells.</li>

<li>For each cell in A (new frontier cell), list the cells near it,
and increment their tracking counter by 1.</li>

<li>For each cell in B (no longer a frontier cell), list the cells
near it, and decrement their tracking counter by 1. Upon reaching
0, remove the map entry.</li>
</ol></dd>
</dl>

<div class="org-src-container">
<pre class="src src-python" id="phi-field-perimeter-tracking"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.wraparound</span>(<span class="org-constant">False</span>)
<span class="org-type">@cy.boundscheck</span>(<span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">opposite_phi_signs</span>(phi_matrix: cy.<span class="org-builtin">float</span>[:,:], y1: pyidx, x1: pyidx, y2: pyidx, x2: pyidx) <span class="org-operator">-&gt;</span> cy.bint:
    <span class="org-doc">"""</span>
<span class="org-doc">    Return True if the phi values at cells (x1,y1) and (x2,y2) have opposite signs.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> phi_matrix[y1, x1] <span class="org-operator">*</span> phi_matrix[y2, x2] <span class="org-operator">&lt;</span> 0.0


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Is it faster to build up a list or a set?</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Should we store each frontier_cells entry as a coord_xy?</span>
<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">identify_all_frontier_cells</span>(phi_matrix: cy.<span class="org-builtin">float</span>[:,:], rows: pyidx, cols: pyidx) <span class="org-operator">-&gt;</span> <span class="org-builtin">set</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">frontier_cells</span>: <span class="org-builtin">set</span> <span class="org-operator">=</span> <span class="org-builtin">set</span>()
    y             : pyidx
    x             : pyidx
    <span class="org-keyword">for</span> y <span class="org-keyword">in</span> <span class="org-builtin">range</span>(rows):
        <span class="org-keyword">for</span> x <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cols):
            <span class="org-comment-delimiter"># </span><span class="org-comment">Compare (north, south, east, west) neighboring cell pairs for opposite phi signs</span>
            <span class="org-variable-name">north_y</span>: pyidx <span class="org-operator">=</span> <span class="org-builtin">min</span>(y<span class="org-operator">+</span>1, rows<span class="org-operator">-</span>1)
            <span class="org-variable-name">south_y</span>: pyidx <span class="org-operator">=</span> <span class="org-builtin">max</span>(y<span class="org-operator">-</span>1, 0)
            <span class="org-variable-name">east_x</span> : pyidx <span class="org-operator">=</span> <span class="org-builtin">min</span>(x<span class="org-operator">+</span>1, cols<span class="org-operator">-</span>1)
            <span class="org-variable-name">west_x</span> : pyidx <span class="org-operator">=</span> <span class="org-builtin">max</span>(x<span class="org-operator">-</span>1, 0)
            <span class="org-keyword">if</span> (opposite_phi_signs(phi_matrix, y, x, north_y, x) <span class="org-keyword">or</span>
                opposite_phi_signs(phi_matrix, y, x, south_y, x) <span class="org-keyword">or</span>
                opposite_phi_signs(phi_matrix, y, x, y, east_x) <span class="org-keyword">or</span>
                opposite_phi_signs(phi_matrix, y, x, y, west_x)):
                frontier_cells.add((y, x))
    <span class="org-keyword">return</span> frontier_cells


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Is it faster to build up a list or a set?</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Should we store each frontier_cells entry as a coord_xy?</span>
<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">identify_tracked_frontier_cells</span>(phi_matrix: cy.<span class="org-builtin">float</span>[:,:], tracked_cells: <span class="org-builtin">dict</span>, rows: pyidx, cols: pyidx) <span class="org-operator">-&gt;</span> <span class="org-builtin">set</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">frontier_cells</span>: <span class="org-builtin">set</span> <span class="org-operator">=</span> <span class="org-builtin">set</span>()
    <span class="org-keyword">for</span> cell_index <span class="org-keyword">in</span> tracked_cells.keys():
        <span class="org-comment-delimiter"># </span><span class="org-comment">Compare (north, south, east, west) neighboring cell pairs for opposite phi signs</span>
        <span class="org-variable-name">y</span>      : pyidx <span class="org-operator">=</span> cell_index[0]
        <span class="org-variable-name">x</span>      : pyidx <span class="org-operator">=</span> cell_index[1]
        <span class="org-variable-name">north_y</span>: pyidx <span class="org-operator">=</span> <span class="org-builtin">min</span>(y<span class="org-operator">+</span>1, rows<span class="org-operator">-</span>1)
        <span class="org-variable-name">south_y</span>: pyidx <span class="org-operator">=</span> <span class="org-builtin">max</span>(y<span class="org-operator">-</span>1, 0)
        <span class="org-variable-name">east_x</span> : pyidx <span class="org-operator">=</span> <span class="org-builtin">min</span>(x<span class="org-operator">+</span>1, cols<span class="org-operator">-</span>1)
        <span class="org-variable-name">west_x</span> : pyidx <span class="org-operator">=</span> <span class="org-builtin">max</span>(x<span class="org-operator">-</span>1, 0)
        <span class="org-keyword">if</span> (opposite_phi_signs(phi_matrix, y, x, north_y, x) <span class="org-keyword">or</span>
            opposite_phi_signs(phi_matrix, y, x, south_y, x) <span class="org-keyword">or</span>
            opposite_phi_signs(phi_matrix, y, x, y, east_x) <span class="org-keyword">or</span>
            opposite_phi_signs(phi_matrix, y, x, y, west_x)):
            frontier_cells.add(cell_index)
    <span class="org-keyword">return</span> frontier_cells


<span class="org-type">@cy.cfunc</span>
<span class="org-keyword">def</span> <span class="org-function-name">project_buffer</span>(cell: coord_yx, buffer_width: pyidx, rows: pyidx, cols: pyidx) <span class="org-operator">-&gt;</span> <span class="org-builtin">list</span>[coord_yx]:
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">y</span>            : pyidx          <span class="org-operator">=</span> cell[0]
    <span class="org-variable-name">x</span>            : pyidx          <span class="org-operator">=</span> cell[1]
    <span class="org-variable-name">buffer_y_min</span> : pyidx          <span class="org-operator">=</span> <span class="org-builtin">max</span>(0, y <span class="org-operator">-</span> buffer_width)
    <span class="org-variable-name">buffer_x_min</span> : pyidx          <span class="org-operator">=</span> <span class="org-builtin">max</span>(0, x <span class="org-operator">-</span> buffer_width)
    <span class="org-variable-name">buffer_y_max</span> : pyidx          <span class="org-operator">=</span> <span class="org-builtin">min</span>(rows, y <span class="org-operator">+</span> buffer_width <span class="org-operator">+</span> 1)
    <span class="org-variable-name">buffer_x_max</span> : pyidx          <span class="org-operator">=</span> <span class="org-builtin">min</span>(cols, x <span class="org-operator">+</span> buffer_width <span class="org-operator">+</span> 1)
    <span class="org-variable-name">buffer_y_span</span>: pyidx          <span class="org-operator">=</span> buffer_y_max <span class="org-operator">-</span> buffer_y_min
    <span class="org-variable-name">buffer_x_span</span>: pyidx          <span class="org-operator">=</span> buffer_x_max <span class="org-operator">-</span> buffer_x_min
    <span class="org-variable-name">buffer_cells</span> : <span class="org-builtin">list</span>[coord_yx] <span class="org-operator">=</span> []
    y_idx        : pyidx
    x_idx        : pyidx
    <span class="org-keyword">for</span> y_idx <span class="org-keyword">in</span> <span class="org-builtin">range</span>(buffer_y_span):
        <span class="org-keyword">for</span> x_idx <span class="org-keyword">in</span> <span class="org-builtin">range</span>(buffer_x_span):
            <span class="org-variable-name">buffer_cell</span>: coord_yx <span class="org-operator">=</span> (y_idx <span class="org-operator">+</span> buffer_y_min, x_idx <span class="org-operator">+</span> buffer_x_min)
            buffer_cells.append(buffer_cell)
    <span class="org-keyword">return</span> buffer_cells


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">identify_tracked_cells</span>(frontier_cells: <span class="org-builtin">set</span>, buffer_width: pyidx, rows: pyidx, cols: pyidx) <span class="org-operator">-&gt;</span> <span class="org-builtin">dict</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">tracked_cells</span>: <span class="org-builtin">dict</span> <span class="org-operator">=</span> {}
    cell         : <span class="org-builtin">tuple</span>
    buffer_cell  : <span class="org-builtin">tuple</span>
    <span class="org-keyword">for</span> cell <span class="org-keyword">in</span> frontier_cells:
        <span class="org-keyword">for</span> buffer_cell <span class="org-keyword">in</span> project_buffer(cell, buffer_width, rows, cols):
            <span class="org-variable-name">tracked_cells</span>[buffer_cell] <span class="org-operator">=</span> tracked_cells.get(buffer_cell, 0) <span class="org-operator">+</span> 1
    <span class="org-keyword">return</span> tracked_cells


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">update_tracked_cells</span>(tracked_cells: <span class="org-builtin">dict</span>, frontier_cells_old: <span class="org-builtin">set</span>, frontier_cells_new: <span class="org-builtin">set</span>,
                         buffer_width: pyidx, rows: pyidx, cols: pyidx) <span class="org-operator">-&gt;</span> <span class="org-builtin">dict</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Determine which frontier cells have been added or dropped</span>
    <span class="org-variable-name">frontier_cells_added</span>  : <span class="org-builtin">set</span> <span class="org-operator">=</span> frontier_cells_new.difference(frontier_cells_old)
    <span class="org-variable-name">frontier_cells_dropped</span>: <span class="org-builtin">set</span> <span class="org-operator">=</span> frontier_cells_old.difference(frontier_cells_new)
    cell                  : <span class="org-builtin">tuple</span>
    buffer_cell           : <span class="org-builtin">tuple</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Increment reference counters for all cells within buffer_width of the added frontier cells</span>
    <span class="org-keyword">for</span> cell <span class="org-keyword">in</span> frontier_cells_added:
        <span class="org-keyword">for</span> buffer_cell <span class="org-keyword">in</span> project_buffer(cell, buffer_width, rows, cols):
            <span class="org-variable-name">tracked_cells</span>[buffer_cell] <span class="org-operator">=</span> tracked_cells.get(buffer_cell, 0) <span class="org-operator">+</span> 1
    <span class="org-comment-delimiter"># </span><span class="org-comment">Decrement reference counters for all cells within buffer_width of the dropped frontier cells</span>
    <span class="org-keyword">for</span> cell <span class="org-keyword">in</span> frontier_cells_dropped:
        <span class="org-keyword">for</span> buffer_cell <span class="org-keyword">in</span> project_buffer(cell, buffer_width, rows, cols):
            <span class="org-variable-name">tracked_cells</span>[buffer_cell] <span class="org-operator">-=</span> 1
            <span class="org-keyword">if</span> tracked_cells[buffer_cell] <span class="org-operator">==</span> 0:
                tracked_cells.pop(buffer_cell)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Return updated tracked cells</span>
    <span class="org-keyword">return</span> tracked_cells
</pre>
</div>
</div>
</li>
</ol>
</li>
</ol>
</div>
<div id="outline-container-spread-phi-field" class="outline-4">
<h4 id="spread-phi-field"><span class="section-number-4">9.1.7.</span> Spread Phi Field</h4>
<div class="outline-text-4" id="text-spread-phi-field">
<p>
\(\hat{\nabla} \varphi \cdot U = (\hat{\nabla} \varphi \cdot \frac{\ddot{\nabla} \varphi}{|\ddot{\nabla} \varphi|}) (\frac{\ddot{\nabla} \varphi}{|\ddot{\nabla} \varphi|}\cdot U) = (\hat{\nabla} \varphi \cdot \frac{\ddot{\nabla} \varphi}{|\ddot{\nabla} \varphi|^2}) (\ddot{\nabla} \varphi \cdot U)\)
</p>

<p>
Compute dt at each timestep using the Courant-Friedrichs Lewy condition simplified to the one-dimensional case by computing `UMAX`:
<a href="https://en.wikipedia.org/wiki/Courant%E2%80%93Friedrichs%E2%80%93Lewy_condition">https://en.wikipedia.org/wiki/Courant%E2%80%93Friedrichs%E2%80%93Lewy_condition</a>
</p>

<p>
Here's how to do the correct computation for the \(U_x\) and \(U_y\) horizontal spread rates used in the CFL calculation.
</p>

<p>
Denote \(\bar{U} := (\bar{U}_x, \bar{U}_y)\) the horizontal vector that we need for the CFL. This vector is defined as being front-normal in the horizontal plane, with magnitude \(|\bar{U}| = - \frac{d \varphi}{dt}/|\nabla \varphi|\). It follows that its coordinates can be obtained as:
</p>

<p>
$ \bar{U}_x = - \frac{d \varphi}{dt} \frac{1}{|\nabla \varphi|^2}  \frac{\partial \varphi}{\partial x}$
</p>

<p>
&#x2026; and similarly for \(\bar{U}_y\). The spatial gradient is not flux-limited.
</p>

<div class="org-src-container">
<pre class="src src-python" id="spread-phi-field"><span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Move to pyretechnics.conversion</span>
<span class="org-variable-name">fire_type_codes</span> <span class="org-operator">=</span> {
    <span class="org-string">"unburned"</span>      : 0,
    <span class="org-string">"surface"</span>       : 1,
    <span class="org-string">"passive_crown"</span> : 2,
    <span class="org-string">"active_crown"</span>  : 3,
}


<span class="org-type">@cy.profile</span>(<span class="org-constant">True</span>)
<span class="org-type">@cy.cfunc</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: @cy.exceptval(NULL)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: @cy.wraparound(False)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: @cy.boundscheck(False)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Eliminate optional arguments to function</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Figure out how to type cube_resolution as vec_xyz</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Eliminate calls to np.dot</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: See if we can use a C struct for the fire_behavior and fire_behavior_star dictionaries (not fire_behavior_dict)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Perhaps cell_index should be a Python tuple rather than a C tuple?</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Replace fire_type_codes with as some kind of C type?</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Convert SpaceTimeCube to a @cclass with methods that take pyidx values</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Convert spot.expected_firebrand_production to a @cfunc</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Convert spot.spread_firebrands to a @cfunc</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Replace set.union with list concatenation? (Should ignited_cells be a list for speed?)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Maybe ignition_time should be a Python float?</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Convert update_tracked_cells to a @cfunc</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Speed up burn_cell_toward_phi_gradient</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: cimport the vec_xy and vec_xyz types to prevent typecasting when calling vector_magnitude_2d and dot_2d</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Turn off divide-by-zero checks</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Change for loops to use tracked_cells.keys() and sorted(spot_ignitions.keys())</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: cimport numpy</span>
<span class="org-keyword">def</span> <span class="org-function-name">spread_fire_one_timestep</span>(space_time_cubes: <span class="org-builtin">dict</span>, output_matrices: <span class="org-builtin">dict</span>, frontier_cells: <span class="org-builtin">set</span>, tracked_cells: <span class="org-builtin">dict</span>,
                             cube_resolution: <span class="org-builtin">tuple</span>, start_time: cy.<span class="org-builtin">float</span>, max_timestep: cy.<span class="org-builtin">float</span>,
                             max_cells_per_timestep: cy.<span class="org-builtin">float</span>, use_wind_limit: <span class="org-builtin">bool</span><span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> <span class="org-constant">True</span>,
                             surface_lw_ratio_model: <span class="org-builtin">str</span><span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> <span class="org-string">"rothermel"</span>, crown_max_lw_ratio: <span class="org-builtin">float</span><span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> <span class="org-constant">None</span>,
                             buffer_width: <span class="org-builtin">int</span><span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> 3, spot_ignitions: <span class="org-builtin">dict</span><span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> {}, spot_config: <span class="org-builtin">dict</span><span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> <span class="org-constant">None</span>,
                             random_generator: np.random.Generator<span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> <span class="org-constant">None</span>) <span class="org-operator">-&gt;</span> <span class="org-builtin">dict</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    NOTE:</span>
<span class="org-doc">    - space_time_cubes and phi must have the same spatial resolution and extent.</span>
<span class="org-doc">    - space_time_cubes must support temporal lookups in minutes.</span>
<span class="org-doc">    - cell_width is in meters.</span>
<span class="org-doc">    - cell_height is in meters.</span>
<span class="org-doc">    - dt is the timestep in minutes.</span>
<span class="org-doc">    - start_time is the start time in minutes.</span>
<span class="org-doc">    """</span>
   <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack output_matrices</span>
    <span class="org-variable-name">phi_matrix</span>               : cy.<span class="org-builtin">float</span>[:,:] <span class="org-operator">=</span> output_matrices[<span class="org-string">"phi"</span>]
    <span class="org-variable-name">phi_star_matrix</span>          : cy.<span class="org-builtin">float</span>[:,:] <span class="org-operator">=</span> output_matrices[<span class="org-string">"phi_star"</span>]
    <span class="org-variable-name">fire_type_matrix</span>         : cy.uchar[:,:] <span class="org-operator">=</span> output_matrices[<span class="org-string">"fire_type"</span>]
    <span class="org-variable-name">spread_rate_matrix</span>       : cy.<span class="org-builtin">float</span>[:,:] <span class="org-operator">=</span> output_matrices[<span class="org-string">"spread_rate"</span>]
    <span class="org-variable-name">spread_direction_matrix</span>  : cy.<span class="org-builtin">float</span>[:,:] <span class="org-operator">=</span> output_matrices[<span class="org-string">"spread_direction"</span>]
    <span class="org-variable-name">fireline_intensity_matrix</span>: cy.<span class="org-builtin">float</span>[:,:] <span class="org-operator">=</span> output_matrices[<span class="org-string">"fireline_intensity"</span>]
    <span class="org-variable-name">flame_length_matrix</span>      : cy.<span class="org-builtin">float</span>[:,:] <span class="org-operator">=</span> output_matrices[<span class="org-string">"flame_length"</span>]
    <span class="org-variable-name">time_of_arrival_matrix</span>   : cy.<span class="org-builtin">float</span>[:,:] <span class="org-operator">=</span> output_matrices[<span class="org-string">"time_of_arrival"</span>]

    <span class="org-comment-delimiter"># </span><span class="org-comment">Extract simulation dimensions</span>
    <span class="org-variable-name">rows</span>: pyidx <span class="org-operator">=</span> phi_matrix.shape[0]
    <span class="org-variable-name">cols</span>: pyidx <span class="org-operator">=</span> phi_matrix.shape[1]

    <span class="org-comment-delimiter"># </span><span class="org-comment">Extract simulation resolution</span>
    <span class="org-variable-name">band_duration</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cube_resolution[0]
    <span class="org-variable-name">cell_height</span>  : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cube_resolution[1]
    <span class="org-variable-name">cell_width</span>   : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cube_resolution[2]

    <span class="org-comment-delimiter"># </span><span class="org-comment">Initialize max spread rates in the x and y dimensions to 0.0</span>
    <span class="org-variable-name">max_spread_rate_x</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 0.0
    <span class="org-variable-name">max_spread_rate_y</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 0.0

    <span class="org-comment-delimiter"># </span><span class="org-comment">Create an empty dictionary to store intermediate fire behavior values per cell</span>
    <span class="org-variable-name">fire_behavior_dict</span>: <span class="org-builtin">dict</span> <span class="org-operator">=</span> {}

    <span class="org-comment-delimiter"># </span><span class="org-comment">Compute fire behavior values at start_time and identify the max spread rates in the x and y dimensions</span>
    cell_index           : coord_yx
    y                    : pyidx
    x                    : pyidx
    space_time_coordinate: coord_tyx
    dphi_dt              : cy.<span class="org-builtin">float</span>
    <span class="org-variable-name">t0</span>                   : pyidx <span class="org-operator">=</span> <span class="org-builtin">int</span>(start_time <span class="org-operator">//</span> band_duration)
    <span class="org-keyword">for</span> cell_index <span class="org-keyword">in</span> tracked_cells:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack cell_index</span>
        <span class="org-variable-name">y</span> <span class="org-operator">=</span> cell_index[0]
        <span class="org-variable-name">x</span> <span class="org-operator">=</span> cell_index[1]

        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate phi gradient on the horizontal plane</span>
        <span class="org-variable-name">phi_gradient_xy</span> : vec_xy   <span class="org-operator">=</span> calc_phi_gradient_approx(phi_matrix,
                                                              cell_width,
                                                              cell_height,
                                                              x,
                                                              y,
                                                              rows,
                                                              cols)
        <span class="org-variable-name">phi_magnitude_xy</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vector_magnitude_2d(phi_gradient_xy)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the fire behavior normal to the fire front on the slope-tangential plane</span>
        <span class="org-variable-name">space_time_coordinate</span> <span class="org-operator">=</span> (t0, y, x)
        <span class="org-variable-name">fire_behavior</span>: <span class="org-builtin">dict</span>   <span class="org-operator">=</span> burn_cell_toward_phi_gradient(space_time_cubes,
                                                              space_time_coordinate,
                                                              phi_gradient_xy,
                                                              use_wind_limit,
                                                              surface_lw_ratio_model,
                                                              crown_max_lw_ratio)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Check whether cell has a positive phi magnitude</span>
        <span class="org-keyword">if</span> phi_magnitude_xy <span class="org-operator">&gt;</span> 0.0:
            <span class="org-comment-delimiter"># </span><span class="org-comment">Keep a running tally of the max horizontal spread rates in the x and y dimensions</span>
            <span class="org-variable-name">dphi_dt</span>                      <span class="org-operator">=</span> fire_behavior[<span class="org-string">"dphi_dt"</span>]
            <span class="org-variable-name">dphi_dx</span>           : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi_gradient_xy[0]
            <span class="org-variable-name">dphi_dy</span>           : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi_gradient_xy[1]
            <span class="org-variable-name">phi_magnitude_xy_2</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi_magnitude_xy <span class="org-operator">*</span> phi_magnitude_xy
            <span class="org-variable-name">spread_rate_x</span>     : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> <span class="org-operator">-</span>dphi_dt <span class="org-operator">*</span> dphi_dx <span class="org-operator">/</span> phi_magnitude_xy_2
            <span class="org-variable-name">spread_rate_y</span>     : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> <span class="org-operator">-</span>dphi_dt <span class="org-operator">*</span> dphi_dy <span class="org-operator">/</span> phi_magnitude_xy_2
            <span class="org-variable-name">max_spread_rate_x</span>            <span class="org-operator">=</span> <span class="org-builtin">max</span>(max_spread_rate_x, <span class="org-builtin">abs</span>(spread_rate_x))
            <span class="org-variable-name">max_spread_rate_y</span>            <span class="org-operator">=</span> <span class="org-builtin">max</span>(max_spread_rate_y, <span class="org-builtin">abs</span>(spread_rate_y))

            <span class="org-comment-delimiter"># </span><span class="org-comment">Integrate the Superbee flux limited phi gradient to make dphi_dt numerically stable</span>
            <span class="org-variable-name">phi_gradient_xy_limited</span>: vec_xy <span class="org-operator">=</span> calc_phi_gradient(phi_matrix,
                                                                dphi_dx,
                                                                dphi_dy,
                                                                cell_width,
                                                                cell_height,
                                                                x,
                                                                y,
                                                                rows,
                                                                cols)
            <span class="org-variable-name">dphi_dt_correction</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> dot_2d(phi_gradient_xy, phi_gradient_xy_limited) <span class="org-operator">/</span> phi_magnitude_xy_2
            <span class="org-variable-name">fire_behavior</span>[<span class="org-string">"dphi_dt"</span>] <span class="org-operator">=</span> dphi_dt <span class="org-operator">*</span> dphi_dt_correction

        <span class="org-comment-delimiter"># </span><span class="org-comment">Store fire behavior values for later use</span>
        <span class="org-variable-name">fire_behavior_dict</span>[cell_index] <span class="org-operator">=</span> fire_behavior

    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate timestep using the CFL condition</span>
    dt: cy.<span class="org-builtin">float</span>
    <span class="org-keyword">if</span> max_spread_rate_x <span class="org-operator">==</span> 0.0:
        <span class="org-keyword">if</span> max_spread_rate_y <span class="org-operator">==</span> 0.0:
            <span class="org-variable-name">dt</span> <span class="org-operator">=</span> max_timestep
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">dt</span> <span class="org-operator">=</span> <span class="org-builtin">min</span>(max_timestep, max_cells_per_timestep <span class="org-operator">*</span> cell_height <span class="org-operator">/</span> max_spread_rate_y)
    <span class="org-keyword">else</span>:
        <span class="org-keyword">if</span> max_spread_rate_y <span class="org-operator">==</span> 0.0:
            <span class="org-variable-name">dt</span> <span class="org-operator">=</span> <span class="org-builtin">min</span>(max_timestep, max_cells_per_timestep <span class="org-operator">*</span> cell_width <span class="org-operator">/</span> max_spread_rate_x)
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">dt</span> <span class="org-operator">=</span> <span class="org-builtin">min</span>(max_timestep, max_cells_per_timestep <span class="org-operator">*</span> <span class="org-builtin">min</span>(cell_width <span class="org-operator">/</span> max_spread_rate_x,
                                                                cell_height <span class="org-operator">/</span> max_spread_rate_y))

    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the stop_time using this timestep</span>
    <span class="org-variable-name">stop_time</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> start_time <span class="org-operator">+</span> dt

    <span class="org-comment-delimiter"># </span><span class="org-comment">Update the tracked cell values in phi_star_matrix</span>
    <span class="org-keyword">for</span> cell_index <span class="org-keyword">in</span> tracked_cells:
        <span class="org-variable-name">y</span> <span class="org-operator">=</span> cell_index[0]
        <span class="org-variable-name">x</span> <span class="org-operator">=</span> cell_index[1]
        <span class="org-variable-name">dphi_dt</span> <span class="org-operator">=</span> fire_behavior_dict[cell_index][<span class="org-string">"dphi_dt"</span>]
        <span class="org-keyword">if</span> dphi_dt <span class="org-operator">!=</span> 0.0:
            <span class="org-variable-name">phi_star_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>] <span class="org-operator">+=</span> dphi_dt <span class="org-operator">*</span> dt

    <span class="org-comment-delimiter"># </span><span class="org-comment">Compute fire behavior values at stop_time and update the output_matrices</span>
    ignition_time: <span class="org-builtin">float</span>
    ignited_cells: <span class="org-builtin">set</span>
    <span class="org-variable-name">t1</span>           : pyidx <span class="org-operator">=</span> <span class="org-builtin">int</span>(stop_time <span class="org-operator">//</span> band_duration)
    <span class="org-keyword">for</span> cell_index <span class="org-keyword">in</span> tracked_cells:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack cell_index</span>
        <span class="org-variable-name">y</span> <span class="org-operator">=</span> cell_index[0]
        <span class="org-variable-name">x</span> <span class="org-operator">=</span> cell_index[1]

        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate phi gradient on the horizontal plane</span>
        <span class="org-variable-name">phi_gradient_xy_star</span> : vec_xy   <span class="org-operator">=</span> calc_phi_gradient_approx(phi_star_matrix,
                                                                   cell_width,
                                                                   cell_height,
                                                                   x,
                                                                   y,
                                                                   rows,
                                                                   cols)
        <span class="org-variable-name">phi_magnitude_xy_star</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vector_magnitude_2d(phi_gradient_xy_star)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the fire behavior normal to the fire front on the slope-tangential plane</span>
        <span class="org-variable-name">space_time_coordinate</span>    <span class="org-operator">=</span> (t1, y, x)
        <span class="org-variable-name">fire_behavior_star</span>: <span class="org-builtin">dict</span> <span class="org-operator">=</span> burn_cell_toward_phi_gradient(space_time_cubes,
                                                                 space_time_coordinate,
                                                                 phi_gradient_xy_star,
                                                                 use_wind_limit,
                                                                 surface_lw_ratio_model,
                                                                 crown_max_lw_ratio)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Check whether cell has a positive phi magnitude</span>
        <span class="org-keyword">if</span> phi_magnitude_xy_star <span class="org-operator">&gt;</span> 0.0:
            <span class="org-comment-delimiter"># </span><span class="org-comment">Integrate the Superbee flux limited phi gradient to make dphi_dt numerically stable</span>
            <span class="org-variable-name">dphi_dt_star</span>                : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> fire_behavior_star[<span class="org-string">"dphi_dt"</span>]
            <span class="org-variable-name">dphi_dx_star</span>                : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi_gradient_xy_star[0]
            <span class="org-variable-name">dphi_dy_star</span>                : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi_gradient_xy_star[1]
            <span class="org-variable-name">phi_gradient_xy_star_limited</span>: vec_xy   <span class="org-operator">=</span> calc_phi_gradient(phi_star_matrix,
                                                                       dphi_dx_star,
                                                                       dphi_dy_star,
                                                                       cell_width,
                                                                       cell_height,
                                                                       x,
                                                                       y,
                                                                       rows,
                                                                       cols)
            <span class="org-variable-name">dphi_dt_star_correction</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (dot_2d(phi_gradient_xy_star, phi_gradient_xy_star_limited)
                                                 <span class="org-operator">/</span> (phi_magnitude_xy_star <span class="org-operator">*</span> phi_magnitude_xy_star))
            <span class="org-variable-name">fire_behavior_star</span>[<span class="org-string">"dphi_dt"</span>] <span class="org-operator">=</span> dphi_dt_star <span class="org-operator">*</span> dphi_dt_star_correction

        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the new phi value at stop_time as phi_next</span>
        <span class="org-variable-name">fire_behavior</span>               <span class="org-operator">=</span> fire_behavior_dict[cell_index]
        <span class="org-variable-name">dphi_dt_estimate1</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> fire_behavior[<span class="org-string">"dphi_dt"</span>]
        <span class="org-variable-name">dphi_dt_estimate2</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> fire_behavior_star[<span class="org-string">"dphi_dt"</span>]
        <span class="org-variable-name">dphi_dt_average</span>  : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (dphi_dt_estimate1 <span class="org-operator">+</span> dphi_dt_estimate2) <span class="org-operator">/</span> 2.0
        <span class="org-keyword">if</span> dphi_dt_average <span class="org-operator">!=</span> 0.0:
            <span class="org-variable-name">phi</span>     : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi_matrix[y,x]
            <span class="org-variable-name">phi_next</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi <span class="org-operator">+</span> dphi_dt_average <span class="org-operator">*</span> dt

            <span class="org-comment-delimiter"># </span><span class="org-comment">Update the tracked cell values in phi_matrix</span>
            <span class="org-variable-name">phi_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>] <span class="org-operator">=</span> phi_next

            <span class="org-comment-delimiter"># </span><span class="org-comment">Record fire behavior values in the output_matrices for cells that are burned in this timestep</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: This records the fire behavior values at start_time and not at the time of arrival.</span>
            <span class="org-keyword">if</span> phi <span class="org-operator">&gt;</span> 0.0 <span class="org-keyword">and</span> phi_next <span class="org-operator">&lt;=</span> 0.0:
                <span class="org-variable-name">fire_type_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]          <span class="org-operator">=</span> fire_type_codes[fire_behavior[<span class="org-string">"fire_type"</span>]]
                <span class="org-variable-name">spread_rate_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]        <span class="org-operator">=</span> fire_behavior[<span class="org-string">"spread_rate"</span>]
                <span class="org-variable-name">spread_direction_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]   <span class="org-operator">=</span> spread_direction_vector_to_angle(fire_behavior[<span class="org-string">"spread_direction"</span>])
                <span class="org-variable-name">fireline_intensity_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>] <span class="org-operator">=</span> fire_behavior[<span class="org-string">"fireline_intensity"</span>]
                <span class="org-variable-name">flame_length_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]       <span class="org-operator">=</span> fire_behavior[<span class="org-string">"flame_length"</span>]
                <span class="org-variable-name">time_of_arrival_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]    <span class="org-operator">=</span> start_time <span class="org-operator">+</span> dt <span class="org-operator">*</span> phi <span class="org-operator">/</span> (phi <span class="org-operator">-</span> phi_next)

                <span class="org-comment-delimiter"># </span><span class="org-comment">Cast firebrands, update firebrand_count_matrix, and update spot_ignitions</span>
                <span class="org-keyword">if</span> spot_config:
                    <span class="org-variable-name">t_cast</span>                  : pyidx    <span class="org-operator">=</span> <span class="org-builtin">int</span>(time_of_arrival_matrix[y,x] <span class="org-operator">//</span> band_duration)
                    <span class="org-variable-name">space_time_coordinate</span>              <span class="org-operator">=</span> (t_cast, y, x)
                    <span class="org-variable-name">slope</span>                   : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"slope"</span>].get(t_cast, y, x)
                    <span class="org-variable-name">aspect</span>                  : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"aspect"</span>].get(t_cast, y, x)
                    <span class="org-variable-name">elevation_gradient</span>      : vec_xy   <span class="org-operator">=</span> calc_elevation_gradient(slope, aspect)
                    <span class="org-variable-name">firebrands_per_unit_heat</span>: <span class="org-builtin">float</span>    <span class="org-operator">=</span> spot_config[<span class="org-string">"firebrands_per_unit_heat"</span>]
                    <span class="org-variable-name">expected_firebrand_count</span>: <span class="org-builtin">float</span>    <span class="org-operator">=</span> spot.expected_firebrand_production(fire_behavior,
                                                                                            elevation_gradient,
                                                                                            cube_resolution,
                                                                                            firebrands_per_unit_heat)
                    new_ignitions: <span class="org-builtin">tuple</span>[<span class="org-builtin">float</span>, <span class="org-builtin">set</span>]<span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> spot.spread_firebrands(space_time_cubes,
                                                                                   output_matrices,
                                                                                   cube_resolution,
                                                                                   space_time_coordinate,
                                                                                   random_generator,
                                                                                   expected_firebrand_count,
                                                                                   spot_config)
                    <span class="org-keyword">if</span> new_ignitions:
                        <span class="org-variable-name">ignition_time</span>                      <span class="org-operator">=</span> new_ignitions[0]
                        <span class="org-variable-name">ignited_cells</span>                      <span class="org-operator">=</span> new_ignitions[1]
                        concurrent_ignited_cells: <span class="org-builtin">set</span><span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> spot_ignitions.get(ignition_time)
                        <span class="org-keyword">if</span> concurrent_ignited_cells:
                            <span class="org-variable-name">spot_ignitions</span>[ignition_time] <span class="org-operator">=</span> <span class="org-builtin">set</span>.union(ignited_cells, concurrent_ignited_cells)
                        <span class="org-keyword">else</span>:
                            <span class="org-variable-name">spot_ignitions</span>[ignition_time] <span class="org-operator">=</span> ignited_cells

    <span class="org-comment-delimiter"># </span><span class="org-comment">Update phi_matrix and time_of_arrival matrix for all cells that ignite a new spot fire before stop_time</span>
    <span class="org-keyword">for</span> ignition_time <span class="org-keyword">in</span> <span class="org-builtin">sorted</span>(spot_ignitions):
        <span class="org-keyword">if</span> ignition_time <span class="org-operator">&lt;</span> stop_time:
            <span class="org-variable-name">ignited_cells</span> <span class="org-operator">=</span> spot_ignitions.pop(ignition_time)
            <span class="org-keyword">for</span> cell_index <span class="org-keyword">in</span> ignited_cells:
                <span class="org-variable-name">y</span> <span class="org-operator">=</span> cell_index[0]
                <span class="org-variable-name">x</span> <span class="org-operator">=</span> cell_index[1]
                <span class="org-keyword">if</span> phi_matrix[y,x] <span class="org-operator">&gt;</span> 0.0:
                    <span class="org-variable-name">phi_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]             <span class="org-operator">=</span> <span class="org-operator">-</span>1.0
                    <span class="org-variable-name">time_of_arrival_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>] <span class="org-operator">=</span> ignition_time <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: REVIEW Should I use stop_time instead?</span>
                    <span class="org-variable-name">tracked_cells</span>[cell_index]   <span class="org-operator">=</span> tracked_cells.get(cell_index, 0)
                    <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: I need to calculate and store the fire_behavior values for these cells</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Save the new phi_matrix values in phi_star_matrix</span>
    <span class="org-keyword">for</span> cell_index <span class="org-keyword">in</span> tracked_cells:
        <span class="org-variable-name">y</span> <span class="org-operator">=</span> cell_index[0]
        <span class="org-variable-name">x</span> <span class="org-operator">=</span> cell_index[1]
        <span class="org-variable-name">phi_star_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>] <span class="org-operator">=</span> phi_matrix[y,x]

    <span class="org-comment-delimiter"># </span><span class="org-comment">Update the sets of frontier cells and tracked cells based on the updated phi matrix</span>
    <span class="org-variable-name">frontier_cells_new</span>: <span class="org-builtin">set</span>  <span class="org-operator">=</span> identify_tracked_frontier_cells(phi_matrix, tracked_cells, rows, cols)
    <span class="org-variable-name">tracked_cells_new</span> : <span class="org-builtin">dict</span> <span class="org-operator">=</span> update_tracked_cells(tracked_cells, frontier_cells, frontier_cells_new,
                                                    buffer_width, rows, cols)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Return the updated world state</span>
    <span class="org-keyword">return</span> {
        <span class="org-string">"simulation_time"</span> : stop_time,
        <span class="org-string">"output_matrices"</span> : output_matrices,
        <span class="org-string">"frontier_cells"</span>  : frontier_cells_new,
        <span class="org-string">"tracked_cells"</span>   : tracked_cells_new,
        <span class="org-string">"spot_ignitions"</span>  : spot_ignitions,
        <span class="org-string">"random_generator"</span>: random_generator,
    }


<span class="org-type">@cy.profile</span>(<span class="org-constant">True</span>)
<span class="org-keyword">def</span> <span class="org-function-name">spread_fire_with_phi_field</span>(space_time_cubes: <span class="org-builtin">dict</span>, output_matrices: <span class="org-builtin">dict</span>, cube_resolution: <span class="org-builtin">tuple</span>,
                               start_time: <span class="org-builtin">float</span>, max_duration: <span class="org-builtin">float</span><span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> <span class="org-constant">None</span>,
                               max_cells_per_timestep: <span class="org-builtin">float</span><span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> 0.4, buffer_width: <span class="org-builtin">int</span><span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> 3,
                               use_wind_limit: <span class="org-builtin">bool</span><span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> <span class="org-constant">True</span>, surface_lw_ratio_model: <span class="org-builtin">str</span><span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> <span class="org-string">"rothermel"</span>,
                               crown_max_lw_ratio: <span class="org-builtin">float</span><span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> <span class="org-constant">None</span>, spot_ignitions: <span class="org-builtin">dict</span><span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> {},
                               spot_config: <span class="org-builtin">dict</span><span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> <span class="org-constant">None</span>):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - space_time_cubes             :: dictionary of (Lazy)SpaceTimeCube objects with these cell types</span>
<span class="org-doc">      - slope                         :: rise/run</span>
<span class="org-doc">      - aspect                        :: degrees clockwise from North</span>
<span class="org-doc">      - fuel_model                    :: integer index in fm.fuel_model_table</span>
<span class="org-doc">      - canopy_cover                  :: 0-1</span>
<span class="org-doc">      - canopy_height                 :: m</span>
<span class="org-doc">      - canopy_base_height            :: m</span>
<span class="org-doc">      - canopy_bulk_density           :: kg/m^3</span>
<span class="org-doc">      - temperature                   :: degrees Celsius (Optional: needed for spotting)</span>
<span class="org-doc">      - wind_speed_10m                :: km/hr</span>
<span class="org-doc">      - upwind_direction              :: degrees clockwise from North</span>
<span class="org-doc">      - fuel_moisture_dead_1hr        :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_dead_10hr       :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_dead_100hr      :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_live_herbaceous :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_live_woody      :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - foliar_moisture               :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_spread_adjustment        :: float &gt;= 0.0 (Optional: defaults to 1.0)</span>
<span class="org-doc">      - weather_spread_adjustment     :: float &gt;= 0.0 (Optional: defaults to 1.0)</span>
<span class="org-doc">    - output_matrices              :: dictionary of 2D Numpy arrays whose spatial dimensions match the space_time_cubes</span>
<span class="org-doc">      - phi                           :: 2D float array of values in [-1,1]</span>
<span class="org-doc">      - fire_type                     :: 2D byte array (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)</span>
<span class="org-doc">      - spread_rate                   :: 2D float array (m/min)</span>
<span class="org-doc">      - spread_direction              :: 2D float array (degrees clockwise from North)</span>
<span class="org-doc">      - fireline_intensity            :: 2D float array (kW/m)</span>
<span class="org-doc">      - flame_length                  :: 2D float array (m)</span>
<span class="org-doc">      - time_of_arrival               :: 2D float array (min)</span>
<span class="org-doc">      - firebrand_count               :: 2D integer array (number of firebrands) (Optional)</span>
<span class="org-doc">    - cube_resolution              :: tuple with these fields</span>
<span class="org-doc">      - band_duration                 :: minutes</span>
<span class="org-doc">      - cell_height                   :: meters</span>
<span class="org-doc">      - cell_width                    :: meters</span>
<span class="org-doc">    - start_time                   :: minutes (from the start of the space_time_cube's temporal origin)</span>
<span class="org-doc">    - max_duration                 :: minutes (Optional)</span>
<span class="org-doc">    - max_cells_per_timestep       :: max number of cells the fire front can travel in one timestep (Optional)</span>
<span class="org-doc">    - buffer_width                 :: Chebyshev distance from frontier cells to include in tracked cells (Optional)</span>
<span class="org-doc">    - use_wind_limit               :: boolean (Optional)</span>
<span class="org-doc">    - surface_lw_ratio_model       :: "rothermel" or "behave" (Optional)</span>
<span class="org-doc">    - crown_max_lw_ratio           :: float &gt; 0.0 (Optional)</span>
<span class="org-doc">    - spot_ignitions               :: dictionary of (ignition_time -&gt; ignited_cells) (Optional: needed for spotting)</span>
<span class="org-doc">    - spot_config                  :: dictionary of spotting parameters (Optional: needed for spotting)</span>
<span class="org-doc">      - random_seed                   :: seed for a numpy.random.Generator object</span>
<span class="org-doc">      - firebrands_per_unit_heat      :: firebrands/kJ</span>
<span class="org-doc">      - downwind_distance_mean        :: meters</span>
<span class="org-doc">      - fireline_intensity_exponent   :: downwind_distance_mean multiplier [I^fireline_intensity_exponent]</span>
<span class="org-doc">      - wind_speed_exponent           :: downwind_distance_mean multiplier [U^wind_speed_exponent]</span>
<span class="org-doc">      - downwind_variance_mean_ratio  :: meters^2 / meter [downwind_variance_mean_ratio = Var(X) / E(X)]</span>
<span class="org-doc">      - crosswind_distance_stdev      :: meters</span>
<span class="org-doc">      - decay_distance                :: meters</span>

<span class="org-doc">    return a dictionary with these keys:</span>
<span class="org-doc">    - stop_time            :: minutes</span>
<span class="org-doc">    - stop_condition       :: "max duration reached" or "no burnable cells"</span>
<span class="org-doc">    - output_matrices      :: dictionary of 2D Numpy arrays whose spatial dimensions match the space_time_cubes</span>
<span class="org-doc">      - phi                   :: 2D float array of values in [-1,1]</span>
<span class="org-doc">      - fire_type             :: 2D byte array (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)</span>
<span class="org-doc">      - spread_rate           :: 2D float array (m/min)</span>
<span class="org-doc">      - spread_direction      :: 2D float array (degrees clockwise from North)</span>
<span class="org-doc">      - fireline_intensity    :: 2D float array (kW/m)</span>
<span class="org-doc">      - flame_length          :: 2D float array (m)</span>
<span class="org-doc">      - time_of_arrival       :: 2D float array (min)</span>
<span class="org-doc">      - firebrand_count       :: 2D integer array (number of firebrands) (only included when provided as an input)</span>
<span class="org-doc">    - spot_ignitions       :: dictionary of (ignition_time -&gt; ignited_cells) (only included when spotting is used)</span>
<span class="org-doc">    - random_generator     :: numpy.random.Generator object (only included when spotting is used)</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Define the provided, required, and optional keys for space_time_cubes</span>
    <span class="org-variable-name">provided_cubes</span> <span class="org-operator">=</span> <span class="org-builtin">set</span>(space_time_cubes.keys())
    <span class="org-variable-name">required_cubes</span> <span class="org-operator">=</span> {
        <span class="org-string">"slope"</span>,
        <span class="org-string">"aspect"</span>,
        <span class="org-string">"fuel_model"</span>,
        <span class="org-string">"canopy_cover"</span>,
        <span class="org-string">"canopy_height"</span>,
        <span class="org-string">"canopy_base_height"</span>,
        <span class="org-string">"canopy_bulk_density"</span>,
        <span class="org-string">"wind_speed_10m"</span>,
        <span class="org-string">"upwind_direction"</span>,
        <span class="org-string">"fuel_moisture_dead_1hr"</span>,
        <span class="org-string">"fuel_moisture_dead_10hr"</span>,
        <span class="org-string">"fuel_moisture_dead_100hr"</span>,
        <span class="org-string">"fuel_moisture_live_herbaceous"</span>,
        <span class="org-string">"fuel_moisture_live_woody"</span>,
        <span class="org-string">"foliar_moisture"</span>,
    } <span class="org-operator">|</span> ({<span class="org-string">"temperature"</span>} <span class="org-keyword">if</span> spot_config <span class="org-keyword">else</span> <span class="org-builtin">set</span>())
    <span class="org-variable-name">optional_cubes</span> <span class="org-operator">=</span> {
        <span class="org-string">"fuel_spread_adjustment"</span>,
        <span class="org-string">"weather_spread_adjustment"</span>,
    }

    <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that all required_cubes are present in provided_cubes</span>
    <span class="org-keyword">if</span> <span class="org-keyword">not</span> provided_cubes.issuperset(required_cubes):
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The space_time_cubes dictionary is missing these required keys: "</span>
                         <span class="org-operator">+</span> <span class="org-builtin">str</span>(required_cubes.difference(provided_cubes)))

    <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that only required_cubes and optional_cubes are present in provided_cubes</span>
    <span class="org-keyword">if</span> <span class="org-keyword">not</span> (required_cubes <span class="org-operator">|</span> optional_cubes).issuperset(provided_cubes):
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The space_time_cubes dictionary contains these unused keys: "</span>
                         <span class="org-operator">+</span> <span class="org-builtin">str</span>(provided_cubes.difference((required_cubes <span class="org-operator">|</span> optional_cubes))))

    <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that all space_time_cubes values are SpaceTimeCube objects</span>
    <span class="org-keyword">for</span> cube <span class="org-keyword">in</span> space_time_cubes.values():
        <span class="org-keyword">if</span> <span class="org-keyword">not</span>(<span class="org-builtin">isinstance</span>(cube, SpaceTimeCube) <span class="org-keyword">or</span> <span class="org-builtin">isinstance</span>(cube, LazySpaceTimeCube)):
            <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"All values in the space_time_cubes dictionary must be SpaceTimeCube or "</span>
                             <span class="org-operator">+</span> <span class="org-string">"LazySpaceTimeCube objects. See pyretechnics.space_time_cube for more information."</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Define the provided, required, and optional keys for output_matrices</span>
    <span class="org-variable-name">provided_matrices</span> <span class="org-operator">=</span> <span class="org-builtin">set</span>(output_matrices.keys())
    <span class="org-variable-name">required_matrices</span> <span class="org-operator">=</span> {
        <span class="org-string">"phi"</span>,
        <span class="org-string">"fire_type"</span>,
        <span class="org-string">"spread_rate"</span>,
        <span class="org-string">"spread_direction"</span>,
        <span class="org-string">"fireline_intensity"</span>,
        <span class="org-string">"flame_length"</span>,
        <span class="org-string">"time_of_arrival"</span>,
    }
    <span class="org-variable-name">optional_matrices</span> <span class="org-operator">=</span> {
        <span class="org-string">"firebrand_count"</span>,
    }

    <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that all required_matrices are present in output_matrices</span>
    <span class="org-keyword">if</span> <span class="org-keyword">not</span> provided_matrices.issuperset(required_matrices):
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The output_matrices dictionary is missing these required keys: "</span>
                         <span class="org-operator">+</span> <span class="org-builtin">str</span>(required_matrices.difference(provided_matrices)))

    <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that only required_matrices and optional_matrices are present in provided_matrices</span>
    <span class="org-keyword">if</span> <span class="org-keyword">not</span> (required_matrices <span class="org-operator">|</span> optional_matrices).issuperset(provided_matrices):
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The output_matrices dictionary contains these unused keys: "</span>
                         <span class="org-operator">+</span> <span class="org-builtin">str</span>(provided_matrices.difference((required_matrices <span class="org-operator">|</span> optional_matrices))))

    <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that all output_matrices values are 2D Numpy arrays</span>
    <span class="org-keyword">for</span> matrix <span class="org-keyword">in</span> output_matrices.values():
        <span class="org-keyword">if</span> <span class="org-keyword">not</span>(<span class="org-builtin">isinstance</span>(matrix, np.ndarray) <span class="org-keyword">and</span> np.ndim(matrix) <span class="org-operator">==</span> 2):
            <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"All values in the output_matrices dictionary must be 2D Numpy arrays."</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Extract simulation dimensions</span>
    (<span class="org-variable-name">bands</span>, <span class="org-variable-name">rows</span>, <span class="org-variable-name">cols</span>) <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"slope"</span>].shape

    <span class="org-comment-delimiter"># </span><span class="org-comment">Extract simulation resolution</span>
    (<span class="org-variable-name">band_duration</span>, <span class="org-variable-name">cell_height</span>, <span class="org-variable-name">cell_width</span>) <span class="org-operator">=</span> cube_resolution

    <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that all space_time_cubes have the same spatial resolution</span>
    <span class="org-keyword">for</span> cube <span class="org-keyword">in</span> space_time_cubes.values():
        <span class="org-keyword">if</span> cube.shape <span class="org-operator">!=</span> (bands, rows, cols):
            <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The space_time_cubes must all share the same spatial resolution."</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that space_time_cubes and output_matrices have the same spatial resolution</span>
    <span class="org-keyword">for</span> matrix <span class="org-keyword">in</span> output_matrices.values():
        <span class="org-keyword">if</span> matrix.shape <span class="org-operator">!=</span> (rows, cols):
            <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The space_time_cubes and output_matrices must all share the same spatial resolution."</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that all cube resolution values are positive</span>
    <span class="org-keyword">if</span> band_duration <span class="org-operator">&lt;=</span> 0.0 <span class="org-keyword">or</span> cell_height <span class="org-operator">&lt;=</span> 0.0 <span class="org-keyword">or</span> cell_width <span class="org-operator">&lt;=</span> 0.0:
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The cube_resolution tuple may only contain positive values."</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the cube duration</span>
    <span class="org-variable-name">cube_duration</span> <span class="org-operator">=</span> bands <span class="org-operator">*</span> band_duration

    <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that start_time exists within the temporal bounds of the space_time_cubes</span>
    <span class="org-keyword">if</span> <span class="org-keyword">not</span>(0.0 <span class="org-operator">&lt;=</span> start_time <span class="org-operator">&lt;</span> cube_duration):
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The start_time falls outside of the temporal bounds of the space_time_cubes."</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the max stop time</span>
    <span class="org-variable-name">max_stop_time</span> <span class="org-operator">=</span> start_time <span class="org-operator">+</span> max_duration <span class="org-keyword">if</span> max_duration <span class="org-keyword">else</span> cube_duration

    <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that the max_stop_time does not exceed the cube_duration</span>
    <span class="org-keyword">if</span> max_stop_time <span class="org-operator">&gt;</span> cube_duration:
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The start_time + max_duration exceeds the temporal limit of the space_time_cubes."</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Identify the sets of frontier cells and tracked cells based on the phi matrix</span>
    <span class="org-variable-name">phi_matrix</span>     <span class="org-operator">=</span> output_matrices[<span class="org-string">"phi"</span>]
    <span class="org-variable-name">frontier_cells</span> <span class="org-operator">=</span> identify_all_frontier_cells(phi_matrix, rows, cols)
    <span class="org-variable-name">tracked_cells</span>  <span class="org-operator">=</span> identify_tracked_cells(frontier_cells, buffer_width, rows, cols)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Make a copy of the phi matrix to use for intermediate calculations in each timestep</span>
    <span class="org-variable-name">output_matrices</span>[<span class="org-string">"phi_star"</span>] <span class="org-operator">=</span> np.copy(phi_matrix)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Create a numpy.random.Generator object to produce random samples if spot_config is provided</span>
    <span class="org-variable-name">random_generator</span> <span class="org-operator">=</span> np.random.default_rng(seed<span class="org-operator">=</span>spot_config[<span class="org-string">"random_seed"</span>]) <span class="org-keyword">if</span> spot_config <span class="org-keyword">else</span> <span class="org-constant">None</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Spread the fire until an exit condition is reached</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: I don't think the "no burnable cells" condition can ever be met currently.</span>
    <span class="org-variable-name">simulation_time</span> <span class="org-operator">=</span> start_time
    <span class="org-keyword">while</span>(simulation_time <span class="org-operator">&lt;</span> max_stop_time <span class="org-keyword">and</span> (<span class="org-builtin">len</span>(tracked_cells) <span class="org-operator">&gt;</span> 0 <span class="org-keyword">or</span> <span class="org-builtin">len</span>(spot_ignitions) <span class="org-operator">&gt;</span> 0)):
        <span class="org-comment-delimiter"># </span><span class="org-comment">Compute max_timestep based on the remaining time in the temporal band and simulation</span>
        <span class="org-variable-name">remaining_time_in_band</span>       <span class="org-operator">=</span> band_duration <span class="org-operator">-</span> simulation_time <span class="org-operator">%</span> band_duration
        <span class="org-variable-name">remaining_time_in_simulation</span> <span class="org-operator">=</span> max_stop_time <span class="org-operator">-</span> simulation_time
        <span class="org-variable-name">max_timestep</span>                 <span class="org-operator">=</span> <span class="org-builtin">min</span>(remaining_time_in_band, remaining_time_in_simulation)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Spread fire one timestep</span>
        <span class="org-variable-name">results</span> <span class="org-operator">=</span> spread_fire_one_timestep(space_time_cubes, output_matrices, frontier_cells, tracked_cells,
                                           cube_resolution, simulation_time, max_timestep, max_cells_per_timestep,
                                           use_wind_limit, surface_lw_ratio_model, crown_max_lw_ratio,
                                           buffer_width, spot_ignitions, spot_config, random_generator)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Reset spread inputs</span>
        <span class="org-variable-name">simulation_time</span>  <span class="org-operator">=</span> results[<span class="org-string">"simulation_time"</span>]
        <span class="org-variable-name">output_matrices</span>  <span class="org-operator">=</span> results[<span class="org-string">"output_matrices"</span>]
        <span class="org-variable-name">frontier_cells</span>   <span class="org-operator">=</span> results[<span class="org-string">"frontier_cells"</span>]
        <span class="org-variable-name">tracked_cells</span>    <span class="org-operator">=</span> results[<span class="org-string">"tracked_cells"</span>]
        <span class="org-variable-name">spot_ignitions</span>   <span class="org-operator">=</span> results[<span class="org-string">"spot_ignitions"</span>]
        <span class="org-variable-name">random_generator</span> <span class="org-operator">=</span> results[<span class="org-string">"random_generator"</span>]

    <span class="org-comment-delimiter"># </span><span class="org-comment">Remove the temporary copy of the phi matrix from output_matrices</span>
    output_matrices.pop(<span class="org-string">"phi_star"</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Return the final simulation results</span>
    <span class="org-keyword">return</span> {
        <span class="org-string">"stop_time"</span>      : simulation_time,
        <span class="org-string">"stop_condition"</span> : <span class="org-string">"max duration reached"</span> <span class="org-keyword">if</span> <span class="org-builtin">len</span>(tracked_cells) <span class="org-operator">&gt;</span> 0 <span class="org-keyword">else</span> <span class="org-string">"no burnable cells"</span>,
        <span class="org-string">"output_matrices"</span>: output_matrices,
    } <span class="org-operator">|</span> ({
        <span class="org-string">"spot_ignitions"</span>  : spot_ignitions,
        <span class="org-string">"random_generator"</span>: random_generator,
    } <span class="org-keyword">if</span> spot_config <span class="org-keyword">else</span> {})
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-for-users-fire-spread" class="outline-3">
<h3 id="for-users-fire-spread"><span class="section-number-3">9.2.</span> For Users</h3>
<div class="outline-text-3" id="text-for-users-fire-spread">
</div>
<div id="outline-container-how-to-spread-a-fire-from-a-point-ignition" class="outline-4">
<h4 id="how-to-spread-a-fire-from-a-point-ignition"><span class="section-number-4">9.2.1.</span> How to Spread a Fire from a Point Ignition</h4>
<div class="outline-text-4" id="text-how-to-spread-a-fire-from-a-point-ignition">
</div>
<ol class="org-ol">
<li><a id="configure-and-run-the-fire-spread-simulation"></a>Configure and Run the Fire Spread Simulation<br>
<div class="outline-text-5" id="text-configure-and-run-the-fire-spread-simulation">
<div class="org-src-container">
<pre class="src src-python" id="run-spread-fire-with-phi-field"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> pyretechnics.eulerian_level_set <span class="org-keyword">as</span> els
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube
<span class="org-keyword">import</span> time

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (
    240, <span class="org-comment-delimiter"># </span><span class="org-comment">bands: 10 days @ 1 hour/band</span>
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">rows:  3 km @ 30 meters/row</span>
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">cols:  3 km @ 30 meters/col</span>
)

<span class="org-variable-name">grid_shape</span> <span class="org-operator">=</span> cube_shape[1:]

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube resolution</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">cube_resolution</span> <span class="org-operator">=</span> (
    60, <span class="org-comment-delimiter"># </span><span class="org-comment">band_duration: minutes</span>
    30, <span class="org-comment-delimiter"># </span><span class="org-comment">cell_height:   meters</span>
    30, <span class="org-comment-delimiter"># </span><span class="org-comment">cell_width:    meters</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Create an input dictionary of SpaceTimeCubes (using constant data for this example)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-keyword">def</span> <span class="org-function-name">arr2d</span>(value):
    <span class="org-keyword">return</span> np.full(grid_shape, value)

<span class="org-keyword">def</span> <span class="org-function-name">arr3d</span>(value):
    (<span class="org-variable-name">b</span>, <span class="org-variable-name">r</span>, <span class="org-variable-name">c</span>) <span class="org-operator">=</span> cube_shape
    <span class="org-keyword">return</span> np.full((b, r<span class="org-operator">//</span>10, c<span class="org-operator">//</span>10) , value)

<span class="org-variable-name">space_time_cubes</span> <span class="org-operator">=</span> {
    <span class="org-string">"slope"</span>                        : SpaceTimeCube(cube_shape, arr2d(0.8)),   <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-string">"aspect"</span>                       : SpaceTimeCube(cube_shape, arr2d(225.0)), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_model"</span>                   : SpaceTimeCube(cube_shape, arr2d(101)),   <span class="org-comment-delimiter"># </span><span class="org-comment">integer index in fm.fuel_model_table</span>
    <span class="org-string">"canopy_cover"</span>                 : SpaceTimeCube(cube_shape, arr2d(0.6)),   <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
    <span class="org-string">"canopy_height"</span>                : SpaceTimeCube(cube_shape, arr2d(30.0)),  <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_base_height"</span>           : SpaceTimeCube(cube_shape, arr2d(3.0)),   <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_bulk_density"</span>          : SpaceTimeCube(cube_shape, arr2d(0.3)),   <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>
    <span class="org-string">"wind_speed_10m"</span>               : SpaceTimeCube(cube_shape, arr3d(30.0)),  <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-string">"upwind_direction"</span>             : SpaceTimeCube(cube_shape, arr3d(180.0)), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_moisture_dead_1hr"</span>       : SpaceTimeCube(cube_shape, arr3d(0.05)),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_10hr"</span>      : SpaceTimeCube(cube_shape, arr3d(0.10)),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_100hr"</span>     : SpaceTimeCube(cube_shape, arr3d(0.15)),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_herbaceous"</span>: SpaceTimeCube(cube_shape, arr3d(0.90)),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_woody"</span>     : SpaceTimeCube(cube_shape, arr3d(0.60)),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"foliar_moisture"</span>              : SpaceTimeCube(cube_shape, arr3d(0.90)),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_spread_adjustment"</span>       : SpaceTimeCube(cube_shape, arr2d(1.0)),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
    <span class="org-string">"weather_spread_adjustment"</span>    : SpaceTimeCube(cube_shape, arr3d(1.0)),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
}

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Create an output dictionary of 2D Numpy arrays</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">output_matrices</span> <span class="org-operator">=</span> {
    <span class="org-string">"phi"</span>               : np.ones(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>),       <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array of values in [-1,1]</span>
    <span class="org-string">"fire_type"</span>         : np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"uint8"</span>),        <span class="org-comment-delimiter"># </span><span class="org-comment">2D byte array (0-3)</span>
    <span class="org-string">"spread_rate"</span>       : np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>),      <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array (m/min)</span>
    <span class="org-string">"spread_direction"</span>  : np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>),      <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array (degrees clockwise from North)</span>
    <span class="org-string">"fireline_intensity"</span>: np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>),      <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array (kW/m)</span>
    <span class="org-string">"flame_length"</span>      : np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>),      <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array (m)</span>
    <span class="org-string">"time_of_arrival"</span>   : np.full(grid_shape, <span class="org-operator">-</span>1.0, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>), <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array (min)</span>
}

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Set the start time, max duration, and initially ignited cell</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Day 2 @ 10:30am</span>
<span class="org-variable-name">start_time</span> <span class="org-operator">=</span> 2070  <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">8 hours</span>
<span class="org-variable-name">max_duration</span> <span class="org-operator">=</span> 480 <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Burn initially ignited cell into the phi matrix by setting it to -1.0</span>
output_matrices[<span class="org-string">"phi"</span>][50,50] <span class="org-operator">=</span> <span class="org-operator">-</span>1.0

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Spread fire from the start time for the max duration</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">runtime_start</span>       <span class="org-operator">=</span> time.perf_counter()
<span class="org-variable-name">fire_spread_results</span> <span class="org-operator">=</span> els.spread_fire_with_phi_field(space_time_cubes, output_matrices, cube_resolution,
                                                     start_time, max_duration)
<span class="org-variable-name">runtime_stop</span>        <span class="org-operator">=</span> time.perf_counter()

<span class="org-variable-name">stop_time</span>       <span class="org-operator">=</span> fire_spread_results[<span class="org-string">"stop_time"</span>]       <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>
<span class="org-variable-name">stop_condition</span>  <span class="org-operator">=</span> fire_spread_results[<span class="org-string">"stop_condition"</span>]  <span class="org-comment-delimiter"># </span><span class="org-comment">"max duration reached" or "no burnable cells"</span>
<span class="org-variable-name">output_matrices</span> <span class="org-operator">=</span> fire_spread_results[<span class="org-string">"output_matrices"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">updated 2D arrays (mutated from inputs)</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Print out the acres burned, total runtime, and runtime per burned cell</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">num_burned_cells</span>        <span class="org-operator">=</span> np.count_nonzero(output_matrices[<span class="org-string">"fire_type"</span>]) <span class="org-comment-delimiter"># </span><span class="org-comment">cells</span>
<span class="org-variable-name">acres_burned</span>            <span class="org-operator">=</span> num_burned_cells <span class="org-operator">/</span> 4.5                         <span class="org-comment-delimiter"># </span><span class="org-comment">acres</span>
<span class="org-variable-name">simulation_runtime</span>      <span class="org-operator">=</span> runtime_stop <span class="org-operator">-</span> runtime_start                   <span class="org-comment-delimiter"># </span><span class="org-comment">seconds</span>
<span class="org-variable-name">runtime_per_burned_cell</span> <span class="org-operator">=</span> 1000.0 <span class="org-operator">*</span> simulation_runtime <span class="org-operator">/</span> num_burned_cells <span class="org-comment-delimiter"># </span><span class="org-comment">ms/cell</span>

<span class="org-builtin">print</span>(<span class="org-string">"Acres Burned: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(acres_burned))
<span class="org-builtin">print</span>(<span class="org-string">"Total Runtime: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(simulation_runtime) <span class="org-operator">+</span> <span class="org-string">" seconds"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Runtime per Burned Cell: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(runtime_per_burned_cell) <span class="org-operator">+</span> <span class="org-string">" ms/cell"</span>)
</pre>
</div>
</div>
</li>
<li><a id="display-summary-statistics-of-the-output-matrices"></a>Display Summary Statistics of the Output Matrices<br>
<div class="outline-text-5" id="text-display-summary-statistics-of-the-output-matrices">
<div class="org-src-container">
<pre class="src src-python" id="run-spread-fire-with-phi-field-stats"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Display summary statistics of our fire spread results</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Used as a filter in get_array_stats below</span>
<span class="org-variable-name">burned_cells</span> <span class="org-operator">=</span> output_matrices[<span class="org-string">"fire_type"</span>] <span class="org-operator">&gt;</span> 0

<span class="org-keyword">def</span> <span class="org-function-name">get_array_stats</span>(array, use_burn_scar_mask<span class="org-operator">=</span><span class="org-constant">True</span>):
    <span class="org-variable-name">array_values_to_analyze</span> <span class="org-operator">=</span> array[burned_cells] <span class="org-keyword">if</span> use_burn_scar_mask <span class="org-keyword">else</span> array
    <span class="org-keyword">if</span> <span class="org-builtin">len</span>(array_values_to_analyze) <span class="org-operator">&gt;</span> 0:
        <span class="org-keyword">return</span> {
            <span class="org-string">"Min"</span>  : np.<span class="org-builtin">min</span>(array_values_to_analyze),
            <span class="org-string">"Max"</span>  : np.<span class="org-builtin">max</span>(array_values_to_analyze),
            <span class="org-string">"Mean"</span> : np.mean(array_values_to_analyze),
            <span class="org-string">"Stdev"</span>: np.std(array_values_to_analyze),
        }
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> {
            <span class="org-string">"Min"</span>  : <span class="org-string">"No Data"</span>,
            <span class="org-string">"Max"</span>  : <span class="org-string">"No Data"</span>,
            <span class="org-string">"Mean"</span> : <span class="org-string">"No Data"</span>,
            <span class="org-string">"Stdev"</span>: <span class="org-string">"No Data"</span>,
        }

<span class="org-builtin">print</span>(<span class="org-string">"Fire Behavior from Day 2 @ 10:30am - Day 2 @ 6:30pm Spreading from Coordinate (50,50)</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 100)

<span class="org-builtin">print</span>(<span class="org-string">"Stop Time: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(stop_time) <span class="org-operator">+</span> <span class="org-string">" (minutes)"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Stop Condition: "</span> <span class="org-operator">+</span> stop_condition)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Phi (phi &lt;= 0: burned, phi &gt; 0: unburned"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"phi"</span>], use_burn_scar_mask<span class="org-operator">=</span><span class="org-constant">False</span>), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Fire Type (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"fire_type"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Spread Rate (m/min)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"spread_rate"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Spread Direction (degrees clockwise from North)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"spread_direction"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Fireline Intensity (kW/m)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"fireline_intensity"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Flame Length (meters)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"flame_length"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Time of Arrival (minutes)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"time_of_arrival"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)
</pre>
</div>

<pre class="example" id="run-spread-fire-with-phi-field-stats-results">
Fire Behavior from Day 2 @ 10:30am - Day 2 @ 6:30pm Spreading from Coordinate (50,50)
====================================================================================================
Stop Time: 2550.0 (minutes)
Stop Condition: max duration reached

Phi (phi &lt;= 0: burned, phi &gt; 0: unburned
{'Min': -0.9256893, 'Max': 1.0, 'Mean': 0.9060591, 'Stdev': 0.3892009}

Fire Type (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)
{'Min': 1, 'Max': 1, 'Mean': 1.0, 'Stdev': 0.0}

Spread Rate (m/min)
{'Min': 0.16077116, 'Max': 2.2964668, 'Mean': 1.2116479, 'Stdev': 0.6341628}

Spread Direction (degrees clockwise from North)
{'Min': 0.658666, 'Max': 359.69885, 'Mean': 191.40175, 'Stdev': 117.9331}

Fireline Intensity (kW/m)
{'Min': 2.2772384, 'Max': 32.528233, 'Mean': 17.16235, 'Stdev': 8.982579}

Flame Length (meters)
{'Min': 0.11312115, 'Max': 0.38439324, 'Mean': 0.27523616, 'Stdev': 0.07356826}

Time of Arrival (minutes)
{'Min': 2081.8516, 'Max': 2548.1523, 'Mean': 2385.591, 'Stdev': 116.83735}
</pre>
</div>
</li>
<li><a id="create-images-of-the-output-matrices"></a>Create Images of the Output Matrices<br>
<div class="outline-text-5" id="text-create-images-of-the-output-matrices">
<div class="org-src-container">
<pre class="src src-python" id="run-spread-fire-with-phi-field-images"><span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np


<span class="org-keyword">def</span> <span class="org-function-name">save_matrix_as_heatmap</span>(matrix, colors, units, title, filename, vmin<span class="org-operator">=</span><span class="org-constant">None</span>, vmax<span class="org-operator">=</span><span class="org-constant">None</span>, ticks<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-variable-name">image</span>    <span class="org-operator">=</span> plt.imshow(matrix, origin<span class="org-operator">=</span><span class="org-string">"lower"</span>, cmap<span class="org-operator">=</span>colors, vmin<span class="org-operator">=</span>vmin, vmax<span class="org-operator">=</span>vmax)
    <span class="org-variable-name">colorbar</span> <span class="org-operator">=</span> plt.colorbar(image, orientation<span class="org-operator">=</span><span class="org-string">"vertical"</span>, ticks<span class="org-operator">=</span>ticks)
    colorbar.set_label(units)
    plt.title(title)
    plt.savefig(filename)
    plt.close(<span class="org-string">"all"</span>)


<span class="org-keyword">def</span> <span class="org-function-name">save_matrix_as_contours</span>(matrix, title, filename, levels<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-variable-name">fig</span>, <span class="org-variable-name">ax</span> <span class="org-operator">=</span> plt.subplots()
    <span class="org-variable-name">cs</span>      <span class="org-operator">=</span> ax.contour(matrix, levels<span class="org-operator">=</span>levels)
    ax.clabel(cs, inline<span class="org-operator">=</span><span class="org-constant">True</span>, fontsize<span class="org-operator">=</span>10)
    ax.set_aspect(<span class="org-string">'equal'</span>, <span class="org-string">'box'</span>)
    ax.set_title(title)
    plt.savefig(filename)
    plt.close(<span class="org-string">"all"</span>)


<span class="org-comment-delimiter"># </span><span class="org-comment">See https://matplotlib.org/stable/gallery/color/colormap_reference.html for the available options for "colors"</span>
<span class="org-variable-name">heatmap_configs</span> <span class="org-operator">=</span> [
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"phi"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"plasma"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"phi &lt;= 0: burned, phi &gt; 0: unburned"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Phi"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_phi.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"fire_type"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"viridis"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"0=unburned, 1=surface, 2=passive_crown, 3=active_crown"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Fire Type"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_fire_type.png"</span>,
        <span class="org-string">"vmin"</span>    : 0,
        <span class="org-string">"vmax"</span>    : 3,
        <span class="org-string">"ticks"</span>   : [0,1,2,3],
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"spread_rate"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"m/min"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Spread Rate"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_spread_rate.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"spread_direction"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"viridis"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"degrees clockwise from North"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Spread Direction"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_spread_direction.png"</span>,
        <span class="org-string">"vmin"</span>    : 0,
        <span class="org-string">"vmax"</span>    : 360,
        <span class="org-string">"ticks"</span>   : [0,45,90,135,180,225,270,315,360]
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"fireline_intensity"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"kW/m"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Fireline Intensity"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_fireline_intensity.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"flame_length"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"meters"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Flame Length"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_flame_length.png"</span>,
    },
]


<span class="org-variable-name">contour_configs</span> <span class="org-operator">=</span> [
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"time_of_arrival"</span>],
        <span class="org-string">"title"</span>   : <span class="org-string">"Time of Arrival"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_time_of_arrival.png"</span>,
        <span class="org-string">"levels"</span>  : <span class="org-builtin">int</span>(start_time) <span class="org-operator">+</span> np.asarray(<span class="org-builtin">range</span>(0, <span class="org-builtin">int</span>(max_duration) <span class="org-operator">+</span> 1, 60)),
    },
]


<span class="org-keyword">for</span> heatmap_config <span class="org-keyword">in</span> heatmap_configs:
    save_matrix_as_heatmap(<span class="org-operator">**</span>heatmap_config)


<span class="org-keyword">for</span> contour_config <span class="org-keyword">in</span> contour_configs:
    save_matrix_as_contours(<span class="org-operator">**</span>contour_config)
</pre>
</div>

<table id="fire-behavior-matplotlib-heatmaps">
<caption class="t-above"><span class="table-number">Table 6:</span> Fire behavior attributes after 8 hours of spread</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="pics/els_phi.png" alt="els_phi.png"></td>
<td class="org-left"><img src="pics/els_fire_type.png" alt="els_fire_type.png"></td>
</tr>

<tr>
<td class="org-left"><img src="pics/els_spread_rate.png" alt="els_spread_rate.png"></td>
<td class="org-left"><img src="pics/els_spread_direction.png" alt="els_spread_direction.png"></td>
</tr>

<tr>
<td class="org-left"><img src="pics/els_fireline_intensity.png" alt="els_fireline_intensity.png"></td>
<td class="org-left"><img src="pics/els_flame_length.png" alt="els_flame_length.png"></td>
</tr>
</tbody>
</table>


<div id="time-of-arrival-matplotlib-countours" class="figure">
<p><img src="pics/els_time_of_arrival.png" alt="els_time_of_arrival.png">
</p>
<p><span class="figure-number">Figure 4: </span>Time of arrival with hourly perimeters</p>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-how-to-spread-a-fire-from-a-point-ignition-with-spotting-enabled" class="outline-4">
<h4 id="how-to-spread-a-fire-from-a-point-ignition-with-spotting-enabled"><span class="section-number-4">9.2.2.</span> How to Spread a Fire from a Point Ignition with Spotting Enabled</h4>
<div class="outline-text-4" id="text-how-to-spread-a-fire-from-a-point-ignition-with-spotting-enabled">
</div>
<ol class="org-ol">
<li><a id="configure-and-run-the-fire-spread-simulation-with-spotting-enabled"></a>Configure and Run the Fire Spread Simulation with Spotting Enabled<br>
<div class="outline-text-5" id="text-configure-and-run-the-fire-spread-simulation-with-spotting-enabled">
<div class="org-src-container">
<pre class="src src-python" id="run-spread-fire-with-phi-field-with-spotting"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> pyretechnics.eulerian_level_set <span class="org-keyword">as</span> els
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube
<span class="org-keyword">import</span> time

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (
    240, <span class="org-comment-delimiter"># </span><span class="org-comment">bands: 10 days @ 1 hour/band</span>
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">rows:  3 km @ 30 meters/row</span>
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">cols:  3 km @ 30 meters/col</span>
)

<span class="org-variable-name">grid_shape</span> <span class="org-operator">=</span> cube_shape[1:]

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube resolution</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">cube_resolution</span> <span class="org-operator">=</span> (
    60, <span class="org-comment-delimiter"># </span><span class="org-comment">band_duration: minutes</span>
    30, <span class="org-comment-delimiter"># </span><span class="org-comment">cell_height:   meters</span>
    30, <span class="org-comment-delimiter"># </span><span class="org-comment">cell_width:    meters</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Create an input dictionary of SpaceTimeCubes (using constant data for this example)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">space_time_cubes</span> <span class="org-operator">=</span> {
    <span class="org-string">"slope"</span>                        : SpaceTimeCube(cube_shape, 0.8),   <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-string">"aspect"</span>                       : SpaceTimeCube(cube_shape, 225.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_model"</span>                   : SpaceTimeCube(cube_shape, 101),   <span class="org-comment-delimiter"># </span><span class="org-comment">integer index in fm.fuel_model_table</span>
    <span class="org-string">"canopy_cover"</span>                 : SpaceTimeCube(cube_shape, 0.6),   <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
    <span class="org-string">"canopy_height"</span>                : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_base_height"</span>           : SpaceTimeCube(cube_shape, 3.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_bulk_density"</span>          : SpaceTimeCube(cube_shape, 0.3),   <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>
    <span class="org-string">"temperature"</span>                  : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">degrees Celsius</span>
    <span class="org-string">"wind_speed_10m"</span>               : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-string">"upwind_direction"</span>             : SpaceTimeCube(cube_shape, 180.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_moisture_dead_1hr"</span>       : SpaceTimeCube(cube_shape, 0.05),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_10hr"</span>      : SpaceTimeCube(cube_shape, 0.10),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_100hr"</span>     : SpaceTimeCube(cube_shape, 0.15),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_herbaceous"</span>: SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_woody"</span>     : SpaceTimeCube(cube_shape, 0.60),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"foliar_moisture"</span>              : SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_spread_adjustment"</span>       : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
    <span class="org-string">"weather_spread_adjustment"</span>    : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
}

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Create an output dictionary of 2D Numpy arrays</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">output_matrices</span> <span class="org-operator">=</span> {
    <span class="org-string">"phi"</span>               : np.ones(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>),       <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array of values in [-1,1]</span>
    <span class="org-string">"fire_type"</span>         : np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"uint8"</span>),        <span class="org-comment-delimiter"># </span><span class="org-comment">2D byte array (0-3)</span>
    <span class="org-string">"spread_rate"</span>       : np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>),      <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array (m/min)</span>
    <span class="org-string">"spread_direction"</span>  : np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>),      <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array (degrees clockwise from North)</span>
    <span class="org-string">"fireline_intensity"</span>: np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>),      <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array (kW/m)</span>
    <span class="org-string">"flame_length"</span>      : np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>),      <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array (m)</span>
    <span class="org-string">"time_of_arrival"</span>   : np.full(grid_shape, <span class="org-operator">-</span>1.0, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>), <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array (min)</span>
    <span class="org-string">"firebrand_count"</span>   : np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"int32"</span>),        <span class="org-comment-delimiter"># </span><span class="org-comment">2D integer array (number of firebrands)</span>
}

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Set the start time, max duration, and initially ignited cell</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Day 2 @ 10:30am</span>
<span class="org-variable-name">start_time</span> <span class="org-operator">=</span> 2070  <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">8 hours</span>
<span class="org-variable-name">max_duration</span> <span class="org-operator">=</span> 480 <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Burn initially ignited cell into the phi matrix by setting it to -1.0</span>
output_matrices[<span class="org-string">"phi"</span>][50,50] <span class="org-operator">=</span> <span class="org-operator">-</span>1.0

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the spotting parameters</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">spot_config</span> <span class="org-operator">=</span> {
    <span class="org-string">"random_seed"</span>                 : 1234567890,
    <span class="org-string">"firebrands_per_unit_heat"</span>    : 1e<span class="org-operator">-</span>6,       <span class="org-comment-delimiter"># </span><span class="org-comment">firebrands/kJ</span>
    <span class="org-string">"downwind_distance_mean"</span>      : 10.0,       <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
    <span class="org-string">"fireline_intensity_exponent"</span> : 0.3,        <span class="org-comment-delimiter"># </span><span class="org-comment">downwind_distance_mean multiplier [I^fireline_intensity_exponent]</span>
    <span class="org-string">"wind_speed_exponent"</span>         : 0.55,       <span class="org-comment-delimiter"># </span><span class="org-comment">downwind_distance_mean multiplier [U^wind_speed_exponent]</span>
    <span class="org-string">"downwind_variance_mean_ratio"</span>: 425.0,      <span class="org-comment-delimiter"># </span><span class="org-comment">meters^2 / meter [downwind_variance_mean_ratio = Var(X) / E(X)]</span>
    <span class="org-string">"crosswind_distance_stdev"</span>    : 100.0,      <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
    <span class="org-string">"decay_distance"</span>              : 200.0,      <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
}

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Spread fire from the start time for the max duration</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">runtime_start</span>       <span class="org-operator">=</span> time.perf_counter()
<span class="org-variable-name">fire_spread_results</span> <span class="org-operator">=</span> els.spread_fire_with_phi_field(space_time_cubes, output_matrices, cube_resolution,
                                                     start_time, max_duration, spot_ignitions<span class="org-operator">=</span>{},
                                                     spot_config<span class="org-operator">=</span>spot_config)
<span class="org-variable-name">runtime_stop</span>        <span class="org-operator">=</span> time.perf_counter()

<span class="org-variable-name">stop_time</span>        <span class="org-operator">=</span> fire_spread_results[<span class="org-string">"stop_time"</span>]                  <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>
<span class="org-variable-name">stop_condition</span>   <span class="org-operator">=</span> fire_spread_results[<span class="org-string">"stop_condition"</span>]             <span class="org-comment-delimiter"># </span><span class="org-comment">"max duration reached" or "no burnable cells"</span>
<span class="org-variable-name">output_matrices</span>  <span class="org-operator">=</span> fire_spread_results[<span class="org-string">"output_matrices"</span>]            <span class="org-comment-delimiter"># </span><span class="org-comment">updated 2D arrays (mutated from inputs)</span>
<span class="org-variable-name">spot_ignitions</span>   <span class="org-operator">=</span> fire_spread_results.get(<span class="org-string">"spot_ignitions"</span>, {})     <span class="org-comment-delimiter"># </span><span class="org-comment">remaining firebrands on the landscape</span>
<span class="org-variable-name">random_generator</span> <span class="org-operator">=</span> fire_spread_results.get(<span class="org-string">"random_generator"</span>, <span class="org-constant">None</span>) <span class="org-comment-delimiter"># </span><span class="org-comment">numpy.random.Generator object</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Print out the acres burned, total runtime, and runtime per burned cell</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">num_burned_cells</span>        <span class="org-operator">=</span> np.count_nonzero(output_matrices[<span class="org-string">"fire_type"</span>]) <span class="org-comment-delimiter"># </span><span class="org-comment">cells</span>
<span class="org-variable-name">acres_burned</span>            <span class="org-operator">=</span> num_burned_cells <span class="org-operator">/</span> 4.5                         <span class="org-comment-delimiter"># </span><span class="org-comment">acres</span>
<span class="org-variable-name">simulation_runtime</span>      <span class="org-operator">=</span> runtime_stop <span class="org-operator">-</span> runtime_start                   <span class="org-comment-delimiter"># </span><span class="org-comment">seconds</span>
<span class="org-variable-name">runtime_per_burned_cell</span> <span class="org-operator">=</span> 1000.0 <span class="org-operator">*</span> simulation_runtime <span class="org-operator">/</span> num_burned_cells <span class="org-comment-delimiter"># </span><span class="org-comment">ms/cell</span>

<span class="org-builtin">print</span>(<span class="org-string">"Acres Burned: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(acres_burned))
<span class="org-builtin">print</span>(<span class="org-string">"Total Runtime: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(simulation_runtime) <span class="org-operator">+</span> <span class="org-string">" seconds"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Runtime per Burned Cell: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(runtime_per_burned_cell) <span class="org-operator">+</span> <span class="org-string">" ms/cell"</span>)
</pre>
</div>
</div>
</li>
<li><a id="display-summary-statistics-of-the-output-matrices-and-spot-ignitions"></a>Display Summary Statistics of the Output Matrices and Spot Ignitions<br>
<div class="outline-text-5" id="text-display-summary-statistics-of-the-output-matrices-and-spot-ignitions">
<div class="org-src-container">
<pre class="src src-python" id="run-spread-fire-with-phi-field-with-spotting-stats"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Display summary statistics of our fire spread results</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Used as a filter in get_array_stats below</span>
<span class="org-variable-name">burned_cells</span> <span class="org-operator">=</span> output_matrices[<span class="org-string">"fire_type"</span>] <span class="org-operator">&gt;</span> 0

<span class="org-keyword">def</span> <span class="org-function-name">get_array_stats</span>(array, use_burn_scar_mask<span class="org-operator">=</span><span class="org-constant">True</span>):
    <span class="org-variable-name">array_values_to_analyze</span> <span class="org-operator">=</span> array[burned_cells] <span class="org-keyword">if</span> use_burn_scar_mask <span class="org-keyword">else</span> array
    <span class="org-keyword">if</span> <span class="org-builtin">len</span>(array_values_to_analyze) <span class="org-operator">&gt;</span> 0:
        <span class="org-keyword">return</span> {
            <span class="org-string">"Min"</span>  : np.<span class="org-builtin">min</span>(array_values_to_analyze),
            <span class="org-string">"Max"</span>  : np.<span class="org-builtin">max</span>(array_values_to_analyze),
            <span class="org-string">"Mean"</span> : np.mean(array_values_to_analyze),
            <span class="org-string">"Stdev"</span>: np.std(array_values_to_analyze),
        }
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> {
            <span class="org-string">"Min"</span>  : <span class="org-string">"No Data"</span>,
            <span class="org-string">"Max"</span>  : <span class="org-string">"No Data"</span>,
            <span class="org-string">"Mean"</span> : <span class="org-string">"No Data"</span>,
            <span class="org-string">"Stdev"</span>: <span class="org-string">"No Data"</span>,
        }

<span class="org-builtin">print</span>(<span class="org-string">"Fire Behavior from Day 2 @ 10:30am - Day 2 @ 6:30pm Spreading from Coordinate (50,50)</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 100)

<span class="org-builtin">print</span>(<span class="org-string">"Stop Time: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(stop_time) <span class="org-operator">+</span> <span class="org-string">" (minutes)"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Stop Condition: "</span> <span class="org-operator">+</span> stop_condition)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Phi (phi &lt;= 0: burned, phi &gt; 0: unburned"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"phi"</span>], use_burn_scar_mask<span class="org-operator">=</span><span class="org-constant">False</span>), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Fire Type (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"fire_type"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Spread Rate (m/min)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"spread_rate"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Spread Direction (degrees clockwise from North)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"spread_direction"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Fireline Intensity (kW/m)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"fireline_intensity"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Flame Length (meters)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"flame_length"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Time of Arrival (minutes)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"time_of_arrival"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-variable-name">firebrand_count_matrix</span> <span class="org-operator">=</span> output_matrices.get(<span class="org-string">"firebrand_count"</span>)
<span class="org-keyword">if</span> <span class="org-builtin">isinstance</span>(firebrand_count_matrix, np.ndarray):
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Firebrand Count (number of firebrands)"</span>)
    pprint(get_array_stats(firebrand_count_matrix, use_burn_scar_mask<span class="org-operator">=</span><span class="org-constant">False</span>), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Total Firebrands on Grid: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(np.<span class="org-builtin">sum</span>(firebrand_count_matrix)))

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Future Spot Ignitions:"</span>)
pprint(spot_ignitions)
</pre>
</div>

<pre class="example" id="run-spread-fire-with-phi-field-with-spotting-stats-results">
Fire Behavior from Day 2 @ 10:30am - Day 2 @ 6:30pm Spreading from Coordinate (50,50)
====================================================================================================
Stop Time: 2550.0 (minutes)
Stop Condition: max duration reached

Phi (phi &lt;= 0: burned, phi &gt; 0: unburned
{'Min': -0.9967122, 'Max': 1.0, 'Mean': 0.7720047, 'Stdev': 0.5722504}

Fire Type (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)
{'Min': 1, 'Max': 1, 'Mean': 1.0, 'Stdev': 0.0}

Spread Rate (m/min)
{'Min': 0.16055717, 'Max': 2.2964664, 'Mean': 1.3839706, 'Stdev': 0.6849228}

Spread Direction (degrees clockwise from North)
{'Min': 0.015500054, 'Max': 359.82297, 'Mean': 179.89368, 'Stdev': 127.714645}

Fireline Intensity (kW/m)
{'Min': 2.274207, 'Max': 32.52823, 'Mean': 19.60321, 'Stdev': 9.701569}

Flame Length (meters)
{'Min': 0.11305186, 'Max': 0.38439322, 'Mean': 0.29242113, 'Stdev': 0.079029635}

Time of Arrival (minutes)
{'Min': 2081.8516, 'Max': 2549.8735, 'Mean': 2406.4568, 'Stdev': 106.72756}

Firebrand Count (number of firebrands)
{'Min': 0, 'Max': 4, 'Mean': 0.0743, 'Stdev': 0.32307817939316175}

Total Firebrands on Grid: 743

Future Spot Ignitions:
{2551.197586000257: {(78, 75)},
 2551.4126499292092: {(79, 54), (80, 60)},
 2551.856804638606: {(82, 36)},
 2553.2429458344905: {(73, 50)},
 2553.503079371683: {(82, 42)},
 2553.670617042156: {(88, 50)},
 2554.83807664013: {(78, 64)},
 2555.525101157285: {(78, 60), (78, 58)},
 2556.2804247854724: {(80, 74)},
 2556.956798222929: {(79, 80), (78, 75)},
 2557.195619307969: {(72, 52), (75, 51)},
 2560.051319507768: {(82, 76)},
 2560.0546776037436: {(75, 81)},
 2562.2242880384597: {(78, 53)},
 2563.013039281081: {(60, 78)},
 2563.863116389773: {(81, 38)},
 2566.6678273977955: {(82, 40)},
 2567.2125614511942: {(78, 77)},
 2567.3587638733025: {(83, 69)},
 2569.330376022855: {(79, 77)},
 2570.921652617251: {(83, 43), (83, 36)},
 2573.7323031261817: {(92, 51)},
 2574.6585895680705: {(53, 44)},
 2574.794226434831: {(85, 72)},
 2575.851040433648: {(81, 65), (80, 63)},
 2576.9250365965636: {(90, 38)},
 2576.970322423062: {(78, 60), (80, 63)},
 2581.2574393261707: {(73, 78)},
 2583.2559022370483: {(84, 31)},
 2583.5325256200385: {(84, 54)},
 2583.757301741892: {(70, 84)},
 2591.9147157633897: {(66, 34), (71, 40)},
 2592.883811071109: {(64, 36)},
 2603.1103976938066: {(80, 55)},
 2613.4410783216385: {(61, 37)}}
</pre>
</div>
</li>
<li><a id="create-images-of-the-output-matrices-with-spotting-enabled"></a>Create Images of the Output Matrices with Spotting Enabled<br>
<div class="outline-text-5" id="text-create-images-of-the-output-matrices-with-spotting-enabled">
<div class="org-src-container">
<pre class="src src-python" id="run-spread-fire-with-phi-field-with-spotting-images"><span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np


<span class="org-keyword">def</span> <span class="org-function-name">save_matrix_as_heatmap</span>(matrix, colors, units, title, filename, vmin<span class="org-operator">=</span><span class="org-constant">None</span>, vmax<span class="org-operator">=</span><span class="org-constant">None</span>, ticks<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-variable-name">image</span>    <span class="org-operator">=</span> plt.imshow(matrix, origin<span class="org-operator">=</span><span class="org-string">"lower"</span>, cmap<span class="org-operator">=</span>colors, vmin<span class="org-operator">=</span>vmin, vmax<span class="org-operator">=</span>vmax)
    <span class="org-variable-name">colorbar</span> <span class="org-operator">=</span> plt.colorbar(image, orientation<span class="org-operator">=</span><span class="org-string">"vertical"</span>, ticks<span class="org-operator">=</span>ticks)
    colorbar.set_label(units)
    plt.title(title)
    plt.savefig(filename)
    plt.close(<span class="org-string">"all"</span>)


<span class="org-keyword">def</span> <span class="org-function-name">save_matrix_as_contours</span>(matrix, title, filename, levels<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-variable-name">fig</span>, <span class="org-variable-name">ax</span> <span class="org-operator">=</span> plt.subplots()
    <span class="org-variable-name">cs</span>      <span class="org-operator">=</span> ax.contour(matrix, levels<span class="org-operator">=</span>levels)
    ax.clabel(cs, inline<span class="org-operator">=</span><span class="org-constant">True</span>, fontsize<span class="org-operator">=</span>10)
    ax.set_aspect(<span class="org-string">'equal'</span>, <span class="org-string">'box'</span>)
    ax.set_title(title)
    plt.savefig(filename)
    plt.close(<span class="org-string">"all"</span>)


<span class="org-comment-delimiter"># </span><span class="org-comment">See https://matplotlib.org/stable/gallery/color/colormap_reference.html for the available options for "colors"</span>
<span class="org-variable-name">heatmap_configs</span> <span class="org-operator">=</span> [
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"phi"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"plasma"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"phi &lt;= 0: burned, phi &gt; 0: unburned"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Phi"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_spot_phi.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"fire_type"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"viridis"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"0=unburned, 1=surface, 2=passive_crown, 3=active_crown"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Fire Type"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_spot_fire_type.png"</span>,
        <span class="org-string">"vmin"</span>    : 0,
        <span class="org-string">"vmax"</span>    : 3,
        <span class="org-string">"ticks"</span>   : [0,1,2,3],
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"spread_rate"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"m/min"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Spread Rate"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_spot_spread_rate.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"spread_direction"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"viridis"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"degrees clockwise from North"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Spread Direction"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_spot_spread_direction.png"</span>,
        <span class="org-string">"vmin"</span>    : 0,
        <span class="org-string">"vmax"</span>    : 360,
        <span class="org-string">"ticks"</span>   : [0,45,90,135,180,225,270,315,360]
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"fireline_intensity"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"kW/m"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Fireline Intensity"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_spot_fireline_intensity.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"flame_length"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"meters"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Flame Length"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_spot_flame_length.png"</span>,
    },
]


<span class="org-variable-name">firebrand_count_matrix</span> <span class="org-operator">=</span> output_matrices.get(<span class="org-string">"firebrand_count"</span>)
<span class="org-keyword">if</span> <span class="org-builtin">isinstance</span>(firebrand_count_matrix, np.ndarray):
    heatmap_configs.append(
        {
            <span class="org-string">"matrix"</span>  : firebrand_count_matrix,
            <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
            <span class="org-string">"units"</span>   : <span class="org-string">"number of firebrands"</span>,
            <span class="org-string">"title"</span>   : <span class="org-string">"Firebrand Count"</span>,
            <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_spot_firebrand_count.png"</span>,
        }
    )


<span class="org-variable-name">contour_configs</span> <span class="org-operator">=</span> [
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"time_of_arrival"</span>],
        <span class="org-string">"title"</span>   : <span class="org-string">"Time of Arrival"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_spot_time_of_arrival.png"</span>,
        <span class="org-string">"levels"</span>  : <span class="org-builtin">int</span>(start_time) <span class="org-operator">+</span> np.asarray(<span class="org-builtin">range</span>(0, <span class="org-builtin">int</span>(max_duration) <span class="org-operator">+</span> 1, 60)),
    },
]


<span class="org-keyword">for</span> heatmap_config <span class="org-keyword">in</span> heatmap_configs:
    save_matrix_as_heatmap(<span class="org-operator">**</span>heatmap_config)


<span class="org-keyword">for</span> contour_config <span class="org-keyword">in</span> contour_configs:
    save_matrix_as_contours(<span class="org-operator">**</span>contour_config)
</pre>
</div>

<table id="spot-fire-behavior-matplotlib-heatmaps">
<caption class="t-above"><span class="table-number">Table 7:</span> Fire behavior attributes after 8 hours of spread with spotting enabled</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="pics/els_spot_phi.png" alt="els_spot_phi.png"></td>
<td class="org-left"><img src="pics/els_spot_fire_type.png" alt="els_spot_fire_type.png"></td>
</tr>

<tr>
<td class="org-left"><img src="pics/els_spot_spread_rate.png" alt="els_spot_spread_rate.png"></td>
<td class="org-left"><img src="pics/els_spot_spread_direction.png" alt="els_spot_spread_direction.png"></td>
</tr>

<tr>
<td class="org-left"><img src="pics/els_spot_fireline_intensity.png" alt="els_spot_fireline_intensity.png"></td>
<td class="org-left"><img src="pics/els_spot_flame_length.png" alt="els_spot_flame_length.png"></td>
</tr>
</tbody>
</table>


<div id="spot-firebrand-count-matplotlib-heatmap" class="figure">
<p><img src="pics/els_spot_firebrand_count.png" alt="els_spot_firebrand_count.png">
</p>
<p><span class="figure-number">Figure 5: </span>Firebrand count with spotting enabled (NOTE: This is not the same as ember exposure.)</p>
</div>


<div id="spot-time-of-arrival-matplotlib-countours" class="figure">
<p><img src="pics/els_spot_time_of_arrival.png" alt="els_spot_time_of_arrival.png">
</p>
<p><span class="figure-number">Figure 6: </span>Time of arrival with hourly perimeters with spotting enabled</p>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-how-to-spread-a-fire,-pause,-fork,-and-continue" class="outline-4">
<h4 id="how-to-spread-a-fire,-pause,-fork,-and-continue"><span class="section-number-4">9.2.3.</span> How to Spread a Fire, Pause, Fork, and Continue</h4>
<div class="outline-text-4" id="text-how-to-spread-a-fire,-pause,-fork,-and-continue">
</div>
<ol class="org-ol">
<li><a id="configure-and-run-the-initial-fire-spread-simulation"></a>Configure and Run the Initial Fire Spread Simulation<br>
<div class="outline-text-5" id="text-configure-and-run-the-initial-fire-spread-simulation">
<div class="org-src-container">
<pre class="src src-python" id="run-spread-fire-with-phi-field-initial"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> pyretechnics.eulerian_level_set <span class="org-keyword">as</span> els
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube
<span class="org-keyword">import</span> time

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (
    240, <span class="org-comment-delimiter"># </span><span class="org-comment">bands: 10 days @ 1 hour/band</span>
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">rows:  3 km @ 30 meters/row</span>
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">cols:  3 km @ 30 meters/col</span>
)

<span class="org-variable-name">grid_shape</span> <span class="org-operator">=</span> cube_shape[1:]

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube resolution</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">cube_resolution</span> <span class="org-operator">=</span> (
    60, <span class="org-comment-delimiter"># </span><span class="org-comment">band_duration: minutes</span>
    30, <span class="org-comment-delimiter"># </span><span class="org-comment">cell_height:   meters</span>
    30, <span class="org-comment-delimiter"># </span><span class="org-comment">cell_width:    meters</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Create an input dictionary of SpaceTimeCubes (using constant data for this example)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">space_time_cubes</span> <span class="org-operator">=</span> {
    <span class="org-string">"slope"</span>                        : SpaceTimeCube(cube_shape, 0.8),   <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-string">"aspect"</span>                       : SpaceTimeCube(cube_shape, 225.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_model"</span>                   : SpaceTimeCube(cube_shape, 101),   <span class="org-comment-delimiter"># </span><span class="org-comment">integer index in fm.fuel_model_table</span>
    <span class="org-string">"canopy_cover"</span>                 : SpaceTimeCube(cube_shape, 0.6),   <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
    <span class="org-string">"canopy_height"</span>                : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_base_height"</span>           : SpaceTimeCube(cube_shape, 3.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_bulk_density"</span>          : SpaceTimeCube(cube_shape, 0.3),   <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>
    <span class="org-string">"wind_speed_10m"</span>               : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-string">"upwind_direction"</span>             : SpaceTimeCube(cube_shape, 180.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_moisture_dead_1hr"</span>       : SpaceTimeCube(cube_shape, 0.05),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_10hr"</span>      : SpaceTimeCube(cube_shape, 0.10),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_100hr"</span>     : SpaceTimeCube(cube_shape, 0.15),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_herbaceous"</span>: SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_woody"</span>     : SpaceTimeCube(cube_shape, 0.60),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"foliar_moisture"</span>              : SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_spread_adjustment"</span>       : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
    <span class="org-string">"weather_spread_adjustment"</span>    : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
}

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Create an output dictionary of 2D Numpy arrays</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">output_matrices</span> <span class="org-operator">=</span> {
    <span class="org-string">"phi"</span>               : np.ones(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>),       <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array of values in [-1,1]</span>
    <span class="org-string">"fire_type"</span>         : np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"uint8"</span>),        <span class="org-comment-delimiter"># </span><span class="org-comment">2D byte array (0-3)</span>
    <span class="org-string">"spread_rate"</span>       : np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>),      <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array (m/min)</span>
    <span class="org-string">"spread_direction"</span>  : np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>),      <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array (degrees clockwise from North)</span>
    <span class="org-string">"fireline_intensity"</span>: np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>),      <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array (kW/m)</span>
    <span class="org-string">"flame_length"</span>      : np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>),      <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array (m)</span>
    <span class="org-string">"time_of_arrival"</span>   : np.full(grid_shape, <span class="org-operator">-</span>1.0, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>), <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array (min)</span>
}

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Set the start time, max duration, and initially ignited cell</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Day 2 @ 10:30am</span>
<span class="org-variable-name">start_time</span> <span class="org-operator">=</span> 2070  <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">8 hours</span>
<span class="org-variable-name">max_duration</span> <span class="org-operator">=</span> 480 <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Burn initially ignited cell into the phi matrix by setting it to -1.0</span>
output_matrices[<span class="org-string">"phi"</span>][50,50] <span class="org-operator">=</span> <span class="org-operator">-</span>1.0

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Spread fire from the start time for the max duration</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">runtime_start</span>         <span class="org-operator">=</span> time.perf_counter()
<span class="org-variable-name">fire_spread_results_8</span> <span class="org-operator">=</span> els.spread_fire_with_phi_field(space_time_cubes, output_matrices, cube_resolution,
                                                       start_time, max_duration)
<span class="org-variable-name">runtime_stop</span>          <span class="org-operator">=</span> time.perf_counter()

<span class="org-variable-name">stop_time</span>       <span class="org-operator">=</span> fire_spread_results_8[<span class="org-string">"stop_time"</span>]       <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>
<span class="org-variable-name">stop_condition</span>  <span class="org-operator">=</span> fire_spread_results_8[<span class="org-string">"stop_condition"</span>]  <span class="org-comment-delimiter"># </span><span class="org-comment">"max duration reached" or "no burnable cells"</span>
<span class="org-variable-name">output_matrices</span> <span class="org-operator">=</span> fire_spread_results_8[<span class="org-string">"output_matrices"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">updated 2D arrays (mutated from inputs)</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Print out the acres burned, total runtime, and runtime per burned cell</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">num_burned_cells</span>        <span class="org-operator">=</span> np.count_nonzero(output_matrices[<span class="org-string">"fire_type"</span>]) <span class="org-comment-delimiter"># </span><span class="org-comment">cells</span>
<span class="org-variable-name">acres_burned</span>            <span class="org-operator">=</span> num_burned_cells <span class="org-operator">/</span> 4.5                         <span class="org-comment-delimiter"># </span><span class="org-comment">acres</span>
<span class="org-variable-name">simulation_runtime</span>      <span class="org-operator">=</span> runtime_stop <span class="org-operator">-</span> runtime_start                   <span class="org-comment-delimiter"># </span><span class="org-comment">seconds</span>
<span class="org-variable-name">runtime_per_burned_cell</span> <span class="org-operator">=</span> 1000.0 <span class="org-operator">*</span> simulation_runtime <span class="org-operator">/</span> num_burned_cells <span class="org-comment-delimiter"># </span><span class="org-comment">ms/cell</span>

<span class="org-builtin">print</span>(<span class="org-string">"Acres Burned: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(acres_burned))
<span class="org-builtin">print</span>(<span class="org-string">"Total Runtime: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(simulation_runtime) <span class="org-operator">+</span> <span class="org-string">" seconds"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Runtime per Burned Cell: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(runtime_per_burned_cell) <span class="org-operator">+</span> <span class="org-string">" ms/cell"</span>)
</pre>
</div>
</div>
</li>
<li><a id="fork-and-run-two-fire-spread-scenarios"></a>Fork and Run Two Fire Spread Scenarios<br>
<div class="outline-text-5" id="text-fork-and-run-two-fire-spread-scenarios">
<div class="org-src-container">
<pre class="src src-python" id="run-spread-fire-with-phi-field-forked"><span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Fork the simulation by creating a copy of the space_time_cubes and output_matrices</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-keyword">def</span> <span class="org-function-name">copy_matrices</span>(matrix_dict):
    <span class="org-keyword">return</span> {k: np.copy(matrix_dict[k]) <span class="org-keyword">for</span> k <span class="org-keyword">in</span> matrix_dict}

<span class="org-variable-name">space_time_cubes_fork</span> <span class="org-operator">=</span> space_time_cubes.copy()

<span class="org-variable-name">output_matrices_fork</span> <span class="org-operator">=</span> copy_matrices(output_matrices)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Add a non-burnable fire-break to the forked space_time_cubes fuel model</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Extract 2D array of fuel_model values at the cube's spatial dimensions (100 x 100)</span>
<span class="org-variable-name">fuel_model_grid_ro</span> <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_model"</span>].getSpatialPlane(0, <span class="org-constant">None</span>, <span class="org-constant">None</span>) <span class="org-comment-delimiter"># </span><span class="org-comment">read-only</span>
<span class="org-variable-name">fuel_model_grid</span>    <span class="org-operator">=</span> np.copy(fuel_model_grid_ro)                                   <span class="org-comment-delimiter"># </span><span class="org-comment">writable</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Add a non-burnable fire-break in the northeastern corner of the grid</span>
(<span class="org-variable-name">ys</span>, <span class="org-variable-name">xs</span>) <span class="org-operator">=</span> np.diag_indices(40)
fuel_model_grid[60:,60:][(<span class="org-builtin">list</span>(<span class="org-builtin">reversed</span>(ys)), xs)] <span class="org-operator">=</span> 91 <span class="org-comment-delimiter"># </span><span class="org-comment">NB1</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Replace the old fuel_model cube with a new fire-break-containing cube</span>
<span class="org-variable-name">space_time_cubes_fork</span>[<span class="org-string">"fuel_model"</span>] <span class="org-operator">=</span> SpaceTimeCube(cube_shape, fuel_model_grid)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Run both simulations for another 4 hours</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Day 2 @ 6:30pm</span>
<span class="org-variable-name">new_start_time</span> <span class="org-operator">=</span> stop_time <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">4 hours</span>
<span class="org-variable-name">new_max_duration</span> <span class="org-operator">=</span> 240     <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Spread the main simulation</span>
<span class="org-variable-name">runtime_start_main</span>     <span class="org-operator">=</span> time.perf_counter()
<span class="org-variable-name">fire_spread_results_12</span> <span class="org-operator">=</span> els.spread_fire_with_phi_field(space_time_cubes, output_matrices,
                                                        cube_resolution, new_start_time, new_max_duration)
<span class="org-variable-name">runtime_stop_main</span>      <span class="org-operator">=</span> time.perf_counter()

<span class="org-variable-name">stop_time</span>       <span class="org-operator">=</span> fire_spread_results_12[<span class="org-string">"stop_time"</span>]       <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>
<span class="org-variable-name">stop_condition</span>  <span class="org-operator">=</span> fire_spread_results_12[<span class="org-string">"stop_condition"</span>]  <span class="org-comment-delimiter"># </span><span class="org-comment">"max duration reached" or "no burnable cells"</span>
<span class="org-variable-name">output_matrices</span> <span class="org-operator">=</span> fire_spread_results_12[<span class="org-string">"output_matrices"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">updated 2D arrays (mutated from inputs)</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Spread the forked simulation</span>
<span class="org-variable-name">runtime_start_fork</span>          <span class="org-operator">=</span> time.perf_counter()
<span class="org-variable-name">fire_spread_results_12_fork</span> <span class="org-operator">=</span> els.spread_fire_with_phi_field(space_time_cubes_fork, output_matrices_fork,
                                                             cube_resolution, new_start_time, new_max_duration)
<span class="org-variable-name">runtime_stop_fork</span>           <span class="org-operator">=</span> time.perf_counter()

<span class="org-variable-name">stop_time_fork</span>       <span class="org-operator">=</span> fire_spread_results_12_fork[<span class="org-string">"stop_time"</span>]       <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>
<span class="org-variable-name">stop_condition_fork</span>  <span class="org-operator">=</span> fire_spread_results_12_fork[<span class="org-string">"stop_condition"</span>]  <span class="org-comment-delimiter"># </span><span class="org-comment">"max duration reached" or "no burnable cells"</span>
<span class="org-variable-name">output_matrices_fork</span> <span class="org-operator">=</span> fire_spread_results_12_fork[<span class="org-string">"output_matrices"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">updated 2D arrays (mutated from inputs)</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Print out the acres burned, total runtime, and runtime per burned cell for the main run</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">num_burned_cells</span>         <span class="org-operator">=</span> np.count_nonzero(output_matrices[<span class="org-string">"fire_type"</span>])       <span class="org-comment-delimiter"># </span><span class="org-comment">cells</span>
<span class="org-variable-name">acres_burned</span>             <span class="org-operator">=</span> num_burned_cells <span class="org-operator">/</span> 4.5                               <span class="org-comment-delimiter"># </span><span class="org-comment">acres</span>
<span class="org-variable-name">simulation_runtime_main</span>  <span class="org-operator">=</span> runtime_stop_main <span class="org-operator">-</span> runtime_start_main               <span class="org-comment-delimiter"># </span><span class="org-comment">seconds</span>
<span class="org-variable-name">simulation_runtime_total</span> <span class="org-operator">=</span> simulation_runtime <span class="org-operator">+</span> simulation_runtime_main         <span class="org-comment-delimiter"># </span><span class="org-comment">seconds</span>
<span class="org-variable-name">runtime_per_burned_cell</span>  <span class="org-operator">=</span> 1000.0 <span class="org-operator">*</span> simulation_runtime_total <span class="org-operator">/</span> num_burned_cells <span class="org-comment-delimiter"># </span><span class="org-comment">ms/cell</span>

<span class="org-builtin">print</span>(<span class="org-string">"Main Fire</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)
<span class="org-builtin">print</span>(<span class="org-string">"Acres Burned: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(acres_burned))
<span class="org-builtin">print</span>(<span class="org-string">"Total Runtime: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(simulation_runtime_total) <span class="org-operator">+</span> <span class="org-string">" seconds"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Runtime per Burned Cell: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(runtime_per_burned_cell) <span class="org-operator">+</span> <span class="org-string">" ms/cell"</span>)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Print out the acres burned, total runtime, and runtime per burned cell for the forked run</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">num_burned_cells</span>         <span class="org-operator">=</span> np.count_nonzero(output_matrices_fork[<span class="org-string">"fire_type"</span>])  <span class="org-comment-delimiter"># </span><span class="org-comment">cells</span>
<span class="org-variable-name">acres_burned</span>             <span class="org-operator">=</span> num_burned_cells <span class="org-operator">/</span> 4.5                               <span class="org-comment-delimiter"># </span><span class="org-comment">acres</span>
<span class="org-variable-name">simulation_runtime_fork</span>  <span class="org-operator">=</span> runtime_stop_fork <span class="org-operator">-</span> runtime_start_fork               <span class="org-comment-delimiter"># </span><span class="org-comment">seconds</span>
<span class="org-variable-name">simulation_runtime_total</span> <span class="org-operator">=</span> simulation_runtime <span class="org-operator">+</span> simulation_runtime_fork         <span class="org-comment-delimiter"># </span><span class="org-comment">seconds</span>
<span class="org-variable-name">runtime_per_burned_cell</span>  <span class="org-operator">=</span> 1000.0 <span class="org-operator">*</span> simulation_runtime_total <span class="org-operator">/</span> num_burned_cells <span class="org-comment-delimiter"># </span><span class="org-comment">ms/cell</span>

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Forked Fire</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)
<span class="org-builtin">print</span>(<span class="org-string">"Acres Burned: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(acres_burned))
<span class="org-builtin">print</span>(<span class="org-string">"Total Runtime: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(simulation_runtime_total) <span class="org-operator">+</span> <span class="org-string">" seconds"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Runtime per Burned Cell: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(runtime_per_burned_cell) <span class="org-operator">+</span> <span class="org-string">" ms/cell"</span>)
</pre>
</div>
</div>
</li>
<li><a id="display-summary-statistics-of-the-two-scenarios'-outputs"></a>Display Summary Statistics of the Two Scenarios' Outputs<br>
<div class="outline-text-5" id="text-display-summary-statistics-of-the-two-scenarios'-outputs">
<div class="org-src-container">
<pre class="src src-python" id="run-spread-fire-with-phi-field-stats-forked"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Display summary statistics of our fire spread results</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Used as filters in get_array_stats and get_array_stats_fork below</span>
<span class="org-variable-name">burned_cells</span>      <span class="org-operator">=</span> output_matrices[<span class="org-string">"fire_type"</span>] <span class="org-operator">&gt;</span> 0
<span class="org-variable-name">burned_cells_fork</span> <span class="org-operator">=</span> output_matrices_fork[<span class="org-string">"fire_type"</span>] <span class="org-operator">&gt;</span> 0

<span class="org-keyword">def</span> <span class="org-function-name">get_array_stats</span>(array, use_burn_scar_mask<span class="org-operator">=</span><span class="org-constant">True</span>):
    <span class="org-variable-name">array_values_to_analyze</span> <span class="org-operator">=</span> array[burned_cells] <span class="org-keyword">if</span> use_burn_scar_mask <span class="org-keyword">else</span> array
    <span class="org-keyword">if</span> <span class="org-builtin">len</span>(array_values_to_analyze) <span class="org-operator">&gt;</span> 0:
        <span class="org-keyword">return</span> {
            <span class="org-string">"Min"</span>  : np.<span class="org-builtin">min</span>(array_values_to_analyze),
            <span class="org-string">"Max"</span>  : np.<span class="org-builtin">max</span>(array_values_to_analyze),
            <span class="org-string">"Mean"</span> : np.mean(array_values_to_analyze),
            <span class="org-string">"Stdev"</span>: np.std(array_values_to_analyze),
        }
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> {
            <span class="org-string">"Min"</span>  : <span class="org-string">"No Data"</span>,
            <span class="org-string">"Max"</span>  : <span class="org-string">"No Data"</span>,
            <span class="org-string">"Mean"</span> : <span class="org-string">"No Data"</span>,
            <span class="org-string">"Stdev"</span>: <span class="org-string">"No Data"</span>,
        }

<span class="org-keyword">def</span> <span class="org-function-name">get_array_stats_fork</span>(array, use_burn_scar_mask<span class="org-operator">=</span><span class="org-constant">True</span>):
    <span class="org-variable-name">array_values_to_analyze</span> <span class="org-operator">=</span> array[burned_cells_fork] <span class="org-keyword">if</span> use_burn_scar_mask <span class="org-keyword">else</span> array
    <span class="org-keyword">if</span> <span class="org-builtin">len</span>(array_values_to_analyze) <span class="org-operator">&gt;</span> 0:
        <span class="org-keyword">return</span> {
            <span class="org-string">"Min"</span>  : np.<span class="org-builtin">min</span>(array_values_to_analyze),
            <span class="org-string">"Max"</span>  : np.<span class="org-builtin">max</span>(array_values_to_analyze),
            <span class="org-string">"Mean"</span> : np.mean(array_values_to_analyze),
            <span class="org-string">"Stdev"</span>: np.std(array_values_to_analyze),
        }
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> {
            <span class="org-string">"Min"</span>  : <span class="org-string">"No Data"</span>,
            <span class="org-string">"Max"</span>  : <span class="org-string">"No Data"</span>,
            <span class="org-string">"Mean"</span> : <span class="org-string">"No Data"</span>,
            <span class="org-string">"Stdev"</span>: <span class="org-string">"No Data"</span>,
        }

<span class="org-builtin">print</span>(<span class="org-string">"Fire Behavior from Day 2 @ 10:30am - Day 2 @ 10:30pm Spreading from Coordinate (50,50)</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 100)

<span class="org-builtin">print</span>(<span class="org-string">"Stop Time (Main): "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(stop_time) <span class="org-operator">+</span> <span class="org-string">" (minutes)"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Stop Time (Fork): "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(stop_time_fork) <span class="org-operator">+</span> <span class="org-string">" (minutes)"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Stop Condition (Main): "</span> <span class="org-operator">+</span> stop_condition)
<span class="org-builtin">print</span>(<span class="org-string">"Stop Condition (Fork): "</span> <span class="org-operator">+</span> stop_condition_fork)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Phi (phi &lt;= 0: burned, phi &gt; 0: unburned"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Main: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"phi"</span>], use_burn_scar_mask<span class="org-operator">=</span><span class="org-constant">False</span>), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Fork: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats_fork(output_matrices_fork[<span class="org-string">"phi"</span>], use_burn_scar_mask<span class="org-operator">=</span><span class="org-constant">False</span>), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Fire Type (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Main: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"fire_type"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Fork: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats_fork(output_matrices_fork[<span class="org-string">"fire_type"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Spread Rate (m/min)"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Main: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"spread_rate"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Fork: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats_fork(output_matrices_fork[<span class="org-string">"spread_rate"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Spread Direction (degrees clockwise from North)"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Main: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"spread_direction"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Fork: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats_fork(output_matrices_fork[<span class="org-string">"spread_direction"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Fireline Intensity (kW/m)"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Main: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"fireline_intensity"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Fork: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats_fork(output_matrices_fork[<span class="org-string">"fireline_intensity"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Flame Length (meters)"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Main: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"flame_length"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Fork: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats_fork(output_matrices_fork[<span class="org-string">"flame_length"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Time of Arrival (minutes)"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Main: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"time_of_arrival"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Fork: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats_fork(output_matrices_fork[<span class="org-string">"time_of_arrival"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)
</pre>
</div>

<pre class="example" id="run-spread-fire-with-phi-field-stats-forked-results">
Fire Behavior from Day 2 @ 10:30am - Day 2 @ 10:30pm Spreading from Coordinate (50,50)
====================================================================================================
Stop Time (Main): 2790.0 (minutes)
Stop Time (Fork): 2790.0 (minutes)
Stop Condition (Main): max duration reached
Stop Condition (Fork): max duration reached

Phi (phi &lt;= 0: burned, phi &gt; 0: unburned
Main: {'Min': -0.92524624, 'Max': 1.0, 'Mean': 0.7945679, 'Stdev': 0.5639848}
Fork: {'Min': -0.92524624, 'Max': 1.0, 'Mean': 0.7984585, 'Stdev': 0.56110543}

Fire Type (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)
Main: {'Min': 1, 'Max': 1, 'Mean': 1.0, 'Stdev': 0.0}
Fork: {'Min': 1, 'Max': 1, 'Mean': 1.0, 'Stdev': 0.0}

Spread Rate (m/min)
Main: {'Min': 0.16077116, 'Max': 2.2964668, 'Mean': 1.2057376, 'Stdev': 0.6379757}
Fork: {'Min': 0.16077116, 'Max': 2.2964668, 'Mean': 1.1890496, 'Stdev': 0.63051146}

Spread Direction (degrees clockwise from North)
Main: {'Min': 0.27235666, 'Max': 359.69885, 'Mean': 190.26033, 'Stdev': 117.35212}
Fork: {'Min': 0.27235666, 'Max': 359.69885, 'Mean': 192.25833, 'Stdev': 116.70386}

Fireline Intensity (kW/m)
Main: {'Min': 2.2772384, 'Max': 32.528233, 'Mean': 17.078634, 'Stdev': 9.036588}
Fork: {'Min': 2.2772384, 'Max': 32.528233, 'Mean': 16.842258, 'Stdev': 8.9308605}

Flame Length (meters)
Main: {'Min': 0.11312115, 'Max': 0.38439324, 'Mean': 0.27460182, 'Stdev': 0.073415086}
Fork: {'Min': 0.11312115, 'Max': 0.38439324, 'Mean': 0.27287114, 'Stdev': 0.07285743}

Time of Arrival (minutes)
Main: {'Min': 2081.8516, 'Max': 2789.743, 'Mean': 2543.6892, 'Stdev': 173.15518}
Fork: {'Min': 2081.8516, 'Max': 2789.743, 'Mean': 2539.6372, 'Stdev': 171.93945}
</pre>
</div>
</li>
<li><a id="create-images-of-the-two-scenarios'-outputs"></a>Create Images of the Two Scenarios' Outputs<br>
<div class="outline-text-5" id="text-create-images-of-the-two-scenarios'-outputs">
<div class="org-src-container">
<pre class="src src-python" id="run-spread-fire-with-phi-field-images-forked"><span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np


<span class="org-keyword">def</span> <span class="org-function-name">save_matrix_as_heatmap</span>(matrix, colors, units, title, filename, vmin<span class="org-operator">=</span><span class="org-constant">None</span>, vmax<span class="org-operator">=</span><span class="org-constant">None</span>, ticks<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-variable-name">image</span>    <span class="org-operator">=</span> plt.imshow(matrix, origin<span class="org-operator">=</span><span class="org-string">"lower"</span>, cmap<span class="org-operator">=</span>colors, vmin<span class="org-operator">=</span>vmin, vmax<span class="org-operator">=</span>vmax)
    <span class="org-variable-name">colorbar</span> <span class="org-operator">=</span> plt.colorbar(image, orientation<span class="org-operator">=</span><span class="org-string">"vertical"</span>, ticks<span class="org-operator">=</span>ticks)
    colorbar.set_label(units)
    plt.title(title)
    plt.savefig(filename)
    plt.close(<span class="org-string">"all"</span>)


<span class="org-keyword">def</span> <span class="org-function-name">save_matrix_as_contours</span>(matrix, title, filename, levels<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-variable-name">fig</span>, <span class="org-variable-name">ax</span> <span class="org-operator">=</span> plt.subplots()
    <span class="org-variable-name">cs</span>      <span class="org-operator">=</span> ax.contour(matrix, levels<span class="org-operator">=</span>levels)
    ax.clabel(cs, inline<span class="org-operator">=</span><span class="org-constant">True</span>, fontsize<span class="org-operator">=</span>10)
    ax.set_aspect(<span class="org-string">'equal'</span>, <span class="org-string">'box'</span>)
    ax.set_title(title)
    plt.savefig(filename)
    plt.close(<span class="org-string">"all"</span>)


<span class="org-comment-delimiter"># </span><span class="org-comment">See https://matplotlib.org/stable/gallery/color/colormap_reference.html for the available options for "colors"</span>
<span class="org-variable-name">heatmap_configs</span> <span class="org-operator">=</span> [
    {
        <span class="org-string">"matrix"</span>  : space_time_cubes[<span class="org-string">"fuel_model"</span>].getSpatialPlane(0, <span class="org-constant">None</span>, <span class="org-constant">None</span>),
        <span class="org-string">"colors"</span>  : <span class="org-string">"viridis_r"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"fuel model number: 91-204"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Fuel Model"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_fuel_model_main.png"</span>,
        <span class="org-string">"vmin"</span>    : 91,
        <span class="org-string">"vmax"</span>    : 204,
    },
    {
        <span class="org-string">"matrix"</span>  : space_time_cubes_fork[<span class="org-string">"fuel_model"</span>].getSpatialPlane(0, <span class="org-constant">None</span>, <span class="org-constant">None</span>),
        <span class="org-string">"colors"</span>  : <span class="org-string">"viridis_r"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"fuel model number: 91-204"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Fuel Model"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_fuel_model_fork.png"</span>,
        <span class="org-string">"vmin"</span>    : 91,
        <span class="org-string">"vmax"</span>    : 204,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"phi"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"plasma"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"phi &lt;= 0: burned, phi &gt; 0: unburned"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Phi"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_phi_main.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices_fork[<span class="org-string">"phi"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"plasma"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"phi &lt;= 0: burned, phi &gt; 0: unburned"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Phi"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_phi_fork.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"fire_type"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"viridis"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"0=unburned, 1=surface, 2=passive_crown, 3=active_crown"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Fire Type"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_fire_type_main.png"</span>,
        <span class="org-string">"vmin"</span>    : 0,
        <span class="org-string">"vmax"</span>    : 3,
        <span class="org-string">"ticks"</span>   : [0,1,2,3],
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices_fork[<span class="org-string">"fire_type"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"viridis"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"0=unburned, 1=surface, 2=passive_crown, 3=active_crown"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Fire Type"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_fire_type_fork.png"</span>,
        <span class="org-string">"vmin"</span>    : 0,
        <span class="org-string">"vmax"</span>    : 3,
        <span class="org-string">"ticks"</span>   : [0,1,2,3],
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"spread_rate"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"m/min"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Spread Rate"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_spread_rate_main.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices_fork[<span class="org-string">"spread_rate"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"m/min"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Spread Rate"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_spread_rate_fork.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"spread_direction"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"viridis"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"degrees clockwise from North"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Spread Direction"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_spread_direction_main.png"</span>,
        <span class="org-string">"vmin"</span>    : 0,
        <span class="org-string">"vmax"</span>    : 360,
        <span class="org-string">"ticks"</span>   : [0,45,90,135,180,225,270,315,360]
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices_fork[<span class="org-string">"spread_direction"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"viridis"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"degrees clockwise from North"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Spread Direction"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_spread_direction_fork.png"</span>,
        <span class="org-string">"vmin"</span>    : 0,
        <span class="org-string">"vmax"</span>    : 360,
        <span class="org-string">"ticks"</span>   : [0,45,90,135,180,225,270,315,360]
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"fireline_intensity"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"kW/m"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Fireline Intensity"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_fireline_intensity_main.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices_fork[<span class="org-string">"fireline_intensity"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"kW/m"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Fireline Intensity"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_fireline_intensity_fork.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"flame_length"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"meters"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Flame Length"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_flame_length_main.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices_fork[<span class="org-string">"flame_length"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"meters"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Flame Length"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_flame_length_fork.png"</span>,
    },
]


<span class="org-variable-name">contour_configs</span> <span class="org-operator">=</span> [
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"time_of_arrival"</span>],
        <span class="org-string">"title"</span>   : <span class="org-string">"Time of Arrival"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_time_of_arrival_main.png"</span>,
        <span class="org-string">"levels"</span>  : <span class="org-builtin">int</span>(start_time) <span class="org-operator">+</span> np.asarray(<span class="org-builtin">range</span>(0, <span class="org-builtin">int</span>(max_duration) <span class="org-operator">+</span> 1, 60)),
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices_fork[<span class="org-string">"time_of_arrival"</span>],
        <span class="org-string">"title"</span>   : <span class="org-string">"Time of Arrival"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"pics/els_time_of_arrival_fork.png"</span>,
        <span class="org-string">"levels"</span>  : <span class="org-builtin">int</span>(start_time) <span class="org-operator">+</span> np.asarray(<span class="org-builtin">range</span>(0, <span class="org-builtin">int</span>(max_duration) <span class="org-operator">+</span> 1, 60)),
    },
]


<span class="org-keyword">for</span> heatmap_config <span class="org-keyword">in</span> heatmap_configs:
    save_matrix_as_heatmap(<span class="org-operator">**</span>heatmap_config)


<span class="org-keyword">for</span> contour_config <span class="org-keyword">in</span> contour_configs:
    save_matrix_as_contours(<span class="org-operator">**</span>contour_config)
</pre>
</div>

<table id="fuel-model-matplotlib-heatmaps-forked">
<caption class="t-above"><span class="table-number">Table 8:</span> Fuel model [Left: Main, Right: Fork]</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="pics/els_fuel_model_main.png" alt="els_fuel_model_main.png"></td>
<td class="org-left"><img src="pics/els_fuel_model_fork.png" alt="els_fuel_model_fork.png"></td>
</tr>
</tbody>
</table>

<table id="fire-behavior-matplotlib-heatmaps-forked">
<caption class="t-above"><span class="table-number">Table 9:</span> Fire behavior attributes after 12 hours of spread [Left: Main, Right: Fork]</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="pics/els_phi_main.png" alt="els_phi_main.png"></td>
<td class="org-left"><img src="pics/els_phi_fork.png" alt="els_phi_fork.png"></td>
</tr>

<tr>
<td class="org-left"><img src="pics/els_fire_type_main.png" alt="els_fire_type_main.png"></td>
<td class="org-left"><img src="pics/els_fire_type_fork.png" alt="els_fire_type_fork.png"></td>
</tr>

<tr>
<td class="org-left"><img src="pics/els_spread_rate_main.png" alt="els_spread_rate_main.png"></td>
<td class="org-left"><img src="pics/els_spread_rate_fork.png" alt="els_spread_rate_fork.png"></td>
</tr>

<tr>
<td class="org-left"><img src="pics/els_spread_direction_main.png" alt="els_spread_direction_main.png"></td>
<td class="org-left"><img src="pics/els_spread_direction_fork.png" alt="els_spread_direction_fork.png"></td>
</tr>

<tr>
<td class="org-left"><img src="pics/els_fireline_intensity_main.png" alt="els_fireline_intensity_main.png"></td>
<td class="org-left"><img src="pics/els_fireline_intensity_fork.png" alt="els_fireline_intensity_fork.png"></td>
</tr>

<tr>
<td class="org-left"><img src="pics/els_flame_length_main.png" alt="els_flame_length_main.png"></td>
<td class="org-left"><img src="pics/els_flame_length_fork.png" alt="els_flame_length_fork.png"></td>
</tr>
</tbody>
</table>

<table id="time-of-arrival-matplotlib-countours-forked">
<caption class="t-above"><span class="table-number">Table 10:</span> Time of arrival with hourly perimeters [Left: Main, Right: Fork]</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="pics/els_time_of_arrival_main.png" alt="els_time_of_arrival_main.png"></td>
<td class="org-left"><img src="pics/els_time_of_arrival_fork.png" alt="els_time_of_arrival_fork.png"></td>
</tr>
</tbody>
</table>
</div>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-appendices" class="outline-2">
<h2 id="appendices"><span class="section-number-2">10.</span> Appendices</h2>
<div class="outline-text-2" id="text-appendices">
</div>
<div id="outline-container-units-conversion-functions-(pyretechnics.conversion)" class="outline-3">
<h3 id="units-conversion-functions-(pyretechnics.conversion)"><span class="section-number-3">10.1.</span> Units Conversion Functions (pyretechnics.conversion)</h3>
<div class="outline-text-3" id="text-units-conversion-functions-(pyretechnics.conversion)">
<div class="org-src-container">
<pre class="src src-python" id="units-conversion"><span class="org-comment-delimiter"># </span><span class="org-comment">cython: profile=False</span>
<span class="org-keyword">import</span> cython
<span class="org-keyword">if</span> cython.compiled:
    <span class="org-keyword">from</span> cython.cimports.pyretechnics.math <span class="org-keyword">import</span> sqrt, sin, cos, tan, atan, atan2
    <span class="org-keyword">from</span> cython.cimports.pyretechnics.cy_types <span class="org-keyword">import</span> vec_xy
<span class="org-keyword">else</span>:
    <span class="org-keyword">from</span> math <span class="org-keyword">import</span> sqrt, sin, cos, tan, atan, atan2
    <span class="org-keyword">from</span> pyretechnics.py_types <span class="org-keyword">import</span> vec_xy


<span class="org-keyword">import</span> cython <span class="org-keyword">as</span> cy


<span class="org-variable-name">PI</span> <span class="org-operator">=</span> cy.declare(cy.double, 3.14159265358979323846)


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.cdivision</span>(<span class="org-constant">True</span>)
<span class="org-keyword">def</span> <span class="org-function-name">rad_to_deg</span>(radians: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert radians to degrees."""</span>
    <span class="org-keyword">return</span> radians <span class="org-operator">*</span> 180.0 <span class="org-operator">/</span> PI


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">deg_to_rad</span>(degrees: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert degrees to radians."""</span>
    <span class="org-keyword">return</span> degrees <span class="org-operator">*</span> PI <span class="org-operator">/</span> 180.0


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">deg_to_ratio</span>(degrees: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert degrees to ratio."""</span>
    <span class="org-keyword">return</span> tan(deg_to_rad(degrees))


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">ratio_to_deg</span>(ratio: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert ratio to degrees."""</span>
    <span class="org-keyword">return</span> rad_to_deg(atan(ratio))


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">F_to_K</span>(degrees: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert fahrenheit to kelvin."""</span>
    <span class="org-keyword">return</span> (degrees <span class="org-operator">+</span> 459.67) <span class="org-operator">*</span> 0.5555555555555556


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">K_to_F</span>(degrees: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert kelvin to fahrenheit."""</span>
    <span class="org-keyword">return</span> (degrees <span class="org-operator">*</span> 1.8) <span class="org-operator">-</span> 459.67


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">F_to_C</span>(degrees: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert fahrenheit to celsius."""</span>
    <span class="org-keyword">return</span> (degrees <span class="org-operator">-</span> 32.0) <span class="org-operator">*</span> 0.5555555555555556


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">C_to_F</span>(degrees: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert celsius to fahrenheit."""</span>
    <span class="org-keyword">return</span> (degrees <span class="org-operator">*</span> 1.8) <span class="org-operator">+</span> 32.0


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">ch_to_m</span>(ch: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert chains to meters."""</span>
    <span class="org-keyword">return</span> ch <span class="org-operator">*</span> 20.1168


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">m_to_ch</span>(m: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert meters to chains."""</span>
    <span class="org-keyword">return</span> m <span class="org-operator">*</span> 0.0497097


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">m_to_ft</span>(m: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert meters to feet."""</span>
    <span class="org-keyword">return</span> m <span class="org-operator">*</span> 3.281


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">ft_to_m</span>(ft: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert feet to meters."""</span>
    <span class="org-keyword">return</span> ft <span class="org-operator">*</span> 0.30478512648582745


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">mph_to_mps</span>(mph: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert miles per hour to meters per second."""</span>
    <span class="org-keyword">return</span> mph <span class="org-operator">*</span> 0.44701818551254696


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">mps_to_mph</span>(mps: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert meters per second to miles per hour."""</span>
    <span class="org-keyword">return</span> mps <span class="org-operator">*</span> 2.237045454545455


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">km_hr_to_mps</span>(km_hr: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert kilometers per hour to meters per second."""</span>
    <span class="org-keyword">return</span> km_hr <span class="org-operator">*</span> 0.277764222883701


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">mps_to_km_hr</span>(mps: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert meters per second to kilometers per hour."""</span>
    <span class="org-keyword">return</span> mps <span class="org-operator">*</span> 3.6001756800000004


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">mph_to_km_hr</span>(mph: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert miles per hour to kilometers per hour."""</span>
    <span class="org-keyword">return</span> mph <span class="org-operator">*</span> 1.609344


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">km_hr_to_mph</span>(km_hr: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert kilometers per hour to miles per hour."""</span>
    <span class="org-keyword">return</span> km_hr <span class="org-operator">*</span> 0.621371192237334


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">m_min_to_km_hr</span>(m_min: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert meters per minute to kilometers per hour."""</span>
    <span class="org-keyword">return</span> m_min <span class="org-operator">*</span> 0.06


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">km_hr_to_m_min</span>(km_hr: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert kilometers per hour to meters per minute."""</span>
    <span class="org-keyword">return</span> km_hr <span class="org-operator">/</span> 0.06


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">m_min_to_mph</span>(m_min: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert meters per minute to miles per hour."""</span>
    <span class="org-keyword">return</span> m_min <span class="org-operator">*</span> 0.0372840909091


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">mph_to_m_min</span>(mph: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert miles per hour to meters per minute."""</span>
    <span class="org-keyword">return</span> mph <span class="org-operator">*</span> 26.8210911307


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">mps_to_fpm</span>(mps: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert meters per second to feet per minute."""</span>
    <span class="org-keyword">return</span> mps <span class="org-operator">*</span> 196.86


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">fpm_to_mps</span>(fpm: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert feet per minute to meters per second."""</span>
    <span class="org-keyword">return</span> fpm <span class="org-operator">/</span> 196.86


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">mph_to_fpm</span>(mph: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert miles per hour to feet per minute."""</span>
    <span class="org-keyword">return</span> mph <span class="org-operator">*</span> 88.0


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">fpm_to_mph</span>(fpm: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert feet per minute to miles per hour."""</span>
    <span class="org-keyword">return</span> fpm <span class="org-operator">/</span> 88.0


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">Btu_ft_s_to_kW_m</span>(Btu_ft_s: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert BTU per feet per second to kilowatt per meter."""</span>
    <span class="org-keyword">return</span> Btu_ft_s <span class="org-operator">*</span> 3.46165186


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">kW_m_to_Btu_ft_s</span>(kW_m: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert kilowatt per meter to BTU per feet per second."""</span>
    <span class="org-keyword">return</span> kW_m <span class="org-operator">*</span> 0.28887942532730604


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">Btu_lb_to_kJ_kg</span>(Btu_lb: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert BTU per lb to kilojoule per kilogram."""</span>
    <span class="org-keyword">return</span> Btu_lb <span class="org-operator">*</span> 2.3259999996185


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">kJ_kg_to_Btu_lb</span>(kJ_kg: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert kilojoule per kilogram to BTU per lb."""</span>
    <span class="org-keyword">return</span> kJ_kg <span class="org-operator">/</span> 2.3259999996185


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">kg_m3_to_lb_ft3</span>(kg_m3: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert kilogram per cubic meter to pound per cubic foot."""</span>
    <span class="org-keyword">return</span> kg_m3 <span class="org-operator">*</span> 0.0624


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">lb_ft3_to_kg_m3</span>(lb_ft3: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert pound per cubic foot to kilogram per cubic meter."""</span>
    <span class="org-keyword">return</span> lb_ft3 <span class="org-operator">*</span> 16.025641025641026


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">percent_to_dec</span>(percent: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert percent to decimal."""</span>
    <span class="org-keyword">return</span> percent <span class="org-operator">*</span> 0.01


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">dec_to_percent</span>(decimal: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert decimal to percent."""</span>
    <span class="org-keyword">return</span> decimal <span class="org-operator">*</span> 100.0


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">sec_to_min</span>(seconds: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert seconds to minutes."""</span>
    <span class="org-keyword">return</span> seconds <span class="org-operator">*</span> 0.016666666666666666


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">min_to_sec</span>(minutes: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert minutes to seconds."""</span>
    <span class="org-keyword">return</span> minutes <span class="org-operator">*</span> 60.0


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">ms_to_min</span>(milliseconds: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert milliseconds to minutes."""</span>
    <span class="org-keyword">return</span> milliseconds <span class="org-operator">*</span> 0.000016667


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">min_to_ms</span>(minutes: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert minutes to milliseconds."""</span>
    <span class="org-keyword">return</span> minutes <span class="org-operator">*</span> 60000.0


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">hour_to_min</span>(hours: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Converts hours to minutes."""</span>
    <span class="org-keyword">return</span> hours <span class="org-operator">*</span> 60.0


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">min_to_hour</span>(minutes: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Converts minutes to hours."""</span>
    <span class="org-keyword">return</span> minutes <span class="org-operator">/</span> 60.0


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">day_to_min</span>(days: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert days to minutes."""</span>
    <span class="org-keyword">return</span> days <span class="org-operator">*</span> 1440.0


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">min_to_day</span>(minutes: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert minutes to days."""</span>
    <span class="org-keyword">return</span> minutes <span class="org-operator">/</span> 1440.0


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">cartesian_to_polar</span>(x: cy.<span class="org-builtin">float</span>, y: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> vec_xy:
    <span class="org-doc">"""Convert cartesian coordinates (x, y) to polar coordinates (r, theta)."""</span>
    <span class="org-variable-name">r</span>        : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> sqrt(x <span class="org-operator">*</span> x <span class="org-operator">+</span> y <span class="org-operator">*</span> y)
    <span class="org-variable-name">theta_rad</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> atan2(y, x)
    <span class="org-variable-name">theta</span>    : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> rad_to_deg(theta_rad) <span class="org-operator">%</span> 360.0
    <span class="org-keyword">return</span> (r, theta)


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">polar_to_cartesian</span>(r: cy.<span class="org-builtin">float</span>, theta: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> vec_xy:
    <span class="org-doc">"""Convert polar coordinates (r, theta) to cartesian coordinates (x, y)."""</span>
    <span class="org-variable-name">theta_rad</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> deg_to_rad(theta)
    <span class="org-variable-name">x</span>        : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> r <span class="org-operator">*</span> cos(theta_rad)
    <span class="org-variable-name">y</span>        : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> r <span class="org-operator">*</span> sin(theta_rad)
    <span class="org-keyword">return</span> (x, y)


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">cartesian_to_azimuthal</span>(x: cy.<span class="org-builtin">float</span>, y: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> vec_xy:
    <span class="org-doc">"""Convert cartesian coordinates (x, y) to azimuthal coordinates (r, azimuth)."""</span>
    <span class="org-variable-name">r</span>          : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> sqrt(x <span class="org-operator">*</span> x <span class="org-operator">+</span> y <span class="org-operator">*</span> y)
    <span class="org-variable-name">azimuth_rad</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> atan2(x, y)
    <span class="org-variable-name">azimuth</span>    : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> rad_to_deg(azimuth_rad) <span class="org-operator">%</span> 360.0
    <span class="org-keyword">return</span> (r, azimuth)


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">azimuthal_to_cartesian</span>(r: cy.<span class="org-builtin">float</span>, azimuth: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> vec_xy:
    <span class="org-doc">"""Convert azimuthal coordinates (r, azimuth) to cartesian coordinates (x, y)."""</span>
    <span class="org-variable-name">azimuth_rad</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> deg_to_rad(azimuth)
    <span class="org-variable-name">x</span>          : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> r <span class="org-operator">*</span> sin(azimuth_rad)
    <span class="org-variable-name">y</span>          : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> r <span class="org-operator">*</span> cos(azimuth_rad)
    <span class="org-keyword">return</span> (x, y)


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">opposite_direction</span>(theta: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert theta to theta + 180 degrees."""</span>
    <span class="org-keyword">return</span> (theta <span class="org-operator">+</span> 180.0) <span class="org-operator">%</span> 360.0


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">wind_speed_10m_to_wind_speed_20ft</span>(wind_speed_10m: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert wind speed at 10m to wind speed at 20ft."""</span>
    <span class="org-keyword">return</span> 0.87 <span class="org-operator">*</span> wind_speed_10m


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">wind_speed_20ft_to_wind_speed_10m</span>(wind_speed_20ft: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert wind speed at 20ft to wind speed at 10m."""</span>
    <span class="org-keyword">return</span> wind_speed_20ft <span class="org-operator">/</span> 0.87
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python" id="conversion-pxd">cimport pyretechnics.cy_types
<span class="org-keyword">from</span> pyretechnics.cy_types cimport vec_xy

<span class="org-comment-delimiter">#</span><span class="org-comment">==================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Cython functions to cimport into other modules</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==================================================</span>

cpdef <span class="org-builtin">float</span> rad_to_deg(<span class="org-builtin">float</span> radians)
cpdef <span class="org-builtin">float</span> deg_to_rad(<span class="org-builtin">float</span> degrees)
cpdef <span class="org-builtin">float</span> deg_to_ratio(<span class="org-builtin">float</span> degrees)
cpdef <span class="org-builtin">float</span> ratio_to_deg(<span class="org-builtin">float</span> ratio)
cpdef <span class="org-builtin">float</span> F_to_K(<span class="org-builtin">float</span> degrees)
cpdef <span class="org-builtin">float</span> K_to_F(<span class="org-builtin">float</span> degrees)
cpdef <span class="org-builtin">float</span> F_to_C(<span class="org-builtin">float</span> degrees)
cpdef <span class="org-builtin">float</span> C_to_F(<span class="org-builtin">float</span> degrees)
cpdef <span class="org-builtin">float</span> ch_to_m(<span class="org-builtin">float</span> ch)
cpdef <span class="org-builtin">float</span> m_to_ch(<span class="org-builtin">float</span> m)
cpdef <span class="org-builtin">float</span> m_to_ft(<span class="org-builtin">float</span> m)
cpdef <span class="org-builtin">float</span> ft_to_m(<span class="org-builtin">float</span> ft)
cpdef <span class="org-builtin">float</span> mph_to_mps(<span class="org-builtin">float</span> mph)
cpdef <span class="org-builtin">float</span> mps_to_mph(<span class="org-builtin">float</span> mps)
cpdef <span class="org-builtin">float</span> km_hr_to_mps(<span class="org-builtin">float</span> km_hr)
cpdef <span class="org-builtin">float</span> mps_to_km_hr(<span class="org-builtin">float</span> mps)
cpdef <span class="org-builtin">float</span> mph_to_km_hr(<span class="org-builtin">float</span> mph)
cpdef <span class="org-builtin">float</span> km_hr_to_mph(<span class="org-builtin">float</span> km_hr)
cpdef <span class="org-builtin">float</span> m_min_to_km_hr(<span class="org-builtin">float</span> m_min)
cpdef <span class="org-builtin">float</span> km_hr_to_m_min(<span class="org-builtin">float</span> km_hr)
cpdef <span class="org-builtin">float</span> m_min_to_mph(<span class="org-builtin">float</span> m_min)
cpdef <span class="org-builtin">float</span> mph_to_m_min(<span class="org-builtin">float</span> mph)
cpdef <span class="org-builtin">float</span> mps_to_fpm(<span class="org-builtin">float</span> mps)
cpdef <span class="org-builtin">float</span> fpm_to_mps(<span class="org-builtin">float</span> fpm)
cpdef <span class="org-builtin">float</span> mph_to_fpm(<span class="org-builtin">float</span> mph)
cpdef <span class="org-builtin">float</span> fpm_to_mph(<span class="org-builtin">float</span> fpm)
cpdef <span class="org-builtin">float</span> Btu_ft_s_to_kW_m(<span class="org-builtin">float</span> Btu_ft_s)
cpdef <span class="org-builtin">float</span> kW_m_to_Btu_ft_s(<span class="org-builtin">float</span> kW_m)
cpdef <span class="org-builtin">float</span> Btu_lb_to_kJ_kg(<span class="org-builtin">float</span> Btu_lb)
cpdef <span class="org-builtin">float</span> kJ_kg_to_Btu_lb(<span class="org-builtin">float</span> kJ_kg)
cpdef <span class="org-builtin">float</span> kg_m3_to_lb_ft3(<span class="org-builtin">float</span> kg_m3)
cpdef <span class="org-builtin">float</span> lb_ft3_to_kg_m3(<span class="org-builtin">float</span> lb_ft3)
cpdef <span class="org-builtin">float</span> percent_to_dec(<span class="org-builtin">float</span> percent)
cpdef <span class="org-builtin">float</span> dec_to_percent(<span class="org-builtin">float</span> decimal)
cpdef <span class="org-builtin">float</span> sec_to_min(<span class="org-builtin">float</span> seconds)
cpdef <span class="org-builtin">float</span> min_to_sec(<span class="org-builtin">float</span> minutes)
cpdef <span class="org-builtin">float</span> ms_to_min(<span class="org-builtin">float</span> milliseconds)
cpdef <span class="org-builtin">float</span> min_to_ms(<span class="org-builtin">float</span> minutes)
cpdef <span class="org-builtin">float</span> hour_to_min(<span class="org-builtin">float</span> hours)
cpdef <span class="org-builtin">float</span> min_to_hour(<span class="org-builtin">float</span> minutes)
cpdef <span class="org-builtin">float</span> day_to_min(<span class="org-builtin">float</span> days)
cpdef <span class="org-builtin">float</span> min_to_day(<span class="org-builtin">float</span> minutes)
cpdef vec_xy cartesian_to_polar(<span class="org-builtin">float</span> x, <span class="org-builtin">float</span> y)
cpdef vec_xy polar_to_cartesian(<span class="org-builtin">float</span> r, <span class="org-builtin">float</span> theta)
cpdef vec_xy cartesian_to_azimuthal(<span class="org-builtin">float</span> x, <span class="org-builtin">float</span> y)
cpdef vec_xy azimuthal_to_cartesian(<span class="org-builtin">float</span> r, <span class="org-builtin">float</span> azimuth)
cpdef <span class="org-builtin">float</span> opposite_direction(<span class="org-builtin">float</span> theta)
cpdef <span class="org-builtin">float</span> wind_speed_10m_to_wind_speed_20ft(<span class="org-builtin">float</span> wind_speed_10m)
cpdef <span class="org-builtin">float</span> wind_speed_20ft_to_wind_speed_10m(<span class="org-builtin">float</span> wind_speed_20ft)
</pre>
</div>
</div>
</div>
<div id="outline-container-vector-utility-functions-(pyretechnics.vector_utils)" class="outline-3">
<h3 id="vector-utility-functions-(pyretechnics.vector_utils)"><span class="section-number-3">10.2.</span> Vector Utility Functions (pyretechnics.vector_utils)</h3>
<div class="outline-text-3" id="text-vector-utility-functions-(pyretechnics.vector_utils)">
<div class="org-src-container">
<pre class="src src-python" id="vector-utilities"><span class="org-comment-delimiter"># </span><span class="org-comment">cython: profile=False</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Fix "result uninitialized" warnings</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Fix cimport of numpy</span>
<span class="org-keyword">import</span> cython
<span class="org-keyword">if</span> cython.compiled:
    <span class="org-keyword">from</span> numpy <span class="org-keyword">import</span> add, multiply, cross
    <span class="org-comment-delimiter"># </span><span class="org-comment">from cython.cimports.numpy import add, multiply, cross</span>
    <span class="org-keyword">from</span> cython.cimports.pyretechnics.math <span class="org-keyword">import</span> sqrt, sin, cos
    <span class="org-keyword">from</span> cython.cimports.pyretechnics.cy_types <span class="org-keyword">import</span> pyidx, vec_xy, vec_xyz
    <span class="org-keyword">from</span> cython.cimports.pyretechnics.conversion <span class="org-keyword">import</span> \
        opposite_direction, azimuthal_to_cartesian, cartesian_to_azimuthal, deg_to_rad
<span class="org-keyword">else</span>:
    <span class="org-keyword">from</span> numpy <span class="org-keyword">import</span> add, multiply, cross
    <span class="org-keyword">from</span> math <span class="org-keyword">import</span> sqrt, sin, cos
    <span class="org-keyword">from</span> pyretechnics.py_types <span class="org-keyword">import</span> pyidx, vec_xy, vec_xyz
    <span class="org-keyword">from</span> pyretechnics.conversion <span class="org-keyword">import</span> \
        opposite_direction, azimuthal_to_cartesian, cartesian_to_azimuthal, deg_to_rad


<span class="org-keyword">import</span> cython <span class="org-keyword">as</span> cy


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Replace with vector_magnitude_3d and remove</span>
<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.wraparound</span>(<span class="org-constant">False</span>)
<span class="org-type">@cy.boundscheck</span>(<span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">vector_magnitude</span>(vector: cy.double[:]) <span class="org-operator">-&gt;</span> cy.double:
    i  : pyidx
    x  : cy.double
    <span class="org-variable-name">acc</span>: cy.double <span class="org-operator">=</span> 0.0
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(<span class="org-builtin">len</span>(vector)):
        <span class="org-variable-name">x</span>    <span class="org-operator">=</span> vector[i]
        <span class="org-variable-name">acc</span> <span class="org-operator">+=</span> x <span class="org-operator">*</span> x
    <span class="org-keyword">return</span> sqrt(acc)


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">dot_2d</span>(vector1: vec_xy, vector2: vec_xy) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-keyword">return</span> vector1[0] <span class="org-operator">*</span> vector2[0] <span class="org-operator">+</span> vector1[1] <span class="org-operator">*</span> vector2[1]


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">dot_3d</span>(vector1: vec_xyz, vector2: vec_xyz) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-keyword">return</span> vector1[0] <span class="org-operator">*</span> vector2[0] <span class="org-operator">+</span> vector1[1] <span class="org-operator">*</span> vector2[1] <span class="org-operator">+</span> vector1[2] <span class="org-operator">*</span> vector2[2]


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">vector_magnitude_2d</span>(vector: vec_xy) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-keyword">return</span> sqrt(dot_2d(vector, vector))


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">vector_magnitude_3d</span>(vector: vec_xyz) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-keyword">return</span> sqrt(dot_3d(vector, vector))


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.cdivision</span>(<span class="org-constant">True</span>)
<span class="org-keyword">def</span> <span class="org-function-name">as_unit_vector_2d</span>(vector: vec_xy) <span class="org-operator">-&gt;</span> vec_xy:
    <span class="org-variable-name">magnitude</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vector_magnitude_2d(vector)
    <span class="org-keyword">if</span> magnitude <span class="org-operator">==</span> 0.0:
        <span class="org-keyword">return</span> vector
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">ux</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vector[0] <span class="org-operator">/</span> magnitude
        <span class="org-variable-name">uy</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vector[1] <span class="org-operator">/</span> magnitude
        <span class="org-keyword">return</span> (ux, uy)


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.cdivision</span>(<span class="org-constant">True</span>)
<span class="org-keyword">def</span> <span class="org-function-name">as_unit_vector_3d</span>(vector: vec_xyz) <span class="org-operator">-&gt;</span> vec_xyz:
    <span class="org-variable-name">magnitude</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vector_magnitude_3d(vector)
    <span class="org-keyword">if</span> magnitude <span class="org-operator">==</span> 0.0:
        <span class="org-keyword">return</span> vector
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">ux</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vector[0] <span class="org-operator">/</span> magnitude
        <span class="org-variable-name">uy</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vector[1] <span class="org-operator">/</span> magnitude
        <span class="org-variable-name">uz</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vector[2] <span class="org-operator">/</span> magnitude
        <span class="org-keyword">return</span> (ux, uy, uz)


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">to_slope_plane</span>(vector_2d: vec_xy, elevation_gradient: vec_xy) <span class="org-operator">-&gt;</span> vec_xyz:
    <span class="org-keyword">return</span> (
        vector_2d[0],
        vector_2d[1],
        dot_2d(vector_2d, elevation_gradient)
    )


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">to_horizontal_plane</span>(vector_3d: vec_xyz) <span class="org-operator">-&gt;</span> vec_xy:
    <span class="org-keyword">return</span> (vector_3d[0], vector_3d[1])


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Replace input numpy array with vec_xyz</span>
<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.wraparound</span>(<span class="org-constant">False</span>)
<span class="org-type">@cy.boundscheck</span>(<span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">spread_direction_vector_to_angle</span>(vector_3d: cy.double[:]) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-variable-name">x</span>        : cy.double <span class="org-operator">=</span> vector_3d[0]
    <span class="org-variable-name">y</span>        : cy.double <span class="org-operator">=</span> vector_3d[1]
    <span class="org-variable-name">az_coords</span>: vec_xy    <span class="org-operator">=</span> cartesian_to_azimuthal(x, y)
    <span class="org-variable-name">azimuth</span>  : cy.<span class="org-builtin">float</span>  <span class="org-operator">=</span> az_coords[1]
    <span class="org-keyword">return</span> azimuth


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">get_slope_normal_vector</span>(elevation_gradient: vec_xy) <span class="org-operator">-&gt;</span> vec_xyz:
    (<span class="org-variable-name">dz_dx</span>, <span class="org-variable-name">dz_dy</span>)               <span class="org-operator">=</span> elevation_gradient
    <span class="org-variable-name">slope_normal_vector</span>: vec_xyz <span class="org-operator">=</span> (<span class="org-operator">-</span>dz_dx, <span class="org-operator">-</span>dz_dy, 1.0)
    <span class="org-keyword">return</span> as_unit_vector_3d(slope_normal_vector)


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Eliminate need for numpy</span>
<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">rotate_on_sloped_plane</span>(vector: cy.double[:], theta: cy.<span class="org-builtin">float</span>, slope: cy.<span class="org-builtin">float</span>, aspect: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.double[:]:
    <span class="org-doc">"""</span>
<span class="org-doc">    Rotate a 3D vector &lt;x,y,z&gt; theta degrees clockwise on the plane defined by the slope and aspect.</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the slope normal vector from the slope and aspect</span>
    <span class="org-variable-name">elevation_gradient</span> : vec_xy  <span class="org-operator">=</span> azimuthal_to_cartesian(slope, opposite_direction(aspect))
    <span class="org-variable-name">slope_normal_vector</span>: vec_xyz <span class="org-operator">=</span> get_slope_normal_vector(elevation_gradient)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Rotate theta degrees clockwise around the slope_normal_vector</span>
    <span class="org-variable-name">theta_rad</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> deg_to_rad(theta)
    <span class="org-keyword">return</span> add(multiply(cos(theta_rad),
                        vector),
               cross(multiply(sin(theta_rad),
                              vector),
                    slope_normal_vector))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python" id="vector-utils-pxd">cimport pyretechnics.cy_types
<span class="org-keyword">from</span> pyretechnics.cy_types cimport vec_xy, vec_xyz

<span class="org-comment-delimiter">#</span><span class="org-comment">==================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Cython functions to cimport into other modules</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==================================================</span>

cpdef double vector_magnitude(double[:] vector)
cpdef <span class="org-builtin">float</span> dot_2d(vec_xy vector1, vec_xy vector2)
cpdef <span class="org-builtin">float</span> dot_3d(vec_xyz vector1, vec_xyz vector2)
cpdef <span class="org-builtin">float</span> vector_magnitude_2d(vec_xy vector)
cpdef <span class="org-builtin">float</span> vector_magnitude_3d(vec_xyz vector)
cpdef vec_xy as_unit_vector_2d(vec_xy vector)
cpdef vec_xyz as_unit_vector_3d(vec_xyz vector)
cpdef vec_xyz to_slope_plane(vec_xy vector_2d, vec_xy elevation_gradient)
cpdef vec_xy to_horizontal_plane(vec_xyz vector_3d)
cpdef <span class="org-builtin">float</span> spread_direction_vector_to_angle(double[:] vector_3d)
cpdef vec_xyz get_slope_normal_vector(vec_xy elevation_gradient)
cpdef double[:] rotate_on_sloped_plane(double[:] vector, <span class="org-builtin">float</span> theta, <span class="org-builtin">float</span> slope, <span class="org-builtin">float</span> aspect)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python" id="math-pxd"><span class="org-comment-delimiter">#</span><span class="org-comment">==================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">C functions to cimport into other modules</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==================================================</span>

cdef extern <span class="org-keyword">from</span> <span class="org-string">"math.h"</span>:
     cdef double sqrt(double x)
     cdef double sin(double x)
     cdef double cos(double x)
     cdef double tan(double x)
     cdef double atan(double x)
     cdef double atan2(double y, double x)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python" id="cy-types-pxd"><span class="org-comment-delimiter">#</span><span class="org-comment">==================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Type aliases</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==================================================</span>

ctypedef Py_ssize_t pyidx
ctypedef (<span class="org-builtin">float</span>, <span class="org-builtin">float</span>) vec_xy
ctypedef (<span class="org-builtin">float</span>, <span class="org-builtin">float</span>, <span class="org-builtin">float</span>) vec_xyz
ctypedef (pyidx, pyidx) coord_yx
ctypedef (pyidx, pyidx, pyidx) coord_tyx
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python" id="py-types-py"><span class="org-keyword">import</span> cython <span class="org-keyword">as</span> cy

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Runtime-defined type aliases</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

<span class="org-variable-name">pyidx</span>     <span class="org-operator">=</span> cy.typedef(cy.Py_ssize_t)
<span class="org-variable-name">vec_xy</span>    <span class="org-operator">=</span> cy.typedef(<span class="org-builtin">tuple</span>[cy.<span class="org-builtin">float</span>, cy.<span class="org-builtin">float</span>])
<span class="org-variable-name">vec_xyz</span>   <span class="org-operator">=</span> cy.typedef(<span class="org-builtin">tuple</span>[cy.<span class="org-builtin">float</span>, cy.<span class="org-builtin">float</span>, cy.<span class="org-builtin">float</span>])
<span class="org-variable-name">coord_yx</span>  <span class="org-operator">=</span> cy.typedef(<span class="org-builtin">tuple</span>[pyidx, pyidx])
<span class="org-variable-name">coord_tyx</span> <span class="org-operator">=</span> cy.typedef(<span class="org-builtin">tuple</span>[pyidx, pyidx, pyidx])
</pre>
</div>
</div>
</div>
<div id="outline-container-spacetimecube-and-lazyspacetimecube-tests-(pyretechnics_test.test_space_time_cube)" class="outline-3">
<h3 id="spacetimecube-and-lazyspacetimecube-tests-(pyretechnics_test.test_space_time_cube)"><span class="section-number-3">10.3.</span> SpaceTimeCube and LazySpaceTimeCube Tests (pyretechnics_test.test_space_time_cube)</h3>
<div class="outline-text-3" id="text-spacetimecube-and-lazyspacetimecube-tests-(pyretechnics_test.test_space_time_cube)">
<div class="org-src-container">
<pre class="src src-python" id="test-space-time-cube"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube, LazySpaceTimeCube

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Raw Data - Managed by the Caller</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">2D Arrays (e.g. 30m x 30m resolution, 30km x 30km extent)</span>
<span class="org-variable-name">elevation_layer</span>                    <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">slope_layer</span>                        <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">aspect_layer</span>                       <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">fuel_model_layer</span>                   <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">canopy_cover_layer</span>                 <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">canopy_height_layer</span>                <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">canopy_base_height_layer</span>           <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">canopy_bulk_density_layer</span>          <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">fuel_spread_adjustment_layer</span>       <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000) <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>
<span class="org-variable-name">suppression_difficulty_index_layer</span> <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000) <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">3D Arrays (e.g. 1hr x 300m x 300m resolution, 1day x 30km x 30km extent)</span>
<span class="org-variable-name">temperature_layer</span>                   <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">relative_humidity_layer</span>             <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">wind_speed_10m_layer</span>                <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">upwind_direction_layer</span>              <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">fuel_moisture_dead_1hr_layer</span>        <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">fuel_moisture_dead_10hr_layer</span>       <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">fuel_moisture_dead_100hr_layer</span>      <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">fuel_moisture_live_herbaceous_layer</span> <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">fuel_moisture_live_woody_layer</span>      <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">foliar_moisture_layer</span>               <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">weather_spread_adjustment_layer</span>     <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100) <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube Dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (
    24,   <span class="org-comment-delimiter"># </span><span class="org-comment">bands: 1 day @ 1 hour/band</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">rows:  30 km @ 30 meters/row</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">cols:  30 km @ 30 meters/col</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Create the Dictionary of Layer Names to SpaceTimeCubes</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

<span class="org-keyword">def</span> <span class="org-function-name">test_make_layer_lookup</span>():
    <span class="org-variable-name">layer_lookup</span> <span class="org-operator">=</span> {
        <span class="org-comment-delimiter"># </span><span class="org-comment">2D Arrays (e.g. 30m x 30m resolution, 30km x 30km extent)</span>
        <span class="org-string">"elevation"</span>                    : SpaceTimeCube(cube_shape, elevation_layer),
        <span class="org-string">"slope"</span>                        : SpaceTimeCube(cube_shape, slope_layer),
        <span class="org-string">"aspect"</span>                       : SpaceTimeCube(cube_shape, aspect_layer),
        <span class="org-string">"fuel_model"</span>                   : SpaceTimeCube(cube_shape, fuel_model_layer),
        <span class="org-string">"canopy_cover"</span>                 : SpaceTimeCube(cube_shape, canopy_cover_layer),
        <span class="org-string">"canopy_height"</span>                : SpaceTimeCube(cube_shape, canopy_height_layer),
        <span class="org-string">"canopy_base_height"</span>           : SpaceTimeCube(cube_shape, canopy_base_height_layer),
        <span class="org-string">"canopy_bulk_density"</span>          : SpaceTimeCube(cube_shape, canopy_bulk_density_layer),
        <span class="org-string">"fuel_spread_adjustment"</span>       : SpaceTimeCube(cube_shape, fuel_spread_adjustment_layer),       <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>
        <span class="org-string">"suppression_difficulty_index"</span> : SpaceTimeCube(cube_shape, suppression_difficulty_index_layer), <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">3D Arrays (e.g. 1hr x 300m x 300m resolution, 1day x 30km x 30km extent)</span>
        <span class="org-string">"temperature"</span>                  : SpaceTimeCube(cube_shape, temperature_layer),
        <span class="org-string">"relative_humidity"</span>            : SpaceTimeCube(cube_shape, relative_humidity_layer),
        <span class="org-string">"wind_speed_10m"</span>               : SpaceTimeCube(cube_shape, wind_speed_10m_layer),
        <span class="org-string">"upwind_direction"</span>             : SpaceTimeCube(cube_shape, upwind_direction_layer),
        <span class="org-string">"fuel_moisture_dead_1hr"</span>       : SpaceTimeCube(cube_shape, fuel_moisture_dead_1hr_layer),
        <span class="org-string">"fuel_moisture_dead_10hr"</span>      : SpaceTimeCube(cube_shape, fuel_moisture_dead_10hr_layer),
        <span class="org-string">"fuel_moisture_dead_100hr"</span>     : SpaceTimeCube(cube_shape, fuel_moisture_dead_100hr_layer),
        <span class="org-string">"fuel_moisture_live_herbaceous"</span>: SpaceTimeCube(cube_shape, fuel_moisture_live_herbaceous_layer),
        <span class="org-string">"fuel_moisture_live_woody"</span>     : SpaceTimeCube(cube_shape, fuel_moisture_live_woody_layer),
        <span class="org-string">"foliar_moisture"</span>              : SpaceTimeCube(cube_shape, foliar_moisture_layer),
        <span class="org-string">"weather_spread_adjustment"</span>    : SpaceTimeCube(cube_shape, weather_spread_adjustment_layer),    <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>
    }
    <span class="org-keyword">assert</span> <span class="org-builtin">all</span>(<span class="org-builtin">map</span>(<span class="org-keyword">lambda</span> cube: <span class="org-builtin">isinstance</span>(cube.data, np.ndarray), layer_lookup.values()))
    <span class="org-keyword">return</span> layer_lookup

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Looking Up Values in the Layers</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

<span class="org-keyword">def</span> <span class="org-function-name">test_use_layer_lookup_2d</span>():
    <span class="org-variable-name">layer_lookup</span> <span class="org-operator">=</span> test_make_layer_lookup()
    <span class="org-variable-name">dem_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"elevation"</span>].get(0,100,100)
    <span class="org-variable-name">slp_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"slope"</span>].get(0,100,100)
    <span class="org-variable-name">asp_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"aspect"</span>].get(0,100,100)
    <span class="org-variable-name">fbfm_100_100</span> <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_model"</span>].get(0,100,100)
    <span class="org-variable-name">cc_100_100</span>   <span class="org-operator">=</span> layer_lookup[<span class="org-string">"canopy_cover"</span>].get(0,100,100)
    <span class="org-variable-name">ch_100_100</span>   <span class="org-operator">=</span> layer_lookup[<span class="org-string">"canopy_height"</span>].get(0,100,100)
    <span class="org-variable-name">cbh_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"canopy_base_height"</span>].get(0,100,100)
    <span class="org-variable-name">cbd_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"canopy_bulk_density"</span>].get(0,100,100)
    <span class="org-variable-name">fsa_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_spread_adjustment"</span>].get(0,100,100)           <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>
    <span class="org-variable-name">sdi_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"suppression_difficulty_index"</span>].get(0,100,100)     <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>
    <span class="org-keyword">assert</span> dem_100_100  <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> slp_100_100  <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> asp_100_100  <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> fbfm_100_100 <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> cc_100_100   <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> ch_100_100   <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> cbh_100_100  <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> cbd_100_100  <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> fsa_100_100  <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> sdi_100_100  <span class="org-operator">==</span> 100100


<span class="org-keyword">def</span> <span class="org-function-name">test_use_layer_lookup_3d</span>():
    <span class="org-variable-name">layer_lookup</span>     <span class="org-operator">=</span> test_make_layer_lookup()
    <span class="org-variable-name">temp_12_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"temperature"</span>].get(12,100,100)
    <span class="org-variable-name">rh_12_100_100</span>    <span class="org-operator">=</span> layer_lookup[<span class="org-string">"relative_humidity"</span>].get(12,100,100)
    <span class="org-variable-name">wsp_12_100_100</span>   <span class="org-operator">=</span> layer_lookup[<span class="org-string">"wind_speed_10m"</span>].get(12,100,100)
    <span class="org-variable-name">wdir_12_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"upwind_direction"</span>].get(12,100,100)
    <span class="org-variable-name">md1_12_100_100</span>   <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_moisture_dead_1hr"</span>].get(12,100,100)
    <span class="org-variable-name">md10_12_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_moisture_dead_10hr"</span>].get(12,100,100)
    <span class="org-variable-name">md100_12_100_100</span> <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_moisture_dead_100hr"</span>].get(12,100,100)
    <span class="org-variable-name">mlh_12_100_100</span>   <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_moisture_live_herbaceous"</span>].get(12,100,100)
    <span class="org-variable-name">mlw_12_100_100</span>   <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_moisture_live_woody"</span>].get(12,100,100)
    <span class="org-variable-name">fm_12_100_100</span>    <span class="org-operator">=</span> layer_lookup[<span class="org-string">"foliar_moisture"</span>].get(12,100,100)
    <span class="org-variable-name">wsa_12_100_100</span>   <span class="org-operator">=</span> layer_lookup[<span class="org-string">"weather_spread_adjustment"</span>].get(12,100,100) <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>
    <span class="org-keyword">assert</span> temp_12_100_100  <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> rh_12_100_100    <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> wsp_12_100_100   <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> wdir_12_100_100  <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> md1_12_100_100   <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> md10_12_100_100  <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> md100_12_100_100 <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> mlh_12_100_100   <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> mlw_12_100_100   <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> fm_12_100_100    <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> wsa_12_100_100   <span class="org-operator">==</span> 121010
</pre>
</div>
</div>
</div>
<div id="outline-container-loading-landfire-inputs-(pyretechnics.load_landfire)" class="outline-3">
<h3 id="loading-landfire-inputs-(pyretechnics.load_landfire)"><span class="section-number-3">10.4.</span> Loading LANDFIRE Inputs (pyretechnics.load_landfire)</h3>
<div class="outline-text-3" id="text-loading-landfire-inputs-(pyretechnics.load_landfire)">
<p>
In order to use the functions from <code>pyretechnics.burn_cells</code> (see
section <a href="#burning-cells-on-a-grid-(pyretechnics.burn_cells)">8</a>), we must
first create a collection of <code>SpaceTimeCube</code> objects, representing all
of the input layers that are needed to describe the simulation
environment. A popular source of data for the space-varying
topography, fuels, and vegetation layers are the 30m raster layers
provided by the US LANDFIRE program<sup><a id="fnr.59" class="footref" href="#fn.59" role="doc-backlink">59</a></sup> (see
table <a href="#tab:landfire-layers">11</a> for details).
</p>

<table id="tab:landfire-layers">
<caption class="t-above"><span class="table-number">Table 11:</span> 2022 LANDFIRE Raster Layers</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Layer Name</th>
<th scope="col" class="org-left">Label</th>
<th scope="col" class="org-left">Units</th>
<th scope="col" class="org-right">Min</th>
<th scope="col" class="org-right">Max</th>
<th scope="col" class="org-right">NoData</th>
<th scope="col" class="org-left">Notes</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">SRID</th>
<th scope="col" class="org-left">Cell Size</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Elevation</td>
<td class="org-left">DEM</td>
<td class="org-left">meters above sea level</td>
<td class="org-right">0</td>
<td class="org-right">8850</td>
<td class="org-right">32767</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Slope</td>
<td class="org-left">SLP</td>
<td class="org-left">percent (100 * meters rise / meters run)</td>
<td class="org-right">0</td>
<td class="org-right">400</td>
<td class="org-right">32767</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Aspect</td>
<td class="org-left">ASP</td>
<td class="org-left">degrees CW from North</td>
<td class="org-right">0</td>
<td class="org-right">359</td>
<td class="org-right">32767</td>
<td class="org-left">-1 = no slope</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Fuel Model (S&amp;B 40)</td>
<td class="org-left">FBFM40</td>
<td class="org-left">integer classes</td>
<td class="org-right">91</td>
<td class="org-right">204</td>
<td class="org-right">32767</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Canopy Cover</td>
<td class="org-left">CC</td>
<td class="org-left">percent (100 * canopy area / total area)</td>
<td class="org-right">0</td>
<td class="org-right">95</td>
<td class="org-right">32767</td>
<td class="org-left">0 = no canopy</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Canopy Height</td>
<td class="org-left">CH</td>
<td class="org-left">meters * 10</td>
<td class="org-right">0</td>
<td class="org-right">510</td>
<td class="org-right">32767</td>
<td class="org-left">0 = no canopy</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Canopy Base Height</td>
<td class="org-left">CBH</td>
<td class="org-left">meters * 10</td>
<td class="org-right">0</td>
<td class="org-right">100</td>
<td class="org-right">32767</td>
<td class="org-left">0 = no canopy</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Canopy Bulk Density</td>
<td class="org-left">CBD</td>
<td class="org-left">kg/m^3 * 100</td>
<td class="org-right">0</td>
<td class="org-right">45</td>
<td class="org-right">32767</td>
<td class="org-left">0 = no canopy</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>
</tbody>
</table>

<p>
For convenience, this section introduces functionality to load these
raster layers from files on disk into a Python dictionary of
<code>SpaceTimeCube</code> objects.
</p>
</div>
<div id="outline-container-loading-raster-files-with-python-rasterio" class="outline-4">
<h4 id="loading-raster-files-with-python-rasterio"><span class="section-number-4">10.4.1.</span> Loading Raster Files with Python Rasterio</h4>
<div class="outline-text-4" id="text-loading-raster-files-with-python-rasterio">
<p>
We will begin by defining a <code>load_raster</code> function that takes a path
to a raster file (e.g., a GeoTIFF) and returns a dictionary containing
these keys:
</p>

<dl class="org-dl">
<dt>array</dt><dd>raster data as a 3D Numpy array <code>(bands, rows, cols)</code> of the specified <code>dtype</code> (default: <code>float32</code>)</dd>
<dt>metadata</dt><dd>dictionary of raster metadata values (e.g., number of bands/rows/cols, band dtypes, nodata value, georeferencing info)</dd>
</dl>

<div class="org-src-container">
<pre class="src src-python" id="load-raster"><span class="org-keyword">import</span> rasterio


<span class="org-keyword">def</span> <span class="org-function-name">raster_metadata</span>(raster):
    <span class="org-keyword">return</span> {
        <span class="org-string">"name"</span>      : raster.name,
        <span class="org-string">"bands"</span>     : raster.count,
        <span class="org-string">"rows"</span>      : raster.height,
        <span class="org-string">"cols"</span>      : raster.width,
        <span class="org-string">"band_types"</span>: {i: dtype <span class="org-keyword">for</span> i, dtype <span class="org-keyword">in</span> <span class="org-builtin">zip</span>(raster.indexes, raster.dtypes)},
        <span class="org-string">"nodata"</span>    : raster.nodata,
        <span class="org-string">"crs"</span>       : raster.crs,
        <span class="org-string">"bounds"</span>    : raster.bounds,
        <span class="org-string">"transform"</span> : raster.transform,
    }


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: rasterio.open can also load chunks of a raster file: https://pypi.org/project/rasterio/</span>
<span class="org-keyword">def</span> <span class="org-function-name">load_raster</span>(file_path, dtype<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-keyword">with</span> rasterio.<span class="org-builtin">open</span>(file_path, <span class="org-string">"r"</span>) <span class="org-keyword">as</span> input_raster:
        <span class="org-keyword">return</span> {
            <span class="org-string">"array"</span>   : input_raster.read(out_dtype<span class="org-operator">=</span>dtype),
            <span class="org-string">"metadata"</span>: raster_metadata(input_raster),
        }
</pre>
</div>
</div>
</div>
<div id="outline-container-converting-landfire-units-and-datatypes" class="outline-4">
<h4 id="converting-landfire-units-and-datatypes"><span class="section-number-4">10.4.2.</span> Converting LANDFIRE Units and Datatypes</h4>
<div class="outline-text-4" id="text-converting-landfire-units-and-datatypes">
<p>
The units and datatypes of our LANDFIRE GeoTIFFs are documented in
Table <a href="#tab:landfire-layers">11</a>. In order to make them match those required
by the Pyretechnics Fire Spread API, we need to apply some conversions
during the layer loading process.
</p>

<div class="org-src-container">
<pre class="src src-python" id="load-and-convert-landfire-rasters"><span class="org-variable-name">landfire_array_conversions</span> <span class="org-operator">=</span> {
    <span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Layer Name         : (New dtype, Mult), # New Units                [Min-Max]</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================================</span>
    <span class="org-string">"elevation"</span>          : (<span class="org-string">"float32"</span>, 1.00), <span class="org-comment-delimiter"># </span><span class="org-comment">meters above sea level   [0-8850]</span>
    <span class="org-string">"slope"</span>              : (<span class="org-string">"float32"</span>, 0.01), <span class="org-comment-delimiter"># </span><span class="org-comment">meters rise / meters run [0-4]</span>
    <span class="org-string">"aspect"</span>             : (<span class="org-string">"int16"</span>  , 1   ), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees CW from North    [0-359]</span>
    <span class="org-string">"fuel_model"</span>         : (<span class="org-string">"int16"</span>  , 1   ), <span class="org-comment-delimiter"># </span><span class="org-comment">integer classes          [1-204]</span>
    <span class="org-string">"canopy_cover"</span>       : (<span class="org-string">"float32"</span>, 0.01), <span class="org-comment-delimiter"># </span><span class="org-comment">canopy area / total area [0-0.95]</span>
    <span class="org-string">"canopy_height"</span>      : (<span class="org-string">"float32"</span>, 0.10), <span class="org-comment-delimiter"># </span><span class="org-comment">meters                   [0-51]</span>
    <span class="org-string">"canopy_base_height"</span> : (<span class="org-string">"float32"</span>, 0.10), <span class="org-comment-delimiter"># </span><span class="org-comment">meters                   [0-10]</span>
    <span class="org-string">"canopy_bulk_density"</span>: (<span class="org-string">"float32"</span>, 0.01), <span class="org-comment-delimiter"># </span><span class="org-comment">kilograms/meters^3       [0-0.45]</span>
}


<span class="org-keyword">def</span> <span class="org-function-name">load_and_convert_landfire_rasters</span>(landfire_file_paths):
    <span class="org-variable-name">landfire_rasters</span> <span class="org-operator">=</span> {}

    <span class="org-keyword">for</span> name, path <span class="org-keyword">in</span> landfire_file_paths.items():
        (<span class="org-variable-name">dtype</span>, <span class="org-variable-name">multiplier</span>) <span class="org-operator">=</span> landfire_array_conversions[name]
        <span class="org-variable-name">landfire_rasters</span>[name] <span class="org-operator">=</span> load_raster(path, dtype)
        <span class="org-keyword">if</span> multiplier <span class="org-operator">!=</span> 1:
            <span class="org-variable-name">array</span>  <span class="org-operator">=</span> landfire_rasters[name][<span class="org-string">"array"</span>]
            <span class="org-variable-name">nodata</span> <span class="org-operator">=</span> landfire_rasters[name][<span class="org-string">"metadata"</span>][<span class="org-string">"nodata"</span>]
            <span class="org-variable-name">array</span>[array <span class="org-operator">!=</span> nodata] <span class="org-operator">*=</span> multiplier

    <span class="org-keyword">return</span> landfire_rasters
</pre>
</div>
</div>
</div>
<div id="outline-container-verifying-raster-constraints" class="outline-4">
<h4 id="verifying-raster-constraints"><span class="section-number-4">10.4.3.</span> Verifying Raster Constraints</h4>
<div class="outline-text-4" id="text-verifying-raster-constraints">
<p>
In order to work with the Pyretechnics Fire Spread API, all rasters
must meet certain requirements:
</p>

<ol class="org-ol">
<li>All rasters must have array shapes <code>(bands, rows, cols)</code> that evenly divide a user-specified space-time cube shape <code>(t,y,x)</code>.</li>
<li>All rasters must share the same spatial extent and projection.</li>
</ol>

<p>
Below we implement functions to check these constraints:
</p>

<div class="org-src-container">
<pre class="src src-python" id="verify-raster-constraints"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np


<span class="org-keyword">def</span> <span class="org-function-name">verify_cube_compatible_dimensions</span>(cube_shape, rasters):
    <span class="org-variable-name">cube_shape_</span> <span class="org-operator">=</span> np.asarray(cube_shape)
    <span class="org-keyword">for</span> r <span class="org-keyword">in</span> rasters:
        <span class="org-variable-name">raster_shape</span> <span class="org-operator">=</span> np.asarray((r[<span class="org-string">"metadata"</span>][<span class="org-string">"bands"</span>],
                                   r[<span class="org-string">"metadata"</span>][<span class="org-string">"rows"</span>],
                                   r[<span class="org-string">"metadata"</span>][<span class="org-string">"cols"</span>]))
        <span class="org-keyword">if</span> <span class="org-builtin">any</span>(<span class="org-builtin">map</span>(<span class="org-keyword">lambda</span> x: x <span class="org-operator">!=</span> 0, cube_shape_ <span class="org-operator">%</span> raster_shape)):
            <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"Some rasters do not evenly divide the space-time cube dimensions."</span>)

    <span class="org-keyword">return</span> <span class="org-constant">True</span>


<span class="org-keyword">def</span> <span class="org-function-name">verify_same_georeferences</span>(rasters):
    <span class="org-variable-name">georeferences</span> <span class="org-operator">=</span> [
        (r[<span class="org-string">"metadata"</span>][<span class="org-string">"crs"</span>],
         r[<span class="org-string">"metadata"</span>][<span class="org-string">"bounds"</span>],
         r[<span class="org-string">"metadata"</span>][<span class="org-string">"transform"</span>])
        <span class="org-keyword">for</span> r <span class="org-keyword">in</span> rasters
    ]
    <span class="org-keyword">if</span> <span class="org-builtin">len</span>(<span class="org-builtin">set</span>(georeferences)) <span class="org-operator">==</span> 1:
        <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">else</span>:
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"All rasters do not share the same georeferences."</span>)


<span class="org-keyword">def</span> <span class="org-function-name">verify_raster_constraints</span>(cube_shape, rasters):
    <span class="org-keyword">return</span> verify_cube_compatible_dimensions(cube_shape, rasters) <span class="org-keyword">and</span> verify_same_georeferences(rasters)
</pre>
</div>
</div>
</div>
<div id="outline-container-converting-rasters-to-spacetimecubes" class="outline-4">
<h4 id="converting-rasters-to-spacetimecubes"><span class="section-number-4">10.4.4.</span> Converting Rasters to SpaceTimeCubes</h4>
<div class="outline-text-4" id="text-converting-rasters-to-spacetimecubes">
<p>
Another requirement of the Pyretechnics Fire Spread API is that each
input layer must be specified as a <code>SpaceTimeCube</code> or
<code>LazySpaceTimeCube</code> object (see section <a href="#loading-data-into-the-3d-space-time-cube-(pyretechnics.space_time_cube)">3</a>). This abstracts away
the underlying data representation (e.g., an ND array, a single
constant value, a random sampling function), allowing many different
sources of information to interoperate through a simple unified
interface.
</p>

<p>
For our LANDFIRE use case, the following function converts a
dictionary of single-band rasters <code>(1, rows, cols)</code> into a dictionary
of <code>SpaceTimeCube</code> objects, that always return the same value for each
<code>(t,y,x)</code> coordinate regardless of the time value <code>t</code> specified in
lookup calls.
</p>

<div class="org-src-container">
<pre class="src src-python" id="convert-rasters-to-space-time-cubes"><span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube


<span class="org-keyword">def</span> <span class="org-function-name">convert_rasters_to_space_time_cubes</span>(cube_shape, raster_dict):
    <span class="org-variable-name">fn_dict</span> <span class="org-operator">=</span> {}

    <span class="org-keyword">for</span> name, raster <span class="org-keyword">in</span> raster_dict.items():
        <span class="org-variable-name">fn_dict</span>[name] <span class="org-operator">=</span> SpaceTimeCube(cube_shape, raster[<span class="org-string">"array"</span>])

    <span class="org-keyword">return</span> fn_dict
</pre>
</div>
</div>
</div>
<div id="outline-container-putting-it-all-together" class="outline-4">
<h4 id="putting-it-all-together"><span class="section-number-4">10.4.5.</span> Putting It All Together</h4>
<div class="outline-text-4" id="text-putting-it-all-together">
<p>
By combining the functions defined in the previous sections, we can
now read in a dictionary of layer names to file paths, load the
associated rasters and apply the correct dtype and unit conversions,
verify all of our raster constraints, and wrap each raster's array
with a <code>SpaceTimeCube</code> object.
</p>

<div class="org-src-container">
<pre class="src src-python" id="read-landfire-rasters-as-space-time-cubes"><span class="org-keyword">def</span> <span class="org-function-name">read_landfire_rasters_as_space_time_cubes</span>(cube_shape, landfire_file_paths):
    <span class="org-variable-name">landfire_rasters</span> <span class="org-operator">=</span> load_and_convert_landfire_rasters(landfire_file_paths)
    <span class="org-keyword">if</span> verify_raster_constraints(cube_shape, landfire_rasters.values()):
        <span class="org-keyword">return</span> convert_rasters_to_space_time_cubes(cube_shape, landfire_rasters)
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://en.wikipedia.org/wiki/Literate_programming">https://en.wikipedia.org/wiki/Literate_programming</a></p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://guix.gnu.org">https://guix.gnu.org</a></p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://landfire.gov">https://landfire.gov</a></p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://www.nco.ncep.noaa.gov/pmb/products/rtma/">https://www.nco.ncep.noaa.gov/pmb/products/rtma/</a></p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5" role="doc-backlink">5</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Anderson1982</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6" role="doc-backlink">6</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Scott2005</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7" role="doc-backlink">7</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Burgan1979</p></div></div>

<div class="footdef"><sup><a id="fn.8" class="footnum" href="#fnr.8" role="doc-backlink">8</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Rothermel1972</p></div></div>

<div class="footdef"><sup><a id="fn.9" class="footnum" href="#fnr.9" role="doc-backlink">9</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Rothermel1972</p></div></div>

<div class="footdef"><sup><a id="fn.10" class="footnum" href="#fnr.10" role="doc-backlink">10</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1976</p></div></div>

<div class="footdef"><sup><a id="fn.11" class="footnum" href="#fnr.11" role="doc-backlink">11</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Rothermel1972</p></div></div>

<div class="footdef"><sup><a id="fn.12" class="footnum" href="#fnr.12" role="doc-backlink">12</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1976</p></div></div>

<div class="footdef"><sup><a id="fn.13" class="footnum" href="#fnr.13" role="doc-backlink">13</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Andrews2018</p></div></div>

<div class="footdef"><sup><a id="fn.14" class="footnum" href="#fnr.14" role="doc-backlink">14</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Anderson1969</p></div></div>

<div class="footdef"><sup><a id="fn.15" class="footnum" href="#fnr.15" role="doc-backlink">15</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Byram1959</p></div></div>

<div class="footdef"><sup><a id="fn.16" class="footnum" href="#fnr.16" role="doc-backlink">16</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">AndrewsRothermel1982</p></div></div>

<div class="footdef"><sup><a id="fn.17" class="footnum" href="#fnr.17" role="doc-backlink">17</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1976</p></div></div>

<div class="footdef"><sup><a id="fn.18" class="footnum" href="#fnr.18" role="doc-backlink">18</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1979</p></div></div>

<div class="footdef"><sup><a id="fn.19" class="footnum" href="#fnr.19" role="doc-backlink">19</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Andrews2012</p></div></div>

<div class="footdef"><sup><a id="fn.20" class="footnum" href="#fnr.20" role="doc-backlink">20</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Rothermel1983</p></div></div>

<div class="footdef"><sup><a id="fn.21" class="footnum" href="#fnr.21" role="doc-backlink">21</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Waeselynck2024</p></div></div>

<div class="footdef"><sup><a id="fn.22" class="footnum" href="#fnr.22" role="doc-backlink">22</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1980</p></div></div>

<div class="footdef"><sup><a id="fn.23" class="footnum" href="#fnr.23" role="doc-backlink">23</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Rothermel1991</p></div></div>

<div class="footdef"><sup><a id="fn.24" class="footnum" href="#fnr.24" role="doc-backlink">24</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://github.com/firelab/behave/blob/00b90853182031c9e22e33f22bb0ac497bad9415/src/behave/fireSize.cpp#L93">https://github.com/firelab/behave/blob/00b90853182031c9e22e33f22bb0ac497bad9415/src/behave/fireSize.cpp#L93</a></p></div></div>

<div class="footdef"><sup><a id="fn.25" class="footnum" href="#fnr.25" role="doc-backlink">25</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Rothermel1972</p></div></div>

<div class="footdef"><sup><a id="fn.26" class="footnum" href="#fnr.26" role="doc-backlink">26</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Andrews2013</p></div></div>

<div class="footdef"><sup><a id="fn.27" class="footnum" href="#fnr.27" role="doc-backlink">27</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">VanWagner1977</p></div></div>

<div class="footdef"><sup><a id="fn.28" class="footnum" href="#fnr.28" role="doc-backlink">28</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Cruz2005</p></div></div>

<div class="footdef"><sup><a id="fn.29" class="footnum" href="#fnr.29" role="doc-backlink">29</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">VanWagner1977</p></div></div>

<div class="footdef"><sup><a id="fn.30" class="footnum" href="#fnr.30" role="doc-backlink">30</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Cruz2005</p></div></div>

<div class="footdef"><sup><a id="fn.31" class="footnum" href="#fnr.31" role="doc-backlink">31</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Rothermel1991</p></div></div>

<div class="footdef"><sup><a id="fn.32" class="footnum" href="#fnr.32" role="doc-backlink">32</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1980</p></div></div>

<div class="footdef"><sup><a id="fn.33" class="footnum" href="#fnr.33" role="doc-backlink">33</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Waeselynck2024</p></div></div>

<div class="footdef"><sup><a id="fn.34" class="footnum" href="#fnr.34" role="doc-backlink">34</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Perryman2012</p></div></div>

<div class="footdef"><sup><a id="fn.35" class="footnum" href="#fnr.35" role="doc-backlink">35</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Sardoy2008</p></div></div>

<div class="footdef"><sup><a id="fn.36" class="footnum" href="#fnr.36" role="doc-backlink">36</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Himoto2005</p></div></div>

<div class="footdef"><sup><a id="fn.37" class="footnum" href="#fnr.37" role="doc-backlink">37</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Sardoy2008</p></div></div>

<div class="footdef"><sup><a id="fn.38" class="footnum" href="#fnr.38" role="doc-backlink">38</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://elmfire.io">https://elmfire.io</a></p></div></div>

<div class="footdef"><sup><a id="fn.39" class="footnum" href="#fnr.39" role="doc-backlink">39</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Perryman2012</p></div></div>

<div class="footdef"><sup><a id="fn.40" class="footnum" href="#fnr.40" role="doc-backlink">40</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Himoto2005</p></div></div>

<div class="footdef"><sup><a id="fn.41" class="footnum" href="#fnr.41" role="doc-backlink">41</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Sardoy2008</p></div></div>

<div class="footdef"><sup><a id="fn.42" class="footnum" href="#fnr.42" role="doc-backlink">42</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Sardoy2008</p></div></div>

<div class="footdef"><sup><a id="fn.43" class="footnum" href="#fnr.43" role="doc-backlink">43</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Himoto2005</p></div></div>

<div class="footdef"><sup><a id="fn.44" class="footnum" href="#fnr.44" role="doc-backlink">44</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Sardoy2008</p></div></div>

<div class="footdef"><sup><a id="fn.45" class="footnum" href="#fnr.45" role="doc-backlink">45</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Himoto2005</p></div></div>

<div class="footdef"><sup><a id="fn.46" class="footnum" href="#fnr.46" role="doc-backlink">46</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Sardoy2008</p></div></div>

<div class="footdef"><sup><a id="fn.47" class="footnum" href="#fnr.47" role="doc-backlink">47</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Himoto2005</p></div></div>

<div class="footdef"><sup><a id="fn.48" class="footnum" href="#fnr.48" role="doc-backlink">48</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Perryman2012</p></div></div>

<div class="footdef"><sup><a id="fn.49" class="footnum" href="#fnr.49" role="doc-backlink">49</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Schroeder1969</p></div></div>

<div class="footdef"><sup><a id="fn.50" class="footnum" href="#fnr.50" role="doc-backlink">50</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1979</p></div></div>

<div class="footdef"><sup><a id="fn.51" class="footnum" href="#fnr.51" role="doc-backlink">51</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Stauffer2008</p></div></div>

<div class="footdef"><sup><a id="fn.52" class="footnum" href="#fnr.52" role="doc-backlink">52</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Perryman2012</p></div></div>

<div class="footdef"><sup><a id="fn.53" class="footnum" href="#fnr.53" role="doc-backlink">53</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1979spot</p></div></div>

<div class="footdef"><sup><a id="fn.54" class="footnum" href="#fnr.54" role="doc-backlink">54</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">McAlpine1991</p></div></div>

<div class="footdef"><sup><a id="fn.55" class="footnum" href="#fnr.55" role="doc-backlink">55</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1979spot</p></div></div>

<div class="footdef"><sup><a id="fn.56" class="footnum" href="#fnr.56" role="doc-backlink">56</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1979spot</p></div></div>

<div class="footdef"><sup><a id="fn.57" class="footnum" href="#fnr.57" role="doc-backlink">57</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1979spot</p></div></div>

<div class="footdef"><sup><a id="fn.58" class="footnum" href="#fnr.58" role="doc-backlink">58</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://elmfire.io">https://elmfire.io</a></p></div></div>

<div class="footdef"><sup><a id="fn.59" class="footnum" href="#fnr.59" role="doc-backlink">59</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://landfire.gov">https://landfire.gov</a></p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Gary W. Johnson, Valentin Waeselynck, Chris Lautenberger, David Saah</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
