<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Pyretechnics Fire Behavior Library</title>
<meta name="author" content="Gary W. Johnson, Valentin Waeselynck, Chris Lautenberger, David Saah" />
<meta name="description" content="A Python library for simulating fire behavior in a variety of ways." />
<meta name="keywords" content="pyretechnics fire behavior model python library pyregence pyrecast" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="pyretechnics-base.css" />
<link rel="stylesheet" type="text/css" href="pyretechnics-custom.css" />

<script src="org-info.js">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
// @license-end
</script>

<script>
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
org_html_manager.set("TOC_DEPTH", "3");
org_html_manager.set("LINK_HOME", "");
org_html_manager.set("LINK_UP", "");
org_html_manager.set("LOCAL_TOC", "1");
org_html_manager.set("VIEW_BUTTONS", "0");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "1");
org_html_manager.set("VIEW", "info");
org_html_manager.setup();  // activate after the parameters are set
// @license-end
</script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">The Pyretechnics Fire Behavior Library
<br>
<span class="subtitle">Copyright Â© 2023-2025 Spatial Informatics Group, LLC</span>
</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#preface">1. Preface</a></li>
<li><a href="#data-model">2. Data Model</a>
<ul>
<li><a href="#working-in-a-3d-space-time-cube">2.1. Working in a 3D Space-Time Cube</a></li>
<li><a href="#fires-as-conical-shapes-in-space-time">2.2. Fires as Conical Shapes in Space-Time</a></li>
<li><a href="#support-for-input-datasets-of-varying-dimensionality">2.3. Support for Input Datasets of Varying Dimensionality</a></li>
<li><a href="#support-for-input-datasets-of-varying-resolution">2.4. Support for Input Datasets of Varying Resolution</a></li>
</ul>
</li>
<li><a href="#loading-data-into-the-3d-space-time-cube-(pyretechnics.space_time_cube)">3. Loading Data into the 3D Space-Time Cube (pyretechnics.space_time_cube)</a>
<ul>
<li><a href="#for-developers-spacetimecube">3.1. For Developers</a>
<ul>
<li><a href="#module-imports-space-time-cube">3.1.1. Module Imports</a></li>
<li><a href="#utility-functions-space-time-cube">3.1.2. Utility Functions</a></li>
<li><a href="#ispacetimecube-class">3.1.3. ISpaceTimeCube Class</a></li>
<li><a href="#spacetimecube-class">3.1.4. SpaceTimeCube Class</a></li>
<li><a href="#lazyspacetimecube-class">3.1.5. LazySpaceTimeCube Class</a></li>
</ul>
</li>
<li><a href="#for-users-spacetimecube">3.2. For Users</a>
<ul>
<li><a href="#how-to-use-spacetimecube">3.2.1. How to Use SpaceTimeCube</a></li>
<li><a href="#how-to-use-lazyspacetimecube">3.2.2. How to Use LazySpaceTimeCube</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#fuel-model-and-moisture-definitions-(pyretechnics.fuel_models)">4. Fuel Model and Moisture Definitions (pyretechnics.fuel_models)</a>
<ul>
<li><a href="#for-developers-fuel">4.1. For Developers</a>
<ul>
<li><a href="#module-imports-fuel-models">4.1.1. Module Imports</a></li>
<li><a href="#fuel-model-properties">4.1.2. Fuel Model Properties</a></li>
<li><a href="#fuel-model-definitions">4.1.3. Fuel Model Definitions</a></li>
<li><a href="#fuel-categories-and-size-classes">4.1.4. Fuel Categories and Size Classes</a></li>
<li><a href="#dynamic-fuel-loading">4.1.5. Dynamic Fuel Loading</a></li>
<li><a href="#size-class-weighting-factors">4.1.6. Size Class Weighting Factors</a></li>
<li><a href="#live-moisture-of-extinction">4.1.7. Live Moisture of Extinction</a></li>
<li><a href="#applying-fuel-moisture-to-a-fuel-model">4.1.8. Applying Fuel Moisture to a Fuel Model</a></li>
</ul>
</li>
<li><a href="#for-users-fuel">4.2. For Users</a>
<ul>
<li><a href="#how-to-look-up-a-fuel-model's-properties">4.2.1. How to Look Up a Fuel Model's Properties</a></li>
<li><a href="#how-to-apply-fuel-moisture-to-a-fuel-model">4.2.2. How to Apply Fuel Moisture to a Fuel Model</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#surface-fire-equations-(pyretechnics.surface_fire)">5. Surface Fire Equations (pyretechnics.surface_fire)</a>
<ul>
<li><a href="#for-developers-surface">5.1. For Developers</a>
<ul>
<li><a href="#module-imports-surface-fire">5.1.1. Module Imports</a></li>
<li><a href="#rothermel's-surface-fire-rate-of-spread-equation">5.1.2. Rothermel's Surface Fire Rate of Spread Equation</a></li>
<li><a href="#surface-fire-spread-rate-functions-(no-wind-no-slope)">5.1.3. Surface Fire Spread Rate Functions (No Wind No Slope)</a></li>
<li><a href="#surface-fire-intensity-functions">5.1.4. Surface Fire Intensity Functions</a></li>
<li><a href="#wind-and-slope-factor-functions">5.1.5. Wind and Slope Factor Functions</a></li>
<li><a href="#surface-fire-behavior-functions-(no-wind-no-slope)">5.1.6. Surface Fire Behavior Functions (No Wind No Slope)</a></li>
<li><a href="#midflame-wind-speed">5.1.7. Midflame Wind Speed</a></li>
<li><a href="#combining-wind-and-slope-vectors">5.1.8. Combining Wind and Slope Vectors</a></li>
<li><a href="#surface-elliptical-eccentricity">5.1.9. Surface Elliptical Eccentricity</a></li>
<li><a href="#surface-fire-behavior-in-the-direction-of-maximum-spread">5.1.10. Surface Fire Behavior in the Direction of Maximum Spread</a></li>
<li><a href="#surface-fire-behavior-in-any-direction">5.1.11. Surface Fire Behavior in Any Direction</a></li>
</ul>
</li>
<li><a href="#for-users-surface">5.2. For Users</a>
<ul>
<li><a href="#how-to-calculate-the-no-wind-no-slope-surface-fire-behavior">5.2.1. How to Calculate the No-Wind-No-Slope Surface Fire Behavior</a></li>
<li><a href="#how-to-translate-the-10m-wind-speed-vector-into-the-midflame-wind-speed-vector">5.2.2. How to Translate the 10m Wind Speed Vector into the Midflame Wind Speed Vector</a></li>
<li><a href="#how-to-calculate-the-surface-fire-behavior-in-the-direction-of-maximum-spread">5.2.3. How to Calculate the Surface Fire Behavior in the Direction of Maximum Spread</a></li>
<li><a href="#how-to-calculate-the-surface-fire-behavior-in-any-direction">5.2.4. How to Calculate the Surface Fire Behavior in Any Direction</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#crown-fire-equations-(pyretechnics.crown_fire)">6. Crown Fire Equations (pyretechnics.crown_fire)</a>
<ul>
<li><a href="#for-developers-crown">6.1. For Developers</a>
<ul>
<li><a href="#module-imports-crown-fire">6.1.1. Module Imports</a></li>
<li><a href="#crown-fire-initiation">6.1.2. Crown Fire Initiation</a></li>
<li><a href="#passive-and-active-crown-fire-spread-rate-functions">6.1.3. Passive and Active Crown Fire Spread Rate Functions</a></li>
<li><a href="#crown-fire-intensity-functions">6.1.4. Crown Fire Intensity Functions</a></li>
<li><a href="#crown-elliptical-eccentricity">6.1.5. Crown Elliptical Eccentricity</a></li>
<li><a href="#crown-fire-behavior-in-the-direction-of-maximum-spread">6.1.6. Crown Fire Behavior in the Direction of Maximum Spread</a></li>
<li><a href="#crown-fire-behavior-in-any-direction">6.1.7. Crown Fire Behavior in Any Direction</a></li>
<li><a href="#combining-surface-and-crown-fire-behavior">6.1.8. Combining Surface and Crown Fire Behavior</a></li>
</ul>
</li>
<li><a href="#for-users-crown">6.2. For Users</a>
<ul>
<li><a href="#how-to-determine-whether-a-surface-fire-transitions-to-a-crown-fire">6.2.1. How to Determine Whether a Surface Fire Transitions to a Crown Fire</a></li>
<li><a href="#how-to-calculate-the-crown-fire-behavior-in-the-direction-of-maximum-spread">6.2.2. How to Calculate the Crown Fire Behavior in the Direction of Maximum Spread</a></li>
<li><a href="#how-to-calculate-the-crown-fire-behavior-in-any-direction">6.2.3. How to Calculate the Crown Fire Behavior in Any Direction</a></li>
<li><a href="#how-to-calculate-the-combined-surface-and-crown-fire-behavior-in-any-direction">6.2.4. How to Calculate the Combined Surface and Crown Fire Behavior in Any Direction</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#spot-fire-equations-(pyretechnics.spot_fire)">7. Spot Fire Equations (pyretechnics.spot_fire)</a>
<ul>
<li><a href="#for-developers-spot">7.1. For Developers</a>
<ul>
<li><a href="#module-imports-spot-fire">7.1.1. Module Imports</a></li>
<li><a href="#expected-firebrand-production">7.1.2. Expected Firebrand Production</a></li>
<li><a href="#firebrand-dispersal-model">7.1.3. Firebrand Dispersal Model</a></li>
<li><a href="#resolution-of-log-normal-parameters">7.1.4. Resolution of Log-Normal Parameters</a></li>
<li><a href="#wind-perpendicular-dispersal">7.1.5. Wind-Perpendicular Dispersal</a></li>
<li><a href="#sampling-firebrand-casting-distances">7.1.6. Sampling Firebrand Casting Distances</a></li>
<li><a href="#spot-ignition-model">7.1.7. Spot Ignition Model</a></li>
<li><a href="#time-to-spot-ignition">7.1.8. Time to Spot Ignition</a></li>
<li><a href="#spreading-firebrands">7.1.9. Spreading Firebrands</a></li>
</ul>
</li>
<li><a href="#for-users-spot">7.2. For Users</a>
<ul>
<li><a href="#how-to-estimate-the-areal-heat-output-for-all-surface-fuel-models">7.2.1. How to Estimate the Areal Heat Output for All Surface Fuel Models</a></li>
<li><a href="#how-to-estimate-the-number-of-firebrands-cast-per-burned-cell">7.2.2. How to Estimate the Number of Firebrands Cast per Burned Cell</a></li>
<li><a href="#how-to-estimate-typical-ranges-for-the-$\vec{\delta}$-distribution-characteristics">7.2.3. How to Estimate Typical Ranges for the \(\vec{\Delta}\) Distribution Characteristics</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#burning-cells-on-a-grid-(pyretechnics.burn_cells)">8. Burning Cells on a Grid (pyretechnics.burn_cells)</a>
<ul>
<li><a href="#for-developers-burn-cells">8.1. For Developers</a>
<ul>
<li><a href="#module-imports-burn-cells">8.1.1. Module Imports</a></li>
<li><a href="#burn-cells-as-a-head-fire">8.1.2. Burn Cells as a Head Fire</a></li>
<li><a href="#burn-cells-in-any-direction">8.1.3. Burn Cells in Any Direction</a></li>
</ul>
</li>
<li><a href="#for-users-burn-cells">8.2. For Users</a>
<ul>
<li><a href="#how-to-burn-a-single-cell-as-a-head-fire">8.2.1. How to Burn a Single Cell as a Head Fire</a></li>
<li><a href="#how-to-burn-a-region-of-cells-as-a-head-fire">8.2.2. How to Burn a Region of Cells as a Head Fire</a></li>
<li><a href="#how-to-burn-a-single-cell-in-any-direction">8.2.3. How to Burn a Single Cell in Any Direction</a></li>
<li><a href="#how-to-burn-a-region-of-cells-in-any-direction">8.2.4. How to Burn a Region of Cells in Any Direction</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#fire-spread-algorithm:-eulerian-level-set-method-(pyretechnics.eulerian_level_set)">9. Fire Spread Algorithm (ELMFIRE): Eulerian Level Set Method (pyretechnics.eulerian_level_set)</a>
<ul>
<li><a href="#for-developers-fire-spread">9.1. For Developers</a>
<ul>
<li><a href="#module-imports-eulerian-level-set">9.1.1. Module Imports</a></li>
<li><a href="#the-$\phi$-field">9.1.2. The \(\phi\) Field</a></li>
<li><a href="#fire-front-normal-vector">9.1.3. Fire Front Normal Vector</a></li>
<li><a href="#numerical-solution-of-the-$\phi$-field-equation">9.1.4. Numerical Solution of the \(\phi\) Field Equation</a></li>
<li><a href="#calculate-the-surface/crown-fireline-normal-behavior">9.1.5. Calculate the Surface/Crown Fireline Normal Behavior</a></li>
<li><a href="#burn-cell-normal-to-the-fire-perimeter">9.1.6. Burn Cell Normal to the Fire Perimeter</a></li>
<li><a href="#identify-cells-near-the-fire-perimeter-($\phi-=-0$)">9.1.7. Identify Cells Near the Fire Perimeter (\(\phi = 0\))</a></li>
<li><a href="#spread-phi-field">9.1.8. Spread Phi Field</a></li>
</ul>
</li>
<li><a href="#for-users-fire-spread">9.2. For Users</a>
<ul>
<li><a href="#how-to-spread-a-fire-from-a-point-ignition">9.2.1. How to Spread a Fire from a Point Ignition</a></li>
<li><a href="#how-to-spread-a-fire-from-a-point-ignition-with-spotting-enabled">9.2.2. How to Spread a Fire from a Point Ignition with Spotting Enabled</a></li>
<li><a href="#how-to-spread-a-fire,-pause,-fork,-and-continue">9.2.3. How to Spread a Fire, Pause, Fork, and Continue</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#appendices">10. Appendices</a>
<ul>
<li><a href="#custom-types-(pyretechnics.py_types)">10.1. Custom Types (pyretechnics.py_types)</a></li>
<li><a href="#units-conversion-functions-(pyretechnics.conversion)">10.2. Units Conversion Functions (pyretechnics.conversion)</a></li>
<li><a href="#vector-utility-functions-(pyretechnics.vector_utils)">10.3. Vector Utility Functions (pyretechnics.vector_utils)</a></li>
<li><a href="#spacetimecube-and-lazyspacetimecube-tests-(pyretechnics_test.test_space_time_cube)">10.4. SpaceTimeCube and LazySpaceTimeCube Tests (pyretechnics_test.test_space_time_cube)</a></li>
<li><a href="#loading-landfire-inputs-(pyretechnics.load_landfire)">10.5. Loading LANDFIRE Inputs (pyretechnics.load_landfire)</a>
<ul>
<li><a href="#module-imports-load-landfire">10.5.1. Module Imports</a></li>
<li><a href="#loading-raster-files-with-python-rasterio">10.5.2. Loading Raster Files with Python Rasterio</a></li>
<li><a href="#converting-landfire-units-and-datatypes">10.5.3. Converting LANDFIRE Units and Datatypes</a></li>
<li><a href="#verifying-raster-constraints">10.5.4. Verifying Raster Constraints</a></li>
<li><a href="#converting-rasters-to-spacetimecubes">10.5.5. Converting Rasters to SpaceTimeCubes</a></li>
<li><a href="#putting-it-all-together">10.5.6. Putting It All Together</a></li>
</ul>
</li>
<li><a href="#cython-pxd-files">10.6. Cython PXD Files</a>
<ul>
<li><a href="#pyretechnics-cy-types-pxd">10.6.1. pyretechnics.cy_types</a></li>
<li><a href="#pyretechnics-conversion-pxd">10.6.2. pyretechnics.conversion</a></li>
<li><a href="#pyretechnics-vector-utils-pxd">10.6.3. pyretechnics.vector_utils</a></li>
<li><a href="#pyretechnics-random-pxd">10.6.4. pyretechnics.random</a></li>
<li><a href="#pyretechnics-space-time-cube-pxd">10.6.5. pyretechnics.space_time_cube</a></li>
<li><a href="#pyretechnics-fuel-models-pxd">10.6.6. pyretechnics.fuel_models</a></li>
<li><a href="#pyretechnics-surface-fire-pxd">10.6.7. pyretechnics.surface_fire</a></li>
<li><a href="#pyretechnics-crown-fire-pxd">10.6.8. pyretechnics.crown_fire</a></li>
<li><a href="#pyretechnics-spot-fire-pxd">10.6.9. pyretechnics.spot_fire</a></li>
<li><a href="#pyretechnics-burn-cells-pxd">10.6.10. pyretechnics.burn_cells</a></li>
<li><a href="#pyretechnics-narrow-band-tracking-pxd">10.6.11. pyretechnics.narrow_band_tracking</a></li>
<li><a href="#pyretechnics-eulerian-level-set-pxd">10.6.12. pyretechnics.eulerian_level_set</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-preface" class="outline-2">
<h2 id="preface"><span class="section-number-2">1.</span> Preface</h2>
<div class="outline-text-2" id="text-preface">
<p>
This document is a Literate
Program<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>,
containing both the source code of the software it describes as well
as the rationale used in each step of its design and implementation.
The purpose of this approach is to enable both programmers and
non-programmers alike to retrace the author's footsteps as they read
through the text and code. By the time they have reached the end of
this document, the reader should have just as strong a grasp of the
system as the original programmer.
</p>

<p>
The source code repository containing this document provides a
comprehensive reproducible development environment through the use of
the open source GNU Guix<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup> transactional
package manager. This tool will automatically install all the software
needed to tangle, detangle, weave, test, build, and install this
library on your machine without conflicting with the main package
manager of your operating system. See <a href="../README.md">README.md</a> for more details.
</p>
</div>
</div>

<div id="outline-container-data-model" class="outline-2">
<h2 id="data-model"><span class="section-number-2">2.</span> Data Model</h2>
<div class="outline-text-2" id="text-data-model">
</div>
<div id="outline-container-working-in-a-3d-space-time-cube" class="outline-3">
<h3 id="working-in-a-3d-space-time-cube"><span class="section-number-3">2.1.</span> Working in a 3D Space-Time Cube</h3>
<div class="outline-text-3" id="text-working-in-a-3d-space-time-cube">
<p>
In Pyretechnics, a fire is viewed as a three-dimensional event
occurring within a bounded region of space-time \((T,Y,X)\). In this
mental model, the environment in which a fire develops can be
visualized as a cube in which space is described in 2D by the \(X\) and
\(Y\) dimensions and time projects this 2D world into 3D along the \(T\)
dimension.
</p>

<p>
Note, in particular, that this is not the same thing as a
three-dimensional model of fire behavior that incorporates surface
elevation as the third dimension. Although terrain data (such as
elevation, slope, and aspect) and tree cover characteristics (such as
canopy height and canopy base height) are incorporated into the
implemented spread equations in order to determine the rate,
direction, and mode of fire spread, the outputs of the fire behavior
algorithms in Pyretechnics currently only use two dimensions to
describe spatial heterogeneity within the simulation environment. The
third dimension is instead reserved for temporal variations in the
model inputs and outputs.
</p>
</div>
</div>

<div id="outline-container-fires-as-conical-shapes-in-space-time" class="outline-3">
<h3 id="fires-as-conical-shapes-in-space-time"><span class="section-number-3">2.2.</span> Fires as Conical Shapes in Space-Time</h3>
<div class="outline-text-3" id="text-fires-as-conical-shapes-in-space-time">
<p>
All fire events begin from an ignition somewhere in space-time. As
combustion and propagation occur in burnable fuels, the burned area
(a.k.a "burn scar") of a fire spreads monotonically outward in space.
Viewed from the lens of our 3D space-time cube, these monotonically
expanding burn scars form conical solids within the simulation
environment, with the bottom point of the cone representing the
initial ignition point and the upper edge of the cone representing the
actively burning fire perimeter. Of course, we only expect idealized
fire cones to appear in environments with homogeneous topography,
weather, fuels, and fuel moisture. As these inputs become more
heterogenous throughout the burned region of space-time, these
idealized cones will become distorted in the directions of faster or
slower spread and their perimeters may become more finely dissected.
However, we use this conical shape description of fire events within
the simulated space-time cube to convey both their monotonically
increasing spatial area over time as well as to provide the foundation
for a more visually intuitive understanding of the effect of
temporally varying environmental conditions on the behavior (and thus
shape) of fires.
</p>
</div>
</div>

<div id="outline-container-support-for-input-datasets-of-varying-dimensionality" class="outline-3">
<h3 id="support-for-input-datasets-of-varying-dimensionality"><span class="section-number-3">2.3.</span> Support for Input Datasets of Varying Dimensionality</h3>
<div class="outline-text-3" id="text-support-for-input-datasets-of-varying-dimensionality">
<p>
At the beginning of a fire behavior simulation, our 3D space-time cube
will be populated with all of the information that describes the
environment and will remain effectively static as the fire event
unfolds. This includes (but is not limited to) topography, weather,
fuels, and fuel moisture. In many common simulation scenarios, we
expect that topography and fuels will probably vary in space but not
in time, and weather and fuel moisture may vary in both space and
time. However, we use "may" in these statements because the data model
within Pyretechnics is flexibly designed to allow any of these
environmental input variables to take on any of these forms:
</p>

<dl class="org-dl">
<dt>Constant</dt><dd>Constant in both space and time. <br>
<b>Ex</b>: A single constant foliar moisture value could be used over the
simulation area for the entire simulation duration.</dd>

<dt>Temporal</dt><dd>Constant in space but variable in time. <br>
<b>Ex</b>: An hourly sequence of spread rate adjustment factors could be
used to globally ramp up and down fire spread rates throughout a
day/night cycle, creating burn periods of arbitrary length and
intensity.</dd>

<dt>Spatial</dt><dd>Variable in space but constant in time. <br>
<b>Ex</b>: A raster layer downloaded from
LANDFIRE<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup> can be used to specify the
spatial distribution of FBFM40 fuel model values on a landscape.</dd>

<dt>Spatio-temporal</dt><dd>Variable in both space and time. <br>
<b>Ex</b>: Hourly
RTMA<sup><a id="fnr.4" class="footref" href="#fn.4" role="doc-backlink">4</a></sup> weather
data can be loaded from a multi-band raster and used to specify the
spatio-temporal distribution of wind speed and direction throughout
the simulation domain.</dd>
</dl>

<p>
This is accomplished by representing each such input value as an
abstract datatype with a set of 3D space-time lookup functions for
accessing its values within 0D, 1D, 2D, and 3D slices of the
space-time cube at the simulation resolution. Such lookups should
always be referentially transparent, so as to ensure that subsequent
lookups with the same coordinate will always yield the same values.
See section <a href="#loading-data-into-the-3d-space-time-cube-(pyretechnics.space_time_cube)">3</a> for implementation details.
</p>
</div>
</div>

<div id="outline-container-support-for-input-datasets-of-varying-resolution" class="outline-3">
<h3 id="support-for-input-datasets-of-varying-resolution"><span class="section-number-3">2.4.</span> Support for Input Datasets of Varying Resolution</h3>
<div class="outline-text-3" id="text-support-for-input-datasets-of-varying-resolution">
<p>
Even when dimensions are the same between input datasets, they may be
provided at different resolutions from one another, provided that the
following conditions are met:
</p>

<dl class="org-dl">
<dt>Same Projection</dt><dd>All spatially varying datasets must share the
same projection.</dd>

<dt>Same Extent</dt><dd>All spatial and temporal extents must match.</dd>

<dt>Data Resolutions No Greater Than Simulation Resolutions</dt><dd>All
spatial and temporal resolutions must be less than or equal to the
simulation resolutions.</dd>
</dl>

<p>
The simulated space-time cube will share the same projection and
extent as the input datasets, but its resolution may be specified by
the user, provided that it meets condition 3 above. The 3D lookup
functions for each input will then be responsible for translating the
space-time coordinates they receive at the simulation resolution into
the correct coordinates for their underlying dataset's native
resolution. See section <a href="#loading-data-into-the-3d-space-time-cube-(pyretechnics.space_time_cube)">3</a> for implementation details.
</p>
</div>
</div>
</div>

<div id="outline-container-loading-data-into-the-3d-space-time-cube-(pyretechnics.space_time_cube)" class="outline-2">
<h2 id="loading-data-into-the-3d-space-time-cube-(pyretechnics.space_time_cube)"><span class="section-number-2">3.</span> Loading Data into the 3D Space-Time Cube (pyretechnics.space_time_cube)</h2>
<div class="outline-text-2" id="text-loading-data-into-the-3d-space-time-cube-(pyretechnics.space_time_cube)">
</div>
<div id="outline-container-for-developers-spacetimecube" class="outline-3">
<h3 id="for-developers-spacetimecube"><span class="section-number-3">3.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-for-developers-spacetimecube">
<p>
The following sections define Python classes that construct 3D
space-time cubes corresponding to the data model described above for
various types of input datasets.
</p>
</div>

<div id="outline-container-module-imports-space-time-cube" class="outline-4">
<h4 id="module-imports-space-time-cube"><span class="section-number-4">3.1.1.</span> Module Imports</h4>
<div class="outline-text-4" id="text-module-imports-space-time-cube">
<div class="org-src-container">
<pre class="src src-python" id="space-time-cube-imports"><span class="org-keyword">import</span> cython
<span class="org-keyword">import</span> cython <span class="org-keyword">as</span> cy
<span class="org-keyword">from</span> functools <span class="org-keyword">import</span> <span class="org-builtin">reduce</span>
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">if</span> cython.compiled:
    <span class="org-keyword">from</span> cython.cimports.numpy <span class="org-keyword">import</span> ndarray
    <span class="org-keyword">from</span> cython.cimports.pyretechnics.cy_types <span class="org-keyword">import</span> pyidx
<span class="org-keyword">else</span>:
    <span class="org-keyword">from</span> numpy <span class="org-keyword">import</span> ndarray
    <span class="org-keyword">from</span> pyretechnics.py_types <span class="org-keyword">import</span> pyidx
</pre>
</div>
</div>
</div>

<div id="outline-container-utility-functions-space-time-cube" class="outline-4">
<h4 id="utility-functions-space-time-cube"><span class="section-number-4">3.1.2.</span> Utility Functions</h4>
<div class="outline-text-4" id="text-utility-functions-space-time-cube">
<div class="org-src-container">
<pre class="src src-python" id="space-time-cube-utilities"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">is_pos_int</span>(x: <span class="org-builtin">object</span>) <span class="org-operator">-&gt;</span> cy.bint:
    <span class="org-keyword">return</span> <span class="org-builtin">isinstance</span>(x, <span class="org-builtin">int</span>) <span class="org-keyword">and</span> x <span class="org-operator">&gt;</span> 0


<span class="org-type">@cy.cfunc</span>
<span class="org-keyword">def</span> <span class="org-function-name">divide_evenly</span>(dividend: cy.<span class="org-builtin">int</span>, divisor: cy.<span class="org-builtin">int</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">int</span>:
    <span class="org-keyword">if</span> divisor <span class="org-operator">==</span> 0:
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(f<span class="org-string">"</span>{divisor}<span class="org-string"> may not be zero."</span>)
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">quotient</span> : cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> dividend <span class="org-operator">//</span> divisor
        <span class="org-variable-name">remainder</span>: cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> dividend <span class="org-operator">%</span> divisor
        <span class="org-keyword">if</span> remainder <span class="org-operator">==</span> 0:
            <span class="org-keyword">return</span> quotient
        <span class="org-keyword">else</span>:
            <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(f<span class="org-string">"</span>{dividend}<span class="org-string"> must be an exact multiple of </span>{divisor}<span class="org-string">."</span>)


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">to_positive_index_range</span>(index_range: <span class="org-builtin">tuple</span>[pyidx, pyidx]<span class="org-operator">|</span><span class="org-constant">None</span>, axis_length: pyidx) <span class="org-operator">-&gt;</span> <span class="org-builtin">tuple</span>[pyidx, pyidx]:
    <span class="org-doc">"""</span>
<span class="org-doc">    Translate None and negative indices to positive indices.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">if</span> index_range <span class="org-keyword">is</span> <span class="org-constant">None</span>:
        <span class="org-keyword">return</span> (0, axis_length)
    <span class="org-keyword">else</span>:
        start: pyidx<span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> index_range[0]
        stop : pyidx<span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> index_range[1]
        <span class="org-keyword">return</span> (
            0 <span class="org-keyword">if</span> start <span class="org-keyword">is</span> <span class="org-constant">None</span> <span class="org-keyword">else</span> axis_length <span class="org-operator">+</span> start <span class="org-keyword">if</span> start <span class="org-operator">&lt;</span> 0 <span class="org-keyword">else</span> start,
            axis_length <span class="org-keyword">if</span> stop <span class="org-keyword">is</span> <span class="org-constant">None</span> <span class="org-keyword">else</span> axis_length <span class="org-operator">+</span> stop <span class="org-keyword">if</span> stop <span class="org-operator">&lt;</span> 0 <span class="org-keyword">else</span> stop
        )


<span class="org-type">@cy.cfunc</span>
<span class="org-keyword">def</span> <span class="org-function-name">stretch_array</span>(old_array: ndarray, new_length: cy.<span class="org-builtin">int</span>, repetitions: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> ndarray:
    <span class="org-variable-name">new_array</span>: ndarray <span class="org-operator">=</span> np.zeros(new_length, dtype<span class="org-operator">=</span>old_array.dtype)
    i        : pyidx
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(new_length):
        <span class="org-variable-name">new_array</span>[i] <span class="org-operator">=</span> old_array[<span class="org-builtin">int</span>(i <span class="org-operator">/</span> repetitions)]
    <span class="org-keyword">return</span> new_array


<span class="org-type">@cy.cfunc</span>
<span class="org-keyword">def</span> <span class="org-function-name">maybe_repeat_array</span>(maybe_array: ndarray, axis_repetitions: <span class="org-builtin">tuple</span>[pyidx, cy.<span class="org-builtin">float</span>]) <span class="org-operator">-&gt;</span> ndarray:
    <span class="org-doc">"""</span>
<span class="org-doc">    Return a new array that is created by repeating the elements from the input</span>
<span class="org-doc">    array repetitions times along the specified array axis. Avoid allocating</span>
<span class="org-doc">    new memory if repetitions == 1 or if the repeated array axis has length 1.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">axis</span>       : pyidx    <span class="org-operator">=</span> axis_repetitions[0]
    <span class="org-variable-name">repetitions</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> axis_repetitions[1]
    <span class="org-variable-name">old_array</span>  : ndarray  <span class="org-operator">=</span> np.asarray(maybe_array)
    <span class="org-variable-name">array_dims</span> : pyidx    <span class="org-operator">=</span> old_array.ndim
    <span class="org-variable-name">array_shape</span>: <span class="org-builtin">list</span>     <span class="org-operator">=</span> <span class="org-builtin">list</span>(np.shape(old_array))
    <span class="org-variable-name">axis_length</span>: cy.<span class="org-builtin">int</span>   <span class="org-operator">=</span> array_shape[axis]
    <span class="org-keyword">if</span> repetitions <span class="org-operator">==</span> 1.0:
        <span class="org-comment-delimiter"># </span><span class="org-comment">no repetitions necessary</span>
        <span class="org-keyword">return</span> old_array
    <span class="org-keyword">elif</span> axis_length <span class="org-operator">==</span> 1:
        <span class="org-comment-delimiter"># </span><span class="org-comment">broadcast single-element axis repetitions times</span>
        <span class="org-variable-name">array_shape</span>[axis] <span class="org-operator">=</span> <span class="org-builtin">int</span>(repetitions)
        <span class="org-keyword">return</span> np.broadcast_to(old_array, array_shape)
    <span class="org-keyword">elif</span> repetitions <span class="org-operator">%</span> 1.0 <span class="org-operator">==</span> 0.0:
        <span class="org-comment-delimiter"># </span><span class="org-comment">repeat each element on the chosen axis repetitions times</span>
        <span class="org-keyword">return</span> np.repeat(old_array, <span class="org-builtin">int</span>(repetitions), axis)
    <span class="org-keyword">elif</span> axis <span class="org-operator">==</span> 0 <span class="org-keyword">and</span> array_dims <span class="org-operator">==</span> 1:
        <span class="org-comment-delimiter"># </span><span class="org-comment">populate a new 1D array of the expected length by translating its indices into the original array</span>
        <span class="org-variable-name">new_axis_length</span>: cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>(axis_length <span class="org-operator">*</span> repetitions)
        <span class="org-keyword">return</span> stretch_array(old_array, new_axis_length, repetitions)
    <span class="org-keyword">elif</span> axis <span class="org-operator">==</span> 0 <span class="org-keyword">and</span> array_dims <span class="org-operator">==</span> 2:
        <span class="org-comment-delimiter"># </span><span class="org-comment">populate a new 2D array of the expected length by translating its indices into the original array</span>
        <span class="org-variable-name">new_rows</span>: cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>(axis_length <span class="org-operator">*</span> repetitions)
        <span class="org-keyword">return</span> np.stack([old_array[<span class="org-builtin">int</span>(i <span class="org-operator">/</span> repetitions)] <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(new_rows)])
    <span class="org-keyword">elif</span> axis <span class="org-operator">==</span> 1 <span class="org-keyword">and</span> array_dims <span class="org-operator">==</span> 2:
        <span class="org-comment-delimiter"># </span><span class="org-comment">populate a new 2D array of the expected length by translating its indices into the original array</span>
        <span class="org-variable-name">old_rows</span>: cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> array_shape[0]
        <span class="org-variable-name">new_cols</span>: cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>(axis_length <span class="org-operator">*</span> repetitions)
        <span class="org-keyword">return</span> np.stack([stretch_array(old_array[i], new_cols, repetitions) <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(old_rows)])
    <span class="org-keyword">elif</span> axis <span class="org-operator">==</span> 0 <span class="org-keyword">and</span> array_dims <span class="org-operator">==</span> 3:
        <span class="org-comment-delimiter"># </span><span class="org-comment">populate a new 3D array of the expected length by translating its indices into the original array</span>
        <span class="org-variable-name">new_bands</span>: cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>(axis_length <span class="org-operator">*</span> repetitions)
        <span class="org-keyword">return</span> np.stack([old_array[<span class="org-builtin">int</span>(b <span class="org-operator">/</span> repetitions)] <span class="org-keyword">for</span> b <span class="org-keyword">in</span> <span class="org-builtin">range</span>(new_bands)])
    <span class="org-keyword">elif</span> axis <span class="org-operator">==</span> 1 <span class="org-keyword">and</span> array_dims <span class="org-operator">==</span> 3:
        <span class="org-comment-delimiter"># </span><span class="org-comment">populate a new 2D array of the expected length by translating its indices into the original array</span>
        <span class="org-variable-name">old_bands</span>: cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> array_shape[0]
        <span class="org-variable-name">new_rows</span> : cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>(axis_length <span class="org-operator">*</span> repetitions)
        <span class="org-keyword">return</span> np.stack([
            np.stack([
                old_array[b, <span class="org-builtin">int</span>(i <span class="org-operator">/</span> repetitions)]
                <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(new_rows)
            ])
            <span class="org-keyword">for</span> b <span class="org-keyword">in</span> <span class="org-builtin">range</span>(old_bands)
        ])
    <span class="org-keyword">elif</span> axis <span class="org-operator">==</span> 2 <span class="org-keyword">and</span> array_dims <span class="org-operator">==</span> 3:
        <span class="org-comment-delimiter"># </span><span class="org-comment">populate a new 3D array of the expected length by translating its indices into the original array</span>
        <span class="org-variable-name">old_bands</span>: cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> array_shape[0]
        <span class="org-variable-name">old_rows</span> : cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> array_shape[1]
        <span class="org-variable-name">new_cols</span> : cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>(axis_length <span class="org-operator">*</span> repetitions)
        <span class="org-keyword">return</span> np.stack([
            np.stack([
                stretch_array(old_array[b,i], new_cols, repetitions)
                <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(old_rows)
            ])
            <span class="org-keyword">for</span> b <span class="org-keyword">in</span> <span class="org-builtin">range</span>(old_bands)
        ])
    <span class="org-keyword">else</span>:
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"Floating point repetitions are only supported for 1D, 2D, and 3D arrays."</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-ispacetimecube-class" class="outline-4">
<h4 id="ispacetimecube-class"><span class="section-number-4">3.1.3.</span> ISpaceTimeCube Class</h4>
<div class="outline-text-4" id="text-ispacetimecube-class">
<p>
The ISpaceTimeCube class provides an abstract parent class from which
both the SpaceTimeCube and LazySpaceTimeCube classes inherit. Because
of this, functions which accept an ISpaceTimeCube can provide
polymorphism over these two child classes.
</p>

<div class="org-src-container">
<pre class="src src-python" id="ispace-time-cube-class"><span class="org-type">@cy.cclass</span>
<span class="org-keyword">class</span> <span class="org-type">ISpaceTimeCube</span>:
    <span class="org-type">@cy.cfunc</span>
    <span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
    <span class="org-keyword">def</span> <span class="org-function-name">get</span>(<span class="org-keyword">self</span>, t: pyidx, y: pyidx, x: pyidx) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
        <span class="org-keyword">pass</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-spacetimecube-class" class="outline-4">
<h4 id="spacetimecube-class"><span class="section-number-4">3.1.4.</span> SpaceTimeCube Class</h4>
<div class="outline-text-4" id="text-spacetimecube-class">
<p>
When an input dataset is already loaded into memory as either a single
scalar value or a 1D, 2D, or 3D array of values, it can be made
available to the various Pyretechnics algorithms by wrapping it in a
<code>SpaceTimeCube</code> object. As described in sections <a href="#support-for-input-datasets-of-varying-dimensionality">2.3</a> and <a href="#support-for-input-datasets-of-varying-resolution">2.4</a>, this input data can be provided in a variety of
dimensions and resolutions, subject to some simple constraints.
</p>

<p>
The <code>SpaceTimeCube</code> object will be created with a tuple of
user-specified spatio-temporal resolutions, called the <i>cube shape</i>,
which must be greater than or equal to those of the underlying data.
For memory efficiency, input values are stored within the
<code>SpaceTimeCube</code> object at their native resolution but can be accessed
at any spatio-temporal point or region within the <code>SpaceTimeCube</code>'s
extent using coordinates from the <i>cube shape</i> resolution.
</p>

<p>
The various accessor functions provided by this class receive 3D
space-time coordinates at the <i>cube shape</i> resolution and will
correctly map them into the corresponding index within the native
dataset. Whenever a bounded region of space-time is requested via an
accessor function, the underlying data will be expanded to fill a new
Numpy array at the <i>cube shape</i> resolution. Whenever possible, Numpy
array broadcasting will be used instead of data copying for any
constant input dimensions.
</p>

<div class="org-src-container">
<pre class="src src-python" id="space-time-cube-class"><span class="org-type">@cy.cclass</span>
<span class="org-keyword">class</span> <span class="org-type">SpaceTimeCube</span>(ISpaceTimeCube):
    <span class="org-doc">"""</span>
<span class="org-doc">    Create an object that represents a 3D array with dimensions (T,Y,X) given by cube_shape.</span>
<span class="org-doc">    Internally, data is stored as a 3D Numpy array at the resolution of the provided base data.</span>
<span class="org-doc">    Whenever a point value or contiguous space-time region of values is requested, translate</span>
<span class="org-doc">    the given cube_shape coordinates into base coordinates, look up the values from the base data,</span>
<span class="org-doc">    expand them (if necessary) back into the cube_shape resolution, and return the resulting scalar</span>
<span class="org-doc">    value or array to the caller.</span>
<span class="org-doc">    """</span>
    ndim         : cy.<span class="org-builtin">int</span>
    size         : cy.ulonglong
    shape        : <span class="org-builtin">tuple</span>[cy.<span class="org-builtin">int</span>, cy.<span class="org-builtin">int</span>, cy.<span class="org-builtin">int</span>]
    base         : <span class="org-builtin">object</span>
    t_repetitions: cy.<span class="org-builtin">float</span>
    y_repetitions: cy.<span class="org-builtin">float</span>
    x_repetitions: cy.<span class="org-builtin">float</span>
    data         : cy.<span class="org-builtin">float</span>[:,:,::1] <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Restore polymorphism for the underlying Numpy arrays</span>


    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, cube_shape: <span class="org-builtin">tuple</span>[<span class="org-builtin">int</span>, <span class="org-builtin">int</span>, <span class="org-builtin">int</span>], base: <span class="org-builtin">object</span>) <span class="org-operator">-&gt;</span> cy.void:
        <span class="org-doc">"""</span>
<span class="org-doc">        NOTE: The resolutions in cube_shape must be exact multiples of any existing dimensions</span>
<span class="org-doc">              in the base data. If base is not a Numpy float32 array, a new array will be allocated.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that cube_shape contains 3 values or throw an error</span>
        <span class="org-keyword">if</span> <span class="org-builtin">len</span>(cube_shape) <span class="org-operator">!=</span> 3:
            <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The cube_shape must contain exactly three values."</span>)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack the cube_shape values without type-checking</span>
        <span class="org-variable-name">cube_bands_</span>: <span class="org-builtin">object</span> <span class="org-operator">=</span> cube_shape[0]
        <span class="org-variable-name">cube_rows_</span> : <span class="org-builtin">object</span> <span class="org-operator">=</span> cube_shape[1]
        <span class="org-variable-name">cube_cols_</span> : <span class="org-builtin">object</span> <span class="org-operator">=</span> cube_shape[2]

        <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that cube_shape only contains positive integers or throw an error</span>
        <span class="org-keyword">if</span> <span class="org-keyword">not</span>(is_pos_int(cube_bands_) <span class="org-keyword">and</span> is_pos_int(cube_rows_) <span class="org-keyword">and</span> is_pos_int(cube_cols_)):
            <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The cube_shape must contain only positive integers."</span>)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Cast the cube_shape values as primitive ints</span>
        <span class="org-variable-name">cube_bands</span>: cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> cube_bands_
        <span class="org-variable-name">cube_rows</span> : cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> cube_rows_
        <span class="org-variable-name">cube_cols</span> : cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> cube_cols_

        <span class="org-comment-delimiter"># </span><span class="org-comment">Store the cube metadata for later</span>
        <span class="org-keyword">self</span>.<span class="org-variable-name">ndim</span>  <span class="org-operator">=</span> 3
        <span class="org-keyword">self</span>.<span class="org-variable-name">size</span>  <span class="org-operator">=</span> cube_bands <span class="org-operator">*</span> cube_rows <span class="org-operator">*</span> cube_cols
        <span class="org-keyword">self</span>.<span class="org-variable-name">shape</span> <span class="org-operator">=</span> (cube_bands, cube_rows, cube_cols)
        <span class="org-keyword">self</span>.<span class="org-variable-name">base</span>  <span class="org-operator">=</span> base

        <span class="org-comment-delimiter"># </span><span class="org-comment">Store the base data as a 3D array along with its axis repetitions</span>
        <span class="org-variable-name">base_dimensions</span>: cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> np.ndim(base)

        <span class="org-keyword">if</span> base_dimensions <span class="org-operator">==</span> 0:
            <span class="org-comment-delimiter"># </span><span class="org-comment">0D: Constant Input</span>
            <span class="org-keyword">self</span>.<span class="org-variable-name">t_repetitions</span> <span class="org-operator">=</span> cube_bands
            <span class="org-keyword">self</span>.<span class="org-variable-name">y_repetitions</span> <span class="org-operator">=</span> cube_rows
            <span class="org-keyword">self</span>.<span class="org-variable-name">x_repetitions</span> <span class="org-operator">=</span> cube_cols
            <span class="org-keyword">self</span>.<span class="org-variable-name">data</span>          <span class="org-operator">=</span> np.asarray([[[base]]], dtype<span class="org-operator">=</span>np.float32)

        <span class="org-keyword">elif</span> base_dimensions <span class="org-operator">==</span> 1:
            <span class="org-comment-delimiter"># </span><span class="org-comment">1D: Time-Series Input</span>
            <span class="org-variable-name">base_bands</span>: cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> <span class="org-builtin">len</span>(base)
            <span class="org-keyword">self</span>.<span class="org-variable-name">t_repetitions</span> <span class="org-operator">=</span> <span class="org-builtin">float</span>(cube_bands) <span class="org-operator">/</span> <span class="org-builtin">float</span>(base_bands)
            <span class="org-keyword">self</span>.<span class="org-variable-name">y_repetitions</span> <span class="org-operator">=</span> cube_rows
            <span class="org-keyword">self</span>.<span class="org-variable-name">x_repetitions</span> <span class="org-operator">=</span> cube_cols
            <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that the cube_shape is not smaller than the base shape</span>
            <span class="org-keyword">if</span> cube_bands <span class="org-operator">&lt;</span> base_bands:
                <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The cube_shape may not be smaller than the base shape."</span>)
            <span class="org-comment-delimiter"># </span><span class="org-comment">Warn if any repetitions are not whole numbers</span>
            <span class="org-keyword">if</span> <span class="org-keyword">self</span>.t_repetitions <span class="org-operator">%</span> 1.0 <span class="org-operator">!=</span> 0.0:
                <span class="org-builtin">print</span>(<span class="org-string">"WARNING: Input data's shape does not evenly divide the cube_shape."</span>
                      <span class="org-operator">+</span> <span class="org-string">" Index lookups beyond the cube's edge may mistakenly return values without errors."</span>)
            <span class="org-comment-delimiter"># </span><span class="org-comment">Warn if base is not a Numpy float32 array</span>
            <span class="org-keyword">if</span> <span class="org-keyword">not</span>(<span class="org-builtin">isinstance</span>(base, np.ndarray)) <span class="org-keyword">or</span> (base.dtype <span class="org-operator">!=</span> np.float32):
                <span class="org-builtin">print</span>(<span class="org-string">"WARNING: Input data is not a Numpy float32 array. Data will be copied into SpaceTimeCube."</span>,
                      flush<span class="org-operator">=</span><span class="org-constant">True</span>)
            <span class="org-comment-delimiter"># </span><span class="org-comment">Expand (base_bands) -&gt; (base_bands,1,1)</span>
            <span class="org-keyword">self</span>.<span class="org-variable-name">data</span> <span class="org-operator">=</span> np.expand_dims(np.asarray(base, dtype<span class="org-operator">=</span>np.float32), axis<span class="org-operator">=</span>(1,2))

        <span class="org-keyword">elif</span> base_dimensions <span class="org-operator">==</span> 2:
            <span class="org-comment-delimiter"># </span><span class="org-comment">2D: Spatial Input</span>
            <span class="org-variable-name">base_shape</span>: <span class="org-builtin">tuple</span>  <span class="org-operator">=</span> np.shape(base)
            <span class="org-variable-name">base_rows</span> : cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> base_shape[0]
            <span class="org-variable-name">base_cols</span> : cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> base_shape[1]
            <span class="org-keyword">self</span>.<span class="org-variable-name">t_repetitions</span> <span class="org-operator">=</span> cube_bands
            <span class="org-keyword">self</span>.<span class="org-variable-name">y_repetitions</span> <span class="org-operator">=</span> <span class="org-builtin">float</span>(cube_rows) <span class="org-operator">/</span> <span class="org-builtin">float</span>(base_rows)
            <span class="org-keyword">self</span>.<span class="org-variable-name">x_repetitions</span> <span class="org-operator">=</span> <span class="org-builtin">float</span>(cube_cols) <span class="org-operator">/</span> <span class="org-builtin">float</span>(base_cols)
            <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that the cube_shape is not smaller than the base shape</span>
            <span class="org-keyword">if</span> cube_rows <span class="org-operator">&lt;</span> base_rows <span class="org-keyword">or</span> cube_cols <span class="org-operator">&lt;</span> base_cols:
                <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The cube_shape may not be smaller than the base shape."</span>)
            <span class="org-comment-delimiter"># </span><span class="org-comment">Warn if any repetitions are not whole numbers</span>
            <span class="org-keyword">if</span> <span class="org-keyword">self</span>.y_repetitions <span class="org-operator">%</span> 1.0 <span class="org-operator">!=</span> 0.0 <span class="org-keyword">or</span> <span class="org-keyword">self</span>.x_repetitions <span class="org-operator">%</span> 1.0 <span class="org-operator">!=</span> 0.0:
                <span class="org-builtin">print</span>(<span class="org-string">"WARNING: Input data's shape does not evenly divide the cube_shape."</span>
                      <span class="org-operator">+</span> <span class="org-string">" Index lookups beyond the cube's edge may mistakenly return values without errors."</span>)
            <span class="org-comment-delimiter"># </span><span class="org-comment">Warn if base is not a Numpy float32 array</span>
            <span class="org-keyword">if</span> <span class="org-keyword">not</span>(<span class="org-builtin">isinstance</span>(base, np.ndarray)) <span class="org-keyword">or</span> (base.dtype <span class="org-operator">!=</span> np.float32):
                <span class="org-builtin">print</span>(<span class="org-string">"WARNING: Input data is not a Numpy float32 array. Data will be copied into SpaceTimeCube."</span>,
                      flush<span class="org-operator">=</span><span class="org-constant">True</span>)
            <span class="org-comment-delimiter"># </span><span class="org-comment">Expand (base_rows,base_cols) -&gt; (1,base_rows,base_cols)</span>
            <span class="org-keyword">self</span>.<span class="org-variable-name">data</span> <span class="org-operator">=</span> np.expand_dims(np.asarray(base, dtype<span class="org-operator">=</span>np.float32), axis<span class="org-operator">=</span>0)

        <span class="org-keyword">elif</span> base_dimensions <span class="org-operator">==</span> 3:
            <span class="org-comment-delimiter"># </span><span class="org-comment">3D: Spatio-Temporal Input</span>
            <span class="org-variable-name">base_shape</span>: <span class="org-builtin">tuple</span>  <span class="org-operator">=</span> np.shape(base)
            <span class="org-variable-name">base_bands</span>: cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> base_shape[0]
            <span class="org-variable-name">base_rows</span> : cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> base_shape[1]
            <span class="org-variable-name">base_cols</span> : cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> base_shape[2]
            <span class="org-keyword">self</span>.<span class="org-variable-name">t_repetitions</span> <span class="org-operator">=</span> <span class="org-builtin">float</span>(cube_bands) <span class="org-operator">/</span> <span class="org-builtin">float</span>(base_bands)
            <span class="org-keyword">self</span>.<span class="org-variable-name">y_repetitions</span> <span class="org-operator">=</span> <span class="org-builtin">float</span>(cube_rows) <span class="org-operator">/</span> <span class="org-builtin">float</span>(base_rows)
            <span class="org-keyword">self</span>.<span class="org-variable-name">x_repetitions</span> <span class="org-operator">=</span> <span class="org-builtin">float</span>(cube_cols) <span class="org-operator">/</span> <span class="org-builtin">float</span>(base_cols)
            <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that the cube_shape is not smaller than the base shape</span>
            <span class="org-keyword">if</span> cube_bands <span class="org-operator">&lt;</span> base_bands <span class="org-keyword">or</span> cube_rows <span class="org-operator">&lt;</span> base_rows <span class="org-keyword">or</span> cube_cols <span class="org-operator">&lt;</span> base_cols:
                <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The cube_shape may not be smaller than the base shape."</span>)
            <span class="org-comment-delimiter"># </span><span class="org-comment">Warn if any repetitions are not whole numbers</span>
            <span class="org-keyword">if</span> <span class="org-keyword">self</span>.t_repetitions <span class="org-operator">%</span> 1.0 <span class="org-operator">!=</span> 0.0 <span class="org-keyword">or</span> <span class="org-keyword">self</span>.y_repetitions <span class="org-operator">%</span> 1.0 <span class="org-operator">!=</span> 0.0 <span class="org-keyword">or</span> <span class="org-keyword">self</span>.x_repetitions <span class="org-operator">%</span> 1.0 <span class="org-operator">!=</span> 0.0:
                <span class="org-builtin">print</span>(<span class="org-string">"WARNING: Input data's shape does not evenly divide the cube_shape."</span>
                      <span class="org-operator">+</span> <span class="org-string">" Index lookups beyond the cube's edge may mistakenly return values without errors."</span>)
            <span class="org-comment-delimiter"># </span><span class="org-comment">Warn if base is not a Numpy float32 array</span>
            <span class="org-keyword">if</span> <span class="org-keyword">not</span>(<span class="org-builtin">isinstance</span>(base, np.ndarray)) <span class="org-keyword">or</span> (base.dtype <span class="org-operator">!=</span> np.float32):
                <span class="org-builtin">print</span>(<span class="org-string">"WARNING: Input data is not a Numpy float32 array. Data will be copied into SpaceTimeCube."</span>,
                      flush<span class="org-operator">=</span><span class="org-constant">True</span>)
            <span class="org-keyword">self</span>.<span class="org-variable-name">data</span> <span class="org-operator">=</span> np.asarray(base, dtype<span class="org-operator">=</span>np.float32)

        <span class="org-keyword">else</span>:
            <span class="org-comment-delimiter"># </span><span class="org-comment">4D+: Invalid Input</span>
            <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"Invalid input: base must have 0-3 dimensions."</span>)


    <span class="org-type">@cy.ccall</span>
    <span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
    <span class="org-type">@cy.boundscheck</span>(<span class="org-constant">True</span>)
    <span class="org-keyword">def</span> <span class="org-function-name">get</span>(<span class="org-keyword">self</span>, t: pyidx, y: pyidx, x: pyidx) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the scalar value at index (t,y,x) by translating these cube coordinates</span>
<span class="org-doc">        to base coordinates and looking up the value within the base data.</span>

<span class="org-doc">        NOTE: Indices may be negative.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select value by spatio-temporal coordinate</span>
        <span class="org-variable-name">base_t</span>: pyidx <span class="org-operator">=</span> <span class="org-builtin">int</span>(t <span class="org-operator">/</span> <span class="org-keyword">self</span>.t_repetitions)
        <span class="org-variable-name">base_y</span>: pyidx <span class="org-operator">=</span> <span class="org-builtin">int</span>(y <span class="org-operator">/</span> <span class="org-keyword">self</span>.y_repetitions)
        <span class="org-variable-name">base_x</span>: pyidx <span class="org-operator">=</span> <span class="org-builtin">int</span>(x <span class="org-operator">/</span> <span class="org-keyword">self</span>.x_repetitions)
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>.data[base_t, base_y, base_x]


    <span class="org-type">@cy.ccall</span>
    <span class="org-type">@cy.boundscheck</span>(<span class="org-constant">True</span>)
    <span class="org-keyword">def</span> <span class="org-function-name">getTimeSeries</span>(<span class="org-keyword">self</span>, t_range: <span class="org-builtin">tuple</span>[pyidx, pyidx]<span class="org-operator">|</span><span class="org-constant">None</span>, y: pyidx, x: pyidx) <span class="org-operator">-&gt;</span> ndarray:
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 1D array given by the slice (t_range,y,x) by translating these cube</span>
<span class="org-doc">        coordinates to base coordinates, looking up the array slice within the base data,</span>
<span class="org-doc">        and expanding it back to the cube_shape resolution.</span>

<span class="org-doc">        NOTE: Indices may be negative.</span>
<span class="org-doc">        NOTE: Range indices may include one or more None values and</span>
<span class="org-doc">              provide (inclusion, exclusion) semantics like Python array slice notation.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the argument range</span>
        <span class="org-variable-name">t_range_updated</span> : <span class="org-builtin">tuple</span>[<span class="org-variable-name">pyidx</span>, <span class="org-variable-name">pyidx</span>] <span class="org-operator">=</span> to_positive_index_range(t_range, <span class="org-keyword">self</span>.shape[0])
        <span class="org-variable-name">t_start</span>         : pyidx               <span class="org-operator">=</span> t_range_updated[0]
        <span class="org-variable-name">t_stop_exclusive</span>: pyidx               <span class="org-operator">=</span> t_range_updated[1]
        <span class="org-variable-name">t_stop</span>          : pyidx               <span class="org-operator">=</span> t_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res coordinates to low-res coordinates</span>
        <span class="org-variable-name">t_start_chunk</span>: pyidx <span class="org-operator">=</span> <span class="org-builtin">int</span>(t_start <span class="org-operator">/</span> <span class="org-keyword">self</span>.t_repetitions)
        <span class="org-variable-name">t_stop_chunk</span> : pyidx <span class="org-operator">=</span> <span class="org-builtin">int</span>(t_stop  <span class="org-operator">/</span> <span class="org-keyword">self</span>.t_repetitions)
        <span class="org-variable-name">y_chunk</span>      : pyidx <span class="org-operator">=</span> <span class="org-builtin">int</span>(y       <span class="org-operator">/</span> <span class="org-keyword">self</span>.y_repetitions)
        <span class="org-variable-name">x_chunk</span>      : pyidx <span class="org-operator">=</span> <span class="org-builtin">int</span>(x       <span class="org-operator">/</span> <span class="org-keyword">self</span>.x_repetitions)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select the array slice that completely contains all low-res coordinates</span>
        <span class="org-variable-name">low_res_time</span>: ndarray <span class="org-operator">=</span> np.asarray(<span class="org-keyword">self</span>.data[t_start_chunk:(t_stop_chunk <span class="org-operator">+</span> 1),
                                                     y_chunk,
                                                     x_chunk])
        <span class="org-comment-delimiter"># </span><span class="org-comment">Expand the low-res slice into a high-res slice</span>
        <span class="org-variable-name">high_res_time</span>: ndarray <span class="org-operator">=</span> maybe_repeat_array(low_res_time, (0, <span class="org-keyword">self</span>.t_repetitions))
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res global coordinates to high-res slice coordinates</span>
        <span class="org-variable-name">t_chunk_origin</span>: pyidx <span class="org-operator">=</span> <span class="org-builtin">int</span>(t_start_chunk <span class="org-operator">*</span> <span class="org-keyword">self</span>.t_repetitions)
        <span class="org-variable-name">t_start_idx</span>   : pyidx <span class="org-operator">=</span> t_start <span class="org-operator">-</span> t_chunk_origin
        <span class="org-variable-name">t_stop_idx</span>    : pyidx <span class="org-operator">=</span> t_stop  <span class="org-operator">-</span> t_chunk_origin
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select the array slice that matches the high-res slice coordinates</span>
        <span class="org-keyword">return</span> high_res_time[t_start_idx:(t_stop_idx <span class="org-operator">+</span> 1)]


    <span class="org-type">@cy.ccall</span>
    <span class="org-type">@cy.boundscheck</span>(<span class="org-constant">True</span>)
    <span class="org-keyword">def</span> <span class="org-function-name">getSpatialPlane</span>(<span class="org-keyword">self</span>,
                        t      : pyidx,
                        y_range: <span class="org-builtin">tuple</span>[pyidx, pyidx]<span class="org-operator">|</span><span class="org-constant">None</span>,
                        x_range: <span class="org-builtin">tuple</span>[pyidx, pyidx]<span class="org-operator">|</span><span class="org-constant">None</span>) <span class="org-operator">-&gt;</span> ndarray:
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 2D array given by the slice (t,y_range,x_range) by translating these</span>
<span class="org-doc">        cube coordinates to base coordinates, looking up the array slice within the base</span>
<span class="org-doc">        data, and expanding it back to the cube_shape resolution.</span>

<span class="org-doc">        NOTE: Indices may be negative.</span>
<span class="org-doc">        NOTE: Range indices may include one or more None values and</span>
<span class="org-doc">              provide (inclusion, exclusion) semantics like Python array slice notation.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the argument ranges</span>
        <span class="org-variable-name">y_range_updated</span> : <span class="org-builtin">tuple</span>[<span class="org-variable-name">pyidx</span>, <span class="org-variable-name">pyidx</span>] <span class="org-operator">=</span> to_positive_index_range(y_range, <span class="org-keyword">self</span>.shape[1])
        <span class="org-variable-name">x_range_updated</span> : <span class="org-builtin">tuple</span>[<span class="org-variable-name">pyidx</span>, <span class="org-variable-name">pyidx</span>] <span class="org-operator">=</span> to_positive_index_range(x_range, <span class="org-keyword">self</span>.shape[2])
        <span class="org-variable-name">y_start</span>         : pyidx               <span class="org-operator">=</span> y_range_updated[0]
        <span class="org-variable-name">y_stop_exclusive</span>: pyidx               <span class="org-operator">=</span> y_range_updated[1]
        <span class="org-variable-name">x_start</span>         : pyidx               <span class="org-operator">=</span> x_range_updated[0]
        <span class="org-variable-name">x_stop_exclusive</span>: pyidx               <span class="org-operator">=</span> x_range_updated[1]
        <span class="org-variable-name">y_stop</span>          : pyidx               <span class="org-operator">=</span> y_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-variable-name">x_stop</span>          : pyidx               <span class="org-operator">=</span> x_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res coordinates to low-res coordinates</span>
        <span class="org-variable-name">t_chunk</span>      : pyidx <span class="org-operator">=</span> <span class="org-builtin">int</span>(t       <span class="org-operator">/</span> <span class="org-keyword">self</span>.t_repetitions)
        <span class="org-variable-name">y_start_chunk</span>: pyidx <span class="org-operator">=</span> <span class="org-builtin">int</span>(y_start <span class="org-operator">/</span> <span class="org-keyword">self</span>.y_repetitions)
        <span class="org-variable-name">y_stop_chunk</span> : pyidx <span class="org-operator">=</span> <span class="org-builtin">int</span>(y_stop  <span class="org-operator">/</span> <span class="org-keyword">self</span>.y_repetitions)
        <span class="org-variable-name">x_start_chunk</span>: pyidx <span class="org-operator">=</span> <span class="org-builtin">int</span>(x_start <span class="org-operator">/</span> <span class="org-keyword">self</span>.x_repetitions)
        <span class="org-variable-name">x_stop_chunk</span> : pyidx <span class="org-operator">=</span> <span class="org-builtin">int</span>(x_stop  <span class="org-operator">/</span> <span class="org-keyword">self</span>.x_repetitions)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select the array slice that completely contains all low-res coordinates</span>
        <span class="org-variable-name">low_res_space</span>: ndarray <span class="org-operator">=</span> np.asarray(<span class="org-keyword">self</span>.data[t_chunk,
                                                      y_start_chunk:(y_stop_chunk <span class="org-operator">+</span> 1),
                                                      x_start_chunk:(x_stop_chunk <span class="org-operator">+</span> 1)])
        <span class="org-comment-delimiter"># </span><span class="org-comment">Expand the low-res slice into a high-res slice</span>
        <span class="org-variable-name">high_res_space</span>: ndarray <span class="org-operator">=</span> <span class="org-builtin">reduce</span>(maybe_repeat_array,
                                         ((0, <span class="org-keyword">self</span>.y_repetitions),
                                          (1, <span class="org-keyword">self</span>.x_repetitions)),
                                         low_res_space)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res global coordinates to high-res slice coordinates</span>
        <span class="org-variable-name">y_chunk_origin</span>: pyidx <span class="org-operator">=</span> <span class="org-builtin">int</span>(y_start_chunk <span class="org-operator">*</span> <span class="org-keyword">self</span>.y_repetitions)
        <span class="org-variable-name">x_chunk_origin</span>: pyidx <span class="org-operator">=</span> <span class="org-builtin">int</span>(x_start_chunk <span class="org-operator">*</span> <span class="org-keyword">self</span>.x_repetitions)
        <span class="org-variable-name">y_start_idx</span>   : pyidx <span class="org-operator">=</span> y_start <span class="org-operator">-</span> y_chunk_origin
        <span class="org-variable-name">y_stop_idx</span>    : pyidx <span class="org-operator">=</span> y_stop  <span class="org-operator">-</span> y_chunk_origin
        <span class="org-variable-name">x_start_idx</span>   : pyidx <span class="org-operator">=</span> x_start <span class="org-operator">-</span> x_chunk_origin
        <span class="org-variable-name">x_stop_idx</span>    : pyidx <span class="org-operator">=</span> x_stop  <span class="org-operator">-</span> x_chunk_origin
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select the array slice that matches the high-res slice coordinates</span>
        <span class="org-keyword">return</span> high_res_space[y_start_idx:(y_stop_idx <span class="org-operator">+</span> 1),
                              x_start_idx:(x_stop_idx <span class="org-operator">+</span> 1)]


    <span class="org-type">@cy.ccall</span>
    <span class="org-type">@cy.boundscheck</span>(<span class="org-constant">True</span>)
    <span class="org-keyword">def</span> <span class="org-function-name">getSubcube</span>(<span class="org-keyword">self</span>,
                   t_range: <span class="org-builtin">tuple</span>[pyidx, pyidx]<span class="org-operator">|</span><span class="org-constant">None</span>,
                   y_range: <span class="org-builtin">tuple</span>[pyidx, pyidx]<span class="org-operator">|</span><span class="org-constant">None</span>,
                   x_range: <span class="org-builtin">tuple</span>[pyidx, pyidx]<span class="org-operator">|</span><span class="org-constant">None</span>) <span class="org-operator">-&gt;</span> ndarray:
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 3D array given by the slice (t_range,y_range,x_range) by translating</span>
<span class="org-doc">        these cube coordinates to base coordinates, looking up the array slice within the</span>
<span class="org-doc">        base data, and expanding it back to the cube_shape resolution.</span>

<span class="org-doc">        NOTE: Indices may be negative.</span>
<span class="org-doc">        NOTE: Range indices may include one or more None values and</span>
<span class="org-doc">              provide (inclusion, exclusion) semantics like Python array slice notation.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the argument ranges</span>
        <span class="org-variable-name">t_range_updated</span> : <span class="org-builtin">tuple</span>[<span class="org-variable-name">pyidx</span>, <span class="org-variable-name">pyidx</span>] <span class="org-operator">=</span> to_positive_index_range(t_range, <span class="org-keyword">self</span>.shape[0])
        <span class="org-variable-name">y_range_updated</span> : <span class="org-builtin">tuple</span>[<span class="org-variable-name">pyidx</span>, <span class="org-variable-name">pyidx</span>] <span class="org-operator">=</span> to_positive_index_range(y_range, <span class="org-keyword">self</span>.shape[1])
        <span class="org-variable-name">x_range_updated</span> : <span class="org-builtin">tuple</span>[<span class="org-variable-name">pyidx</span>, <span class="org-variable-name">pyidx</span>] <span class="org-operator">=</span> to_positive_index_range(x_range, <span class="org-keyword">self</span>.shape[2])
        <span class="org-variable-name">t_start</span>         : pyidx               <span class="org-operator">=</span> t_range_updated[0]
        <span class="org-variable-name">t_stop_exclusive</span>: pyidx               <span class="org-operator">=</span> t_range_updated[1]
        <span class="org-variable-name">y_start</span>         : pyidx               <span class="org-operator">=</span> y_range_updated[0]
        <span class="org-variable-name">y_stop_exclusive</span>: pyidx               <span class="org-operator">=</span> y_range_updated[1]
        <span class="org-variable-name">x_start</span>         : pyidx               <span class="org-operator">=</span> x_range_updated[0]
        <span class="org-variable-name">x_stop_exclusive</span>: pyidx               <span class="org-operator">=</span> x_range_updated[1]
        <span class="org-variable-name">t_stop</span>          : pyidx               <span class="org-operator">=</span> t_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-variable-name">y_stop</span>          : pyidx               <span class="org-operator">=</span> y_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-variable-name">x_stop</span>          : pyidx               <span class="org-operator">=</span> x_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res coordinates to low-res coordinates</span>
        <span class="org-variable-name">t_start_chunk</span>: pyidx <span class="org-operator">=</span> <span class="org-builtin">int</span>(t_start <span class="org-operator">/</span> <span class="org-keyword">self</span>.t_repetitions)
        <span class="org-variable-name">t_stop_chunk</span> : pyidx <span class="org-operator">=</span> <span class="org-builtin">int</span>(t_stop  <span class="org-operator">/</span> <span class="org-keyword">self</span>.t_repetitions)
        <span class="org-variable-name">y_start_chunk</span>: pyidx <span class="org-operator">=</span> <span class="org-builtin">int</span>(y_start <span class="org-operator">/</span> <span class="org-keyword">self</span>.y_repetitions)
        <span class="org-variable-name">y_stop_chunk</span> : pyidx <span class="org-operator">=</span> <span class="org-builtin">int</span>(y_stop  <span class="org-operator">/</span> <span class="org-keyword">self</span>.y_repetitions)
        <span class="org-variable-name">x_start_chunk</span>: pyidx <span class="org-operator">=</span> <span class="org-builtin">int</span>(x_start <span class="org-operator">/</span> <span class="org-keyword">self</span>.x_repetitions)
        <span class="org-variable-name">x_stop_chunk</span> : pyidx <span class="org-operator">=</span> <span class="org-builtin">int</span>(x_stop  <span class="org-operator">/</span> <span class="org-keyword">self</span>.x_repetitions)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select the array slice that completely contains all low-res coordinates</span>
        <span class="org-variable-name">low_res_cube</span>: ndarray <span class="org-operator">=</span> np.asarray(<span class="org-keyword">self</span>.data[t_start_chunk:(t_stop_chunk <span class="org-operator">+</span> 1),
                                                     y_start_chunk:(y_stop_chunk <span class="org-operator">+</span> 1),
                                                     x_start_chunk:(x_stop_chunk <span class="org-operator">+</span> 1)])
        <span class="org-comment-delimiter"># </span><span class="org-comment">Expand the low-res slice into a high-res slice</span>
        <span class="org-variable-name">high_res_cube</span>: ndarray <span class="org-operator">=</span> <span class="org-builtin">reduce</span>(maybe_repeat_array,
                                        ((0, <span class="org-keyword">self</span>.t_repetitions),
                                         (1, <span class="org-keyword">self</span>.y_repetitions),
                                         (2, <span class="org-keyword">self</span>.x_repetitions)),
                                        low_res_cube)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res global coordinates to high-res slice coordinates</span>
        <span class="org-variable-name">t_chunk_origin</span>: pyidx <span class="org-operator">=</span> <span class="org-builtin">int</span>(t_start_chunk <span class="org-operator">*</span> <span class="org-keyword">self</span>.t_repetitions)
        <span class="org-variable-name">y_chunk_origin</span>: pyidx <span class="org-operator">=</span> <span class="org-builtin">int</span>(y_start_chunk <span class="org-operator">*</span> <span class="org-keyword">self</span>.y_repetitions)
        <span class="org-variable-name">x_chunk_origin</span>: pyidx <span class="org-operator">=</span> <span class="org-builtin">int</span>(x_start_chunk <span class="org-operator">*</span> <span class="org-keyword">self</span>.x_repetitions)
        <span class="org-variable-name">t_start_idx</span>   : pyidx <span class="org-operator">=</span> t_start <span class="org-operator">-</span> t_chunk_origin
        <span class="org-variable-name">t_stop_idx</span>    : pyidx <span class="org-operator">=</span> t_stop  <span class="org-operator">-</span> t_chunk_origin
        <span class="org-variable-name">y_start_idx</span>   : pyidx <span class="org-operator">=</span> y_start <span class="org-operator">-</span> y_chunk_origin
        <span class="org-variable-name">y_stop_idx</span>    : pyidx <span class="org-operator">=</span> y_stop  <span class="org-operator">-</span> y_chunk_origin
        <span class="org-variable-name">x_start_idx</span>   : pyidx <span class="org-operator">=</span> x_start <span class="org-operator">-</span> x_chunk_origin
        <span class="org-variable-name">x_stop_idx</span>    : pyidx <span class="org-operator">=</span> x_stop  <span class="org-operator">-</span> x_chunk_origin
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select the array slice that matches the high-res slice coordinates</span>
        <span class="org-keyword">return</span> high_res_cube[t_start_idx:(t_stop_idx <span class="org-operator">+</span> 1),
                             y_start_idx:(y_stop_idx <span class="org-operator">+</span> 1),
                             x_start_idx:(x_stop_idx <span class="org-operator">+</span> 1)]


    <span class="org-keyword">def</span> <span class="org-function-name">__getFullyRealizedCube</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 3D array created by expanding the base data to the cube_shape resolution.</span>
<span class="org-doc">        Wherever possible, Numpy broadcasting is used to avoid memory allocation along</span>
<span class="org-doc">        constant array dimensions.</span>
<span class="org-doc">        """</span>
        <span class="org-variable-name">base_dimensions</span> <span class="org-operator">=</span> np.ndim(<span class="org-keyword">self</span>.base)

        <span class="org-keyword">if</span> base_dimensions <span class="org-operator">==</span> 0:
            <span class="org-comment-delimiter"># </span><span class="org-comment">0D: Constant Input</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Broadcast (0,0,0) -&gt; (t,y,x)</span>
            <span class="org-keyword">return</span> np.broadcast_to(<span class="org-keyword">self</span>.data, <span class="org-keyword">self</span>.shape)

        <span class="org-keyword">elif</span> base_dimensions <span class="org-operator">==</span> 1:
            <span class="org-comment-delimiter"># </span><span class="org-comment">1D: Time-Series Input</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Repeat (t0,1,1) -&gt; (t,1,1)</span>
            <span class="org-variable-name">repeated_array</span> <span class="org-operator">=</span> maybe_repeat_array(np.asarray(<span class="org-keyword">self</span>.data), (0, <span class="org-keyword">self</span>.t_repetitions))
            <span class="org-comment-delimiter"># </span><span class="org-comment">Broadcast (t,1,1) -&gt; (t,y,x)</span>
            <span class="org-keyword">return</span> np.broadcast_to(repeated_array, <span class="org-keyword">self</span>.shape)

        <span class="org-keyword">elif</span> base_dimensions <span class="org-operator">==</span> 2:
            <span class="org-comment-delimiter"># </span><span class="org-comment">2D: Spatial Input</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Repeat (1,y0,x0) -&gt; (1,y,x)</span>
            <span class="org-variable-name">repeated_array</span> <span class="org-operator">=</span> <span class="org-builtin">reduce</span>(maybe_repeat_array,
                                    ((1, <span class="org-keyword">self</span>.y_repetitions),
                                     (2, <span class="org-keyword">self</span>.x_repetitions)),
                                    np.asarray(<span class="org-keyword">self</span>.data))
            <span class="org-comment-delimiter"># </span><span class="org-comment">Broadcast (1,y,x) -&gt; (t,y,x)</span>
            <span class="org-keyword">return</span> np.broadcast_to(repeated_array, <span class="org-keyword">self</span>.shape)

        <span class="org-keyword">else</span>:
            <span class="org-comment-delimiter"># </span><span class="org-comment">3D: Spatio-Temporal Input</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Repeat (t0,y0,x0) -&gt; (t,y,x)</span>
            <span class="org-keyword">return</span> <span class="org-builtin">reduce</span>(maybe_repeat_array,
                          ((0, <span class="org-keyword">self</span>.t_repetitions),
                           (1, <span class="org-keyword">self</span>.y_repetitions),
                           (2, <span class="org-keyword">self</span>.x_repetitions)),
                          np.asarray(<span class="org-keyword">self</span>.data))


    <span class="org-keyword">def</span> <span class="org-function-name">getFullyRealizedCube</span>(<span class="org-keyword">self</span>, cache<span class="org-operator">=</span><span class="org-constant">False</span>):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 3D array created by expanding the base data to the cube_shape resolution.</span>
<span class="org-doc">        Wherever possible, Numpy broadcasting is used to avoid memory allocation along</span>
<span class="org-doc">        constant array dimensions. When cache == True, this expanded 3D array is cached</span>
<span class="org-doc">        within the SpaceTimeCube object for future immediate retrieval.</span>
<span class="org-doc">        """</span>
        <span class="org-keyword">if</span> <span class="org-builtin">hasattr</span>(<span class="org-keyword">self</span>, <span class="org-string">"cube"</span>):
            <span class="org-keyword">return</span> <span class="org-keyword">self</span>.cube
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">cube</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.__getFullyRealizedCube()
            <span class="org-keyword">if</span> cache <span class="org-keyword">is</span> <span class="org-constant">True</span>:
                <span class="org-keyword">self</span>.<span class="org-variable-name">cube</span> <span class="org-operator">=</span> cube
            <span class="org-keyword">return</span> cube


    <span class="org-keyword">def</span> <span class="org-function-name">releaseFullyRealizedCube</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">"""</span>
<span class="org-doc">        Deletes the cached fully realized cube if it exists.</span>
<span class="org-doc">        """</span>
        <span class="org-keyword">if</span> <span class="org-builtin">hasattr</span>(<span class="org-keyword">self</span>, <span class="org-string">"cube"</span>):
            <span class="org-builtin">delattr</span>(<span class="org-keyword">self</span>, <span class="org-string">"cube"</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-lazyspacetimecube-class" class="outline-4">
<h4 id="lazyspacetimecube-class"><span class="section-number-4">3.1.5.</span> LazySpaceTimeCube Class</h4>
<div class="outline-text-4" id="text-lazyspacetimecube-class">
<p>
When a dataset is too large to fit easily into memory, it can be
partitioned into a collection of subcubes, which will be lazily loaded
on demand into a 3D cache grid of <code>SpaceTimeCube</code> objects provided by
the <code>LazySpaceTimeCube</code> class.
</p>

<p>
The <code>LazySpaceTimeCube</code> object will be created with a tuple of
user-specified spatio-temporal resolutions, called the <i>cube shape</i>,
which must be equal to or exact multiples of the <i>subcube shape</i>.
</p>

<p>
The various accessor functions provided by this class receive 3D
space-time coordinates at the <i>cube shape</i> resolution and will
correctly map them into the corresponding cache and subcube indexes.
Any intersected subcubes that are not already present in the cache
grid will be loaded on demand by calling a user-supplied
<code>load_subcube</code> function and stored in the cache grid for faster
retrieval later. If a bounded region of space-time that spans multiple
subcubes is requested via an accessor function, each of the
intersected subcubes will be loaded and cached, their relevant array
slices will be extracted, and these slices will be merged into a new
array at the <i>cube shape</i> resolution.
</p>

<p>
Fire spread simulations that use the <code>LazySpaceTimeCube</code> class will
only need to load into memory those subcubes which are intersected by
the expanding conical burn scar (see section <a href="#fires-as-conical-shapes-in-space-time">2.2</a>). In simulations of fires that are small relative to the
extent of the full 3D space-time environment, these memory savings may
be substantial and may make it possible to run simulations over larger
extents and/or finer resolutions than have been used previously.
</p>

<div class="org-src-container">
<pre class="src src-python" id="lazy-space-time-cube-class"><span class="org-type">@cy.cclass</span>
<span class="org-keyword">class</span> <span class="org-type">LazySpaceTimeCube</span>(ISpaceTimeCube):
    <span class="org-doc">"""</span>
<span class="org-doc">    Create an object that represents a 3D array with dimensions (T,Y,X) given by cube_shape.</span>
<span class="org-doc">    Internally, data is stored as an initially empty 3D array of SpaceTimeCube objects.</span>
<span class="org-doc">    Whenever a point value or contiguous space-time region of values is requested, identify</span>
<span class="org-doc">    which SpaceTimeCubes contain the requested coordinates, load them into the cache array</span>
<span class="org-doc">    by calling load_subcube for any that are not already present, request the values from</span>
<span class="org-doc">    these SpaceTimeCubes, combine them together if necessary, and return the resulting scalar</span>
<span class="org-doc">    value or array to the caller.</span>
<span class="org-doc">    """</span>
    ndim         : cy.<span class="org-builtin">int</span>
    size         : cy.ulonglong
    shape        : <span class="org-builtin">tuple</span>[cy.<span class="org-builtin">int</span>, cy.<span class="org-builtin">int</span>, cy.<span class="org-builtin">int</span>]
    subcube_shape: <span class="org-builtin">tuple</span>[cy.<span class="org-builtin">int</span>, cy.<span class="org-builtin">int</span>, cy.<span class="org-builtin">int</span>]
    cache_shape  : <span class="org-builtin">tuple</span>[cy.<span class="org-builtin">int</span>, cy.<span class="org-builtin">int</span>, cy.<span class="org-builtin">int</span>]
    cache        : ndarray
    load_subcube : <span class="org-builtin">object</span>


    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>,
                 cube_shape   : <span class="org-builtin">tuple</span>[<span class="org-builtin">int</span>, <span class="org-builtin">int</span>, <span class="org-builtin">int</span>],
                 subcube_shape: <span class="org-builtin">tuple</span>[<span class="org-builtin">int</span>, <span class="org-builtin">int</span>, <span class="org-builtin">int</span>],
                 load_subcube : <span class="org-builtin">object</span>) <span class="org-operator">-&gt;</span> cy.void:
        <span class="org-doc">"""</span>
<span class="org-doc">        NOTE: The resolutions in cube_shape must be exact multiples of those in subcube_shape.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that cube_shape and subcube_shape both contain 3 values or throw an error</span>
        <span class="org-keyword">if</span> <span class="org-builtin">len</span>(cube_shape) <span class="org-operator">!=</span> 3:
            <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The cube_shape must contain exactly three values."</span>)

        <span class="org-keyword">if</span> <span class="org-builtin">len</span>(subcube_shape) <span class="org-operator">!=</span> 3:
            <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The subcube_shape must contain exactly three values."</span>)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack the cube_shape values without type-checking</span>
        <span class="org-variable-name">cube_bands_</span>: <span class="org-builtin">object</span> <span class="org-operator">=</span> cube_shape[0]
        <span class="org-variable-name">cube_rows_</span> : <span class="org-builtin">object</span> <span class="org-operator">=</span> cube_shape[1]
        <span class="org-variable-name">cube_cols_</span> : <span class="org-builtin">object</span> <span class="org-operator">=</span> cube_shape[2]

        <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack the subcube_shape values without type-checking</span>
        <span class="org-variable-name">subcube_bands_</span>: <span class="org-builtin">object</span> <span class="org-operator">=</span> subcube_shape[0]
        <span class="org-variable-name">subcube_rows_</span> : <span class="org-builtin">object</span> <span class="org-operator">=</span> subcube_shape[1]
        <span class="org-variable-name">subcube_cols_</span> : <span class="org-builtin">object</span> <span class="org-operator">=</span> subcube_shape[2]

        <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that cube_shape and subcube_shape only contain positive integers or throw an error</span>
        <span class="org-keyword">if</span> <span class="org-keyword">not</span>(is_pos_int(cube_bands_) <span class="org-keyword">and</span> is_pos_int(cube_rows_) <span class="org-keyword">and</span> is_pos_int(cube_cols_)):
            <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The cube_shape must contain only positive integers."</span>)

        <span class="org-keyword">if</span> <span class="org-keyword">not</span>(is_pos_int(subcube_bands_) <span class="org-keyword">and</span> is_pos_int(subcube_rows_) <span class="org-keyword">and</span> is_pos_int(subcube_cols_)):
            <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The subcube_shape must contain only positive integers."</span>)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Cast the cube_shape values as primitive ints</span>
        <span class="org-variable-name">cube_bands</span>: cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> cube_bands_
        <span class="org-variable-name">cube_rows</span> : cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> cube_rows_
        <span class="org-variable-name">cube_cols</span> : cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> cube_cols_

        <span class="org-comment-delimiter"># </span><span class="org-comment">Cast the subcube_shape values as primitive ints</span>
        <span class="org-variable-name">subcube_bands</span>: cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> subcube_bands_
        <span class="org-variable-name">subcube_rows</span> : cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> subcube_rows_
        <span class="org-variable-name">subcube_cols</span> : cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> subcube_cols_

        <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that cube_shape is divided evenly by subcube_shape or throw an error</span>
        <span class="org-variable-name">cache_bands</span>: cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> divide_evenly(cube_bands, subcube_bands)
        <span class="org-variable-name">cache_rows</span> : cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> divide_evenly(cube_rows, subcube_rows)
        <span class="org-variable-name">cache_cols</span> : cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> divide_evenly(cube_cols, subcube_cols)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Store the cube metadata, subcube_shape, cache_shape, cache, and load_subcube functions for later</span>
        <span class="org-keyword">self</span>.<span class="org-variable-name">ndim</span>          <span class="org-operator">=</span> 3
        <span class="org-keyword">self</span>.<span class="org-variable-name">size</span>          <span class="org-operator">=</span> cube_bands <span class="org-operator">*</span> cube_rows <span class="org-operator">*</span> cube_cols
        <span class="org-keyword">self</span>.<span class="org-variable-name">shape</span>         <span class="org-operator">=</span> (cube_bands, cube_rows, cube_cols)
        <span class="org-keyword">self</span>.<span class="org-variable-name">subcube_shape</span> <span class="org-operator">=</span> (subcube_bands, subcube_rows, subcube_cols)
        <span class="org-keyword">self</span>.<span class="org-variable-name">cache_shape</span>   <span class="org-operator">=</span> (cache_bands, cache_rows, cache_cols)
        <span class="org-keyword">self</span>.<span class="org-variable-name">cache</span>         <span class="org-operator">=</span> np.empty(<span class="org-keyword">self</span>.cache_shape, dtype<span class="org-operator">=</span><span class="org-builtin">object</span>)
        <span class="org-keyword">self</span>.<span class="org-variable-name">load_subcube</span>  <span class="org-operator">=</span> load_subcube


    <span class="org-type">@cy.cfunc</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__getOrLoadSubcube</span>(<span class="org-keyword">self</span>, cache_t: pyidx, cache_y: pyidx, cache_x: pyidx) <span class="org-operator">-&gt;</span> SpaceTimeCube:
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the SpaceTimeCube stored at self.cache[cache_t, cache_y, cache_x] if it</span>
<span class="org-doc">        has already been loaded. Otherwise, call self.load_subcube to load it, store</span>
<span class="org-doc">        it in self.cache, and return it.</span>
<span class="org-doc">        """</span>
        <span class="org-variable-name">subcube</span>: SpaceTimeCube <span class="org-operator">=</span> cy.cast(SpaceTimeCube, <span class="org-keyword">self</span>.cache[cache_t, cache_y, cache_x])
        <span class="org-keyword">if</span> subcube:
            <span class="org-keyword">return</span> subcube
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">subcube</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.load_subcube((cache_t, cache_y, cache_x), <span class="org-keyword">self</span>.subcube_shape)
            <span class="org-keyword">self</span>.<span class="org-variable-name">cache</span>[<span class="org-variable-name">cache_t</span>, <span class="org-variable-name">cache_y</span>, <span class="org-variable-name">cache_x</span>] <span class="org-operator">=</span> subcube
            <span class="org-keyword">return</span> subcube


    <span class="org-type">@cy.ccall</span>
    <span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
    <span class="org-keyword">def</span> <span class="org-function-name">get</span>(<span class="org-keyword">self</span>, t: pyidx, y: pyidx, x: pyidx) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the scalar value at index (t,y,x) by translating these cube coordinates</span>
<span class="org-doc">        to cache and subcube coordinates, loading the matching subcube into the cache grid</span>
<span class="org-doc">        if not already present, and looking up the value within this subcube.</span>

<span class="org-doc">        NOTE: Indices may be negative provided that your load_subcube function can handle</span>
<span class="org-doc">              negative indices in its cache_index argument.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Grab the subcube_shape tuple</span>
        <span class="org-variable-name">subcube_shape</span>: <span class="org-builtin">tuple</span>[cy.<span class="org-builtin">int</span>, cy.<span class="org-builtin">int</span>, cy.<span class="org-builtin">int</span>] <span class="org-operator">=</span> <span class="org-keyword">self</span>.subcube_shape

        <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack the subcube_shape values</span>
        <span class="org-variable-name">subcube_bands</span>: cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> subcube_shape[0]
        <span class="org-variable-name">subcube_rows</span> : cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> subcube_shape[1]
        <span class="org-variable-name">subcube_cols</span> : cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> subcube_shape[2]

        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the cache index</span>
        <span class="org-variable-name">cache_t</span>: pyidx <span class="org-operator">=</span> t <span class="org-operator">//</span> subcube_bands
        <span class="org-variable-name">cache_y</span>: pyidx <span class="org-operator">=</span> y <span class="org-operator">//</span> subcube_rows
        <span class="org-variable-name">cache_x</span>: pyidx <span class="org-operator">=</span> x <span class="org-operator">//</span> subcube_cols

        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the subcube index</span>
        <span class="org-variable-name">subcube_t</span>: pyidx <span class="org-operator">=</span> t <span class="org-operator">%</span> subcube_bands
        <span class="org-variable-name">subcube_y</span>: pyidx <span class="org-operator">=</span> y <span class="org-operator">%</span> subcube_rows
        <span class="org-variable-name">subcube_x</span>: pyidx <span class="org-operator">=</span> x <span class="org-operator">%</span> subcube_cols

        <span class="org-comment-delimiter"># </span><span class="org-comment">Fetch the subcube from the cache</span>
        <span class="org-variable-name">subcube</span>: SpaceTimeCube <span class="org-operator">=</span> <span class="org-keyword">self</span>.__getOrLoadSubcube(cache_t, cache_y, cache_x)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Look up the scalar value in the subcube at the subcube index</span>
        <span class="org-keyword">return</span> subcube.get(subcube_t, subcube_y, subcube_x)


    <span class="org-keyword">def</span> <span class="org-function-name">getTimeSeries</span>(<span class="org-keyword">self</span>, t_range, y, x):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 1D array given by the slice (t_range,y,x) by translating these cube</span>
<span class="org-doc">        coordinates to cache and subcube coordinates, loading the matching subcubes into</span>
<span class="org-doc">        the cache grid if not already present, looking up the array slices within each</span>
<span class="org-doc">        subcube, and merging them together into a single 1D array.</span>

<span class="org-doc">        NOTE: Indices may be negative provided that your load_subcube function can handle</span>
<span class="org-doc">              negative indices in its cache_index argument.</span>
<span class="org-doc">        NOTE: Range indices may include one or more None values and</span>
<span class="org-doc">              provide (inclusion, exclusion) semantics like Python array slice notation.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the argument range</span>
        (<span class="org-variable-name">t_start</span>, <span class="org-variable-name">t_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(t_range, <span class="org-keyword">self</span>.shape[0])
        <span class="org-variable-name">t_stop</span> <span class="org-operator">=</span> t_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res coordinates to cache and subcube coordinates</span>
        (<span class="org-variable-name">subcube_bands</span>, <span class="org-variable-name">subcube_rows</span>, <span class="org-variable-name">subcube_cols</span>) <span class="org-operator">=</span> <span class="org-keyword">self</span>.subcube_shape
        (<span class="org-variable-name">cache_t_start</span>, <span class="org-variable-name">subcube_t_start</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(t_start, subcube_bands)
        (<span class="org-variable-name">cache_t_stop</span>,  <span class="org-variable-name">subcube_t_stop</span>)  <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(t_stop,  subcube_bands)
        (<span class="org-variable-name">cache_y</span>,       <span class="org-variable-name">subcube_y</span>)       <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(y,       subcube_rows)
        (<span class="org-variable-name">cache_x</span>,       <span class="org-variable-name">subcube_x</span>)       <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(x,       subcube_cols)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Load, expand, and combine subcubes</span>
        <span class="org-keyword">return</span> np.concatenate(
            [<span class="org-keyword">self</span>.__getOrLoadSubcube(cache_t,
                                     cache_y,
                                     cache_x
                                    ).getTimeSeries(
                                        (subcube_t_start    <span class="org-keyword">if</span> cache_t <span class="org-operator">==</span> cache_t_start <span class="org-keyword">else</span> 0,
                                         subcube_t_stop <span class="org-operator">+</span> 1 <span class="org-keyword">if</span> cache_t <span class="org-operator">==</span> cache_t_stop  <span class="org-keyword">else</span> subcube_bands),
                                        subcube_y,
                                        subcube_x
                                    )
             <span class="org-keyword">for</span> cache_t <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cache_t_start, cache_t_stop <span class="org-operator">+</span> 1)]
        )


    <span class="org-keyword">def</span> <span class="org-function-name">getSpatialPlane</span>(<span class="org-keyword">self</span>, t, y_range, x_range):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 2D array given by the slice (t,y_range,x_range) by translating these</span>
<span class="org-doc">        cube coordinates to cache and subcube coordinates, loading the matching subcubes</span>
<span class="org-doc">        into the cache grid if not already present, looking up the array slices within each</span>
<span class="org-doc">        subcube, and merging them together into a single 2D array.</span>

<span class="org-doc">        NOTE: Indices may be negative provided that your load_subcube function can handle</span>
<span class="org-doc">              negative indices in its cache_index argument.</span>
<span class="org-doc">        NOTE: Range indices may include one or more None values and</span>
<span class="org-doc">              provide (inclusion, exclusion) semantics like Python array slice notation.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the argument ranges</span>
        (<span class="org-variable-name">y_start</span>, <span class="org-variable-name">y_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(y_range, <span class="org-keyword">self</span>.shape[1])
        (<span class="org-variable-name">x_start</span>, <span class="org-variable-name">x_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(x_range, <span class="org-keyword">self</span>.shape[2])
        <span class="org-variable-name">y_stop</span> <span class="org-operator">=</span> y_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-variable-name">x_stop</span> <span class="org-operator">=</span> x_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res coordinates to cache and subcube coordinates</span>
        (<span class="org-variable-name">subcube_bands</span>, <span class="org-variable-name">subcube_rows</span>, <span class="org-variable-name">subcube_cols</span>) <span class="org-operator">=</span> <span class="org-keyword">self</span>.subcube_shape
        (<span class="org-variable-name">cache_t</span>,       <span class="org-variable-name">subcube_t</span>)       <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(t,       subcube_bands)
        (<span class="org-variable-name">cache_y_start</span>, <span class="org-variable-name">subcube_y_start</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(y_start, subcube_rows)
        (<span class="org-variable-name">cache_y_stop</span>,  <span class="org-variable-name">subcube_y_stop</span>)  <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(y_stop,  subcube_rows)
        (<span class="org-variable-name">cache_x_start</span>, <span class="org-variable-name">subcube_x_start</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(x_start, subcube_cols)
        (<span class="org-variable-name">cache_x_stop</span>,  <span class="org-variable-name">subcube_x_stop</span>)  <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(x_stop,  subcube_cols)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Load, expand, and combine subcubes</span>
        <span class="org-keyword">return</span> np.block(
            [[<span class="org-keyword">self</span>.__getOrLoadSubcube(cache_t,
                                      cache_y,
                                      cache_x
                                      ).getSpatialPlane(
                                          subcube_t,
                                          (subcube_y_start    <span class="org-keyword">if</span> cache_y <span class="org-operator">==</span> cache_y_start <span class="org-keyword">else</span> 0,
                                           subcube_y_stop <span class="org-operator">+</span> 1 <span class="org-keyword">if</span> cache_y <span class="org-operator">==</span> cache_y_stop  <span class="org-keyword">else</span> subcube_rows),
                                          (subcube_x_start    <span class="org-keyword">if</span> cache_x <span class="org-operator">==</span> cache_x_start <span class="org-keyword">else</span> 0,
                                           subcube_x_stop <span class="org-operator">+</span> 1 <span class="org-keyword">if</span> cache_x <span class="org-operator">==</span> cache_x_stop  <span class="org-keyword">else</span> subcube_cols)
                                      )
              <span class="org-keyword">for</span> cache_x <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cache_x_start, cache_x_stop <span class="org-operator">+</span> 1)]
             <span class="org-keyword">for</span> cache_y <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cache_y_start, cache_y_stop <span class="org-operator">+</span> 1)]
        )


    <span class="org-keyword">def</span> <span class="org-function-name">getSubcube</span>(<span class="org-keyword">self</span>, t_range, y_range, x_range):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 3D array given by the slice (t_range,y_range,x_range) by translating</span>
<span class="org-doc">        these cube coordinates to cache and subcube coordinates, loading the matching</span>
<span class="org-doc">        subcubes into the cache grid if not already present, looking up the array slices</span>
<span class="org-doc">        within each subcube, and merging them together into a single 3D array.</span>

<span class="org-doc">        NOTE: Indices may be negative provided that your load_subcube function can handle</span>
<span class="org-doc">              negative indices in its cache_index argument.</span>
<span class="org-doc">        NOTE: Range indices may include one or more None values and</span>
<span class="org-doc">              provide (inclusion, exclusion) semantics like Python array slice notation.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the argument ranges</span>
        (<span class="org-variable-name">t_start</span>, <span class="org-variable-name">t_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(t_range, <span class="org-keyword">self</span>.shape[0])
        (<span class="org-variable-name">y_start</span>, <span class="org-variable-name">y_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(y_range, <span class="org-keyword">self</span>.shape[1])
        (<span class="org-variable-name">x_start</span>, <span class="org-variable-name">x_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(x_range, <span class="org-keyword">self</span>.shape[2])
        <span class="org-variable-name">t_stop</span> <span class="org-operator">=</span> t_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-variable-name">y_stop</span> <span class="org-operator">=</span> y_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-variable-name">x_stop</span> <span class="org-operator">=</span> x_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res coordinates to cache and subcube coordinates</span>
        (<span class="org-variable-name">subcube_bands</span>, <span class="org-variable-name">subcube_rows</span>, <span class="org-variable-name">subcube_cols</span>) <span class="org-operator">=</span> <span class="org-keyword">self</span>.subcube_shape
        (<span class="org-variable-name">cache_t_start</span>, <span class="org-variable-name">subcube_t_start</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(t_start, subcube_bands)
        (<span class="org-variable-name">cache_t_stop</span>,  <span class="org-variable-name">subcube_t_stop</span>)  <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(t_stop,  subcube_bands)
        (<span class="org-variable-name">cache_y_start</span>, <span class="org-variable-name">subcube_y_start</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(y_start, subcube_rows)
        (<span class="org-variable-name">cache_y_stop</span>,  <span class="org-variable-name">subcube_y_stop</span>)  <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(y_stop,  subcube_rows)
        (<span class="org-variable-name">cache_x_start</span>, <span class="org-variable-name">subcube_x_start</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(x_start, subcube_cols)
        (<span class="org-variable-name">cache_x_stop</span>,  <span class="org-variable-name">subcube_x_stop</span>)  <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(x_stop,  subcube_cols)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Load, expand, and combine subcubes</span>
        <span class="org-keyword">return</span> np.block(
            [[[<span class="org-keyword">self</span>.__getOrLoadSubcube(cache_t,
                                       cache_y,
                                       cache_x
                                       ).getSubcube(
                                           (subcube_t_start    <span class="org-keyword">if</span> cache_t <span class="org-operator">==</span> cache_t_start <span class="org-keyword">else</span> 0,
                                            subcube_t_stop <span class="org-operator">+</span> 1 <span class="org-keyword">if</span> cache_t <span class="org-operator">==</span> cache_t_stop  <span class="org-keyword">else</span> subcube_bands),
                                           (subcube_y_start    <span class="org-keyword">if</span> cache_y <span class="org-operator">==</span> cache_y_start <span class="org-keyword">else</span> 0,
                                            subcube_y_stop <span class="org-operator">+</span> 1 <span class="org-keyword">if</span> cache_y <span class="org-operator">==</span> cache_y_stop  <span class="org-keyword">else</span> subcube_rows),
                                           (subcube_x_start    <span class="org-keyword">if</span> cache_x <span class="org-operator">==</span> cache_x_start <span class="org-keyword">else</span> 0,
                                            subcube_x_stop <span class="org-operator">+</span> 1 <span class="org-keyword">if</span> cache_x <span class="org-operator">==</span> cache_x_stop  <span class="org-keyword">else</span> subcube_cols)
                                       )
               <span class="org-keyword">for</span> cache_x <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cache_x_start, cache_x_stop <span class="org-operator">+</span> 1)]
              <span class="org-keyword">for</span> cache_y <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cache_y_start, cache_y_stop <span class="org-operator">+</span> 1)]
             <span class="org-keyword">for</span> cache_t <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cache_t_start, cache_t_stop <span class="org-operator">+</span> 1)]
        )


    <span class="org-keyword">def</span> <span class="org-function-name">getFullyRealizedCube</span>(<span class="org-keyword">self</span>, cache<span class="org-operator">=</span><span class="org-constant">False</span>):
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"getFullyRealizedCube is not implemented for LazySpaceTimeCube.</span><span class="org-constant">\n</span><span class="org-string">"</span>
                         <span class="org-operator">+</span> <span class="org-string">"You probably don't want to do this anyway."</span>)


    <span class="org-keyword">def</span> <span class="org-function-name">releaseFullyRealizedCube</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"releaseFullyRealizedCube is not implemented for LazySpaceTimeCube.</span><span class="org-constant">\n</span><span class="org-string">"</span>
                         <span class="org-operator">+</span> <span class="org-string">"You probably don't want to do this anyway."</span>)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-for-users-spacetimecube" class="outline-3">
<h3 id="for-users-spacetimecube"><span class="section-number-3">3.2.</span> For Users</h3>
<div class="outline-text-3" id="text-for-users-spacetimecube">
<p>
In the following sections, we will use functions from <a href="https://pypi.org/project/numpy/">numpy</a> and the
Python standard library to construct arrays of different resolutions
in memory to use in our <code>SpaceTimeCube</code> and <code>LazySpaceTimeCube</code>
examples. In many real world applications, this array data will
probably be read in from files or databases using Python libraries
such as <a href="https://pypi.org/project/rasterio/">rasterio</a> or <a href="https://pypi.org/project/psycopg2/">psycopg2</a>. All examples should apply equally well
in either case.
</p>
</div>

<div id="outline-container-how-to-use-spacetimecube" class="outline-4">
<h4 id="how-to-use-spacetimecube"><span class="section-number-4">3.2.1.</span> How to Use SpaceTimeCube</h4>
<div class="outline-text-4" id="text-how-to-use-spacetimecube">
</div>
<ol class="org-ol">
<li><a id="create-a-spacetimecube-from-0d,-1d,-2d,-or-3d-input-data"></a>Create a SpaceTimeCube from 0D, 1D, 2D, or 3D Input Data<br>
<div class="outline-text-5" id="text-create-a-spacetimecube-from-0d,-1d,-2d,-or-3d-input-data">
<div class="org-src-container">
<pre class="src src-python" id="space-time-cube-create"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Set a Random Seed</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

np.random.seed(0)

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube Dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (
    240,  <span class="org-comment-delimiter"># </span><span class="org-comment">bands: 10 days @ 1 hour/band</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">rows:  30 km @ 30 meters/row</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">cols:  30 km @ 30 meters/col</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Constant Data: foliar moisture = 70% everywhere</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">foliar_moisture</span> <span class="org-operator">=</span> 0.7
<span class="org-variable-name">constant_cube</span>   <span class="org-operator">=</span> SpaceTimeCube(cube_shape, foliar_moisture)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Temporal Data: 24-hour burn period with ramp up and ramp down for 10 days</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">spread_rate_adjustments</span> <span class="org-operator">=</span> ([0] <span class="org-operator">*</span> 6 <span class="org-operator">+</span> [0.33, 0.66] <span class="org-operator">+</span> [1] <span class="org-operator">*</span> 12 <span class="org-operator">+</span> [0.66, 0.33] <span class="org-operator">+</span> [0] <span class="org-operator">*</span> 2) <span class="org-operator">*</span> 10
<span class="org-variable-name">time_series_cube</span>        <span class="org-operator">=</span> SpaceTimeCube(cube_shape, spread_rate_adjustments)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Spatial Data: 2D elevation raster with 1000 (30m) x 1000 (30m) cells</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">elevation_raster</span> <span class="org-operator">=</span> np.random.normal(500, 100, 1000000).astype(<span class="org-string">"int"</span>).reshape(1000,1000)
<span class="org-variable-name">spatial_cube</span>     <span class="org-operator">=</span> SpaceTimeCube(cube_shape, elevation_raster)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Spatio-Temporal Data: 3D daily max wind speed raster with 10 (days) x 100 (300m) x 100 (300m) cells</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">wind_speed_raster</span>   <span class="org-operator">=</span> np.random.normal(30, 5, 100000).astype(<span class="org-string">"int"</span>).reshape(10,100,100)
<span class="org-variable-name">spatiotemporal_cube</span> <span class="org-operator">=</span> SpaceTimeCube(cube_shape, wind_speed_raster)
</pre>
</div>
</div>
</li>

<li><a id="retrieve-a-scalar-value-at-a-space-time-coordinate"></a>Retrieve a Scalar Value at a Space-Time Coordinate<br>
<div class="outline-text-5" id="text-retrieve-a-scalar-value-at-a-space-time-coordinate">
<div class="org-src-container">
<pre class="src src-python" id="space-time-cube-get-point"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinate</span>
<span class="org-variable-name">band</span> <span class="org-operator">=</span> 12
<span class="org-variable-name">row</span>  <span class="org-operator">=</span> 100
<span class="org-variable-name">col</span>  <span class="org-operator">=</span> 100

<span class="org-builtin">print</span>(<span class="org-string">"Value from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.get(band, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Value from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.get(band, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Value from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.get(band, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Value from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.get(band, row, col))
</pre>
</div>

<pre class="example" id="space-time-cube-get-point-results">
Value from Constant Data: Foliar Moisture
0.699999988079071 

Value from Time Series Data: Spread Rate Adjustment
1.0 

Value from Spatial Data: Elevation
564.0 

Value from Spatio-Temporal Data: Wind Speed
32.0
</pre>
</div>
</li>

<li><a id="retrieve-a-time-series-at-a-spatial-coordinate"></a>Retrieve a Time Series at a Spatial Coordinate<br>
<div class="outline-text-5" id="text-retrieve-a-time-series-at-a-spatial-coordinate">
<div class="org-src-container">
<pre class="src src-python" id="space-time-cube-get-time-series"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinates</span>
<span class="org-variable-name">band_range</span> <span class="org-operator">=</span> (18,30)
<span class="org-variable-name">row</span>        <span class="org-operator">=</span> 100
<span class="org-variable-name">col</span>        <span class="org-operator">=</span> 100

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.getTimeSeries(band_range, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.getTimeSeries(band_range, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.getTimeSeries(band_range, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.getTimeSeries(band_range, row, col))
</pre>
</div>

<pre class="example" id="space-time-cube-get-time-series-results">
Time Series from Constant Data: Foliar Moisture
[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7] 

Time Series from Time Series Data: Spread Rate Adjustment
[1.   1.   0.66 0.33 0.   0.   0.   0.   0.   0.   0.   0.  ] 

Time Series from Spatial Data: Elevation
[564. 564. 564. 564. 564. 564. 564. 564. 564. 564. 564. 564.] 

Time Series from Spatio-Temporal Data: Wind Speed
[32. 32. 32. 32. 32. 32. 37. 37. 37. 37. 37. 37.]
</pre>
</div>
</li>

<li><a id="retrieve-a-spatial-plane-at-a-temporal-coordinate"></a>Retrieve a Spatial Plane at a Temporal Coordinate<br>
<div class="outline-text-5" id="text-retrieve-a-spatial-plane-at-a-temporal-coordinate">
<div class="org-src-container">
<pre class="src src-python" id="space-time-cube-get-spatial-plane"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinates</span>
<span class="org-variable-name">band</span>      <span class="org-operator">=</span> 12
<span class="org-variable-name">row_range</span> <span class="org-operator">=</span> (95,105)
<span class="org-variable-name">col_range</span> <span class="org-operator">=</span> (95,105)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.getSpatialPlane(band, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.getSpatialPlane(band, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.getSpatialPlane(band, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.getSpatialPlane(band, row_range, col_range))
</pre>
</div>

<pre class="example" id="space-time-cube-get-spatial-plane-results">
Spatial Plane from Constant Data: Foliar Moisture
[[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]] 

Spatial Plane from Time Series Data: Spread Rate Adjustment
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]] 

Spatial Plane from Spatial Data: Elevation
[[574. 369. 544. 310. 517. 488. 565. 549. 450. 470.]
 [443. 551. 480. 476. 432. 561. 578. 361. 468. 480.]
 [520. 712. 396. 393. 584. 292. 424. 391. 494. 586.]
 [707. 534. 246. 423. 521. 500. 426. 340. 288. 482.]
 [542. 285. 607. 555. 645. 559. 461. 603. 330. 452.]
 [498. 497. 664. 445. 518. 564. 461. 508. 600. 380.]
 [454. 500. 276. 487. 447. 591. 413. 378. 458. 508.]
 [573. 890. 485. 501. 357. 413. 356. 635. 374. 618.]
 [535. 558. 491. 482. 539. 572. 598. 703. 463. 329.]
 [487. 555. 580. 492. 462. 484. 495. 396. 711. 356.]] 

Spatial Plane from Spatio-Temporal Data: Wind Speed
[[31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
 [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
 [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
 [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
 [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
 [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
 [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
 [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
 [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
 [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]]
</pre>
</div>
</li>

<li><a id="retrieve-a-subcube-within-a-space-time-region"></a>Retrieve a Subcube within a Space-Time Region<br>
<div class="outline-text-5" id="text-retrieve-a-subcube-within-a-space-time-region">
<div class="org-src-container">
<pre class="src src-python" id="space-time-cube-get-subcube"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinates</span>
<span class="org-variable-name">band_range</span> <span class="org-operator">=</span> (23,25)
<span class="org-variable-name">row_range</span>  <span class="org-operator">=</span> (95,105)
<span class="org-variable-name">col_range</span>  <span class="org-operator">=</span> (95,105)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.getSubcube(band_range, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.getSubcube(band_range, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.getSubcube(band_range, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.getSubcube(band_range, row_range, col_range))
</pre>
</div>

<pre class="example" id="space-time-cube-get-subcube-results">
Subcube from Constant Data: Foliar Moisture
[[[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]]

 [[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]]] 

Subcube from Time Series Data: Spread Rate Adjustment
[[[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]]

 [[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]]] 

Subcube from Spatial Data: Elevation
[[[574. 369. 544. 310. 517. 488. 565. 549. 450. 470.]
  [443. 551. 480. 476. 432. 561. 578. 361. 468. 480.]
  [520. 712. 396. 393. 584. 292. 424. 391. 494. 586.]
  [707. 534. 246. 423. 521. 500. 426. 340. 288. 482.]
  [542. 285. 607. 555. 645. 559. 461. 603. 330. 452.]
  [498. 497. 664. 445. 518. 564. 461. 508. 600. 380.]
  [454. 500. 276. 487. 447. 591. 413. 378. 458. 508.]
  [573. 890. 485. 501. 357. 413. 356. 635. 374. 618.]
  [535. 558. 491. 482. 539. 572. 598. 703. 463. 329.]
  [487. 555. 580. 492. 462. 484. 495. 396. 711. 356.]]

 [[574. 369. 544. 310. 517. 488. 565. 549. 450. 470.]
  [443. 551. 480. 476. 432. 561. 578. 361. 468. 480.]
  [520. 712. 396. 393. 584. 292. 424. 391. 494. 586.]
  [707. 534. 246. 423. 521. 500. 426. 340. 288. 482.]
  [542. 285. 607. 555. 645. 559. 461. 603. 330. 452.]
  [498. 497. 664. 445. 518. 564. 461. 508. 600. 380.]
  [454. 500. 276. 487. 447. 591. 413. 378. 458. 508.]
  [573. 890. 485. 501. 357. 413. 356. 635. 374. 618.]
  [535. 558. 491. 482. 539. 572. 598. 703. 463. 329.]
  [487. 555. 580. 492. 462. 484. 495. 396. 711. 356.]]] 

Subcube from Spatio-Temporal Data: Wind Speed
[[[31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
  [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
  [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
  [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
  [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
  [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
  [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
  [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
  [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
  [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]]

 [[30. 30. 30. 30. 30. 36. 36. 36. 36. 36.]
  [30. 30. 30. 30. 30. 36. 36. 36. 36. 36.]
  [30. 30. 30. 30. 30. 36. 36. 36. 36. 36.]
  [30. 30. 30. 30. 30. 36. 36. 36. 36. 36.]
  [30. 30. 30. 30. 30. 36. 36. 36. 36. 36.]
  [34. 34. 34. 34. 34. 37. 37. 37. 37. 37.]
  [34. 34. 34. 34. 34. 37. 37. 37. 37. 37.]
  [34. 34. 34. 34. 34. 37. 37. 37. 37. 37.]
  [34. 34. 34. 34. 34. 37. 37. 37. 37. 37.]
  [34. 34. 34. 34. 34. 37. 37. 37. 37. 37.]]]
</pre>
</div>
</li>
</ol>
</div>

<div id="outline-container-how-to-use-lazyspacetimecube" class="outline-4">
<h4 id="how-to-use-lazyspacetimecube"><span class="section-number-4">3.2.2.</span> How to Use LazySpaceTimeCube</h4>
<div class="outline-text-4" id="text-how-to-use-lazyspacetimecube">
</div>
<ol class="org-ol">
<li><a id="create-a-lazyspacetimecube-from-0d,-1d,-2d,-or-3d-input-data"></a>Create a LazySpaceTimeCube from 0D, 1D, 2D, or 3D Input Data<br>
<div class="outline-text-5" id="text-create-a-lazyspacetimecube-from-0d,-1d,-2d,-or-3d-input-data">
<div class="org-src-container">
<pre class="src src-python" id="lazy-space-time-cube-create"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube, LazySpaceTimeCube

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Set a Random Seed</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

np.random.seed(0)

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube Dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (
    240,  <span class="org-comment-delimiter"># </span><span class="org-comment">bands: 10 days @ 1 hour/band</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">rows:  30 km @ 30 meters/row</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">cols:  30 km @ 30 meters/col</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Constant Data: foliar moisture = 70% everywhere</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">foliar_moisture</span>               <span class="org-operator">=</span> 0.7
<span class="org-variable-name">foliar_moisture_subcube_shape</span> <span class="org-operator">=</span> cube_shape <span class="org-comment-delimiter"># </span><span class="org-comment">Only 1 subcube necessary</span>

<span class="org-keyword">def</span> <span class="org-function-name">foliar_moisture_load_subcube</span>(_, subcube_shape):
    <span class="org-keyword">return</span> SpaceTimeCube(subcube_shape, foliar_moisture)

<span class="org-variable-name">constant_cube</span> <span class="org-operator">=</span> LazySpaceTimeCube(cube_shape,
                                  foliar_moisture_subcube_shape,
                                  foliar_moisture_load_subcube)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Temporal Data: 24-hour burn period with ramp up and ramp down for 10 days</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">spread_rate_adjustments</span>               <span class="org-operator">=</span> ([0] <span class="org-operator">*</span> 6 <span class="org-operator">+</span> [0.33, 0.66] <span class="org-operator">+</span> [1] <span class="org-operator">*</span> 12 <span class="org-operator">+</span> [0.66, 0.33] <span class="org-operator">+</span> [0] <span class="org-operator">*</span> 2) <span class="org-operator">*</span> 10
<span class="org-variable-name">spread_rate_adjustments_subcube_shape</span> <span class="org-operator">=</span> (24, 1000, 1000) <span class="org-comment-delimiter"># </span><span class="org-comment">1 subcube per day (10 total)</span>

<span class="org-keyword">def</span> <span class="org-function-name">spread_rate_adjustments_load_subcube</span>(cache_index, subcube_shape):
    (<span class="org-variable-name">cache_t</span>, <span class="org-variable-name">_</span>, <span class="org-variable-name">_</span>) <span class="org-operator">=</span> cache_index
    <span class="org-variable-name">t_start</span> <span class="org-operator">=</span> 24 <span class="org-operator">*</span> cache_t
    <span class="org-variable-name">t_stop</span>  <span class="org-operator">=</span> 24 <span class="org-operator">*</span> (cache_t <span class="org-operator">+</span> 1)
    <span class="org-keyword">return</span> SpaceTimeCube(subcube_shape,
                         spread_rate_adjustments[t_start:t_stop])

<span class="org-variable-name">time_series_cube</span> <span class="org-operator">=</span> LazySpaceTimeCube(cube_shape,
                                     spread_rate_adjustments_subcube_shape,
                                     spread_rate_adjustments_load_subcube)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Spatial Data: 2D elevation raster with 1000 (30m) x 1000 (30m) cells</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">elevation_raster</span>               <span class="org-operator">=</span> np.random.normal(500, 100, 1000000).astype(<span class="org-string">"int"</span>).reshape(1000,1000)
<span class="org-variable-name">elevation_raster_subcube_shape</span> <span class="org-operator">=</span> (240, 100, 100) <span class="org-comment-delimiter"># </span><span class="org-comment">1 subcube per 100x100 cell region (10x10 = 100 total)</span>

<span class="org-keyword">def</span> <span class="org-function-name">elevation_raster_load_subcube</span>(cache_index, subcube_shape):
    (<span class="org-variable-name">_</span>, <span class="org-variable-name">cache_y</span>, <span class="org-variable-name">cache_x</span>) <span class="org-operator">=</span> cache_index
    <span class="org-variable-name">y_start</span> <span class="org-operator">=</span> 100 <span class="org-operator">*</span> cache_y
    <span class="org-variable-name">y_stop</span>  <span class="org-operator">=</span> 100 <span class="org-operator">*</span> (cache_y <span class="org-operator">+</span> 1)
    <span class="org-variable-name">x_start</span> <span class="org-operator">=</span> 100 <span class="org-operator">*</span> cache_x
    <span class="org-variable-name">x_stop</span>  <span class="org-operator">=</span> 100 <span class="org-operator">*</span> (cache_x <span class="org-operator">+</span> 1)
    <span class="org-keyword">return</span> SpaceTimeCube(subcube_shape,
                         elevation_raster[y_start:y_stop,
                                          x_start:x_stop])

<span class="org-variable-name">spatial_cube</span> <span class="org-operator">=</span> LazySpaceTimeCube(cube_shape,
                                 elevation_raster_subcube_shape,
                                 elevation_raster_load_subcube)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Spatio-Temporal Data: 3D daily max wind speed raster with 10 (days) x 100 (300m) x 100 (300m) cells</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">wind_speed_raster</span>               <span class="org-operator">=</span> np.random.normal(30, 5, 100000).astype(<span class="org-string">"int"</span>).reshape(10,100,100)
<span class="org-variable-name">wind_speed_raster_subcube_shape</span> <span class="org-operator">=</span> (24, 100, 100) <span class="org-comment-delimiter"># </span><span class="org-comment">1 subcube per day per 100x100 cell region (10x10x10 = 1000 total)</span>

<span class="org-keyword">def</span> <span class="org-function-name">wind_speed_raster_load_subcube</span>(cache_index, subcube_shape):
    (<span class="org-variable-name">cache_t</span>, <span class="org-variable-name">cache_y</span>, <span class="org-variable-name">cache_x</span>) <span class="org-operator">=</span> cache_index
    <span class="org-variable-name">t_start</span> <span class="org-operator">=</span> cache_t
    <span class="org-variable-name">t_stop</span>  <span class="org-operator">=</span> cache_t <span class="org-operator">+</span> 1
    <span class="org-variable-name">y_start</span> <span class="org-operator">=</span> 10 <span class="org-operator">*</span> cache_y
    <span class="org-variable-name">y_stop</span>  <span class="org-operator">=</span> 10 <span class="org-operator">*</span> (cache_y <span class="org-operator">+</span> 1)
    <span class="org-variable-name">x_start</span> <span class="org-operator">=</span> 10 <span class="org-operator">*</span> cache_x
    <span class="org-variable-name">x_stop</span>  <span class="org-operator">=</span> 10 <span class="org-operator">*</span> (cache_x <span class="org-operator">+</span> 1)
    <span class="org-keyword">return</span> SpaceTimeCube(subcube_shape,
                         wind_speed_raster[t_start:t_stop,
                                           y_start:y_stop,
                                           x_start:x_stop])

<span class="org-variable-name">spatiotemporal_cube</span> <span class="org-operator">=</span> LazySpaceTimeCube(cube_shape,
                                        wind_speed_raster_subcube_shape,
                                        wind_speed_raster_load_subcube)
</pre>
</div>
</div>
</li>

<li><a id="retrieve-a-scalar-value-at-a-space-time-coordinate"></a>Retrieve a Scalar Value at a Space-Time Coordinate<br>
<div class="outline-text-5" id="text-retrieve-a-scalar-value-at-a-space-time-coordinate">
<div class="org-src-container">
<pre class="src src-python" id="lazy-space-time-cube-get-point"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinate</span>
<span class="org-variable-name">band</span> <span class="org-operator">=</span> 12
<span class="org-variable-name">row</span>  <span class="org-operator">=</span> 100
<span class="org-variable-name">col</span>  <span class="org-operator">=</span> 100

<span class="org-builtin">print</span>(<span class="org-string">"Value from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.get(band, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Value from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.get(band, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Value from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.get(band, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Value from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.get(band, row, col))
</pre>
</div>

<pre class="example" id="lazy-space-time-cube-get-point-results">
Value from Constant Data: Foliar Moisture
0.699999988079071 

Value from Time Series Data: Spread Rate Adjustment
WARNING: Input data is not a Numpy float32 array. Data will be copied into SpaceTimeCube.
1.0 

Value from Spatial Data: Elevation
WARNING: Input data is not a Numpy float32 array. Data will be copied into SpaceTimeCube.
564.0 

Value from Spatio-Temporal Data: Wind Speed
WARNING: Input data is not a Numpy float32 array. Data will be copied into SpaceTimeCube.
32.0
</pre>
</div>
</li>

<li><a id="retrieve-a-time-series-at-a-spatial-coordinate"></a>Retrieve a Time Series at a Spatial Coordinate<br>
<div class="outline-text-5" id="text-retrieve-a-time-series-at-a-spatial-coordinate">
<div class="org-src-container">
<pre class="src src-python" id="lazy-space-time-cube-get-time-series"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinates</span>
<span class="org-variable-name">band_range</span> <span class="org-operator">=</span> (18,30)
<span class="org-variable-name">row</span>        <span class="org-operator">=</span> 100
<span class="org-variable-name">col</span>        <span class="org-operator">=</span> 100

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.getTimeSeries(band_range, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.getTimeSeries(band_range, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.getTimeSeries(band_range, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.getTimeSeries(band_range, row, col))
</pre>
</div>

<pre class="example" id="lazy-space-time-cube-get-time-series-results">
Time Series from Constant Data: Foliar Moisture
[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7] 

Time Series from Time Series Data: Spread Rate Adjustment
WARNING: Input data is not a Numpy float32 array. Data will be copied into SpaceTimeCube.
[1.   1.   0.66 0.33 0.   0.   0.   0.   0.   0.   0.   0.  ] 

Time Series from Spatial Data: Elevation
[564. 564. 564. 564. 564. 564. 564. 564. 564. 564. 564. 564.] 

Time Series from Spatio-Temporal Data: Wind Speed
WARNING: Input data is not a Numpy float32 array. Data will be copied into SpaceTimeCube.
[32. 32. 32. 32. 32. 32. 37. 37. 37. 37. 37. 37.]
</pre>
</div>
</li>

<li><a id="retrieve-a-spatial-plane-at-a-temporal-coordinate"></a>Retrieve a Spatial Plane at a Temporal Coordinate<br>
<div class="outline-text-5" id="text-retrieve-a-spatial-plane-at-a-temporal-coordinate">
<div class="org-src-container">
<pre class="src src-python" id="lazy-space-time-cube-get-spatial-plane"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinates</span>
<span class="org-variable-name">band</span>      <span class="org-operator">=</span> 12
<span class="org-variable-name">row_range</span> <span class="org-operator">=</span> (95,105)
<span class="org-variable-name">col_range</span> <span class="org-operator">=</span> (95,105)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.getSpatialPlane(band, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.getSpatialPlane(band, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.getSpatialPlane(band, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.getSpatialPlane(band, row_range, col_range))
</pre>
</div>

<pre class="example" id="lazy-space-time-cube-get-spatial-plane-results">
Spatial Plane from Constant Data: Foliar Moisture
[[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]] 

Spatial Plane from Time Series Data: Spread Rate Adjustment
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]] 

Spatial Plane from Spatial Data: Elevation
WARNING: Input data is not a Numpy float32 array. Data will be copied into SpaceTimeCube.
WARNING: Input data is not a Numpy float32 array. Data will be copied into SpaceTimeCube.
WARNING: Input data is not a Numpy float32 array. Data will be copied into SpaceTimeCube.
[[574. 369. 544. 310. 517. 488. 565. 549. 450. 470.]
 [443. 551. 480. 476. 432. 561. 578. 361. 468. 480.]
 [520. 712. 396. 393. 584. 292. 424. 391. 494. 586.]
 [707. 534. 246. 423. 521. 500. 426. 340. 288. 482.]
 [542. 285. 607. 555. 645. 559. 461. 603. 330. 452.]
 [498. 497. 664. 445. 518. 564. 461. 508. 600. 380.]
 [454. 500. 276. 487. 447. 591. 413. 378. 458. 508.]
 [573. 890. 485. 501. 357. 413. 356. 635. 374. 618.]
 [535. 558. 491. 482. 539. 572. 598. 703. 463. 329.]
 [487. 555. 580. 492. 462. 484. 495. 396. 711. 356.]] 

Spatial Plane from Spatio-Temporal Data: Wind Speed
WARNING: Input data is not a Numpy float32 array. Data will be copied into SpaceTimeCube.
WARNING: Input data is not a Numpy float32 array. Data will be copied into SpaceTimeCube.
WARNING: Input data is not a Numpy float32 array. Data will be copied into SpaceTimeCube.
[[31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
 [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
 [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
 [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
 [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
 [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
 [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
 [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
 [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
 [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]]
</pre>
</div>
</li>

<li><a id="retrieve-a-subcube-within-a-space-time-region"></a>Retrieve a Subcube within a Space-Time Region<br>
<div class="outline-text-5" id="text-retrieve-a-subcube-within-a-space-time-region">
<div class="org-src-container">
<pre class="src src-python" id="lazy-space-time-cube-get-subcube"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinates</span>
<span class="org-variable-name">band_range</span> <span class="org-operator">=</span> (23,25)
<span class="org-variable-name">row_range</span>  <span class="org-operator">=</span> (95,105)
<span class="org-variable-name">col_range</span>  <span class="org-operator">=</span> (95,105)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.getSubcube(band_range, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.getSubcube(band_range, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.getSubcube(band_range, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.getSubcube(band_range, row_range, col_range))
</pre>
</div>

<pre class="example" id="lazy-space-time-cube-get-subcube-results">
Subcube from Constant Data: Foliar Moisture
[[[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]]

 [[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]]] 

Subcube from Time Series Data: Spread Rate Adjustment
[[[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]]

 [[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]]] 

Subcube from Spatial Data: Elevation
[[[574. 369. 544. 310. 517. 488. 565. 549. 450. 470.]
  [443. 551. 480. 476. 432. 561. 578. 361. 468. 480.]
  [520. 712. 396. 393. 584. 292. 424. 391. 494. 586.]
  [707. 534. 246. 423. 521. 500. 426. 340. 288. 482.]
  [542. 285. 607. 555. 645. 559. 461. 603. 330. 452.]
  [498. 497. 664. 445. 518. 564. 461. 508. 600. 380.]
  [454. 500. 276. 487. 447. 591. 413. 378. 458. 508.]
  [573. 890. 485. 501. 357. 413. 356. 635. 374. 618.]
  [535. 558. 491. 482. 539. 572. 598. 703. 463. 329.]
  [487. 555. 580. 492. 462. 484. 495. 396. 711. 356.]]

 [[574. 369. 544. 310. 517. 488. 565. 549. 450. 470.]
  [443. 551. 480. 476. 432. 561. 578. 361. 468. 480.]
  [520. 712. 396. 393. 584. 292. 424. 391. 494. 586.]
  [707. 534. 246. 423. 521. 500. 426. 340. 288. 482.]
  [542. 285. 607. 555. 645. 559. 461. 603. 330. 452.]
  [498. 497. 664. 445. 518. 564. 461. 508. 600. 380.]
  [454. 500. 276. 487. 447. 591. 413. 378. 458. 508.]
  [573. 890. 485. 501. 357. 413. 356. 635. 374. 618.]
  [535. 558. 491. 482. 539. 572. 598. 703. 463. 329.]
  [487. 555. 580. 492. 462. 484. 495. 396. 711. 356.]]] 

Subcube from Spatio-Temporal Data: Wind Speed
WARNING: Input data is not a Numpy float32 array. Data will be copied into SpaceTimeCube.
WARNING: Input data is not a Numpy float32 array. Data will be copied into SpaceTimeCube.
WARNING: Input data is not a Numpy float32 array. Data will be copied into SpaceTimeCube.
[[[31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
  [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
  [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
  [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
  [31. 31. 31. 31. 31. 31. 31. 31. 31. 31.]
  [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
  [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
  [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
  [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]
  [26. 26. 26. 26. 26. 32. 32. 32. 32. 32.]]

 [[30. 30. 30. 30. 30. 36. 36. 36. 36. 36.]
  [30. 30. 30. 30. 30. 36. 36. 36. 36. 36.]
  [30. 30. 30. 30. 30. 36. 36. 36. 36. 36.]
  [30. 30. 30. 30. 30. 36. 36. 36. 36. 36.]
  [30. 30. 30. 30. 30. 36. 36. 36. 36. 36.]
  [34. 34. 34. 34. 34. 37. 37. 37. 37. 37.]
  [34. 34. 34. 34. 34. 37. 37. 37. 37. 37.]
  [34. 34. 34. 34. 34. 37. 37. 37. 37. 37.]
  [34. 34. 34. 34. 34. 37. 37. 37. 37. 37.]
  [34. 34. 34. 34. 34. 37. 37. 37. 37. 37.]]]
</pre>
</div>
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-fuel-model-and-moisture-definitions-(pyretechnics.fuel_models)" class="outline-2">
<h2 id="fuel-model-and-moisture-definitions-(pyretechnics.fuel_models)"><span class="section-number-2">4.</span> Fuel Model and Moisture Definitions (pyretechnics.fuel_models)</h2>
<div class="outline-text-2" id="text-fuel-model-and-moisture-definitions-(pyretechnics.fuel_models)">
</div>
<div id="outline-container-for-developers-fuel" class="outline-3">
<h3 id="for-developers-fuel"><span class="section-number-3">4.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-for-developers-fuel">
<p>
The following sections encode various fire behavior fuel models as
Python dictionaries and then provide functions to augment their static
properties with additional information that is dependent upon fuel
moisture. This combination of fuel models and moisture form the basis
of many fire behavior analyses.
</p>
</div>

<div id="outline-container-module-imports-fuel-models" class="outline-4">
<h4 id="module-imports-fuel-models"><span class="section-number-4">4.1.1.</span> Module Imports</h4>
<div class="outline-text-4" id="text-module-imports-fuel-models">
<div class="org-src-container">
<pre class="src src-python" id="fuel-models-imports"><span class="org-keyword">import</span> cython
<span class="org-keyword">import</span> cython <span class="org-keyword">as</span> cy
<span class="org-keyword">if</span> cython.compiled:
    <span class="org-keyword">from</span> cython.cimports.libc.math <span class="org-keyword">import</span> exp
    <span class="org-keyword">from</span> cython.cimports.pyretechnics.cy_types <span class="org-keyword">import</span> fcatarr, fclaarr, CompactFuelModel, FuelModel
<span class="org-keyword">else</span>:
    <span class="org-keyword">from</span> math <span class="org-keyword">import</span> exp
    <span class="org-keyword">from</span> pyretechnics.py_types <span class="org-keyword">import</span> fcatarr, fclaarr, CompactFuelModel, FuelModel
</pre>
</div>
</div>
</div>

<div id="outline-container-fuel-model-properties" class="outline-4">
<h4 id="fuel-model-properties"><span class="section-number-4">4.1.2.</span> Fuel Model Properties</h4>
<div class="outline-text-4" id="text-fuel-model-properties">
<p>
All fires ignite and travel through some form of burnable fuel.
Although the effects of wind and slope on the rate of fire spread can
be quite pronounced, its fundamental thermodynamic characteristics are
largely determined by the fuel type in which it is sustained. For
wildfires, these fuels are predominantly herbaceous and woody
vegetation (both alive and dead) as well as decomposing elements of
dead vegetation, such as duff or leaf litter. To estimate the heat
output and rate of spread of a fire burning through any of these
fuels, we must determine those physical properties that affect heat
absorption and release.
</p>

<p>
Of course, measuring these fuel properties for every kind of
vegetation that may be burned in a wildfire is an intractable task. To
cope with this, fuels are classified into categories called "fuel
models" which share similar burning characteristics. Each fuel model
is then assigned a set of representative values for each of the
thermally relevant physical properties shown in Table
<a href="#tab:fuel-model-properties">1</a>.
</p>

<table id="tab:fuel-model-properties">
<caption class="t-above"><span class="table-number">Table 1:</span> Physical properties assigned to each fuel model</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Property</th>
<th scope="col" class="org-left">Description</th>
<th scope="col" class="org-left">Units</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">\(\delta\)</td>
<td class="org-left">fuel depth</td>
<td class="org-left">\(\text{ft}\)</td>
</tr>

<tr>
<td class="org-left">\(w_o\)</td>
<td class="org-left">ovendry fuel loading</td>
<td class="org-left">\(\text{lb}/\text{ft}^2\)</td>
</tr>

<tr>
<td class="org-left">\(\rho_p\)</td>
<td class="org-left">ovendry particle density</td>
<td class="org-left">\(\text{lb}/\text{ft}^3\)</td>
</tr>

<tr>
<td class="org-left">\(\sigma\)</td>
<td class="org-left">fuel particle surface-area-to-volume ratio</td>
<td class="org-left">\(\text{ft}^2/\text{ft}^3\)</td>
</tr>

<tr>
<td class="org-left">\(h\)</td>
<td class="org-left">fuel particle low heat content</td>
<td class="org-left">\(\text{Btu}/\text{lb}\)</td>
</tr>

<tr>
<td class="org-left">\(S_T\)</td>
<td class="org-left">fuel particle total mineral content</td>
<td class="org-left">\(\text{lb minerals}/\text{lb ovendry weight}\)</td>
</tr>

<tr>
<td class="org-left">\(S_e\)</td>
<td class="org-left">fuel particle effective mineral content</td>
<td class="org-left">\(\text{lb silica-free minerals}/\text{lb ovendry weight}\)</td>
</tr>

<tr>
<td class="org-left">\(M_x\)</td>
<td class="org-left">fuel particle moisture of extinction</td>
<td class="org-left">\(\text{lb moisture}/\text{lb ovendry weight}\)</td>
</tr>

<tr>
<td class="org-left">\(M_f\)</td>
<td class="org-left">fuel particle moisture content</td>
<td class="org-left">\(\text{lb moisture}/\text{lb ovendry weight}\)</td>
</tr>
</tbody>
</table>

<p>
While \(M_f\) is not, in fact, directly assigned to any of these fuel
models, their definitions remain incomplete for the purposes of fire
spread modelling (particularly those reliant on the curing formulas of
dynamic fuel loading) until it is provided as a characteristic of
local weather conditions.
</p>

<p>
Although most fuel model properties are static with respect to
environmental conditions, the fuel moisture content can have two
significant impacts on a fuel model's burning potential:
</p>

<ul class="org-ul">
<li>Dynamic fuel loading</li>
<li>Live moisture of extinction</li>
</ul>

<p>
These two topics are discussed in sections <a href="#dynamic-fuel-loading">4.1.5</a> and
<a href="#live-moisture-of-extinction">4.1.7</a>.
</p>
</div>
</div>

<div id="outline-container-fuel-model-definitions" class="outline-4">
<h4 id="fuel-model-definitions"><span class="section-number-4">4.1.3.</span> Fuel Model Definitions</h4>
<div class="outline-text-4" id="text-fuel-model-definitions">
<p>
The fuel models supported by Pyretechnics include the standard 13 fuel
models of Rothermel, Albini, and Anderson<sup><a id="fnr.5" class="footref" href="#fn.5" role="doc-backlink">5</a></sup> and the
additional 40 fuel models defined by Scott and Burgan<sup><a id="fnr.6" class="footref" href="#fn.6" role="doc-backlink">6</a></sup>.
These are all concisely encoded in an internal data structure, which
may be updated to include additional custom fuel models desired by the
user.
</p>

<div class="org-src-container">
<pre class="src src-python" id="fuel-model-compact-table"><span class="org-comment-delimiter"># </span><span class="org-comment">TODO: OPTIM Replace this dictionary with something more efficient</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Lookup table including entries for each of the Anderson 13 and Scott &amp; Burgan 40 fuel models.</span>
<span class="org-comment-delimiter">#</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">The fields have the following meanings:</span>
<span class="org-comment-delimiter">#   </span><span class="org-comment">{</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">fuel_model_number: (delta,</span>
<span class="org-comment-delimiter">#                         </span><span class="org-comment">M_x_dead,</span>
<span class="org-comment-delimiter">#                         </span><span class="org-comment">h,</span>
<span class="org-comment-delimiter">#                         </span><span class="org-comment">w_o_dead_1hr,</span>
<span class="org-comment-delimiter">#                         </span><span class="org-comment">w_o_dead_10hr,</span>
<span class="org-comment-delimiter">#                         </span><span class="org-comment">w_o_dead_100hr,</span>
<span class="org-comment-delimiter">#                         </span><span class="org-comment">w_o_live_herbaceous,</span>
<span class="org-comment-delimiter">#                         </span><span class="org-comment">w_o_live_woody,</span>
<span class="org-comment-delimiter">#                         </span><span class="org-comment">sigma_dead_1hr,</span>
<span class="org-comment-delimiter">#                         </span><span class="org-comment">sigma_dead_10hr,</span>
<span class="org-comment-delimiter">#                         </span><span class="org-comment">sigma_dead_100hr,</span>
<span class="org-comment-delimiter">#                         </span><span class="org-comment">sigma_live_herbaceous,</span>
<span class="org-comment-delimiter">#                         </span><span class="org-comment">sigma_live_woody), # name</span>
<span class="org-comment-delimiter">#   </span><span class="org-comment">}</span>
<span class="org-variable-name">compact_fuel_model_table</span> <span class="org-operator">=</span> cy.declare(<span class="org-builtin">dict</span>, { <span class="org-comment-delimiter"># </span><span class="org-comment">dict[int, CompactFuelModel]</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Anderson 13:</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Grass and Grass-dominated (short-grass,timber-grass-and-understory,tall-grass)</span>
    1  : (1.0, 12.0, 8.0, 0.0340, 0.0000, 0.0000, 0.0000, 0.0000, 3500.0,   0.0,  0.0,    0.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">R01</span>
    2  : (1.0, 15.0, 8.0, 0.0920, 0.0460, 0.0230, 0.0230, 0.0000, 3000.0, 109.0, 30.0, 1500.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">R02</span>
    3  : (2.5, 25.0, 8.0, 0.1380, 0.0000, 0.0000, 0.0000, 0.0000, 1500.0,   0.0,  0.0,    0.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">R03</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Chaparral and Shrubfields (chaparral,brush,dormant-brush-hardwood-slash,southern-rough)</span>
    4  : (6.0, 20.0, 8.0, 0.2300, 0.1840, 0.0920, 0.2300, 0.0000, 2000.0, 109.0, 30.0, 1500.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">R04</span>
    5  : (2.0, 20.0, 8.0, 0.0460, 0.0230, 0.0000, 0.0920, 0.0000, 2000.0, 109.0,  0.0, 1500.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">R05</span>
    6  : (2.5, 25.0, 8.0, 0.0690, 0.1150, 0.0920, 0.0000, 0.0000, 1750.0, 109.0, 30.0,    0.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">R06</span>
    7  : (2.5, 40.0, 8.0, 0.0520, 0.0860, 0.0690, 0.0170, 0.0000, 1750.0, 109.0, 30.0, 1550.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">R07</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Timber Litter (closed-timber-litter,hardwood-litter,timber-litter-and-understory)</span>
    8  : (0.2, 30.0, 8.0, 0.0690, 0.0460, 0.1150, 0.0000, 0.0000, 2000.0, 109.0, 30.0,    0.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">R08</span>
    9  : (0.2, 25.0, 8.0, 0.1340, 0.0190, 0.0070, 0.0000, 0.0000, 2500.0, 109.0, 30.0,    0.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">R09</span>
    10 : (1.0, 25.0, 8.0, 0.1380, 0.0920, 0.2300, 0.0920, 0.0000, 2000.0, 109.0, 30.0, 1500.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">R10</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Logging Slash (light-logging-slash,medium-logging-slash,heavy-logging-slash)</span>
    11 : (1.0, 15.0, 8.0, 0.0690, 0.2070, 0.2530, 0.0000, 0.0000, 1500.0, 109.0, 30.0,    0.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">R11</span>
    12 : (2.3, 20.0, 8.0, 0.1840, 0.6440, 0.7590, 0.0000, 0.0000, 1500.0, 109.0, 30.0,    0.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">R12</span>
    13 : (3.0, 25.0, 8.0, 0.3220, 1.0580, 1.2880, 0.0000, 0.0000, 1500.0, 109.0, 30.0,    0.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">R13</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Nonburnable (NB)</span>
    91 : (0.0,  0.0, 0.0, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,    0.0,   0.0,  0.0,    0.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">NB1</span>
    92 : (0.0,  0.0, 0.0, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,    0.0,   0.0,  0.0,    0.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">NB2</span>
    93 : (0.0,  0.0, 0.0, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,    0.0,   0.0,  0.0,    0.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">NB3</span>
    98 : (0.0,  0.0, 0.0, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,    0.0,   0.0,  0.0,    0.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">NB4</span>
    99 : (0.0,  0.0, 0.0, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,    0.0,   0.0,  0.0,    0.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">NB5</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Scott &amp; Burgan 40:</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Grass (GR)</span>
    101: (0.4, 15.0, 8.0, 0.0046, 0.0000, 0.0000, 0.0138, 0.0000, 2200.0, 109.0, 30.0, 2000.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">GR1</span>
    102: (1.0, 15.0, 8.0, 0.0046, 0.0000, 0.0000, 0.0459, 0.0000, 2000.0, 109.0, 30.0, 1800.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">GR2</span>
    103: (2.0, 30.0, 8.0, 0.0046, 0.0184, 0.0000, 0.0689, 0.0000, 1500.0, 109.0, 30.0, 1300.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">GR3</span>
    104: (2.0, 15.0, 8.0, 0.0115, 0.0000, 0.0000, 0.0872, 0.0000, 2000.0, 109.0, 30.0, 1800.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">GR4</span>
    105: (1.5, 40.0, 8.0, 0.0184, 0.0000, 0.0000, 0.1148, 0.0000, 1800.0, 109.0, 30.0, 1600.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">GR5</span>
    106: (1.5, 40.0, 9.0, 0.0046, 0.0000, 0.0000, 0.1561, 0.0000, 2200.0, 109.0, 30.0, 2000.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">GR6</span>
    107: (3.0, 15.0, 8.0, 0.0459, 0.0000, 0.0000, 0.2479, 0.0000, 2000.0, 109.0, 30.0, 1800.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">GR7</span>
    108: (4.0, 30.0, 8.0, 0.0230, 0.0459, 0.0000, 0.3352, 0.0000, 1500.0, 109.0, 30.0, 1300.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">GR8</span>
    109: (5.0, 40.0, 8.0, 0.0459, 0.0459, 0.0000, 0.4132, 0.0000, 1800.0, 109.0, 30.0, 1600.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">GR9</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Grass-Shrub (GS)</span>
    121: (0.9, 15.0, 8.0, 0.0092, 0.0000, 0.0000, 0.0230, 0.0298, 2000.0, 109.0, 30.0, 1800.0, 1800.0), <span class="org-comment-delimiter"># </span><span class="org-comment">GS1</span>
    122: (1.5, 15.0, 8.0, 0.0230, 0.0230, 0.0000, 0.0275, 0.0459, 2000.0, 109.0, 30.0, 1800.0, 1800.0), <span class="org-comment-delimiter"># </span><span class="org-comment">GS2</span>
    123: (1.8, 40.0, 8.0, 0.0138, 0.0115, 0.0000, 0.0666, 0.0574, 1800.0, 109.0, 30.0, 1600.0, 1600.0), <span class="org-comment-delimiter"># </span><span class="org-comment">GS3</span>
    124: (2.1, 40.0, 8.0, 0.0872, 0.0138, 0.0046, 0.1561, 0.3260, 1800.0, 109.0, 30.0, 1600.0, 1600.0), <span class="org-comment-delimiter"># </span><span class="org-comment">GS4</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Shrub (SH)</span>
    141: (1.0, 15.0, 8.0, 0.0115, 0.0115, 0.0000, 0.0069, 0.0597, 2000.0, 109.0, 30.0, 1800.0, 1600.0), <span class="org-comment-delimiter"># </span><span class="org-comment">SH1</span>
    142: (1.0, 15.0, 8.0, 0.0620, 0.1102, 0.0344, 0.0000, 0.1768, 2000.0, 109.0, 30.0,    0.0, 1600.0), <span class="org-comment-delimiter"># </span><span class="org-comment">SH2</span>
    143: (2.4, 40.0, 8.0, 0.0207, 0.1377, 0.0000, 0.0000, 0.2847, 1600.0, 109.0, 30.0,    0.0, 1400.0), <span class="org-comment-delimiter"># </span><span class="org-comment">SH3</span>
    144: (3.0, 30.0, 8.0, 0.0390, 0.0528, 0.0092, 0.0000, 0.1171, 2000.0, 109.0, 30.0, 1800.0, 1600.0), <span class="org-comment-delimiter"># </span><span class="org-comment">SH4</span>
    145: (6.0, 15.0, 8.0, 0.1653, 0.0964, 0.0000, 0.0000, 0.1331,  750.0, 109.0, 30.0,    0.0, 1600.0), <span class="org-comment-delimiter"># </span><span class="org-comment">SH5</span>
    146: (2.0, 30.0, 8.0, 0.1331, 0.0666, 0.0000, 0.0000, 0.0643,  750.0, 109.0, 30.0,    0.0, 1600.0), <span class="org-comment-delimiter"># </span><span class="org-comment">SH6</span>
    147: (6.0, 15.0, 8.0, 0.1607, 0.2433, 0.1010, 0.0000, 0.1561,  750.0, 109.0, 30.0,    0.0, 1600.0), <span class="org-comment-delimiter"># </span><span class="org-comment">SH7</span>
    148: (3.0, 40.0, 8.0, 0.0941, 0.1561, 0.0390, 0.0000, 0.1997,  750.0, 109.0, 30.0,    0.0, 1600.0), <span class="org-comment-delimiter"># </span><span class="org-comment">SH8</span>
    149: (4.4, 40.0, 8.0, 0.2066, 0.1125, 0.0000, 0.0712, 0.3214,  750.0, 109.0, 30.0, 1800.0, 1500.0), <span class="org-comment-delimiter"># </span><span class="org-comment">SH9</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Timber-Understory (TU)</span>
    161: (0.6, 20.0, 8.0, 0.0092, 0.0413, 0.0689, 0.0092, 0.0413, 2000.0, 109.0, 30.0, 1800.0, 1600.0), <span class="org-comment-delimiter"># </span><span class="org-comment">TU1</span>
    162: (1.0, 30.0, 8.0, 0.0436, 0.0826, 0.0574, 0.0000, 0.0092, 2000.0, 109.0, 30.0,    0.0, 1600.0), <span class="org-comment-delimiter"># </span><span class="org-comment">TU2</span>
    163: (1.3, 30.0, 8.0, 0.0505, 0.0069, 0.0115, 0.0298, 0.0505, 1800.0, 109.0, 30.0, 1600.0, 1400.0), <span class="org-comment-delimiter"># </span><span class="org-comment">TU3</span>
    164: (0.5, 12.0, 8.0, 0.2066, 0.0000, 0.0000, 0.0000, 0.0918, 2300.0, 109.0, 30.0,    0.0, 2000.0), <span class="org-comment-delimiter"># </span><span class="org-comment">TU4</span>
    165: (1.0, 25.0, 8.0, 0.1837, 0.1837, 0.1377, 0.0000, 0.1377, 1500.0, 109.0, 30.0,    0.0,  750.0), <span class="org-comment-delimiter"># </span><span class="org-comment">TU5</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Timber Litter (TL)</span>
    181: (0.2, 30.0, 8.0, 0.0459, 0.1010, 0.1653, 0.0000, 0.0000, 2000.0, 109.0, 30.0,    0.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">TL1</span>
    182: (0.2, 25.0, 8.0, 0.0643, 0.1056, 0.1010, 0.0000, 0.0000, 2000.0, 109.0, 30.0,    0.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">TL2</span>
    183: (0.3, 20.0, 8.0, 0.0230, 0.1010, 0.1286, 0.0000, 0.0000, 2000.0, 109.0, 30.0,    0.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">TL3</span>
    184: (0.4, 25.0, 8.0, 0.0230, 0.0689, 0.1928, 0.0000, 0.0000, 2000.0, 109.0, 30.0,    0.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">TL4</span>
    185: (0.6, 25.0, 8.0, 0.0528, 0.1148, 0.2020, 0.0000, 0.0000, 2000.0, 109.0, 30.0,    0.0, 1600.0), <span class="org-comment-delimiter"># </span><span class="org-comment">TL5</span>
    186: (0.3, 25.0, 8.0, 0.1102, 0.0551, 0.0551, 0.0000, 0.0000, 2000.0, 109.0, 30.0,    0.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">TL6</span>
    187: (0.4, 25.0, 8.0, 0.0138, 0.0643, 0.3719, 0.0000, 0.0000, 2000.0, 109.0, 30.0,    0.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">TL7</span>
    188: (0.3, 35.0, 8.0, 0.2663, 0.0643, 0.0505, 0.0000, 0.0000, 1800.0, 109.0, 30.0,    0.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">TL8</span>
    189: (0.6, 35.0, 8.0, 0.3053, 0.1515, 0.1905, 0.0000, 0.0000, 1800.0, 109.0, 30.0,    0.0, 1600.0), <span class="org-comment-delimiter"># </span><span class="org-comment">TL9</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Slash-Blowdown (SB)</span>
    201: (1.0, 25.0, 8.0, 0.0689, 0.1377, 0.5051, 0.0000, 0.0000, 2000.0, 109.0, 30.0,    0.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">SB1</span>
    202: (1.0, 25.0, 8.0, 0.2066, 0.1951, 0.1837, 0.0000, 0.0000, 2000.0, 109.0, 30.0,    0.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">SB2</span>
    203: (1.2, 25.0, 8.0, 0.2525, 0.1263, 0.1377, 0.0000, 0.0000, 2000.0, 109.0, 30.0,    0.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">SB3</span>
    204: (2.7, 25.0, 8.0, 0.2410, 0.1607, 0.2410, 0.0000, 0.0000, 2000.0, 109.0, 30.0,    0.0,    0.0), <span class="org-comment-delimiter"># </span><span class="org-comment">SB4</span>
})
</pre>
</div>

<p>
Although this compact data structure contains all the properties that
vary by fuel model (i.e., \(\delta\), \(w_o\), \(\sigma\),
\(M_{x-\text{dead}}\), \(h\)), several of their values need to be
multiplied by a coefficient to make their units match those listed in
Table <a href="#tab:fuel-model-properties">1</a>. We also need to add in the missing
\(\rho_p\), \(S_T\), and \(S_e\) values, which are constant across all of
these fuel models, and to expand those properties whose values may
vary by size class into lists with the following encoding:
</p>

<pre class="example" id="fuel-model-categories-and-size-classes">
[dead_1hr dead_10hr dead_100hr dead_herbaceous live_herbaceous live_woody]
</pre>

<p>
As a performance optimization, we set the dead herbaceous values that
don't depend on fuel moisture for the dynamic Scott &amp; Burgan 40 fuel
models. Finally, we add two boolean properties (<code>dynamic</code> and
<code>burnable</code>) to each fuel model for reference in later calculations.
</p>

<div class="org-src-container">
<pre class="src src-python" id="expand-compact-fuel-model-table"><span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: We use this variable for X &gt; 0.0 comparisons to account for floating point precision issues.</span>
<span class="org-variable-name">almost_zero</span> <span class="org-operator">=</span> cy.declare(cy.<span class="org-builtin">float</span>, 1e<span class="org-operator">-</span>6)


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">is_burnable_fuel_model_number</span>(fuel_model_number: cy.<span class="org-builtin">int</span>) <span class="org-operator">-&gt;</span> cy.bint:
    <span class="org-keyword">return</span> <span class="org-keyword">not</span> (91 <span class="org-operator">&lt;=</span> fuel_model_number <span class="org-operator">&lt;=</span> 99)


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">compute_exp_A_sigma</span>(A: cy.<span class="org-builtin">float</span>, sigma_ij: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-keyword">if</span> sigma_ij <span class="org-operator">&gt;</span> almost_zero:
        <span class="org-keyword">return</span> exp(A <span class="org-operator">/</span> sigma_ij)
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> 0.0


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">compute_firemod_size_class</span>(sigma_i: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-keyword">return</span> (
        1.0 <span class="org-keyword">if</span> (sigma_i <span class="org-operator">&gt;=</span> 1200.0)
        <span class="org-keyword">else</span> 2.0 <span class="org-keyword">if</span> (sigma_i <span class="org-operator">&gt;=</span> 192.0)
        <span class="org-keyword">else</span> 3.0 <span class="org-keyword">if</span> (sigma_i <span class="org-operator">&gt;=</span> 96.0)
        <span class="org-keyword">else</span> 4.0 <span class="org-keyword">if</span> (sigma_i <span class="org-operator">&gt;=</span> 48.0)
        <span class="org-keyword">else</span> 5.0 <span class="org-keyword">if</span> (sigma_i <span class="org-operator">&gt;=</span> 16.0)
        <span class="org-keyword">else</span> 6.0
    )


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">expand_compact_fuel_model</span>(fuel_model_number: cy.<span class="org-builtin">int</span>) <span class="org-operator">-&gt;</span> FuelModel:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Look up the CompactFuelModel by fuel_model_number</span>
    <span class="org-variable-name">cfm</span>: CompactFuelModel <span class="org-operator">=</span> compact_fuel_model_table[fuel_model_number]
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack the CompactFuelModel values</span>
    <span class="org-variable-name">delta</span>                : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cfm[0]
    <span class="org-variable-name">M_x_dead</span>             : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cfm[1]
    <span class="org-variable-name">h</span>                    : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cfm[2]
    <span class="org-variable-name">w_o_dead_1hr</span>         : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cfm[3]
    <span class="org-variable-name">w_o_dead_10hr</span>        : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cfm[4]
    <span class="org-variable-name">w_o_dead_100hr</span>       : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cfm[5]
    <span class="org-variable-name">w_o_live_herbaceous</span>  : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cfm[6]
    <span class="org-variable-name">w_o_live_woody</span>       : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cfm[7]
    <span class="org-variable-name">sigma_dead_1hr</span>       : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cfm[8]
    <span class="org-variable-name">sigma_dead_10hr</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cfm[9]
    <span class="org-variable-name">sigma_dead_100hr</span>     : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cfm[10]
    <span class="org-variable-name">sigma_live_herbaceous</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cfm[11]
    <span class="org-variable-name">sigma_live_woody</span>     : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cfm[12]
    <span class="org-comment-delimiter"># </span><span class="org-comment">Expand compressed values</span>
    <span class="org-variable-name">M_x_dead</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> M_x_dead <span class="org-operator">*</span> 0.01
    <span class="org-variable-name">h</span>       : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> h <span class="org-operator">*</span> 1000.0
    <span class="org-comment-delimiter"># </span><span class="org-comment">Pre-compute some dynamic fuel model values</span>
    <span class="org-variable-name">dynamic</span>              : cy.bint  <span class="org-operator">=</span> fuel_model_number <span class="org-operator">&gt;</span> 100 <span class="org-keyword">and</span> w_o_live_herbaceous <span class="org-operator">&gt;</span> almost_zero
    <span class="org-variable-name">M_x_dead_herbaceous</span>  : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> M_x_dead              <span class="org-keyword">if</span> dynamic <span class="org-keyword">else</span> 0.0
    <span class="org-variable-name">sigma_dead_herbaceous</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> sigma_live_herbaceous <span class="org-keyword">if</span> dynamic <span class="org-keyword">else</span> 0.0
    <span class="org-comment-delimiter"># </span><span class="org-comment">Re-pack everything into a FuelModel struct</span>
    <span class="org-keyword">return</span> FuelModel(
        number               <span class="org-operator">=</span> fuel_model_number,
        delta                <span class="org-operator">=</span> delta,
        M_x                  <span class="org-operator">=</span> (M_x_dead,
                                M_x_dead,
                                M_x_dead,
                                M_x_dead_herbaceous,
                                0.0,
                                0.0),
        M_f                  <span class="org-operator">=</span> (0.0, 0.0, 0.0, 0.0, 0.0, 0.0),
        w_o                  <span class="org-operator">=</span> (w_o_dead_1hr,
                                w_o_dead_10hr,
                                w_o_dead_100hr,
                                0.0,
                                w_o_live_herbaceous,
                                w_o_live_woody),
        sigma                <span class="org-operator">=</span> (sigma_dead_1hr,
                                sigma_dead_10hr,
                                sigma_dead_100hr,
                                sigma_dead_herbaceous,
                                sigma_live_herbaceous,
                                sigma_live_woody),
        h                    <span class="org-operator">=</span> (h, h, h, h, h, h),
        rho_p                <span class="org-operator">=</span> (32.0, 32.0, 32.0, 32.0, 32.0, 32.0),
        S_T                  <span class="org-operator">=</span> (0.0555, 0.0555, 0.0555, 0.0555, 0.0555, 0.0555),
        S_e                  <span class="org-operator">=</span> (0.01, 0.01, 0.01, 0.01, 0.01, 0.01),
        dynamic              <span class="org-operator">=</span> dynamic,
        burnable             <span class="org-operator">=</span> is_burnable_fuel_model_number(fuel_model_number),
        exp_A_sigma          <span class="org-operator">=</span> (compute_exp_A_sigma(<span class="org-operator">-</span>138.0, sigma_dead_1hr),
                                compute_exp_A_sigma(<span class="org-operator">-</span>138.0, sigma_dead_10hr),
                                compute_exp_A_sigma(<span class="org-operator">-</span>138.0, sigma_dead_100hr),
                                compute_exp_A_sigma(<span class="org-operator">-</span>138.0, sigma_dead_herbaceous),
                                compute_exp_A_sigma(<span class="org-operator">-</span>500.0, sigma_live_herbaceous),
                                compute_exp_A_sigma(<span class="org-operator">-</span>500.0, sigma_live_woody)),
        firemod_size_classes <span class="org-operator">=</span> (compute_firemod_size_class(sigma_dead_1hr),
                                compute_firemod_size_class(sigma_dead_10hr),
                                compute_firemod_size_class(sigma_dead_100hr),
                                compute_firemod_size_class(sigma_dead_herbaceous),
                                compute_firemod_size_class(sigma_live_herbaceous),
                                compute_firemod_size_class(sigma_live_woody)),
        f_ij                 <span class="org-operator">=</span> (0.0, 0.0, 0.0, 0.0, 0.0, 0.0),
        f_i                  <span class="org-operator">=</span> (0.0, 0.0),
        g_ij                 <span class="org-operator">=</span> (0.0, 0.0, 0.0, 0.0, 0.0, 0.0),
    )


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: OPTIM Replace this dictionary with something more efficient</span>
<span class="org-variable-name">fuel_model_table</span> <span class="org-operator">=</span> cy.declare(<span class="org-builtin">dict</span>, { <span class="org-comment-delimiter"># </span><span class="org-comment">dict[int, FuelModel]</span>
    k: expand_compact_fuel_model(k) <span class="org-keyword">for</span> k <span class="org-keyword">in</span> compact_fuel_model_table.keys()
})


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-keyword">def</span> <span class="org-function-name">list_fuel_model_numbers</span>() <span class="org-operator">-&gt;</span> <span class="org-builtin">list</span>[<span class="org-builtin">int</span>]:
    <span class="org-keyword">return</span> <span class="org-builtin">list</span>(fuel_model_table.keys())


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-keyword">def</span> <span class="org-function-name">list_fuel_models</span>() <span class="org-operator">-&gt;</span> <span class="org-builtin">list</span>[FuelModel]:
    <span class="org-keyword">return</span> <span class="org-builtin">list</span>(fuel_model_table.values())


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">fuel_model_exists</span>(fuel_model_number: cy.<span class="org-builtin">int</span>) <span class="org-operator">-&gt;</span> cy.bint:
    <span class="org-keyword">return</span> fuel_model_number <span class="org-keyword">in</span> fuel_model_table


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">get_fuel_model</span>(fuel_model_number: cy.<span class="org-builtin">int</span>) <span class="org-operator">-&gt;</span> FuelModel:
    <span class="org-keyword">return</span> cy.cast(FuelModel, fuel_model_table[fuel_model_number])
</pre>
</div>
</div>
</div>

<div id="outline-container-fuel-categories-and-size-classes" class="outline-4">
<h4 id="fuel-categories-and-size-classes"><span class="section-number-4">4.1.4.</span> Fuel Categories and Size Classes</h4>
<div class="outline-text-4" id="text-fuel-categories-and-size-classes">
<p>
Each fuel model applies to a collection of burnable material that may
be live or dead and whose constituent elements may vary in size
considerably.
</p>

<p>
The two terms <b>category</b> and <b>size class</b> are used to describe this
heterogeneity within each fuel model.
</p>

<p>
In Pyretechnics, when we refer to a fuel category, we mean one of
these two values:
</p>

<ul class="org-ul">
<li>Dead</li>
<li>Live</li>
</ul>

<p>
When we refer to a fuel size class, we mean one of these six values:
</p>

<ul class="org-ul">
<li>Dead 1 hour (&lt; 1/4" diameter)</li>
<li>Dead 10 hour (1/4"-1" diameter)</li>
<li>Dead 100 hour (1"-3" diameter)</li>
<li>Dead herbaceous (dynamic fuel models only)</li>
<li>Live herbaceous</li>
<li>Live woody</li>
</ul>
</div>
</div>

<div id="outline-container-dynamic-fuel-loading" class="outline-4">
<h4 id="dynamic-fuel-loading"><span class="section-number-4">4.1.5.</span> Dynamic Fuel Loading</h4>
<div class="outline-text-4" id="text-dynamic-fuel-loading">
<p>
All of the Scott &amp; Burgan 40 fuel models with a live herbaceous
component are considered dynamic. In these models, a fraction of the
live herbaceous load is transferred to a new dead herbaceous category
as a function of live herbaceous moisture content (see equation
below).<sup><a id="fnr.7" class="footref" href="#fn.7" role="doc-backlink">7</a></sup> The dead herbaceous size class uses the dead 1
hour moisture content, dead moisture of extinction, and live
herbaceous surface-area-to-volume-ratio. In the following formula,
\(M_f^{lh}\) is the live herbaceous moisture content.
</p>

\begin{align}
  \text{FractionGreen} &= \left\{
    \begin{array}{lr}
      0 & M_f^{lh} \le 0.3 \\
      1 & M_f^{lh} \ge 1.2 \\
      M_f^{lh} / 0.9 - 1/3 & \text{else}
    \end{array}
  \right. \\
  \nonumber \\
  \text{FractionCured} &= 1 - \text{FractionGreen}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="add-dynamic-fuel-loading"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">add_dynamic_fuel_loading</span>(fuel_model: FuelModel, M_f: fclaarr) <span class="org-operator">-&gt;</span> FuelModel:
    <span class="org-doc">"""</span>
<span class="org-doc">    Updates M_f and w_o. Mutates and returns fuel_model.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">if</span> fuel_model.dynamic:
        <span class="org-comment-delimiter"># </span><span class="org-comment">=== Dynamic Fuel Model ===</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate fraction_green and fraction_cured</span>
        <span class="org-variable-name">w_o</span>                     : fclaarr  <span class="org-operator">=</span> fuel_model.w_o
        <span class="org-variable-name">live_herbaceous_load</span>    : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> w_o[4]
        <span class="org-variable-name">live_herbaceous_moisture</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> M_f[4]
        <span class="org-variable-name">fraction_green</span>          : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> <span class="org-builtin">max</span>(0.0, <span class="org-builtin">min</span>(1.0, (live_herbaceous_moisture <span class="org-operator">/</span> 0.9) <span class="org-operator">-</span> 0.3333333333333333))
        <span class="org-variable-name">fraction_cured</span>          : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 1.0 <span class="org-operator">-</span> fraction_green
        <span class="org-comment-delimiter"># </span><span class="org-comment">Set M_f[dead_herbaceous] equal to M_f[dead_1hr]</span>
        <span class="org-variable-name">M_f_dynamic</span>: fclaarr <span class="org-operator">=</span> (M_f[0], <span class="org-comment-delimiter"># </span><span class="org-comment">dead_1hr</span>
                                M_f[1],
                                M_f[2],
                                M_f[0], <span class="org-comment-delimiter"># </span><span class="org-comment">dead_herbaceous</span>
                                M_f[4],
                                M_f[5])
        <span class="org-comment-delimiter"># </span><span class="org-comment">Set w_o[dead_herbaceous] and w_o[live_herbaceous] based on fraction_cured and fraction_green</span>
        <span class="org-variable-name">w_o_dynamic</span>: fclaarr <span class="org-operator">=</span> (w_o[0],
                                w_o[1],
                                w_o[2],
                                live_herbaceous_load <span class="org-operator">*</span> fraction_cured, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_herbaceous</span>
                                live_herbaceous_load <span class="org-operator">*</span> fraction_green, <span class="org-comment-delimiter"># </span><span class="org-comment">live_herbaceous</span>
                                w_o[5])
        <span class="org-comment-delimiter"># </span><span class="org-comment">Update the passed in fuel_model to use M_f_dynamic and w_o_dynamic</span>
        fuel_model.<span class="org-variable-name">M_f</span> <span class="org-operator">=</span> M_f_dynamic
        fuel_model.<span class="org-variable-name">w_o</span> <span class="org-operator">=</span> w_o_dynamic
        <span class="org-keyword">return</span> fuel_model
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">=== Static Fuel Model ===</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Update the passed in fuel_model to use the passed in M_f</span>
        fuel_model.<span class="org-variable-name">M_f</span> <span class="org-operator">=</span> M_f
        <span class="org-keyword">return</span> fuel_model
</pre>
</div>
</div>
</div>

<div id="outline-container-size-class-weighting-factors" class="outline-4">
<h4 id="size-class-weighting-factors"><span class="section-number-4">4.1.6.</span> Size Class Weighting Factors</h4>
<div class="outline-text-4" id="text-size-class-weighting-factors">
<p>
Once the dynamic fuel loading is applied, we can compute the size
class weighting factors expressed in equations 53-57 in Rothermel
1972<sup><a id="fnr.8" class="footref" href="#fn.8" role="doc-backlink">8</a></sup>. For brevity, these formulas are elided from
this text.
</p>

<div class="org-src-container">
<pre class="src src-python" id="add-weighting-factors"><span class="org-comment-delimiter"># </span><span class="org-comment">TODO: OPTIM pre-compute this conditional branching since it's fully determined by sigma.</span>
<span class="org-comment-delimiter">#       </span><span class="org-comment">This information might be represented efficiently in bit flags.</span>
<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">compute_gij</span>(firemod_size_classes : fclaarr,
                f_ij                 : fclaarr,
                firemod_size_class_ij: cy.<span class="org-builtin">float</span>,
                is_dead              : cy.bint) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Sums the f_ij of the same category (dead/live) as i, and having the same firemod_size_class.</span>

<span class="org-doc">    NOTE: There may be repetitions in firemod_size_classes, which is why this expression is not</span>
<span class="org-doc">          trivially equal to f_ij[i].</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">if</span> is_dead:
        <span class="org-variable-name">f_ij_0</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (f_ij[0] <span class="org-keyword">if</span> (firemod_size_class_ij <span class="org-operator">==</span> firemod_size_classes[0]) <span class="org-keyword">else</span> 0.0)
        <span class="org-variable-name">f_ij_1</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (f_ij[1] <span class="org-keyword">if</span> (firemod_size_class_ij <span class="org-operator">==</span> firemod_size_classes[1]) <span class="org-keyword">else</span> 0.0)
        <span class="org-variable-name">f_ij_2</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (f_ij[2] <span class="org-keyword">if</span> (firemod_size_class_ij <span class="org-operator">==</span> firemod_size_classes[2]) <span class="org-keyword">else</span> 0.0)
        <span class="org-variable-name">f_ij_3</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (f_ij[3] <span class="org-keyword">if</span> (firemod_size_class_ij <span class="org-operator">==</span> firemod_size_classes[3]) <span class="org-keyword">else</span> 0.0)
        <span class="org-keyword">return</span> f_ij_0 <span class="org-operator">+</span> f_ij_1 <span class="org-operator">+</span> f_ij_2 <span class="org-operator">+</span> f_ij_3
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">f_ij_4</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (f_ij[4] <span class="org-keyword">if</span> (firemod_size_class_ij <span class="org-operator">==</span> firemod_size_classes[4]) <span class="org-keyword">else</span> 0.0)
        <span class="org-variable-name">f_ij_5</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (f_ij[5] <span class="org-keyword">if</span> (firemod_size_class_ij <span class="org-operator">==</span> firemod_size_classes[5]) <span class="org-keyword">else</span> 0.0)
        <span class="org-keyword">return</span> f_ij_4 <span class="org-operator">+</span> f_ij_5


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">add_weighting_factors</span>(fuel_model: FuelModel) <span class="org-operator">-&gt;</span> FuelModel:
    <span class="org-doc">"""</span>
<span class="org-doc">    Assigns f_ij, f_i, and g_ij. Mutates and returns fuel_model.</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate A_ij, A_i, and A_T</span>
    <span class="org-variable-name">w_o</span>  : fclaarr  <span class="org-operator">=</span> fuel_model.w_o
    <span class="org-variable-name">sigma</span>: fclaarr  <span class="org-operator">=</span> fuel_model.sigma
    <span class="org-variable-name">rho_p</span>: fclaarr  <span class="org-operator">=</span> fuel_model.rho_p
    <span class="org-variable-name">A_ij</span> : fclaarr  <span class="org-operator">=</span> ((sigma[0] <span class="org-operator">*</span> w_o[0]) <span class="org-operator">/</span> rho_p[0],
                       (sigma[1] <span class="org-operator">*</span> w_o[1]) <span class="org-operator">/</span> rho_p[1],
                       (sigma[2] <span class="org-operator">*</span> w_o[2]) <span class="org-operator">/</span> rho_p[2],
                       (sigma[3] <span class="org-operator">*</span> w_o[3]) <span class="org-operator">/</span> rho_p[3],
                       (sigma[4] <span class="org-operator">*</span> w_o[4]) <span class="org-operator">/</span> rho_p[4],
                       (sigma[5] <span class="org-operator">*</span> w_o[5]) <span class="org-operator">/</span> rho_p[5]) <span class="org-comment-delimiter"># </span><span class="org-comment">TODO: OPTIM pre-compute sigma/rho_p</span>
    <span class="org-variable-name">A_i_0</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> A_ij[0] <span class="org-operator">+</span> A_ij[1] <span class="org-operator">+</span> A_ij[2] <span class="org-operator">+</span> A_ij[3]
    <span class="org-variable-name">A_i_1</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> A_ij[4] <span class="org-operator">+</span> A_ij[5]
    <span class="org-variable-name">A_i</span>  : fcatarr  <span class="org-operator">=</span> (A_i_0, A_i_1)
    <span class="org-variable-name">A_T</span>  : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> A_i_0 <span class="org-operator">+</span> A_i_1
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate f_ij</span>
    <span class="org-variable-name">f_ij_0</span>   : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 0.0
    <span class="org-variable-name">f_ij_1</span>   : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 0.0
    <span class="org-variable-name">f_ij_2</span>   : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 0.0
    <span class="org-variable-name">f_ij_3</span>   : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 0.0
    <span class="org-variable-name">f_ij_4</span>   : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 0.0
    <span class="org-variable-name">f_ij_5</span>   : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 0.0
    A_i_0_inv: cy.<span class="org-builtin">float</span>
    A_i_1_inv: cy.<span class="org-builtin">float</span>
    <span class="org-keyword">if</span> A_i_0 <span class="org-operator">&gt;</span> almost_zero:
        <span class="org-variable-name">A_i_0_inv</span> <span class="org-operator">=</span> 1.0 <span class="org-operator">/</span> A_i_0
        <span class="org-variable-name">f_ij_0</span>    <span class="org-operator">=</span> A_ij[0] <span class="org-operator">*</span> A_i_0_inv
        <span class="org-variable-name">f_ij_1</span>    <span class="org-operator">=</span> A_ij[1] <span class="org-operator">*</span> A_i_0_inv
        <span class="org-variable-name">f_ij_2</span>    <span class="org-operator">=</span> A_ij[2] <span class="org-operator">*</span> A_i_0_inv
        <span class="org-variable-name">f_ij_3</span>    <span class="org-operator">=</span> A_ij[3] <span class="org-operator">*</span> A_i_0_inv
    <span class="org-keyword">if</span> A_i_1 <span class="org-operator">&gt;</span> almost_zero:
        <span class="org-variable-name">A_i_1_inv</span> <span class="org-operator">=</span> 1.0 <span class="org-operator">/</span> A_i_1
        <span class="org-variable-name">f_ij_4</span>    <span class="org-operator">=</span> A_ij[4] <span class="org-operator">*</span> A_i_1_inv
        <span class="org-variable-name">f_ij_5</span>    <span class="org-operator">=</span> A_ij[5] <span class="org-operator">*</span> A_i_1_inv
    <span class="org-variable-name">f_ij</span>: fclaarr <span class="org-operator">=</span> (f_ij_0, f_ij_1, f_ij_2, f_ij_3, f_ij_4, f_ij_5)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate f_i</span>
    <span class="org-variable-name">f_i_0</span>  : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 0.0
    <span class="org-variable-name">f_i_1</span>  : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 0.0
    A_T_inv: cy.<span class="org-builtin">float</span>
    <span class="org-keyword">if</span> A_T <span class="org-operator">&gt;</span> almost_zero:
        <span class="org-variable-name">A_T_inv</span> <span class="org-operator">=</span> 1.0 <span class="org-operator">/</span> A_T
        <span class="org-variable-name">f_i_0</span>   <span class="org-operator">=</span> A_i_0 <span class="org-operator">*</span> A_T_inv
        <span class="org-variable-name">f_i_1</span>   <span class="org-operator">=</span> A_i_1 <span class="org-operator">*</span> A_T_inv
    <span class="org-variable-name">f_i</span>: fcatarr <span class="org-operator">=</span> (f_i_0, f_i_1)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate g_ij</span>
    <span class="org-variable-name">firemod_size_classes</span>: fclaarr <span class="org-operator">=</span> fuel_model.firemod_size_classes
    <span class="org-variable-name">g_ij</span>                : fclaarr <span class="org-operator">=</span> (compute_gij(firemod_size_classes, f_ij, firemod_size_classes[0], <span class="org-constant">True</span>),
                                     compute_gij(firemod_size_classes, f_ij, firemod_size_classes[1], <span class="org-constant">True</span>),
                                     compute_gij(firemod_size_classes, f_ij, firemod_size_classes[2], <span class="org-constant">True</span>),
                                     compute_gij(firemod_size_classes, f_ij, firemod_size_classes[3], <span class="org-constant">True</span>),
                                     compute_gij(firemod_size_classes, f_ij, firemod_size_classes[4], <span class="org-constant">False</span>),
                                     compute_gij(firemod_size_classes, f_ij, firemod_size_classes[5], <span class="org-constant">False</span>))
    <span class="org-comment-delimiter"># </span><span class="org-comment">Update the passed in fuel_model to use f_ij, f_i, and g_ij</span>
    fuel_model.<span class="org-variable-name">f_ij</span> <span class="org-operator">=</span> f_ij
    fuel_model.<span class="org-variable-name">f_i</span>  <span class="org-operator">=</span> f_i
    fuel_model.<span class="org-variable-name">g_ij</span> <span class="org-operator">=</span> g_ij
    <span class="org-keyword">return</span> fuel_model
</pre>
</div>
</div>
</div>

<div id="outline-container-live-moisture-of-extinction" class="outline-4">
<h4 id="live-moisture-of-extinction"><span class="section-number-4">4.1.7.</span> Live Moisture of Extinction</h4>
<div class="outline-text-4" id="text-live-moisture-of-extinction">
<p>
The live moisture of extinction for each fuel model is determined from
the dead fuel moisture content, the dead moisture of extinction, and
the ratio of dead fuel loading to live fuel loading using Equation 88
from Rothermel 1972, adjusted according to Albini 1976 Appendix III to
match the behavior of Albini's original FIREMODS
library.<sup><a id="fnr.9" class="footref" href="#fn.9" role="doc-backlink">9</a></sup><sup>, </sup><sup><a id="fnr.10" class="footref" href="#fn.10" role="doc-backlink">10</a></sup> Whenever the fuel moisture
content becomes greater than or equal to the moisture of extinction, a
fire will no longer spread through that fuel. Here are the formulas
referenced above:
</p>

\begin{align}
  M_x^l &= \max(M_x^d, 2.9 \, W' \, (1 - M_f^d / M_x^d) - 0.226) \\
  \nonumber \\
  W' &= \frac{\sum_{c \in D}{w_o^c \> e^{-138/\sigma^c}}}{\sum_{c \in L}{w_o^c \> e^{-500/\sigma^c}}} \\
  \nonumber \\
  M_f^d &= \frac{\sum_{c \in D}{w_o^c \> M_f^c \> e^{-138/\sigma^c}}}{\sum_{c \in D}{w_o^c \> e^{-138/\sigma^c}}}
\end{align}

<p>
where \(M_{x}^{l}\) is the live moisture of extinction, \(M_{x}^{d}\) is
the dead moisture of extinction, \(D\) is the set of dead fuel size
classes (1hr, 10hr, 100hr, herbaceous), \(L\) is the set of live fuel
size classes (herbaceous, woody), \(w_{o}^{c}\) is the dry weight
loading of size class \(c\), \(\sigma^{c}\) is the surface area to volume
ratio of size class \(c\), and \(M_{f}^{c}\) is the moisture content of
size class \(c\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="add-live-moisture-of-extinction"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">add_live_moisture_of_extinction</span>(fuel_model: FuelModel) <span class="org-operator">-&gt;</span> FuelModel:
    <span class="org-doc">"""</span>
<span class="org-doc">    Equation 88 from Rothermel 1972 adjusted by Albini 1976 Appendix III.</span>

<span class="org-doc">    Updates M_x. Mutates and returns fuel_model.</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate dead_moisture_factor, dead_loading_factor, and live_loading_factor</span>
    <span class="org-variable-name">w_o</span>                 : fclaarr  <span class="org-operator">=</span> fuel_model.w_o
    <span class="org-variable-name">exp_A_sigma</span>         : fclaarr  <span class="org-operator">=</span> fuel_model.exp_A_sigma
    <span class="org-variable-name">M_f</span>                 : fclaarr  <span class="org-operator">=</span> fuel_model.M_f
    <span class="org-variable-name">M_x</span>                 : fclaarr  <span class="org-operator">=</span> fuel_model.M_x
    <span class="org-variable-name">M_x_dead</span>            : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> M_x[0]
    <span class="org-variable-name">loading_factors</span>     : fclaarr  <span class="org-operator">=</span> (w_o[0] <span class="org-operator">*</span> exp_A_sigma[0],
                                      w_o[1] <span class="org-operator">*</span> exp_A_sigma[1],
                                      w_o[2] <span class="org-operator">*</span> exp_A_sigma[2],
                                      w_o[3] <span class="org-operator">*</span> exp_A_sigma[3],
                                      w_o[4] <span class="org-operator">*</span> exp_A_sigma[4],
                                      w_o[5] <span class="org-operator">*</span> exp_A_sigma[5])
    <span class="org-variable-name">dead_moisture_factor</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (M_f[0] <span class="org-operator">*</span> loading_factors[0] <span class="org-operator">+</span>
                                      M_f[1] <span class="org-operator">*</span> loading_factors[1] <span class="org-operator">+</span>
                                      M_f[2] <span class="org-operator">*</span> loading_factors[2] <span class="org-operator">+</span>
                                      M_f[3] <span class="org-operator">*</span> loading_factors[3])
    <span class="org-variable-name">dead_loading_factor</span> : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> loading_factors[0] <span class="org-operator">+</span> loading_factors[1] <span class="org-operator">+</span> loading_factors[2] <span class="org-operator">+</span> loading_factors[3]
    <span class="org-variable-name">live_loading_factor</span> : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> loading_factors[4] <span class="org-operator">+</span> loading_factors[5]
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate M_x_live</span>
    dead_fuel_moisture: cy.<span class="org-builtin">float</span>
    dead_to_live_ratio: cy.<span class="org-builtin">float</span>
    M_x_live          : cy.<span class="org-builtin">float</span>
    <span class="org-keyword">if</span> (dead_loading_factor <span class="org-operator">&gt;</span> almost_zero <span class="org-keyword">and</span> live_loading_factor <span class="org-operator">&gt;</span> almost_zero):
        <span class="org-variable-name">dead_fuel_moisture</span> <span class="org-operator">=</span> dead_moisture_factor <span class="org-operator">/</span> dead_loading_factor
        <span class="org-variable-name">dead_to_live_ratio</span> <span class="org-operator">=</span> dead_loading_factor <span class="org-operator">/</span> live_loading_factor
        <span class="org-variable-name">M_x_live</span>           <span class="org-operator">=</span> <span class="org-builtin">max</span>(M_x_dead,
                                 (2.9 <span class="org-operator">*</span> dead_to_live_ratio <span class="org-operator">*</span> (1.0 <span class="org-operator">-</span> (dead_fuel_moisture <span class="org-operator">/</span> M_x_dead))) <span class="org-operator">-</span> 0.226)
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">M_x_live</span> <span class="org-operator">=</span> M_x_dead
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate M_x_new</span>
    <span class="org-variable-name">M_x_new</span>: fclaarr <span class="org-operator">=</span> (M_x[0],
                        M_x[1],
                        M_x[2],
                        M_x[3],
                        M_x_live,
                        M_x_live)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Update the passed in fuel_model to use M_x_new</span>
    fuel_model.<span class="org-variable-name">M_x</span> <span class="org-operator">=</span> M_x_new
    <span class="org-keyword">return</span> fuel_model
</pre>
</div>
</div>
</div>

<div id="outline-container-applying-fuel-moisture-to-a-fuel-model" class="outline-4">
<h4 id="applying-fuel-moisture-to-a-fuel-model"><span class="section-number-4">4.1.8.</span> Applying Fuel Moisture to a Fuel Model</h4>
<div class="outline-text-4" id="text-applying-fuel-moisture-to-a-fuel-model">
<p>
The preceding sections augmented the baseline fuel models by adding
dynamic fuel loading (section <a href="#dynamic-fuel-loading">4.1.5</a>), size class
weighting factors (section <a href="#size-class-weighting-factors">4.1.6</a>), and live
moisture of extinction (section <a href="#live-moisture-of-extinction">4.1.7</a>). In
typical usage, we will want to carry out all three of these steps when
applying fuel moisture to a fuel model. To simplify this task,
Pyretechnics provides the <code>moisturize</code> utility function.
</p>

<div class="org-src-container">
<pre class="src src-python" id="moisturize"><span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">moisturize</span>(fuel_model: FuelModel, fuel_moisture: fclaarr) <span class="org-operator">-&gt;</span> FuelModel:
    <span class="org-doc">"""</span>
<span class="org-doc">    Updates w_o, M_f, and M_x and assigns f_ij, f_i, and g_ij.</span>
<span class="org-doc">    Returns a new FuelModel struct.</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Create a copy of fuel_model</span>
    <span class="org-variable-name">fuel_model_copy</span>: FuelModel <span class="org-operator">=</span> FuelModel(
        number               <span class="org-operator">=</span> fuel_model.number,
        delta                <span class="org-operator">=</span> fuel_model.delta,
        M_x                  <span class="org-operator">=</span> fuel_model.M_x,
        M_f                  <span class="org-operator">=</span> fuel_model.M_f,
        w_o                  <span class="org-operator">=</span> fuel_model.w_o,
        sigma                <span class="org-operator">=</span> fuel_model.sigma,
        h                    <span class="org-operator">=</span> fuel_model.h,
        rho_p                <span class="org-operator">=</span> fuel_model.rho_p,
        S_T                  <span class="org-operator">=</span> fuel_model.S_T,
        S_e                  <span class="org-operator">=</span> fuel_model.S_e,
        dynamic              <span class="org-operator">=</span> fuel_model.dynamic,
        burnable             <span class="org-operator">=</span> fuel_model.burnable,
        exp_A_sigma          <span class="org-operator">=</span> fuel_model.exp_A_sigma,
        firemod_size_classes <span class="org-operator">=</span> fuel_model.firemod_size_classes,
        f_ij                 <span class="org-operator">=</span> fuel_model.f_ij,
        f_i                  <span class="org-operator">=</span> fuel_model.f_i,
        g_ij                 <span class="org-operator">=</span> fuel_model.g_ij,
    )
    <span class="org-comment-delimiter"># </span><span class="org-comment">Mutate and return the copy</span>
    <span class="org-variable-name">dynamic_fuel_model</span>    : FuelModel <span class="org-operator">=</span> add_dynamic_fuel_loading(fuel_model_copy, fuel_moisture)
    <span class="org-variable-name">weighted_fuel_model</span>   : FuelModel <span class="org-operator">=</span> add_weighting_factors(dynamic_fuel_model)
    <span class="org-variable-name">moisturized_fuel_model</span>: FuelModel <span class="org-operator">=</span> add_live_moisture_of_extinction(weighted_fuel_model)
    <span class="org-keyword">return</span> moisturized_fuel_model
</pre>
</div>

<p>
This concludes our coverage of fuel models and fuel moisture.
</p>
</div>
</div>
</div>

<div id="outline-container-for-users-fuel" class="outline-3">
<h3 id="for-users-fuel"><span class="section-number-3">4.2.</span> For Users</h3>
<div class="outline-text-3" id="text-for-users-fuel">
<p>
In the following sections, we will demonstrate how to access fuel
model properties by fuel model number both alone and combined with
fuel moisture.
</p>
</div>

<div id="outline-container-how-to-look-up-a-fuel-model's-properties" class="outline-4">
<h4 id="how-to-look-up-a-fuel-model's-properties"><span class="section-number-4">4.2.1.</span> How to Look Up a Fuel Model's Properties</h4>
<div class="outline-text-4" id="text-how-to-look-up-a-fuel-model's-properties">
<div class="org-src-container">
<pre class="src src-python" id="look-up-fuel-model-properties"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">from</span> pyretechnics.fuel_models <span class="org-keyword">import</span> get_fuel_model

<span class="org-variable-name">static_fuel_model_number</span>  <span class="org-operator">=</span> 1   <span class="org-comment-delimiter"># </span><span class="org-comment">R01</span>
<span class="org-variable-name">dynamic_fuel_model_number</span> <span class="org-operator">=</span> 101 <span class="org-comment-delimiter"># </span><span class="org-comment">GR1</span>

<span class="org-variable-name">static_fuel_model</span>  <span class="org-operator">=</span> get_fuel_model(static_fuel_model_number)
<span class="org-variable-name">dynamic_fuel_model</span> <span class="org-operator">=</span> get_fuel_model(dynamic_fuel_model_number)

<span class="org-builtin">print</span>(<span class="org-string">"Static Fuel Model: R01"</span>)
pprint(static_fuel_model)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Dynamic Fuel Model: GR1"</span>)
pprint(dynamic_fuel_model)
</pre>
</div>

<pre class="example" id="look-up-fuel-model-properties-results">
Static Fuel Model: R01
{'M_f': (0.0, 0.0, 0.0, 0.0, 0.0, 0.0),
 'M_x': (0.11999999731779099,
         0.11999999731779099,
         0.11999999731779099,
         0.0,
         0.0,
         0.0),
 'S_T': (0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574),
 'S_e': (0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582),
 'burnable': True,
 'delta': 1.0,
 'dynamic': False,
 'exp_A_sigma': (0.9613386392593384, 0.0, 0.0, 0.0, 0.0, 0.0),
 'f_i': (0.0, 0.0),
 'f_ij': (0.0, 0.0, 0.0, 0.0, 0.0, 0.0),
 'firemod_size_classes': (1.0, 6.0, 6.0, 6.0, 6.0, 6.0),
 'g_ij': (0.0, 0.0, 0.0, 0.0, 0.0, 0.0),
 'h': (8000.0, 8000.0, 8000.0, 8000.0, 8000.0, 8000.0),
 'number': 1,
 'rho_p': (32.0, 32.0, 32.0, 32.0, 32.0, 32.0),
 'sigma': (3500.0, 0.0, 0.0, 0.0, 0.0, 0.0),
 'w_o': (0.03400000184774399, 0.0, 0.0, 0.0, 0.0, 0.0)}

Dynamic Fuel Model: GR1
{'M_f': (0.0, 0.0, 0.0, 0.0, 0.0, 0.0),
 'M_x': (0.15000000596046448,
         0.15000000596046448,
         0.15000000596046448,
         0.15000000596046448,
         0.0,
         0.0),
 'S_T': (0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574),
 'S_e': (0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582),
 'burnable': True,
 'delta': 0.4000000059604645,
 'dynamic': True,
 'exp_A_sigma': (0.9391995668411255,
                 0.281941682100296,
                 0.010051836259663105,
                 0.9333266615867615,
                 0.7788007855415344,
                 0.0),
 'f_i': (0.0, 0.0),
 'f_ij': (0.0, 0.0, 0.0, 0.0, 0.0, 0.0),
 'firemod_size_classes': (1.0, 3.0, 5.0, 1.0, 1.0, 6.0),
 'g_ij': (0.0, 0.0, 0.0, 0.0, 0.0, 0.0),
 'h': (8000.0, 8000.0, 8000.0, 8000.0, 8000.0, 8000.0),
 'number': 101,
 'rho_p': (32.0, 32.0, 32.0, 32.0, 32.0, 32.0),
 'sigma': (2200.0, 109.0, 30.0, 2000.0, 2000.0, 0.0),
 'w_o': (0.004600000102072954, 0.0, 0.0, 0.0, 0.013799999840557575, 0.0)}
</pre>
</div>
</div>

<div id="outline-container-how-to-apply-fuel-moisture-to-a-fuel-model" class="outline-4">
<h4 id="how-to-apply-fuel-moisture-to-a-fuel-model"><span class="section-number-4">4.2.2.</span> How to Apply Fuel Moisture to a Fuel Model</h4>
<div class="outline-text-4" id="text-how-to-apply-fuel-moisture-to-a-fuel-model">
<div class="org-src-container">
<pre class="src src-python" id="moisturize-fuel-model"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">from</span> pyretechnics.fuel_models <span class="org-keyword">import</span> get_fuel_model, moisturize

<span class="org-variable-name">static_fuel_model_number</span>  <span class="org-operator">=</span> 1   <span class="org-comment-delimiter"># </span><span class="org-comment">R01</span>
<span class="org-variable-name">dynamic_fuel_model_number</span> <span class="org-operator">=</span> 101 <span class="org-comment-delimiter"># </span><span class="org-comment">GR1</span>

<span class="org-variable-name">static_fuel_model</span>  <span class="org-operator">=</span> get_fuel_model(static_fuel_model_number)
<span class="org-variable-name">dynamic_fuel_model</span> <span class="org-operator">=</span> get_fuel_model(dynamic_fuel_model_number)

<span class="org-variable-name">fuel_moisture</span> <span class="org-operator">=</span> (
    0.05, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_1hr</span>
    0.10, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_10hr</span>
    0.15, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_100hr</span>
    0.00, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_herbaceous (will be set by moisturize for dynamic fuel models)</span>
    0.30, <span class="org-comment-delimiter"># </span><span class="org-comment">live_herbaceous</span>
    0.50, <span class="org-comment-delimiter"># </span><span class="org-comment">live_woody</span>
)

<span class="org-builtin">print</span>(<span class="org-string">"Moisturized Static Fuel Model: R01"</span>)
pprint(moisturize(static_fuel_model, fuel_moisture))

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Moisturized Dynamic Fuel Model: GR1"</span>)
pprint(moisturize(dynamic_fuel_model, fuel_moisture))
</pre>
</div>

<pre class="example" id="moisturize-fuel-model-results">
Moisturized Static Fuel Model: R01
{'M_f': (0.05000000074505806,
         0.10000000149011612,
         0.15000000596046448,
         0.0,
         0.30000001192092896,
         0.5),
 'M_x': (0.11999999731779099,
         0.11999999731779099,
         0.11999999731779099,
         0.0,
         0.11999999731779099,
         0.11999999731779099),
 'S_T': (0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574),
 'S_e': (0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582),
 'burnable': True,
 'delta': 1.0,
 'dynamic': False,
 'exp_A_sigma': (0.9613386392593384, 0.0, 0.0, 0.0, 0.0, 0.0),
 'f_i': (1.0, 0.0),
 'f_ij': (1.0, 0.0, 0.0, 0.0, 0.0, 0.0),
 'firemod_size_classes': (1.0, 6.0, 6.0, 6.0, 6.0, 6.0),
 'g_ij': (1.0, 0.0, 0.0, 0.0, 0.0, 0.0),
 'h': (8000.0, 8000.0, 8000.0, 8000.0, 8000.0, 8000.0),
 'number': 1,
 'rho_p': (32.0, 32.0, 32.0, 32.0, 32.0, 32.0),
 'sigma': (3500.0, 0.0, 0.0, 0.0, 0.0, 0.0),
 'w_o': (0.03400000184774399, 0.0, 0.0, 0.0, 0.0, 0.0)}

Moisturized Dynamic Fuel Model: GR1
{'M_f': (0.05000000074505806,
         0.10000000149011612,
         0.15000000596046448,
         0.05000000074505806,
         0.30000001192092896,
         0.5),
 'M_x': (0.15000000596046448,
         0.15000000596046448,
         0.15000000596046448,
         0.15000000596046448,
         0.15000000596046448,
         0.15000000596046448),
 'S_T': (0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574,
         0.05550000071525574),
 'S_e': (0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582,
         0.009999999776482582),
 'burnable': True,
 'delta': 0.4000000059604645,
 'dynamic': True,
 'exp_A_sigma': (0.9391995668411255,
                 0.281941682100296,
                 0.010051836259663105,
                 0.9333266615867615,
                 0.7788007855415344,
                 0.0),
 'f_i': (1.0, 9.691811797551964e-09),
 'f_ij': (0.2682926654815674, 0.0, 0.0, 0.7317073345184326, 0.0, 0.0),
 'firemod_size_classes': (1.0, 3.0, 5.0, 1.0, 1.0, 6.0),
 'g_ij': (1.0, 0.0, 0.0, 1.0, 0.0, 0.0),
 'h': (8000.0, 8000.0, 8000.0, 8000.0, 8000.0, 8000.0),
 'number': 101,
 'rho_p': (32.0, 32.0, 32.0, 32.0, 32.0, 32.0),
 'sigma': (2200.0, 109.0, 30.0, 2000.0, 2000.0, 0.0),
 'w_o': (0.004600000102072954,
         0.0,
         0.0,
         0.013799999840557575,
         1.8278757674128343e-10,
         0.0)}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-surface-fire-equations-(pyretechnics.surface_fire)" class="outline-2">
<h2 id="surface-fire-equations-(pyretechnics.surface_fire)"><span class="section-number-2">5.</span> Surface Fire Equations (pyretechnics.surface_fire)</h2>
<div class="outline-text-2" id="text-surface-fire-equations-(pyretechnics.surface_fire)">
</div>
<div id="outline-container-for-developers-surface" class="outline-3">
<h3 id="for-developers-surface"><span class="section-number-3">5.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-for-developers-surface">
<p>
The following sections define functions that calculate the spread rate
and intensity of a fire burning through surface fuels. These functions
combine fuel models and fuel moisture values (as defined in section
<a href="#fuel-model-and-moisture-definitions-(pyretechnics.fuel_models)">4</a>) with
wind and topography inputs to determine the maximum spread rate and
direction of a surface fire as well as its fireline intensity and
flame length.
</p>
</div>

<div id="outline-container-module-imports-surface-fire" class="outline-4">
<h4 id="module-imports-surface-fire"><span class="section-number-4">5.1.1.</span> Module Imports</h4>
<div class="outline-text-4" id="text-module-imports-surface-fire">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-imports"><span class="org-keyword">import</span> cython
<span class="org-keyword">import</span> cython <span class="org-keyword">as</span> cy
<span class="org-keyword">if</span> cython.compiled:
    <span class="org-keyword">from</span> cython.cimports.libc.math <span class="org-keyword">import</span> sqrt, <span class="org-builtin">pow</span>, log, exp
    <span class="org-keyword">from</span> cython.cimports.pyretechnics.cy_types <span class="org-keyword">import</span> \
        vec_xy, vec_xyz, fcatarr, fclaarr, FuelModel, ProjectedVectors, FireBehaviorMin, \
        FireBehaviorMax, SpreadBehavior
    <span class="org-keyword">import</span> cython.cimports.pyretechnics.conversion <span class="org-keyword">as</span> conv
    <span class="org-keyword">import</span> cython.cimports.pyretechnics.vector_utils <span class="org-keyword">as</span> vu
<span class="org-keyword">else</span>:
    <span class="org-keyword">from</span> math <span class="org-keyword">import</span> sqrt, <span class="org-builtin">pow</span>, log, exp
    <span class="org-keyword">from</span> pyretechnics.py_types <span class="org-keyword">import</span> \
        vec_xy, vec_xyz, fcatarr, fclaarr, FuelModel, ProjectedVectors, FireBehaviorMin, \
        FireBehaviorMax, SpreadBehavior
    <span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv
    <span class="org-keyword">import</span> pyretechnics.vector_utils <span class="org-keyword">as</span> vu
</pre>
</div>
</div>
</div>

<div id="outline-container-rothermel's-surface-fire-rate-of-spread-equation" class="outline-4">
<h4 id="rothermel's-surface-fire-rate-of-spread-equation"><span class="section-number-4">5.1.2.</span> Rothermel's Surface Fire Rate of Spread Equation</h4>
<div class="outline-text-4" id="text-rothermel's-surface-fire-rate-of-spread-equation">
<p>
To simulate fire behavior in as similar a way as possible to the US
government-sponsored fire models (e.g., FARSITE, FlamMap, FPA,
BehavePlus), Pyretechnics adopts the surface fire spread and reaction
intensity formulas from Rothermel's 1972 publication "A Mathematical
Model for Predicting Fire Spread in Wildland Fuels", adjusted
according to Albini 1976 Appendix III to match the behavior of
Albini's original FIREMODS library.<sup><a id="fnr.11" class="footref" href="#fn.11" role="doc-backlink">11</a></sup><sup>, </sup><sup><a id="fnr.12" class="footref" href="#fn.12" role="doc-backlink">12</a></sup>
This should align with the updated description provided in Patricia
Andrews' 2018 publication "The Rothermel Surface Fire Spread Model and
Associated Developments: A Comprehensive
Explanation".<sup><a id="fnr.13" class="footref" href="#fn.13" role="doc-backlink">13</a></sup>
</p>

<p>
Very briefly, the surface rate of spread of a fire's leading edge \(R\)
is described by the following formula:
</p>

\begin{align}
  R = \frac{I_R \, \xi \, (1 + \phi_W + \phi_S)}{\rho_b \, \epsilon \, Q_{ig}}
\end{align}

<p>
where these terms have the meanings shown in Table
<a href="#tab:fire-spread-inputs">2</a>.
</p>

<table id="tab:fire-spread-inputs">
<caption class="t-above"><span class="table-number">Table 2:</span> Inputs to Rothermel's surface fire rate of spread equation</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Term</th>
<th scope="col" class="org-left">Description</th>
<th scope="col" class="org-left">Units</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">\(R\)</td>
<td class="org-left">surface fire spread rate</td>
<td class="org-left">\(\text{ft}/\min\)</td>
</tr>

<tr>
<td class="org-left">\(I_R\)</td>
<td class="org-left">reaction intensity</td>
<td class="org-left">\(\text{Btu}/\text{ft}^2/\min\)</td>
</tr>

<tr>
<td class="org-left">\(\xi\)</td>
<td class="org-left">propagating flux ratio</td>
<td class="org-left">\(\text{unitless}\)</td>
</tr>

<tr>
<td class="org-left">\(\phi_W\)</td>
<td class="org-left">wind factor</td>
<td class="org-left">\(\text{unitless}\)</td>
</tr>

<tr>
<td class="org-left">\(\phi_S\)</td>
<td class="org-left">slope factor</td>
<td class="org-left">\(\text{unitless}\)</td>
</tr>

<tr>
<td class="org-left">\(\rho_b\)</td>
<td class="org-left">oven-dry fuel bed bulk density</td>
<td class="org-left">\(\text{lb}/\text{ft}^3\)</td>
</tr>

<tr>
<td class="org-left">\(\epsilon\)</td>
<td class="org-left">effective heating number</td>
<td class="org-left">\(\text{unitless}\)</td>
</tr>

<tr>
<td class="org-left">\(Q_{ig}\)</td>
<td class="org-left">heat of preignition</td>
<td class="org-left">\(\text{Btu}/\text{lb}\)</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-surface-fire-spread-rate-functions-(no-wind-no-slope)" class="outline-4">
<h4 id="surface-fire-spread-rate-functions-(no-wind-no-slope)"><span class="section-number-4">5.1.3.</span> Surface Fire Spread Rate Functions (No Wind No Slope)</h4>
<div class="outline-text-4" id="text-surface-fire-spread-rate-functions-(no-wind-no-slope)">
<p>
In this section, Rothermel's surface fire spread rate equation will be
computed without introducing the effects of wind or slope (i.e.,
\(\phi_W = \phi_S = 0\)). In this case, the only necessary input is a
moisturized fuel model (as created in section <a href="#applying-fuel-moisture-to-a-fuel-model">4.1.8</a>). Thus, the functions below will focus on the
no-wind-no-slope term \(R_0\) defined as follows:
</p>

\begin{align}
  R_0 &= \frac{I_R \, \xi}{\rho_b \, \epsilon \, Q_{ig}} \\
  \nonumber \\
  R &= R_0 \, (1 + \phi_W + \phi_S)
\end{align}

<p>
Each term will be defined in its own section, and finally they will be
combined together in a single function that computes \(R_0\).
</p>
</div>

<ol class="org-ol">
<li><a id="utility-functions-surface-fire"></a>Utility Functions<br>
<div class="outline-text-5" id="text-utility-functions-surface-fire">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-utility-functions"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">__dotp_in_category</span>(x_ij: fclaarr, y_ij: fclaarr) <span class="org-operator">-&gt;</span> fcatarr:
    <span class="org-doc">"""</span>
<span class="org-doc">    Util: dot-product between fuel size class vectors, within each fuel category (dead/live).</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> (
        (
            (x_ij[0] <span class="org-operator">*</span> y_ij[0]) <span class="org-operator">+</span>
            (x_ij[1] <span class="org-operator">*</span> y_ij[1]) <span class="org-operator">+</span>
            (x_ij[2] <span class="org-operator">*</span> y_ij[2]) <span class="org-operator">+</span>
            (x_ij[3] <span class="org-operator">*</span> y_ij[3])
        ),
        (
            (x_ij[4] <span class="org-operator">*</span> y_ij[4]) <span class="org-operator">+</span>
            (x_ij[5] <span class="org-operator">*</span> y_ij[5])
        )
    )


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">__dotp_categories</span>(x_i: fcatarr, y_i: fcatarr) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-keyword">return</span> (
        (x_i[0] <span class="org-operator">*</span> y_i[0]) <span class="org-operator">+</span>
        (x_i[1] <span class="org-operator">*</span> y_i[1])
    )
</pre>
</div>
</div>
</li>

<li><a id="common-intermediate-calculations:-$\sigma',-\beta,-\beta_{op}$"></a>Common Intermediate Calculations: \(\sigma', \beta, \beta_{op}\)<br>
<div class="outline-text-5" id="text-common-intermediate-calculations:-$\sigma',-\beta,-\beta_{op}$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-common-intermediate-calculations"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_surface_area_to_volume_ratio</span>(f_i: fcatarr, f_ij: fclaarr, sigma: fclaarr) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-variable-name">sigma_prime</span>: fcatarr <span class="org-operator">=</span> __dotp_in_category(f_ij, sigma)
    <span class="org-keyword">return</span> __dotp_categories(f_i, sigma_prime)


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_packing_ratio</span>(w_o: fclaarr, rho_p: fclaarr, delta: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-keyword">if</span> (delta <span class="org-operator">&gt;</span> 0.0):
        <span class="org-variable-name">rho_p_inv</span>: fclaarr <span class="org-operator">=</span> ( <span class="org-comment-delimiter"># </span><span class="org-comment">TODO: OPTIM pre-compute</span>
            1.0<span class="org-operator">/</span>rho_p[0],
            1.0<span class="org-operator">/</span>rho_p[1],
            1.0<span class="org-operator">/</span>rho_p[2],
            1.0<span class="org-operator">/</span>rho_p[3],
            1.0<span class="org-operator">/</span>rho_p[4],
            1.0<span class="org-operator">/</span>rho_p[5]
        )
        <span class="org-variable-name">beta</span>: fcatarr <span class="org-operator">=</span> __dotp_in_category(w_o, rho_p_inv)
        <span class="org-keyword">return</span> (beta[0] <span class="org-operator">+</span> beta[1]) <span class="org-operator">/</span> delta
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> 0.0


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_optimum_packing_ratio</span>(sigma_prime: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-keyword">return</span> (3.348 <span class="org-operator">*</span> <span class="org-builtin">pow</span>(sigma_prime, <span class="org-operator">-</span>0.8189)) <span class="org-keyword">if</span> (sigma_prime <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 1.0
</pre>
</div>
</div>
</li>

<li><a id="reaction-intensity:-$i_r$"></a>Reaction Intensity: \(I_R\)<br>
<div class="outline-text-5" id="text-reaction-intensity:-$i_r$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-reaction-intensity"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_mineral_damping_coefficients</span>(f_ij: fclaarr, S_e: fclaarr) <span class="org-operator">-&gt;</span> fcatarr:
    <span class="org-variable-name">S_e_i</span>: fcatarr <span class="org-operator">=</span> __dotp_in_category(f_ij, S_e)
    (<span class="org-variable-name">S_e_0</span>, <span class="org-variable-name">S_e_1</span>) <span class="org-operator">=</span> S_e_i
    <span class="org-keyword">return</span> (
        0.174 <span class="org-operator">*</span> <span class="org-builtin">pow</span>(S_e_0, <span class="org-operator">-</span>0.19) <span class="org-keyword">if</span> (S_e_0 <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 1.0,
        0.174 <span class="org-operator">*</span> <span class="org-builtin">pow</span>(S_e_1, <span class="org-operator">-</span>0.19) <span class="org-keyword">if</span> (S_e_1 <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 1.0
    )


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">__cat_moisture_damping_coefficient</span>(M_f: cy.<span class="org-builtin">float</span>, M_x: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-keyword">if</span> (M_x <span class="org-operator">&gt;</span> 0.0):
        <span class="org-variable-name">r_M</span> : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> <span class="org-builtin">min</span>(1.0, M_f <span class="org-operator">/</span> M_x)
        <span class="org-variable-name">r_M2</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> r_M <span class="org-operator">*</span> r_M
        <span class="org-variable-name">r_M3</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> r_M2 <span class="org-operator">*</span> r_M
        <span class="org-keyword">return</span> 1.0 <span class="org-operator">-</span> (2.59 <span class="org-operator">*</span> r_M) <span class="org-operator">+</span> (5.11 <span class="org-operator">*</span> r_M2) <span class="org-operator">-</span> (3.52 <span class="org-operator">*</span> r_M3)
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> 0.0


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_moisture_damping_coefficients</span>(f_ij: fclaarr, M_f: fclaarr, M_x: fclaarr) <span class="org-operator">-&gt;</span> fcatarr:
    <span class="org-variable-name">M_f_i</span>: fcatarr <span class="org-operator">=</span> __dotp_in_category(f_ij, M_f)
    <span class="org-variable-name">M_x_i</span>: fcatarr <span class="org-operator">=</span> __dotp_in_category(f_ij, M_x)
    <span class="org-keyword">return</span> (
        __cat_moisture_damping_coefficient(M_f_i[0], M_x_i[0]),
        __cat_moisture_damping_coefficient(M_f_i[1], M_x_i[1])
    )


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_low_heat_content</span>(f_ij: fclaarr, h: fclaarr) <span class="org-operator">-&gt;</span> fcatarr:
    <span class="org-keyword">return</span> __dotp_in_category(f_ij, h)


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_net_fuel_loading</span>(g_ij: fclaarr, w_o: fclaarr, S_T: fclaarr) <span class="org-operator">-&gt;</span> fcatarr:
    <span class="org-keyword">return</span> (
        (
            g_ij[0] <span class="org-operator">*</span> w_o[0] <span class="org-operator">*</span> (1.0 <span class="org-operator">-</span> S_T[0]) <span class="org-operator">+</span>
            g_ij[1] <span class="org-operator">*</span> w_o[1] <span class="org-operator">*</span> (1.0 <span class="org-operator">-</span> S_T[1]) <span class="org-operator">+</span>
            g_ij[2] <span class="org-operator">*</span> w_o[2] <span class="org-operator">*</span> (1.0 <span class="org-operator">-</span> S_T[2]) <span class="org-operator">+</span>
            g_ij[3] <span class="org-operator">*</span> w_o[3] <span class="org-operator">*</span> (1.0 <span class="org-operator">-</span> S_T[3])
        ),
        (
            g_ij[4] <span class="org-operator">*</span> w_o[4] <span class="org-operator">*</span> (1.0 <span class="org-operator">-</span> S_T[4]) <span class="org-operator">+</span>
            g_ij[5] <span class="org-operator">*</span> w_o[5] <span class="org-operator">*</span> (1.0 <span class="org-operator">-</span> S_T[5])
        )
    )


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_heat_per_unit_area</span>(eta_S_i: fcatarr, eta_M_i: fcatarr, h_i: fcatarr, W_n_i: fcatarr) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-keyword">return</span> (
        (W_n_i[0] <span class="org-operator">*</span> h_i[0] <span class="org-operator">*</span> eta_M_i[0] <span class="org-operator">*</span> eta_S_i[0]) <span class="org-operator">+</span>
        (W_n_i[1] <span class="org-operator">*</span> h_i[1] <span class="org-operator">*</span> eta_M_i[1] <span class="org-operator">*</span> eta_S_i[1])
    )


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_optimum_reaction_velocity</span>(sigma_prime: cy.<span class="org-builtin">float</span>, beta: cy.<span class="org-builtin">float</span>, beta_op: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Albini 1976 replaces 1 / (4.774 * (sigma_prime ** 0.1) - 7.27)</span>
    <span class="org-variable-name">A</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (133.0 <span class="org-operator">*</span> <span class="org-builtin">pow</span>(sigma_prime, <span class="org-operator">-</span>0.7913)) <span class="org-keyword">if</span> (sigma_prime <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 0.0
    <span class="org-variable-name">B</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> <span class="org-builtin">pow</span>(sigma_prime, 1.5)
    <span class="org-variable-name">C</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> beta <span class="org-operator">/</span> beta_op
    <span class="org-comment-delimiter"># </span><span class="org-comment">Maximum reaction velocity (1/min)</span>
    <span class="org-variable-name">Gamma_prime_max</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> B <span class="org-operator">/</span> (495.0 <span class="org-operator">+</span> 0.0594 <span class="org-operator">*</span> B)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Optimum reaction velocity (1/min)</span>
    <span class="org-keyword">return</span> Gamma_prime_max <span class="org-operator">*</span> <span class="org-builtin">pow</span>(C, A) <span class="org-operator">*</span> exp(A <span class="org-operator">*</span> (1.0 <span class="org-operator">-</span> C))


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_reaction_intensity</span>(moisturized_fuel_model: FuelModel,
                            sigma_prime           : cy.<span class="org-builtin">float</span>,
                            beta                  : cy.<span class="org-builtin">float</span>,
                            beta_op               : cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack the FuelModel fields</span>
    <span class="org-variable-name">w_o</span> : fclaarr <span class="org-operator">=</span> moisturized_fuel_model.w_o
    <span class="org-variable-name">h</span>   : fclaarr <span class="org-operator">=</span> moisturized_fuel_model.h
    <span class="org-variable-name">S_T</span> : fclaarr <span class="org-operator">=</span> moisturized_fuel_model.S_T
    <span class="org-variable-name">S_e</span> : fclaarr <span class="org-operator">=</span> moisturized_fuel_model.S_e
    <span class="org-variable-name">M_x</span> : fclaarr <span class="org-operator">=</span> moisturized_fuel_model.M_x
    <span class="org-variable-name">M_f</span> : fclaarr <span class="org-operator">=</span> moisturized_fuel_model.M_f
    <span class="org-variable-name">f_ij</span>: fclaarr <span class="org-operator">=</span> moisturized_fuel_model.f_ij
    <span class="org-variable-name">g_ij</span>: fclaarr <span class="org-operator">=</span> moisturized_fuel_model.g_ij
    <span class="org-comment-delimiter"># </span><span class="org-comment">Derive intermediate quantities</span>
    <span class="org-variable-name">eta_S_i</span>    : fcatarr  <span class="org-operator">=</span> calc_mineral_damping_coefficients(f_ij, S_e)
    <span class="org-variable-name">eta_M_i</span>    : fcatarr  <span class="org-operator">=</span> calc_moisture_damping_coefficients(f_ij, M_f, M_x)
    <span class="org-variable-name">h_i</span>        : fcatarr  <span class="org-operator">=</span> calc_low_heat_content(f_ij, h)                             <span class="org-comment-delimiter"># </span><span class="org-comment">(Btu/lb)</span>
    <span class="org-variable-name">W_n_i</span>      : fcatarr  <span class="org-operator">=</span> calc_net_fuel_loading(g_ij, w_o, S_T)                      <span class="org-comment-delimiter"># </span><span class="org-comment">(lb/ft^2)</span>
    <span class="org-variable-name">Btus</span>       : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_heat_per_unit_area(eta_S_i, eta_M_i, h_i, W_n_i)      <span class="org-comment-delimiter"># </span><span class="org-comment">(Btu/ft^2)</span>
    <span class="org-variable-name">Gamma_prime</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_optimum_reaction_velocity(sigma_prime, beta, beta_op) <span class="org-comment-delimiter"># </span><span class="org-comment">(1/min)</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate reaction intensity</span>
    <span class="org-keyword">return</span> Btus <span class="org-operator">*</span> Gamma_prime <span class="org-comment-delimiter"># </span><span class="org-comment">(Btu/ft^2/min)</span>
</pre>
</div>
</div>
</li>

<li><a id="propagating-flux-ratio:-$\xi$"></a>Propagating Flux Ratio: \(\xi\)<br>
<div class="outline-text-5" id="text-propagating-flux-ratio:-$\xi$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-propagating-flux-ratio"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_propagating_flux_ratio</span>(sigma_prime: cy.<span class="org-builtin">float</span>, beta: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-keyword">return</span> exp((0.792 <span class="org-operator">+</span> 0.681 <span class="org-operator">*</span> sqrt(sigma_prime)) <span class="org-operator">*</span> (beta <span class="org-operator">+</span> 0.1)) <span class="org-operator">/</span> (192.0 <span class="org-operator">+</span> 0.2595 <span class="org-operator">*</span> sigma_prime)
</pre>
</div>
</div>
</li>

<li><a id="heat-source-(no-wind-no-slope):-$i_r-\,-\xi$"></a>Heat Source (No Wind No Slope): \(I_R \, \xi\)<br>
<div class="outline-text-5" id="text-heat-source-(no-wind-no-slope):-$i_r-\,-\xi$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-heat-source-no-wind-no-slope"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_heat_source</span>(I_R: cy.<span class="org-builtin">float</span>, xi: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-keyword">return</span> I_R <span class="org-operator">*</span> xi
</pre>
</div>
</div>
</li>

<li><a id="oven-dry-fuel-bed-bulk-density:-!$\rho_b$"></a>Oven-Dry Fuel Bed Bulk Density: \(\rho_b\)<br>
<div class="outline-text-5" id="text-oven-dry-fuel-bed-bulk-density:-!$\rho_b$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-oven-dry-fuel-bed-bulk-density"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_ovendry_bulk_density</span>(w_o: fclaarr, delta: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-keyword">if</span> (delta <span class="org-operator">&gt;</span> 0.0):
        <span class="org-variable-name">w_o_sum</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> w_o[0] <span class="org-operator">+</span> w_o[1] <span class="org-operator">+</span> w_o[2] <span class="org-operator">+</span> w_o[3] <span class="org-operator">+</span> w_o[4] <span class="org-operator">+</span> w_o[5]
        <span class="org-keyword">return</span> w_o_sum <span class="org-operator">/</span> delta
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> 0.0
</pre>
</div>
</div>
</li>

<li><a id="effective-heating-number-distribution:-!$\epsilon_{ij}$"></a>Effective Heating Number Distribution: \(\epsilon_{ij}\)<br>
<div class="outline-text-5" id="text-effective-heating-number-distribution:-!$\epsilon_{ij}$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-effective-heating-number-distribution"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">__sizeclass_heating_number</span>(sigma_i: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-keyword">return</span> exp(<span class="org-operator">-</span>138.0 <span class="org-operator">/</span> sigma_i) <span class="org-keyword">if</span> (sigma_i <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 0.0


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_effective_heating_number_distribution</span>(sigma: fclaarr) <span class="org-operator">-&gt;</span> fclaarr: <span class="org-comment-delimiter"># </span><span class="org-comment">OPTIM pre-compute, exp is expensive</span>
    <span class="org-keyword">return</span> (
        __sizeclass_heating_number(sigma[0]),
        __sizeclass_heating_number(sigma[1]),
        __sizeclass_heating_number(sigma[2]),
        __sizeclass_heating_number(sigma[3]),
        __sizeclass_heating_number(sigma[4]),
        __sizeclass_heating_number(sigma[5])
    )
</pre>
</div>
</div>
</li>

<li><a id="heat-of-preignition-distribution:-!$(q_{ig})_{ij}$"></a>Heat of Preignition Distribution: \((Q_{ig})_{ij}\)<br>
<div class="outline-text-5" id="text-heat-of-preignition-distribution:-!$(q_{ig})_{ij}$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-heat-of-preignition-distribution"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">__sizeclass_heat_of_preignition_distribution</span>(M_f_i: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-variable-name">pos1</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(cy.<span class="org-builtin">float</span>, (M_f_i <span class="org-operator">&gt;</span> 0.0))
    <span class="org-keyword">return</span> (250.0 <span class="org-operator">+</span> 1116.0 <span class="org-operator">*</span> M_f_i) <span class="org-operator">*</span> pos1 <span class="org-comment-delimiter"># </span><span class="org-comment">Returns 0 unless M_f_i &gt; 0</span>


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_heat_of_preignition_distribution</span>(M_f: fclaarr) <span class="org-operator">-&gt;</span> fclaarr:
    <span class="org-keyword">return</span> (
        __sizeclass_heat_of_preignition_distribution(M_f[0]),
        __sizeclass_heat_of_preignition_distribution(M_f[1]),
        __sizeclass_heat_of_preignition_distribution(M_f[2]),
        __sizeclass_heat_of_preignition_distribution(M_f[3]),
        __sizeclass_heat_of_preignition_distribution(M_f[4]),
        __sizeclass_heat_of_preignition_distribution(M_f[5])
    )
</pre>
</div>
</div>
</li>

<li><a id="heat-sink:-$\rho_b-\,-\epsilon-\,-q_{ig}$"></a>Heat Sink: \(\rho_b \, \epsilon \, Q_{ig}\)<br>
<div class="outline-text-5" id="text-heat-sink:-$\rho_b-\,-\epsilon-\,-q_{ig}$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-heat-sink"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_heat_sink</span>(f_i: fcatarr, f_ij: fclaarr, rho_b: cy.<span class="org-builtin">float</span>, epsilon_ij: fclaarr, Q_ig_ij: fclaarr) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-variable-name">effective_heat_of_preignition_i</span>: fcatarr <span class="org-operator">=</span> (
        (
            (f_ij[0] <span class="org-operator">*</span> epsilon_ij[0] <span class="org-operator">*</span> Q_ig_ij[0]) <span class="org-operator">+</span>
            (f_ij[1] <span class="org-operator">*</span> epsilon_ij[1] <span class="org-operator">*</span> Q_ig_ij[1]) <span class="org-operator">+</span>
            (f_ij[2] <span class="org-operator">*</span> epsilon_ij[2] <span class="org-operator">*</span> Q_ig_ij[2]) <span class="org-operator">+</span>
            (f_ij[3] <span class="org-operator">*</span> epsilon_ij[3] <span class="org-operator">*</span> Q_ig_ij[3])
        ),
        (
            (f_ij[4] <span class="org-operator">*</span> epsilon_ij[4] <span class="org-operator">*</span> Q_ig_ij[4]) <span class="org-operator">+</span>
            (f_ij[5] <span class="org-operator">*</span> epsilon_ij[5] <span class="org-operator">*</span> Q_ig_ij[5])
        )
    )
    <span class="org-variable-name">effective_heat_of_preignition</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> __dotp_categories(f_i, effective_heat_of_preignition_i)
    <span class="org-keyword">return</span> rho_b <span class="org-operator">*</span> effective_heat_of_preignition
</pre>
</div>
</div>
</li>

<li><a id="spread-rate-(no-wind-no-slope):-!$r_0$"></a>Spread Rate (No Wind No Slope): \(R_0\)<br>
<div class="outline-text-5" id="text-spread-rate-(no-wind-no-slope):-!$r_0$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-spread-rate-no-wind-no-slope"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_spread_rate</span>(heat_source: cy.<span class="org-builtin">float</span>, heat_sink: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-keyword">return</span> heat_source <span class="org-operator">/</span> heat_sink <span class="org-keyword">if</span> (heat_sink <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 0.0
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-surface-fire-intensity-functions" class="outline-4">
<h4 id="surface-fire-intensity-functions"><span class="section-number-4">5.1.4.</span> Surface Fire Intensity Functions</h4>
<div class="outline-text-4" id="text-surface-fire-intensity-functions">
<p>
Using the surface fire spread rate and reaction intensity values, we
can now calculate several surface fire intensity metrics by applying
Anderson's residence time and flame depth formulas, Byram's fireline
intensity and flame length equations, and Andrews &amp; Rothermel's heat
per unit area
equation:<sup><a id="fnr.14" class="footref" href="#fn.14" role="doc-backlink">14</a></sup><sup>, </sup><sup><a id="fnr.15" class="footref" href="#fn.15" role="doc-backlink">15</a></sup><sup>, </sup><sup><a id="fnr.16" class="footref" href="#fn.16" role="doc-backlink">16</a></sup>
</p>

\begin{align}
  t_{\text{res}} &= \frac{384}{\sigma'} \\
  \nonumber \\
  D_A &= R_s \, t_{\text{res}} \\
  \nonumber \\
  I_s &= \frac{I_R \, D_A}{60} \\
  \nonumber \\
  L_s &= 0.45 (I_s)^{0.46} \\
  \nonumber \\
  H_s &= I_R \, t_{\text{res}} = 60 \frac{I_s}{R_s} \\
\end{align}

<p>
where \(\sigma'\) is the weighted sum by size class of the fuel model's
surface area to volume ratio in \(\text{ft}^2/\text{ft}^3\),
\(t_{\text{res}}\) is the residence time in \(\text{minutes}\), \(R_s\) is
the surface fire spread rate in \(\text{ft}/\min\), \(D_A\) is the flame
depth in \(\text{ft}\), \(I_R\) is the reaction intensity in
\(\text{Btu}/\text{ft}^2/\min\), \(I_s\) is the fireline intensity in
\(\text{Btu}/\text{ft}/\text{s}\), \(L_s\) is the flame length in
\(\text{ft}\), and \(H_s\) is the heat per unit area in
\(\text{Btu}/\text{ft}^2\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="surface-fire-intensity-functions"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_residence_time</span>(sigma_prime: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the residence time (total burning time) of fuel (min) given:</span>
<span class="org-doc">    - sigma_prime :: ft^2/ft^3 (surface area to volume ratio)</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> 384.0 <span class="org-operator">/</span> sigma_prime <span class="org-keyword">if</span> (sigma_prime <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 0.0


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_flame_depth</span>(spread_rate: cy.<span class="org-builtin">float</span>, residence_time: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the depth, or front-to-back distance, of the actively flaming zone</span>
<span class="org-doc">    of a free-spreading fire (ft) given:</span>
<span class="org-doc">    - spread_rate    :: ft/min (orthogonal to the fireline)</span>
<span class="org-doc">    - residence_time :: min</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> spread_rate <span class="org-operator">*</span> residence_time


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_fireline_intensity</span>(reaction_intensity: cy.<span class="org-builtin">float</span>, flame_depth: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the rate of heat release per unit of fire edge (Btu/ft/s) given:</span>
<span class="org-doc">    - reaction_intensity :: Btu/ft^2/min</span>
<span class="org-doc">    - flame_depth        :: ft</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> (reaction_intensity <span class="org-operator">*</span> flame_depth) <span class="org-operator">/</span> 60.0


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_flame_length</span>(fireline_intensity: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the average flame length (m) given:</span>
<span class="org-doc">    - fireline_intensity :: kW/m</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> 0.07747042253266703 <span class="org-operator">*</span> <span class="org-builtin">pow</span>(fireline_intensity, 0.46)


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_areal_heat_output</span>(spread_rate: cy.<span class="org-builtin">float</span>, fireline_intensity: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the heat per unit area (kJ/m^2) given:</span>
<span class="org-doc">    - spread_rate        :: m/min</span>
<span class="org-doc">    - fireline_intensity :: kW/m</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> 60.0 <span class="org-operator">*</span> fireline_intensity <span class="org-operator">/</span> spread_rate <span class="org-keyword">if</span> spread_rate <span class="org-operator">&gt;</span> 0.0 <span class="org-keyword">else</span> 0.0
</pre>
</div>

<p>
Because of the linear relationship between spread rate, flame depth,
and fireline intensity, once we have calculated the no wind, no slope
fireline intensity, we can simply multiply it by the same combined
wind and slope factor that is applied to the no wind, no slope spread
rate in order to derive the maximum fireline intensity.
</p>

<p>
Since flame length's relationship to fireline intensity is non-linear,
we will need to wait until after any transformations are applied to
fireline intensity before calculating the associated flame length.
</p>
</div>
</div>

<div id="outline-container-wind-and-slope-factor-functions" class="outline-4">
<h4 id="wind-and-slope-factor-functions"><span class="section-number-4">5.1.5.</span> Wind and Slope Factor Functions</h4>
<div class="outline-text-4" id="text-wind-and-slope-factor-functions">
<p>
In order to compute the maximum spread rate, direction, and intensity
of the surface fire front, we will need to incorporate the effects of
wind and slope on the fire. However, we can precompute several
intermediate values and functions needed for this step based solely on
the fuel bed characteristics already available to us with just a
moisturized fuel model (see section <a href="#applying-fuel-moisture-to-a-fuel-model">4.1.8</a>).
</p>
</div>

<ol class="org-ol">
<li><a id="max-effective-wind-speed:-!$u_{\text{eff}}^{\max}$"></a>Max Effective Wind Speed: \(U_{\text{eff}}^{\max}\)<br>
<div class="outline-text-5" id="text-max-effective-wind-speed:-!$u_{\text{eff}}^{\max}$">
<p>
The midflame wind speed that would be required to produce the combined
spread rate in a no-slope scenario is termed the effective windspeed
\(U_{\text{eff}}\). Following the recommendations given in Appendix III
of Albini 1976, these midflame wind speeds are all limited by the
reaction intensity \(I_R\) as follows:<sup><a id="fnr.17" class="footref" href="#fn.17" role="doc-backlink">17</a></sup>
</p>

\begin{align}
  U_{\text{eff}}^{\max} = 0.9 \, I_R
\end{align}

<p>
where \(I_R\) is the reaction intensity in \(\text{Btu}/\text{ft}^2/\min\)
and \(U_{\text{eff}}^{\max}\) is the maximum effective wind speed in
\(\text{ft}/\min\)
</p>

<div class="org-src-container">
<pre class="src src-python" id="surface-fire-max-effective-wind-speed"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_max_effective_wind_speed</span>(reaction_intensity: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-keyword">return</span> 0.9 <span class="org-operator">*</span> reaction_intensity
</pre>
</div>
</div>
</li>

<li><a id="slope-factor-function:-$\tan(\theta_s)-\mapsto-\phi_s$"></a>Slope Factor Function: \(\tan(\theta_S) \mapsto \phi_S\)<br>
<div class="outline-text-5" id="text-slope-factor-function:-$\tan(\theta_s)-\mapsto-\phi_s$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-slope-factor-function"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">get_phi_S</span>(surface_fire_min: FireBehaviorMin, slope: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-keyword">return</span> surface_fire_min._phiS_G <span class="org-operator">*</span> (slope <span class="org-operator">*</span> slope)
</pre>
</div>
</div>
</li>

<li><a id="wind-factor-function:-$u_{\text{mid}}-\mapsto-\phi_w$"></a>Wind Factor Function: \(U_{\text{mid}} \mapsto \phi_W\)<br>
<div class="outline-text-5" id="text-wind-factor-function:-$u_{\text{mid}}-\mapsto-\phi_w$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-wind-factor-function"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">get_phi_W</span>(surface_fire_min: FireBehaviorMin, midflame_wind_speed: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-keyword">return</span> surface_fire_min._phiW_scalr <span class="org-operator">*</span> <span class="org-builtin">pow</span>(midflame_wind_speed, surface_fire_min._phiW_expnt)
</pre>
</div>
</div>
</li>

<li><a id="wind-speed-function:-$\phi_w-\mapsto-u_{\text{mid}}$"></a>Wind Speed Function: \(\phi_W \mapsto U_{\text{mid}}\)<br>
<div class="outline-text-5" id="text-wind-speed-function:-$\phi_w-\mapsto-u_{\text{mid}}$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-wind-speed-function"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">get_wind_speed</span>(surface_fire_min: FireBehaviorMin, phi_W: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-keyword">return</span> surface_fire_min._ws_scalr <span class="org-operator">*</span> <span class="org-builtin">pow</span>(phi_W, surface_fire_min._ws_expnt)
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-surface-fire-behavior-functions-(no-wind-no-slope)" class="outline-4">
<h4 id="surface-fire-behavior-functions-(no-wind-no-slope)"><span class="section-number-4">5.1.6.</span> Surface Fire Behavior Functions (No Wind No Slope)</h4>
<div class="outline-text-4" id="text-surface-fire-behavior-functions-(no-wind-no-slope)">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-behavior-no-wind-no-slope"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">make_surface_fire_min</span>(base_spread_rate        : cy.<span class="org-builtin">float</span>,
                          base_fireline_intensity : cy.<span class="org-builtin">float</span>,
                          max_effective_wind_speed: cy.<span class="org-builtin">float</span>,
                          B                       : cy.<span class="org-builtin">float</span>,
                          C                       : cy.<span class="org-builtin">float</span>,
                          F                       : cy.<span class="org-builtin">float</span>,
                          beta                    : cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> FireBehaviorMin:
    <span class="org-variable-name">_phiS_G</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 0.0
    <span class="org-keyword">if</span> (beta <span class="org-operator">&gt;</span> 0.0):
        <span class="org-variable-name">_phiS_G</span> <span class="org-operator">=</span> 5.275 <span class="org-operator">*</span> <span class="org-builtin">pow</span>(beta, <span class="org-operator">-</span>0.3)

    <span class="org-variable-name">_phiW_scalr</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 0.0
    <span class="org-variable-name">_phiW_expnt</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 0.0
    <span class="org-keyword">if</span> (F <span class="org-operator">&gt;</span> 0.0):
        <span class="org-variable-name">_phiW_scalr</span> <span class="org-operator">=</span> (C <span class="org-operator">/</span> F) <span class="org-operator">*</span> <span class="org-builtin">pow</span>(conv.m_to_ft(1.0), B)
        <span class="org-variable-name">_phiW_expnt</span> <span class="org-operator">=</span> B

    <span class="org-variable-name">_ws_scalr</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 0.0
    <span class="org-variable-name">_ws_expnt</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 0.0
    <span class="org-keyword">if</span> (B <span class="org-operator">&gt;</span> 0.0):
        <span class="org-variable-name">B_inverse</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 1.0 <span class="org-operator">/</span> B
        <span class="org-variable-name">_ws_scalr</span> <span class="org-operator">=</span> conv.ft_to_m(<span class="org-builtin">pow</span>((F <span class="org-operator">/</span> C), B_inverse))
        <span class="org-variable-name">_ws_expnt</span> <span class="org-operator">=</span> B_inverse

    <span class="org-keyword">return</span> FireBehaviorMin(
        base_spread_rate,
        base_fireline_intensity,
        max_effective_wind_speed,
        _phiS_G,
        _phiW_scalr,
        _phiW_expnt,
        _ws_scalr,
        _ws_expnt)


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_surface_fire_behavior_no_wind_no_slope</span>(moisturized_fuel_model: FuelModel,
                                                spread_rate_adjustment: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 1.0) <span class="org-operator">-&gt;</span> FireBehaviorMin:
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - moisturized_fuel_model :: FuelModel struct of fuel model and fuel moisture properties</span>
<span class="org-doc">      - delta :: ft                                        (fuel depth)</span>
<span class="org-doc">      - w_o   :: lb/ft^2                                   (ovendry fuel loading)</span>
<span class="org-doc">      - rho_p :: lb/ft^3                                   (ovendry particle density)</span>
<span class="org-doc">      - sigma :: ft^2/ft^3                                 (fuel particle surface-area-to-volume ratio)</span>
<span class="org-doc">      - h     :: Btu/lb                                    (fuel particle low heat content)</span>
<span class="org-doc">      - S_T   :: lb minerals/lb ovendry weight             (fuel particle total mineral content)</span>
<span class="org-doc">      - S_e   :: lb silica-free minerals/lb ovendry weight (fuel particle effective mineral content)</span>
<span class="org-doc">      - M_x   :: lb moisture/lb ovendry weight             (fuel particle moisture of extinction)</span>
<span class="org-doc">      - M_f   :: lb moisture/lb ovendry weight             (fuel particle moisture content)</span>
<span class="org-doc">      - f_ij  :: %                                         (percent load per size class)</span>
<span class="org-doc">      - f_i   :: %                                         (percent load per category)</span>
<span class="org-doc">      - g_ij  :: %                                         (percent load per size class - Albini_1976_FIREMOD, page 20)</span>
<span class="org-doc">    - spread_rate_adjustment :: unitless float (1.0 for no adjustment)</span>

<span class="org-doc">    return a FireBehaviorMin struct containing these keys:</span>
<span class="org-doc">    - base_spread_rate         :: m/min</span>
<span class="org-doc">    - base_fireline_intensity  :: kW/m</span>
<span class="org-doc">    - max_effective_wind_speed :: m/min</span>
<span class="org-doc">    - _phiS_G                  :: intermediate value for computing phi_S (unitless)</span>
<span class="org-doc">    - _phiW_scalr              :: intermediate value for computing phi_W (unitless)</span>
<span class="org-doc">    - _phiW_expnt              :: intermediate value for computing phi_W (unitless)</span>
<span class="org-doc">    - _ws_scalr                :: intermediate value for computing effective_wind_speed (m/min)</span>
<span class="org-doc">    - _ws_expnt                :: intermediate value for computing effective_wind_speed (unitless)</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack fuel model values</span>
    <span class="org-variable-name">delta</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> moisturized_fuel_model.delta
    <span class="org-variable-name">w_o</span>  : fclaarr  <span class="org-operator">=</span> moisturized_fuel_model.w_o
    <span class="org-variable-name">rho_p</span>: fclaarr  <span class="org-operator">=</span> moisturized_fuel_model.rho_p
    <span class="org-variable-name">sigma</span>: fclaarr  <span class="org-operator">=</span> moisturized_fuel_model.sigma
    <span class="org-variable-name">M_f</span>  : fclaarr  <span class="org-operator">=</span> moisturized_fuel_model.M_f
    <span class="org-variable-name">f_ij</span> : fclaarr  <span class="org-operator">=</span> moisturized_fuel_model.f_ij
    <span class="org-variable-name">f_i</span>  : fcatarr  <span class="org-operator">=</span> moisturized_fuel_model.f_i
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate base spread rate (no wind, no slope)</span>
    <span class="org-variable-name">sigma_prime</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_surface_area_to_volume_ratio(f_i, f_ij, sigma)
    <span class="org-variable-name">beta</span>       : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_packing_ratio(w_o, rho_p, delta)
    <span class="org-variable-name">beta_op</span>    : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_optimum_packing_ratio(sigma_prime)
    <span class="org-variable-name">I_R</span>        : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_reaction_intensity(moisturized_fuel_model, sigma_prime, beta, beta_op) <span class="org-comment-delimiter"># </span><span class="org-comment">Btu/ft^2/min</span>
    <span class="org-variable-name">xi</span>         : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_propagating_flux_ratio(sigma_prime, beta)
    <span class="org-variable-name">heat_source</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_heat_source(I_R, xi)                             <span class="org-comment-delimiter"># </span><span class="org-comment">Btu/ft^2/min</span>
    <span class="org-variable-name">rho_b</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_ovendry_bulk_density(w_o, delta)                 <span class="org-comment-delimiter"># </span><span class="org-comment">lb/ft^3</span>
    <span class="org-variable-name">epsilon_ij</span> : fclaarr  <span class="org-operator">=</span> calc_effective_heating_number_distribution(sigma)
    <span class="org-variable-name">Q_ig_ij</span>    : fclaarr  <span class="org-operator">=</span> calc_heat_of_preignition_distribution(M_f)            <span class="org-comment-delimiter"># </span><span class="org-comment">Btu/lb</span>
    <span class="org-variable-name">heat_sink</span>  : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_heat_sink(f_i, f_ij, rho_b, epsilon_ij, Q_ig_ij) <span class="org-comment-delimiter"># </span><span class="org-comment">Btu/ft^3</span>
    <span class="org-variable-name">R0</span>         : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_spread_rate(heat_source, heat_sink)              <span class="org-comment-delimiter"># </span><span class="org-comment">ft/min</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate base fireline intensity (no wind, no slope)</span>
    <span class="org-variable-name">t_res</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_residence_time(sigma_prime)  <span class="org-comment-delimiter"># </span><span class="org-comment">min</span>
    <span class="org-variable-name">D_A</span>  : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_flame_depth(R0, t_res)       <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
    <span class="org-variable-name">I_s</span>  : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_fireline_intensity(I_R, D_A) <span class="org-comment-delimiter"># </span><span class="org-comment">Btu/ft/s</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Pre-compute values related to wind and slope</span>
    <span class="org-variable-name">U_eff_max</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_max_effective_wind_speed(I_R) <span class="org-comment-delimiter"># </span><span class="org-comment">ft/min</span>
    <span class="org-variable-name">B</span>        : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 0.02526 <span class="org-operator">*</span> <span class="org-builtin">pow</span>(sigma_prime, 0.54)
    <span class="org-variable-name">C</span>        : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 7.47 <span class="org-operator">*</span> exp(<span class="org-operator">-</span>0.133 <span class="org-operator">*</span> <span class="org-builtin">pow</span>(sigma_prime, 0.55))
    <span class="org-variable-name">E</span>        : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 0.715 <span class="org-operator">*</span> exp(<span class="org-operator">-</span>3.59 <span class="org-operator">*</span> (sigma_prime <span class="org-operator">*</span> 1e<span class="org-operator">-</span>4))
    <span class="org-variable-name">F</span>        : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> <span class="org-builtin">pow</span>((beta <span class="org-operator">/</span> beta_op), E)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Return no-wind-no-slope surface fire behavior values</span>
    <span class="org-variable-name">base_spread_rate</span>        : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> conv.ft_to_m(R0 <span class="org-operator">*</span> spread_rate_adjustment)
    <span class="org-variable-name">base_fireline_intensity</span> : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> conv.Btu_ft_s_to_kW_m(I_s <span class="org-operator">*</span> spread_rate_adjustment)
    <span class="org-variable-name">max_effective_wind_speed</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> conv.ft_to_m(U_eff_max)
    <span class="org-keyword">return</span> make_surface_fire_min(
        base_spread_rate,
        base_fireline_intensity,
        max_effective_wind_speed,
        B,
        C,
        F,
        beta
    )
</pre>
</div>
</div>
</div>

<div id="outline-container-midflame-wind-speed" class="outline-4">
<h4 id="midflame-wind-speed"><span class="section-number-4">5.1.7.</span> Midflame Wind Speed</h4>
<div class="outline-text-4" id="text-midflame-wind-speed">
<p>
Rothermel's formulas all expect a measure of midflame wind speed
\(U_{\text{mid}}\). However, wind speed data is often collected at a
height 20 feet (or 10 meters) above either unsheltered ground or a
tree canopy layer if present. To convert this 20-ft wind speed
\(U_{20}\) to the required midflame wind speed value, Pyretechnics uses
the wind adjustment factor formula from Albini &amp; Baughman 1979,
parameterized as in BehavePlus, FARSITE, FlamMap, FSPro, and FPA
according to Andrews 2012<sup><a id="fnr.18" class="footref" href="#fn.18" role="doc-backlink">18</a></sup><sup>, </sup><sup><a id="fnr.19" class="footref" href="#fn.19" role="doc-backlink">19</a></sup>.
</p>

\begin{align}
  \text{WAF} &= \left\{
    \begin{array}{lr}
      1.83 \ln(\frac{20.0 + 0.36 \text{FBD}}{0.13 \text{FBD}})^{-1} & CC = 0 \\
      0.555 [\sqrt{\text{CH} (\text{CC}/3.0)} \ln(\frac{20 + 0.36 \text{CH}}{0.13 \text{CH}})]^{-1} & CC > 0
    \end{array}
  \right. \\
  \nonumber \\
  U_{\text{mid}} &= U_{20} \, \text{WAF}
\end{align}

<p>
where \(\text{WAF}\) is the unitless wind adjustment factor,
\(\text{FBD}\) is the fuel bed depth in \(\text{ft}\), \(\text{CH}\) is the
canopy height in \(\text{ft}\), and \(\text{CC}\) is the canopy cover
fraction \((0-1)\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="midflame-wind-speed"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_wind_adjustment_factor</span>(fuel_bed_depth: cy.<span class="org-builtin">float</span>, canopy_height: cy.<span class="org-builtin">float</span>, canopy_cover: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Return the wind adjustment factor (unitless) given these inputs:</span>
<span class="org-doc">    - fuel_bed_depth :: ft</span>
<span class="org-doc">    - canopy_height  :: ft</span>
<span class="org-doc">    - canopy_cover   :: 0-1</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">if</span> (canopy_cover <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">and</span> (canopy_height <span class="org-operator">&gt;</span> 0.0):
        <span class="org-comment-delimiter"># </span><span class="org-comment">sheltered: equation 2 based on CC and CH, CR=1 (Andrews 2012)</span>
        <span class="org-variable-name">A</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> sqrt((canopy_cover <span class="org-operator">/</span> 3.0) <span class="org-operator">*</span> canopy_height)
        <span class="org-variable-name">B</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> log((20.0 <span class="org-operator">+</span> 0.36 <span class="org-operator">*</span> canopy_height) <span class="org-operator">/</span> (0.13 <span class="org-operator">*</span> canopy_height))
        <span class="org-keyword">return</span> 0.555 <span class="org-operator">/</span> (A <span class="org-operator">*</span> B)
    <span class="org-keyword">elif</span> (fuel_bed_depth <span class="org-operator">&gt;</span> 0.0):
        <span class="org-comment-delimiter"># </span><span class="org-comment">unsheltered: equation 6 H_F = H (Andrews 2012)</span>
        <span class="org-variable-name">A</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> log((20.0 <span class="org-operator">+</span> 0.36 <span class="org-operator">*</span> fuel_bed_depth) <span class="org-operator">/</span> (0.13 <span class="org-operator">*</span> fuel_bed_depth))
        <span class="org-keyword">return</span> 1.83 <span class="org-operator">/</span> A <span class="org-comment-delimiter"># </span><span class="org-comment">1.83 truncated from 1.8328795184533409</span>
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">non-burnable fuel model</span>
        <span class="org-keyword">return</span> 0.0


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_midflame_wind_speed</span>(wind_speed_20ft: cy.<span class="org-builtin">float</span>,
                             fuel_bed_depth : cy.<span class="org-builtin">float</span>,
                             canopy_height  : cy.<span class="org-builtin">float</span>,
                             canopy_cover   : cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Return the midflame wind speed (S) given these inputs:</span>
<span class="org-doc">    - wind_speed_20ft :: S</span>
<span class="org-doc">    - fuel_bed_depth  :: ft</span>
<span class="org-doc">    - canopy_height   :: ft</span>
<span class="org-doc">    - canopy_cover    :: 0-1</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">wind_adj_factor</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_wind_adjustment_factor(fuel_bed_depth, canopy_height, canopy_cover)
    <span class="org-keyword">return</span> wind_speed_20ft <span class="org-operator">*</span> wind_adj_factor
</pre>
</div>
</div>
</div>

<div id="outline-container-combining-wind-and-slope-vectors" class="outline-4">
<h4 id="combining-wind-and-slope-vectors"><span class="section-number-4">5.1.8.</span> Combining Wind and Slope Vectors</h4>
<div class="outline-text-4" id="text-combining-wind-and-slope-vectors">
<p>
On flat terrain and in the absence of wind, an idealized surface fire
will spread outward in a circle through homogeneous fuels. On sloped
terrain, a fire will spread more quickly upslope than downslope, and
when wind is present, a fire will spread more quickly in the direction
that the wind is blowing rather than against it. In the presence of
both sloped terrain and wind, the two forces combine to create a new
maximum spread rate and direction for the fire. Together, wind and
slope effects elongate otherwise circular fire perimeters into
ellipses, with the fastest moving edge known as the head fire.
</p>

<p>
Since Rothermel's original equations for computing the head fire
spread rate assume that the wind direction and upslope direction are
aligned, the effects of cross-slope winds must be taken into effect.
To accomplish this, Pyretechnics implements the vector addition
procedure defined in Rothermel 1983 that combines the wind and slope
vectors to calculate the maximum fire spread direction and
magnitude.<sup><a id="fnr.20" class="footref" href="#fn.20" role="doc-backlink">20</a></sup>
</p>

<p>
In order to address potential errors related to projecting the
horizontal wind and slope azimuth vectors to and from the
slope-tangential plane, upon which the equations from Rothermel 1983
are defined, we incorporate the three-dimensional vector combination
procedure provided by Waeselynck 2024.<sup><a id="fnr.21" class="footref" href="#fn.21" role="doc-backlink">21</a></sup>
</p>

<div class="org-src-container">
<pre class="src src-python" id="surface-fire-combine-wind-and-slope-vectors"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">project_wind_and_slope_vectors_3d</span>(wind_speed        : cy.<span class="org-builtin">float</span>,
                                      downwind_direction: cy.<span class="org-builtin">float</span>,
                                      slope             : cy.<span class="org-builtin">float</span>,
                                      upslope_direction : cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> ProjectedVectors:
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - wind_speed         :: S</span>
<span class="org-doc">    - downwind_direction :: degrees clockwise from North</span>
<span class="org-doc">    - slope              :: rise/run</span>
<span class="org-doc">    - upslope_direction  :: degrees clockwise from North</span>

<span class="org-doc">    return a ProjectedVectors struct containing these keys:</span>
<span class="org-doc">    - wind_vector_3d  :: (x: S, y: S, z: S)</span>
<span class="org-doc">    - slope_vector_3d :: (x, y, z)</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Convert wind and slope vectors from azimuthal to cartesian coordinates</span>
    <span class="org-variable-name">wind_vector_2d</span> : vec_xy <span class="org-operator">=</span> conv.azimuthal_to_cartesian(wind_speed, downwind_direction)
    <span class="org-variable-name">slope_vector_2d</span>: vec_xy <span class="org-operator">=</span> conv.azimuthal_to_cartesian(slope, upslope_direction)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Project wind and slope vectors onto the slope-tangential plane</span>
    <span class="org-variable-name">wind_vector_3d</span> : vec_xyz <span class="org-operator">=</span> vu.to_slope_plane(wind_vector_2d, slope_vector_2d)
    <span class="org-variable-name">slope_vector_3d</span>: vec_xyz <span class="org-operator">=</span> vu.to_slope_plane(slope_vector_2d, slope_vector_2d)
    <span class="org-keyword">return</span> ProjectedVectors(wind_vector_3d, slope_vector_3d)


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">get_phi_E</span>(wind_vector_3d: vec_xyz, slope_vector_3d: vec_xyz, phi_W: cy.<span class="org-builtin">float</span>, phi_S: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> vec_xyz:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Convert wind and slope vectors to unit vectors on the slope-tangential plane</span>
    <span class="org-variable-name">w_S</span>: vec_xyz <span class="org-operator">=</span> vu.as_unit_vector_3d(wind_vector_3d)  <span class="org-keyword">if</span> phi_W <span class="org-operator">&gt;</span> 0.0 <span class="org-keyword">else</span> wind_vector_3d
    <span class="org-variable-name">u_S</span>: vec_xyz <span class="org-operator">=</span> vu.as_unit_vector_3d(slope_vector_3d) <span class="org-keyword">if</span> phi_S <span class="org-operator">&gt;</span> 0.0 <span class="org-keyword">else</span> slope_vector_3d
    <span class="org-comment-delimiter"># </span><span class="org-comment">Create the 3D slope-tangential phi_W, phi_S, and phi_E vectors</span>
    <span class="org-variable-name">phi_W_3d</span>: vec_xyz <span class="org-operator">=</span> vu.scale_3d(phi_W, w_S)
    <span class="org-variable-name">phi_S_3d</span>: vec_xyz <span class="org-operator">=</span> vu.scale_3d(phi_S, u_S)
    <span class="org-variable-name">phi_E_3d</span>: vec_xyz <span class="org-operator">=</span> vu.add_3d(phi_W_3d, phi_S_3d)
    <span class="org-keyword">return</span> phi_E_3d
</pre>
</div>
</div>
</div>

<div id="outline-container-surface-elliptical-eccentricity" class="outline-4">
<h4 id="surface-elliptical-eccentricity"><span class="section-number-4">5.1.9.</span> Surface Elliptical Eccentricity</h4>
<div class="outline-text-4" id="text-surface-elliptical-eccentricity">
<p>
The effective wind speed \(U_{\text{eff}}\) is the wind speed that would
be required to produce the same spread rate in flat terrain as that
given by the combination of wind and sloped terrain as described in
section <a href="#combining-wind-and-slope-vectors">5.1.8</a>.
</p>

<p>
In order to project the one-dimensional surface fire spread rate
values calculated in earlier sections onto a two-dimensional plane,
\(U_{\text{eff}}\) is used to compute the length to width ratio
\(\frac{L}{W}\) of an ellipse that approximates the surface fire front.
This length to width ratio is then converted into an eccentricity
measure \(E\) of the ellipse using equation 8 from Albini and Chase
1980.<sup><a id="fnr.22" class="footref" href="#fn.22" role="doc-backlink">22</a></sup>
</p>

\begin{align}
  E = \frac{\sqrt{(\frac{L}{W})^2 - 1}}{\frac{L}{W}}
\end{align}

<p>
Currently Pyretechnics supports two different methods for computing
the length to width ratio \(\frac{L}{W}\):
</p>

<ol class="org-ol">
<li>Using equation 9 from Rothermel 1991.<sup><a id="fnr.23" class="footref" href="#fn.23" role="doc-backlink">23</a></sup></li>
</ol>

\begin{align}
  \frac{L}{W} = 1 + 0.25 \, U_{\text{eff}}
\end{align}

<p>
where \(U_{\text{eff}}\) is the effective wind speed in \(\text{mph}\).
</p>

<ol class="org-ol">
<li>Using the formula implemented in the Missoula Fire Lab's <code>behave</code> C++ library<sup><a id="fnr.24" class="footref" href="#fn.24" role="doc-backlink">24</a></sup></li>
</ol>

\begin{align}
  \frac{L}{W} = \min(8.0, 0.936 e^{(0.1147 U_{\text{eff}})} + 0.461 e^{(-0.0692 U_{\text{eff}})} - 0.397)
\end{align}

<p>
where \(U_{\text{eff}}\) is the effective wind speed in \(\text{mph}\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="surface-fire-eccentricity"><span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Change model from str to enumerated type</span>
<span class="org-type">@cy.cfunc</span>
<span class="org-keyword">def</span> <span class="org-function-name">surface_length_to_width_ratio</span>(effective_wind_speed: cy.<span class="org-builtin">float</span>, model: <span class="org-builtin">str</span> <span class="org-operator">=</span> <span class="org-string">"behave"</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the length_to_width_ratio of the surface fire front given:</span>
<span class="org-doc">    - effective_wind_speed :: m/min (aligned with the slope-tangential plane)</span>
<span class="org-doc">    - model                :: "rothermel" or "behave" (Optional)</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">effective_wind_speed_mph</span> <span class="org-operator">=</span> conv.m_min_to_mph(effective_wind_speed)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Select formula by model</span>
    <span class="org-keyword">if</span> model <span class="org-operator">==</span> <span class="org-string">"rothermel"</span>:
        <span class="org-keyword">return</span> 1.0 <span class="org-operator">+</span> 0.25 <span class="org-operator">*</span> effective_wind_speed_mph

    <span class="org-keyword">elif</span> model <span class="org-operator">==</span> <span class="org-string">"behave"</span>:
        <span class="org-keyword">return</span> <span class="org-builtin">min</span>(8.0,
                   0.936 <span class="org-operator">*</span> exp(0.1147 <span class="org-operator">*</span> effective_wind_speed_mph)
                   <span class="org-operator">+</span>
                   0.461 <span class="org-operator">*</span> exp(<span class="org-operator">-</span>0.0692 <span class="org-operator">*</span> effective_wind_speed_mph)
                   <span class="org-operator">-</span>
                   0.397)

    <span class="org-keyword">else</span>:
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"Invalid input: model must be 'rothermel' or 'behave'."</span>)


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">surface_fire_eccentricity</span>(length_to_width_ratio: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the eccentricity (E) of the surface fire front using eq. 8 from</span>
<span class="org-doc">    Albini and Chase 1980 given:</span>
<span class="org-doc">    - L/W :: (1: circular spread, &gt; 1: elliptical spread)</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> sqrt((length_to_width_ratio <span class="org-operator">*</span> length_to_width_ratio) <span class="org-operator">-</span> 1.0) <span class="org-operator">/</span> length_to_width_ratio
</pre>
</div>
</div>
</div>

<div id="outline-container-surface-fire-behavior-in-the-direction-of-maximum-spread" class="outline-4">
<h4 id="surface-fire-behavior-in-the-direction-of-maximum-spread"><span class="section-number-4">5.1.10.</span> Surface Fire Behavior in the Direction of Maximum Spread</h4>
<div class="outline-text-4" id="text-surface-fire-behavior-in-the-direction-of-maximum-spread">
<p>
This section introduces a function that applies the effects of wind
and slope to the no-wind-no-slope surface fire behavior values
produced in section <a href="#surface-fire-behavior-functions-(no-wind-no-slope)">5.1.6</a>, in order to compute the maximum surface fire behavior values
associated with a head fire.
</p>

<p>
A noteworthy decision for users is whether or not to limit the
effective wind speed \(U_{\text{eff}}\) in these calculations.
</p>

<p>
Rothermel 1972 defines a maximum effective wind speed, above which the
predicted spread rate and intensity remains constant. However, a 2013
publication by Andrews et al recommends instead that this wind speed
limit not be imposed, in order to avoid possible spread rate
underprediction.<sup><a id="fnr.25" class="footref" href="#fn.25" role="doc-backlink">25</a></sup><sup>, </sup><sup><a id="fnr.26" class="footref" href="#fn.26" role="doc-backlink">26</a></sup>
</p>

<p>
In order to support both use cases, the
<code>calc_surface_fire_behavior_max</code> function includes an optional
<code>use_wind_limit</code> argument that can be used to toggle this limit on or
off.
</p>

<div class="org-src-container">
<pre class="src src-python" id="surface-fire-behavior-max"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">maybe_limit_wind_speed</span>(use_wind_limit  : cy.bint,
                           max_wind_speed  : cy.<span class="org-builtin">float</span>,
                           surface_fire_min: FireBehaviorMin,
                           phi_E_magnitude : cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> <span class="org-builtin">tuple</span>[cy.<span class="org-builtin">float</span>, cy.<span class="org-builtin">float</span>]:
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - use_wind_limit   :: boolean</span>
<span class="org-doc">    - max_wind_speed   :: m/min</span>
<span class="org-doc">    - surface_fire_min :: FireBehaviorMin struct of no-wind-no-slope surface fire behavior values</span>
<span class="org-doc">      - base_spread_rate         :: m/min</span>
<span class="org-doc">      - base_fireline_intensity  :: kW/m</span>
<span class="org-doc">      - max_effective_wind_speed :: m/min</span>
<span class="org-doc">      - _phiS_G                  :: intermediate value for computing phi_S (unitless)</span>
<span class="org-doc">      - _phiW_scalr              :: intermediate value for computing phi_W (unitless)</span>
<span class="org-doc">      - _phiW_expnt              :: intermediate value for computing phi_W (unitless)</span>
<span class="org-doc">      - _ws_scalr                :: intermediate value for computing effective_wind_speed (m/min)</span>
<span class="org-doc">      - _ws_expnt                :: intermediate value for computing effective_wind_speed (unitless)</span>
<span class="org-doc">    - phi_E_magnitude  :: unitless</span>

<span class="org-doc">    return a tuple with these fields:</span>
<span class="org-doc">    - limited_wind_speed :: m/min</span>
<span class="org-doc">    - limited_phi_E      :: unitless</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">effective_wind_speed</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> get_wind_speed(surface_fire_min, phi_E_magnitude)
    <span class="org-keyword">if</span> (use_wind_limit <span class="org-keyword">and</span> effective_wind_speed <span class="org-operator">&gt;</span> max_wind_speed):
        <span class="org-keyword">return</span> (
            max_wind_speed,
            get_phi_W(surface_fire_min, max_wind_speed),
        )
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> (
            effective_wind_speed,
            phi_E_magnitude,
        )


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_surface_fire_behavior_max</span>(surface_fire_min      : FireBehaviorMin,
                                   midflame_wind_speed   : cy.<span class="org-builtin">float</span>,
                                   upwind_direction      : cy.<span class="org-builtin">float</span>,
                                   slope                 : cy.<span class="org-builtin">float</span>,
                                   aspect                : cy.<span class="org-builtin">float</span>,
                                   use_wind_limit        : cy.bint <span class="org-operator">=</span> <span class="org-constant">True</span>,
                                   surface_lw_ratio_model: <span class="org-builtin">str</span> <span class="org-operator">=</span> <span class="org-string">"behave"</span>) <span class="org-operator">-&gt;</span> FireBehaviorMax:
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - surface_fire_min       :: FireBehaviorMin struct of no-wind-no-slope surface fire behavior values</span>
<span class="org-doc">      - base_spread_rate         :: m/min</span>
<span class="org-doc">      - base_fireline_intensity  :: kW/m</span>
<span class="org-doc">      - max_effective_wind_speed :: m/min</span>
<span class="org-doc">      - _phiS_G                  :: intermediate value for computing phi_S (unitless)</span>
<span class="org-doc">      - _phiW_scalr              :: intermediate value for computing phi_W (unitless)</span>
<span class="org-doc">      - _phiW_expnt              :: intermediate value for computing phi_W (unitless)</span>
<span class="org-doc">      - _ws_scalr                :: intermediate value for computing effective_wind_speed (m/min)</span>
<span class="org-doc">      - _ws_expnt                :: intermediate value for computing effective_wind_speed (unitless)</span>
<span class="org-doc">    - midflame_wind_speed    :: m/min</span>
<span class="org-doc">    - upwind_direction       :: degrees clockwise from North</span>
<span class="org-doc">    - slope                  :: rise/run</span>
<span class="org-doc">    - aspect                 :: degrees clockwise from North</span>
<span class="org-doc">    - use_wind_limit         :: boolean (Optional)</span>
<span class="org-doc">    - surface_lw_ratio_model :: "rothermel" or "behave" (Optional)</span>

<span class="org-doc">    return a FireBehaviorMax struct containing these keys:</span>
<span class="org-doc">    - max_fire_type          :: 1 (surface)</span>
<span class="org-doc">    - max_spread_rate        :: m/min</span>
<span class="org-doc">    - max_spread_direction   :: (x, y, z) unit vector</span>
<span class="org-doc">    - max_fireline_intensity :: kW/m</span>
<span class="org-doc">    - max_flame_length       :: m</span>
<span class="org-doc">    - length_to_width_ratio  :: unitless (1: circular spread, &gt; 1: elliptical spread)</span>
<span class="org-doc">    - eccentricity           :: unitless (0: circular spread, &gt; 0: elliptical spread)</span>
<span class="org-doc">    - critical_spread_rate   :: m/min</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack no-wind-no-slope surface fire behavior values</span>
    <span class="org-variable-name">spread_rate</span>       : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> surface_fire_min.base_spread_rate
    <span class="org-variable-name">fireline_intensity</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> surface_fire_min.base_fireline_intensity
    <span class="org-variable-name">max_wind_speed</span>    : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> surface_fire_min.max_effective_wind_speed
    <span class="org-comment-delimiter"># </span><span class="org-comment">Reverse the provided wind and slope directions</span>
    <span class="org-variable-name">downwind_direction</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> conv.opposite_direction(upwind_direction)
    <span class="org-variable-name">upslope_direction</span> : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> conv.opposite_direction(aspect)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Project wind and slope vectors onto the slope-tangential plane</span>
    <span class="org-variable-name">vectors</span>        : ProjectedVectors <span class="org-operator">=</span> project_wind_and_slope_vectors_3d(midflame_wind_speed,
                                                                          downwind_direction,
                                                                          slope,
                                                                          upslope_direction)
    <span class="org-variable-name">wind_vector_3d</span> : vec_xyz <span class="org-operator">=</span> vectors.wind_vector_3d  <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
    <span class="org-variable-name">slope_vector_3d</span>: vec_xyz <span class="org-operator">=</span> vectors.slope_vector_3d <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate phi_W and phi_S</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: |wind_vector_3d| = slope-aligned midflame wind speed</span>
    <span class="org-variable-name">phi_W</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> get_phi_W(surface_fire_min, vu.vector_magnitude_3d(wind_vector_3d))
    <span class="org-variable-name">phi_S</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> get_phi_S(surface_fire_min, slope)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate phi_E and the max_spread_direction</span>
    <span class="org-variable-name">phi_E_3d</span>: vec_xyz  <span class="org-operator">=</span> get_phi_E(wind_vector_3d, slope_vector_3d, phi_W, phi_S)
    <span class="org-variable-name">phi_E</span>   : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vu.vector_magnitude_3d(phi_E_3d)
    max_spread_direction: vec_xyz
    <span class="org-keyword">if</span> phi_E <span class="org-operator">&gt;</span> 0.0:
        <span class="org-variable-name">max_spread_direction</span> <span class="org-operator">=</span> vu.as_unit_vector_3d(phi_E_3d)
    <span class="org-keyword">elif</span> phi_S <span class="org-operator">&gt;</span> 0.0:
        <span class="org-variable-name">max_spread_direction</span> <span class="org-operator">=</span> vu.as_unit_vector_3d(slope_vector_3d)
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">max_spread_direction</span> <span class="org-operator">=</span> (0.0, 1.0, 0.0) <span class="org-comment-delimiter"># </span><span class="org-comment">default: North</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Limit effective wind speed to max wind speed if use_wind_limit == True</span>
    (<span class="org-variable-name">limited_wind_speed</span>, <span class="org-variable-name">limited_phi_E</span>) <span class="org-operator">=</span> maybe_limit_wind_speed(use_wind_limit,
                                                                 max_wind_speed,
                                                                 surface_fire_min,
                                                                 phi_E)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate and return max surface fire behavior values</span>
    <span class="org-variable-name">max_spread_rate</span>       : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> spread_rate <span class="org-operator">*</span> (1.0 <span class="org-operator">+</span> limited_phi_E)
    <span class="org-variable-name">max_fireline_intensity</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> fireline_intensity <span class="org-operator">*</span> (1.0 <span class="org-operator">+</span> limited_phi_E)
    <span class="org-variable-name">length_to_width_ratio</span> : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> surface_length_to_width_ratio(limited_wind_speed, surface_lw_ratio_model)
    <span class="org-keyword">return</span> FireBehaviorMax(
        max_fire_type          <span class="org-operator">=</span> 1,
        max_spread_rate        <span class="org-operator">=</span> max_spread_rate,
        max_spread_direction   <span class="org-operator">=</span> max_spread_direction,
        max_fireline_intensity <span class="org-operator">=</span> max_fireline_intensity,
        max_flame_length       <span class="org-operator">=</span> calc_flame_length(max_fireline_intensity),
        length_to_width_ratio  <span class="org-operator">=</span> length_to_width_ratio,
        eccentricity           <span class="org-operator">=</span> surface_fire_eccentricity(length_to_width_ratio),
        critical_spread_rate   <span class="org-operator">=</span> 0.0,
    )
</pre>
</div>
</div>
</div>

<div id="outline-container-surface-fire-behavior-in-any-direction" class="outline-4">
<h4 id="surface-fire-behavior-in-any-direction"><span class="section-number-4">5.1.11.</span> Surface Fire Behavior in Any Direction</h4>
<div class="outline-text-4" id="text-surface-fire-behavior-in-any-direction">
<p>
Once we have calculated the maximum surface fire behavior values
associated with a head fire, we can use the elliptical eccentricity
\(E\) to project the maximum spread rate \(R_s\) and maximum fireline
intensity \(I_s\) to any point along the fire front as follows:
</p>

\begin{align}
  \eta &= \frac{1-E}{1-E\cos\omega} \\
  \nonumber \\
  R_s(\omega) &= R_s \, \eta \\
  \nonumber \\
  I_s(\omega) &= I_s \, \eta
\end{align}

<p>
where \(\omega\) is the angular offset from the direction of maximum
fire spread and \(R_s(\omega)\) and \(I_s(\omega)\) are the spread rate
and fireline intensity in this direction respectively.
</p>

<p>
Since the surface fire ellipse is defined on the slope-tangential
plane, we must represent spread directions with three dimensional unit
vectors aligned with this plane rather than with angles. Fortunately,
we can use the relationship between the dot product of two vectors and
the cosine of the angle between them to rewrite the \(\eta\) function
above as follows:
</p>

\begin{align}
  \eta = \frac{1-E}{1-E(\vec{u_{\max}} \cdot \vec{u_{\omega}})}
\end{align}

<p>
where \(\vec{u_{\max}}\) is the slope-tangential unit vector in the
direction of maximum spread and \(\vec{u_{\omega}}\) is the
slope-tangential unit vector rotated \(\omega\) degrees clockwise along
this plane from \(\vec{u_{\max}}\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="surface-fire-behavior-in-direction"><span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_surface_fire_behavior_in_direction</span>(surface_fire_max: FireBehaviorMax,
                                            spread_direction: vec_xyz) <span class="org-operator">-&gt;</span> SpreadBehavior:
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - surface_fire_max     :: FireBehaviorMax struct of max surface fire behavior values</span>
<span class="org-doc">      - max_fire_type          :: 1 (surface)</span>
<span class="org-doc">      - max_spread_rate        :: m/min</span>
<span class="org-doc">      - max_spread_direction   :: (x, y, z) unit vector</span>
<span class="org-doc">      - max_fireline_intensity :: kW/m</span>
<span class="org-doc">      - max_flame_length       :: m</span>
<span class="org-doc">      - length_to_width_ratio  :: unitless (1: circular spread, &gt; 1: elliptical spread)</span>
<span class="org-doc">      - eccentricity           :: unitless (0: circular spread, &gt; 0: elliptical spread)</span>
<span class="org-doc">      - critical_spread_rate   :: m/min</span>
<span class="org-doc">    - spread_direction     :: 3D unit vector on the slope-tangential plane</span>

<span class="org-doc">    return a SpreadBehavior struct containing these keys:</span>
<span class="org-doc">    - dphi_dt            :: phi/min</span>
<span class="org-doc">    - fire_type          :: 1 (surface)</span>
<span class="org-doc">    - spread_rate        :: m/min</span>
<span class="org-doc">    - spread_direction   :: (x, y, z) unit vector</span>
<span class="org-doc">    - fireline_intensity :: kW/m</span>
<span class="org-doc">    - flame_length       :: m</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack max surface fire behavior values</span>
    <span class="org-variable-name">max_spread_rate</span>       : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> surface_fire_max.max_spread_rate
    <span class="org-variable-name">max_spread_direction</span>  : vec_xyz  <span class="org-operator">=</span> surface_fire_max.max_spread_direction
    <span class="org-variable-name">max_fireline_intensity</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> surface_fire_max.max_fireline_intensity
    <span class="org-variable-name">eccentricity</span>          : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> surface_fire_max.eccentricity
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate cos(w), where w is the offset angle between these unit vectors on the slope-tangential plane</span>
    <span class="org-variable-name">cos_w</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vu.dot_3d(max_spread_direction, spread_direction)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate adjustment due to the offset angle from the max spread direction</span>
    <span class="org-variable-name">adjustment</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (1.0 <span class="org-operator">-</span> eccentricity) <span class="org-operator">/</span> (1.0 <span class="org-operator">-</span> eccentricity <span class="org-operator">*</span> cos_w)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Update surface fire behavior values by the adjustment value</span>
    <span class="org-variable-name">fireline_intensity</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> max_fireline_intensity <span class="org-operator">*</span> adjustment
    <span class="org-keyword">return</span> SpreadBehavior(
        dphi_dt            <span class="org-operator">=</span> 0.0,
        fire_type          <span class="org-operator">=</span> 1, <span class="org-comment-delimiter"># </span><span class="org-comment">surface</span>
        spread_rate        <span class="org-operator">=</span> max_spread_rate <span class="org-operator">*</span> adjustment,
        spread_direction   <span class="org-operator">=</span> spread_direction,
        fireline_intensity <span class="org-operator">=</span> fireline_intensity,
        flame_length       <span class="org-operator">=</span> calc_flame_length(fireline_intensity),
    )
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-for-users-surface" class="outline-3">
<h3 id="for-users-surface"><span class="section-number-3">5.2.</span> For Users</h3>
<div class="outline-text-3" id="text-for-users-surface">
<p>
In the following sections, we will demonstrate how to calculate the
surface fire behavior values given a fuel model and measurements of
fuel moisture, wind speed, wind direction, slope, and aspect. This
will be done first for the no-wind-no-slope case, followed by the max
spread direction case, and finally in any direction on the sloped
surface using both offset angles from the heading fire direction and
3D vectors specifying absolute directions.
</p>

<p>
Because wind speed and direction will often be provided from
measurements taken 10m or 20ft above the canopy and may be given in
either cartesion <code>(x,y)</code> or azimuthal <code>(r,azimuth)</code> coordinates, we
also demonstrate how to convert from cartesian to azimuthal
coordinates, from 10m to 20ft wind speeds, and from 20ft to midflame
wind speeds, given a fuel model and measurements of canopy height and
canopy cover.
</p>

<p>
See Appendix <a href="#units-conversion-functions-(pyretechnics.conversion)">10.2</a> for
the full list of available units conversion functions.
</p>

<p>
See Appendix <a href="#vector-utility-functions-(pyretechnics.vector_utils)">10.3</a> for
the full list of available vector manipulation functions.
</p>
</div>

<div id="outline-container-how-to-calculate-the-no-wind-no-slope-surface-fire-behavior" class="outline-4">
<h4 id="how-to-calculate-the-no-wind-no-slope-surface-fire-behavior"><span class="section-number-4">5.2.1.</span> How to Calculate the No-Wind-No-Slope Surface Fire Behavior</h4>
<div class="outline-text-4" id="text-how-to-calculate-the-no-wind-no-slope-surface-fire-behavior">
<div class="org-src-container">
<pre class="src src-python" id="compute-surface-fire-behavior-min"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.fuel_models <span class="org-keyword">as</span> fm
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf

<span class="org-comment-delimiter"># </span><span class="org-comment">Set input parameters</span>
<span class="org-variable-name">fuel_model</span>    <span class="org-operator">=</span> fm.get_fuel_model(101) <span class="org-comment-delimiter"># </span><span class="org-comment">GR1</span>
<span class="org-variable-name">fuel_moisture</span> <span class="org-operator">=</span> (
    0.05, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_1hr</span>
    0.10, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_10hr</span>
    0.15, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_100hr</span>
    0.00, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_herbaceous (will be set by moisturize for dynamic fuel models)</span>
    0.90, <span class="org-comment-delimiter"># </span><span class="org-comment">live_herbaceous</span>
    0.60, <span class="org-comment-delimiter"># </span><span class="org-comment">live_woody</span>
)

<span class="org-comment-delimiter"># </span><span class="org-comment">Apply fuel moisture to fuel model</span>
<span class="org-variable-name">moisturized_fuel_model</span> <span class="org-operator">=</span> fm.moisturize(fuel_model, fuel_moisture)

<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate no-wind-no-slope surface fire behavior</span>
<span class="org-variable-name">surface_fire_min</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model)

<span class="org-comment-delimiter"># </span><span class="org-comment">View results</span>
<span class="org-builtin">print</span>(<span class="org-string">"No-Wind-No-Slope Surface Fire Behavior for Fuel Model GR1 with Fuel Moisture = "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(moisturized_fuel_model[<span class="org-string">"M_f"</span>]))
pprint({k: surface_fire_min[k] <span class="org-keyword">for</span> k <span class="org-keyword">in</span> [<span class="org-string">"base_spread_rate"</span>, <span class="org-string">"base_fireline_intensity"</span>, <span class="org-string">"max_effective_wind_speed"</span>]})
</pre>
</div>

<pre class="example">
No-Wind-No-Slope Surface Fire Behavior for Fuel Model GR1 with Fuel Moisture = (0.05000000074505806, 0.10000000149011612, 0.15000000596046448, 0.05000000074505806, 0.8999999761581421, 0.6000000238418579)
{'base_fireline_intensity': 1.7899988889694214,
 'base_spread_rate': 0.12637242674827576,
 'max_effective_wind_speed': 109.77295684814453}
</pre>
</div>
</div>

<div id="outline-container-how-to-translate-the-10m-wind-speed-vector-into-the-midflame-wind-speed-vector" class="outline-4">
<h4 id="how-to-translate-the-10m-wind-speed-vector-into-the-midflame-wind-speed-vector"><span class="section-number-4">5.2.2.</span> How to Translate the 10m Wind Speed Vector into the Midflame Wind Speed Vector</h4>
<div class="outline-text-4" id="text-how-to-translate-the-10m-wind-speed-vector-into-the-midflame-wind-speed-vector">
<div class="org-src-container">
<pre class="src src-python" id="translate-10m-wind-to-midflame-wind"><span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv
<span class="org-keyword">import</span> pyretechnics.fuel_models <span class="org-keyword">as</span> fm
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf

<span class="org-comment-delimiter"># </span><span class="org-comment">Set input parameters</span>
<span class="org-variable-name">fuel_model</span>       <span class="org-operator">=</span> fm.get_fuel_model(101) <span class="org-comment-delimiter"># </span><span class="org-comment">GR1</span>
<span class="org-variable-name">canopy_height</span>    <span class="org-operator">=</span> 20                     <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
<span class="org-variable-name">canopy_cover</span>     <span class="org-operator">=</span> 0.6                    <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
<span class="org-variable-name">wind_speed_10m</span>   <span class="org-operator">=</span> 20                     <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
<span class="org-variable-name">upwind_direction</span> <span class="org-operator">=</span> 45.0                   <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 10m wind speed to 20ft wind speed</span>
<span class="org-variable-name">wind_speed_20ft</span> <span class="org-operator">=</span> conv.wind_speed_10m_to_wind_speed_20ft(wind_speed_10m) <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 20ft wind speed to midflame wind speed in m/min</span>
<span class="org-variable-name">midflame_wind_speed</span> <span class="org-operator">=</span> sf.calc_midflame_wind_speed(conv.km_hr_to_m_min(wind_speed_20ft), <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
                                                  fuel_model[<span class="org-string">"delta"</span>],                  <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                  conv.m_to_ft(canopy_height),          <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                  canopy_cover)                         <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">View results</span>
<span class="org-builtin">print</span>(<span class="org-string">"Midflame Wind Speed and Direction for 10m Wind Speed = 20 km/hr, Upwind Direction = 45.0</span><span class="org-constant">\n</span><span class="org-string">"</span>
      <span class="org-operator">+</span> <span class="org-string">" with Fuel Model GR1, Canopy Height = 20m, and Canopy Cover = 60%</span><span class="org-constant">\n</span><span class="org-string">"</span>
      <span class="org-operator">+</span> <span class="org-string">"- Speed: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(midflame_wind_speed) <span class="org-operator">+</span> <span class="org-string">" (m/min)</span><span class="org-constant">\n</span><span class="org-string">"</span>
      <span class="org-operator">+</span> <span class="org-string">"- Downwind Direction: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(conv.opposite_direction(upwind_direction)) <span class="org-operator">+</span> <span class="org-string">" (degrees clockwise from North)"</span>)
</pre>
</div>

<pre class="example">
Midflame Wind Speed and Direction for 10m Wind Speed = 20 km/hr, Upwind Direction = 45.0
 with Fuel Model GR1, Canopy Height = 20m, and Canopy Cover = 60%
- Speed: 27.21068000793457 (m/min)
- Downwind Direction: 225.0 (degrees clockwise from North)
</pre>
</div>
</div>

<div id="outline-container-how-to-calculate-the-surface-fire-behavior-in-the-direction-of-maximum-spread" class="outline-4">
<h4 id="how-to-calculate-the-surface-fire-behavior-in-the-direction-of-maximum-spread"><span class="section-number-4">5.2.3.</span> How to Calculate the Surface Fire Behavior in the Direction of Maximum Spread</h4>
<div class="outline-text-4" id="text-how-to-calculate-the-surface-fire-behavior-in-the-direction-of-maximum-spread">
<div class="org-src-container">
<pre class="src src-python" id="compute-surface-fire-behavior-max"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.fuel_models <span class="org-keyword">as</span> fm
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf

<span class="org-comment-delimiter"># </span><span class="org-comment">Set input parameters</span>
<span class="org-variable-name">fuel_model</span>    <span class="org-operator">=</span> fm.get_fuel_model(101) <span class="org-comment-delimiter"># </span><span class="org-comment">GR1</span>
<span class="org-variable-name">fuel_moisture</span> <span class="org-operator">=</span> (
    0.05, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_1hr</span>
    0.10, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_10hr</span>
    0.15, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_100hr</span>
    0.00, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_herbaceous (will be set by moisturize for dynamic fuel models)</span>
    0.90, <span class="org-comment-delimiter"># </span><span class="org-comment">live_herbaceous</span>
    0.60, <span class="org-comment-delimiter"># </span><span class="org-comment">live_woody</span>
)
<span class="org-variable-name">midflame_wind_speed</span> <span class="org-operator">=</span> 500.0 <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
<span class="org-variable-name">upwind_direction</span>    <span class="org-operator">=</span> 215.0 <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
<span class="org-variable-name">slope</span>               <span class="org-operator">=</span> 0.2   <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
<span class="org-variable-name">aspect</span>              <span class="org-operator">=</span> 270.0 <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Apply fuel moisture to fuel model</span>
<span class="org-variable-name">moisturized_fuel_model</span> <span class="org-operator">=</span> fm.moisturize(fuel_model, fuel_moisture)

<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate no-wind-no-slope surface fire behavior</span>
<span class="org-variable-name">surface_fire_min</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model)

<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread with effective wind speed limit</span>
<span class="org-variable-name">surface_fire_max</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_max(surface_fire_min,
                                                     midflame_wind_speed,
                                                     upwind_direction,
                                                     slope,
                                                     aspect,
                                                     surface_lw_ratio_model<span class="org-operator">=</span><span class="org-string">"rothermel"</span>)

<span class="org-comment-delimiter"># </span><span class="org-comment">View results</span>
<span class="org-builtin">print</span>(<span class="org-string">"Surface Fire Behavior Max (Limited) for Fuel Model GR1 with Fuel Moisture = "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(moisturized_fuel_model[<span class="org-string">"M_f"</span>]))
pprint(surface_fire_max)

<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread without effective wind speed limit</span>
<span class="org-variable-name">surface_fire_max_unlimited</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_max(surface_fire_min,
                                                               midflame_wind_speed,
                                                               upwind_direction,
                                                               slope,
                                                               aspect,
                                                               use_wind_limit<span class="org-operator">=</span><span class="org-constant">False</span>,
                                                               surface_lw_ratio_model<span class="org-operator">=</span><span class="org-string">"rothermel"</span>)

<span class="org-comment-delimiter"># </span><span class="org-comment">View results</span>
<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Surface Fire Behavior Max (Unlimited) for Fuel Model GR1 with Fuel Moisture = "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(moisturized_fuel_model[<span class="org-string">"M_f"</span>]))
pprint(surface_fire_max_unlimited)
</pre>
</div>

<pre class="example" id="compute-surface-fire-behavior-max-results">
Surface Fire Behavior Max (Limited) for Fuel Model GR1 with Fuel Moisture = (0.05000000074505806, 0.10000000149011612, 0.15000000596046448, 0.05000000074505806, 0.8999999761581421, 0.6000000238418579)
{'critical_spread_rate': 0.0,
 'eccentricity': 0.8693099021911621,
 'length_to_width_ratio': 2.023196220397949,
 'max_fire_type': 1,
 'max_fireline_intensity': 32.52827453613281,
 'max_flame_length': 0.38439345359802246,
 'max_spread_direction': (0.5751420855522156,
                          0.8099259734153748,
                          0.11502841860055923),
 'max_spread_rate': 2.29646897315979}

Surface Fire Behavior Max (Unlimited) for Fuel Model GR1 with Fuel Moisture = (0.05000000074505806, 0.10000000149011612, 0.15000000596046448, 0.05000000074505806, 0.8999999761581421, 0.6000000238418579)
{'critical_spread_rate': 0.0,
 'eccentricity': 0.9845208525657654,
 'length_to_width_ratio': 5.705564498901367,
 'max_fire_type': 1,
 'max_fireline_intensity': 330.52349853515625,
 'max_flame_length': 1.1167834997177124,
 'max_spread_direction': (0.5751420855522156,
                          0.8099259734153748,
                          0.11502841860055923),
 'max_spread_rate': 23.33468246459961}
</pre>
</div>
</div>

<div id="outline-container-how-to-calculate-the-surface-fire-behavior-in-any-direction" class="outline-4">
<h4 id="how-to-calculate-the-surface-fire-behavior-in-any-direction"><span class="section-number-4">5.2.4.</span> How to Calculate the Surface Fire Behavior in Any Direction</h4>
<div class="outline-text-4" id="text-how-to-calculate-the-surface-fire-behavior-in-any-direction">
<div class="org-src-container">
<pre class="src src-python" id="compute-surface-fire-behavior-in-direction"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.fuel_models <span class="org-keyword">as</span> fm
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf
<span class="org-keyword">import</span> pyretechnics.vector_utils <span class="org-keyword">as</span> vu

<span class="org-comment-delimiter"># </span><span class="org-comment">Set input parameters</span>
<span class="org-variable-name">fuel_model</span>    <span class="org-operator">=</span> fm.get_fuel_model(101) <span class="org-comment-delimiter"># </span><span class="org-comment">GR1</span>
<span class="org-variable-name">fuel_moisture</span> <span class="org-operator">=</span> (
    0.05, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_1hr</span>
    0.10, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_10hr</span>
    0.15, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_100hr</span>
    0.00, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_herbaceous (will be set by moisturize for dynamic fuel models)</span>
    0.90, <span class="org-comment-delimiter"># </span><span class="org-comment">live_herbaceous</span>
    0.60, <span class="org-comment-delimiter"># </span><span class="org-comment">live_woody</span>
)
<span class="org-variable-name">midflame_wind_speed</span> <span class="org-operator">=</span> 500.0 <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
<span class="org-variable-name">upwind_direction</span>    <span class="org-operator">=</span> 215.0 <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
<span class="org-variable-name">slope</span>               <span class="org-operator">=</span> 0.2   <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
<span class="org-variable-name">aspect</span>              <span class="org-operator">=</span> 270.0 <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Apply fuel moisture to fuel model</span>
<span class="org-variable-name">moisturized_fuel_model</span> <span class="org-operator">=</span> fm.moisturize(fuel_model, fuel_moisture)

<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate no-wind-no-slope surface fire behavior</span>
<span class="org-variable-name">surface_fire_min</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model)

<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread with effective wind speed limit</span>
<span class="org-variable-name">surface_fire_max</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_max(surface_fire_min,
                                                     midflame_wind_speed,
                                                     upwind_direction,
                                                     slope,
                                                     aspect,
                                                     surface_lw_ratio_model<span class="org-operator">=</span><span class="org-string">"rothermel"</span>)

<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior for the heading, flanking, and backing fires</span>
<span class="org-variable-name">heading_fire_direction</span>  <span class="org-operator">=</span> surface_fire_max[<span class="org-string">"max_spread_direction"</span>]
<span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Change upstream functions to return max_spread_direction as type vec_xyz</span>
<span class="org-comment-delimiter">#        </span><span class="org-comment">and change downstream functions to accept spread_direction as type vec_xyz</span>
(<span class="org-variable-name">dx</span>, <span class="org-variable-name">dy</span>, <span class="org-variable-name">dz</span>)            <span class="org-operator">=</span> heading_fire_direction
<span class="org-variable-name">flanking_fire_direction</span> <span class="org-operator">=</span> np.asarray(vu.rotate_on_sloped_plane((dx, dy, dz), 90.0, slope, aspect))
<span class="org-variable-name">backing_fire_direction</span>  <span class="org-operator">=</span> np.asarray(vu.rotate_on_sloped_plane((dx, dy, dz), 180.0, slope, aspect))

<span class="org-variable-name">heading_fire_behavior</span>  <span class="org-operator">=</span> sf.calc_surface_fire_behavior_in_direction(surface_fire_max, heading_fire_direction)
<span class="org-variable-name">flanking_fire_behavior</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_in_direction(surface_fire_max, flanking_fire_direction)
<span class="org-variable-name">backing_fire_behavior</span>  <span class="org-operator">=</span> sf.calc_surface_fire_behavior_in_direction(surface_fire_max, backing_fire_direction)

<span class="org-comment-delimiter"># </span><span class="org-comment">View heading fire results</span>
<span class="org-builtin">print</span>(<span class="org-string">"Heading Fire Behavior for Fuel Model GR1 with Fuel Moisture = "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(moisturized_fuel_model[<span class="org-string">"M_f"</span>]))
pprint(heading_fire_behavior)

<span class="org-comment-delimiter"># </span><span class="org-comment">View flanking fire results</span>
<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Flanking Fire Behavior for Fuel Model GR1 with Fuel Moisture = "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(moisturized_fuel_model[<span class="org-string">"M_f"</span>]))
pprint(flanking_fire_behavior)

<span class="org-comment-delimiter"># </span><span class="org-comment">View backing fire results</span>
<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Backing Fire Behavior for Fuel Model GR1 with Fuel Moisture = "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(moisturized_fuel_model[<span class="org-string">"M_f"</span>]))
pprint(backing_fire_behavior)
</pre>
</div>

<pre class="example" id="compute-surface-fire-behavior-in-direction-results">
Heading Fire Behavior for Fuel Model GR1 with Fuel Moisture = (0.05000000074505806, 0.10000000149011612, 0.15000000596046448, 0.05000000074505806, 0.8999999761581421, 0.6000000238418579)
{'dphi_dt': 0.0,
 'fire_type': 1,
 'fireline_intensity': 32.52827453613281,
 'flame_length': 0.38439345359802246,
 'spread_direction': (0.5751420855522156,
                      0.8099259734153748,
                      0.11502841860055923),
 'spread_rate': 2.29646897315979}

Flanking Fire Behavior for Fuel Model GR1 with Fuel Moisture = (0.05000000074505806, 0.10000000149011612, 0.15000000596046448, 0.05000000074505806, 0.8999999761581421, 0.6000000238418579)
{'dphi_dt': 0.0,
 'fire_type': 1,
 'fireline_intensity': 4.251122951507568,
 'flame_length': 0.15074662864208221,
 'spread_direction': (0.7941977381706238,
                      -0.5865322351455688,
                      0.15883956849575043),
 'spread_rate': 0.30012571811676025}

Backing Fire Behavior for Fuel Model GR1 with Fuel Moisture = (0.05000000074505806, 0.10000000149011612, 0.15000000596046448, 0.05000000074505806, 0.8999999761581421, 0.6000000238418579)
{'dphi_dt': 0.0,
 'fire_type': 1,
 'fireline_intensity': 2.27416729927063,
 'flame_length': 0.11305095255374908,
 'spread_direction': (-0.5751421451568604,
                      -0.80992591381073,
                      -0.11502843350172043),
 'spread_rate': 0.16055430471897125}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-crown-fire-equations-(pyretechnics.crown_fire)" class="outline-2">
<h2 id="crown-fire-equations-(pyretechnics.crown_fire)"><span class="section-number-2">6.</span> Crown Fire Equations (pyretechnics.crown_fire)</h2>
<div class="outline-text-2" id="text-crown-fire-equations-(pyretechnics.crown_fire)">
</div>
<div id="outline-container-for-developers-crown" class="outline-3">
<h3 id="for-developers-crown"><span class="section-number-3">6.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-for-developers-crown">
<p>
The following sections define functions that calculate the spread rate
and intensity of a fire burning through tree canopy fuels. These
functions combine the surface fire behavior values calculated in
section <a href="#surface-fire-equations-(pyretechnics.surface_fire)">5</a> with
measurements of foliar moisture, dead 1 hour fuel moisture, canopy
cover, canopy height, canopy base height, and canopy bulk density to
determine whether a surface fire will spread into either a passive or
active crown fire. If so, they can then calculate the maximum spread
rate and direction of this crown fire as well as its fireline
intensity and flame length.
</p>
</div>

<div id="outline-container-module-imports-crown-fire" class="outline-4">
<h4 id="module-imports-crown-fire"><span class="section-number-4">6.1.1.</span> Module Imports</h4>
<div class="outline-text-4" id="text-module-imports-crown-fire">
<div class="org-src-container">
<pre class="src src-python" id="crown-fire-imports"><span class="org-keyword">import</span> cython
<span class="org-keyword">import</span> cython <span class="org-keyword">as</span> cy
<span class="org-keyword">if</span> cython.compiled:
    <span class="org-keyword">from</span> cython.cimports.libc.math <span class="org-keyword">import</span> sqrt, exp, <span class="org-builtin">pow</span>
    <span class="org-keyword">from</span> cython.cimports.pyretechnics.cy_types <span class="org-keyword">import</span> \
        vec_xyz, ProjectedVectors, FireBehaviorMax, SpreadBehavior, CrownSpreadInfo
    <span class="org-keyword">import</span> cython.cimports.pyretechnics.conversion <span class="org-keyword">as</span> conv
    <span class="org-keyword">import</span> cython.cimports.pyretechnics.vector_utils <span class="org-keyword">as</span> vu
    <span class="org-keyword">import</span> cython.cimports.pyretechnics.surface_fire <span class="org-keyword">as</span> sf
<span class="org-keyword">else</span>:
    <span class="org-keyword">from</span> math <span class="org-keyword">import</span> sqrt, exp, <span class="org-builtin">pow</span>
    <span class="org-keyword">from</span> pyretechnics.py_types <span class="org-keyword">import</span> \
        vec_xyz, ProjectedVectors, FireBehaviorMax, SpreadBehavior, CrownSpreadInfo
    <span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv
    <span class="org-keyword">import</span> pyretechnics.vector_utils <span class="org-keyword">as</span> vu
    <span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf
</pre>
</div>
</div>
</div>

<div id="outline-container-crown-fire-initiation" class="outline-4">
<h4 id="crown-fire-initiation"><span class="section-number-4">6.1.2.</span> Crown Fire Initiation</h4>
<div class="outline-text-4" id="text-crown-fire-initiation">
<p>
In order to incorporate the effects of crown fire behavior,
Pyretechnics includes the crown fire initiation routine from Van
Wagner 1977.<sup><a id="fnr.27" class="footref" href="#fn.27" role="doc-backlink">27</a></sup> According to this approach, we begin
by calculating the <i>critical fireline intensity</i> as follows:
</p>

\begin{align}
  H &= 460 + 2600 M^f \\
  \nonumber \\
  I_s^* &= (0.01 \, Z_b \, H)^{1.5}
\end{align}

<p>
where \(H\) is the heat of ignition for the herbaceous material in the
canopy in \(\text{kJ/kg}\), \(M^f\) is the foliar moisture content in
\(\text{kg moisture/kg ovendry weight}\), \(Z_b\) is the canopy base
height in meters, and \(I_s^*\) is the critical fireline intensity in
\(\text{kW/m}\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="van-wagner-critical-fireline-intensity"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">van_wagner_critical_fireline_intensity</span>(canopy_base_height: cy.<span class="org-builtin">float</span>, foliar_moisture: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the critical fireline intensity (kW/m) given:</span>
<span class="org-doc">    - canopy_base_height :: m</span>
<span class="org-doc">    - foliar_moisture    :: kg moisture/kg ovendry weight</span>

<span class="org-doc">    Constants used:</span>
<span class="org-doc">    460.0 = heat-of-ignition :: kJ/kg</span>
<span class="org-doc">    0.01 = empirical estimate for C in Van Wagner 1977 (eq. 4)</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">H</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 460.0 <span class="org-operator">+</span> 2600.0 <span class="org-operator">*</span> foliar_moisture
    <span class="org-variable-name">v</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 0.01 <span class="org-operator">*</span> canopy_base_height <span class="org-operator">*</span> H
    <span class="org-keyword">return</span> v <span class="org-operator">*</span> sqrt(v) <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: This is faster than pow(v, 1.5).</span>
</pre>
</div>

<p>
By using the linear relationship between spread rate and fireline
intensity outlined in section <a href="#surface-fire-intensity-functions">5.1.4</a>, we can
also calculate the surface fire spread rate at which crowning occurs.
</p>

\begin{align}
  R_s^* = R_s \frac{I_s^*}{I_s}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="van-wagner-crowning-spread-rate"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">van_wagner_crowning_spread_rate</span>(surface_fire_max  : FireBehaviorMax,
                                    canopy_base_height: cy.<span class="org-builtin">float</span>,
                                    foliar_moisture   : cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the surface spread rate above which crown fire occurs (m/min) given:</span>
<span class="org-doc">    - surface_fire_max   :: FireBehaviorMax struct</span>
<span class="org-doc">    - canopy_base_height :: m</span>
<span class="org-doc">    - foliar_moisture    :: kg moisture/kg ovendry weight</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">surface_max_fireline_intensity</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> surface_fire_max.max_fireline_intensity
    <span class="org-keyword">if</span> surface_max_fireline_intensity <span class="org-operator">&gt;</span> 0.0:
        <span class="org-variable-name">surface_max_spread_rate</span>    : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> surface_fire_max.max_spread_rate
        <span class="org-variable-name">critical_fireline_intensity</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> van_wagner_critical_fireline_intensity(canopy_base_height,
                                                                                       foliar_moisture)
        <span class="org-keyword">return</span> (surface_max_spread_rate <span class="org-operator">*</span> critical_fireline_intensity <span class="org-operator">/</span> surface_max_fireline_intensity)
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> 0.0
</pre>
</div>

<p>
If a surface fire is present, the canopy cover is greater than 40%,
and the surface fireline intensity \(I_s\) is greater than or equal to
the critical fireline intensity \(I_s^*\), then the surface fire
transitions to a crown fire.
</p>

<div class="org-src-container">
<pre class="src src-python" id="van-wagner-crown-fire-initiation"><span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">van_wagner_crown_fire_initiation</span>(surface_fireline_intensity: cy.<span class="org-builtin">float</span>,
                                     canopy_cover              : cy.<span class="org-builtin">float</span>,
                                     canopy_base_height        : cy.<span class="org-builtin">float</span>,
                                     foliar_moisture           : cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.bint:
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns True if the surface fire transitions to a crown fire or False otherwise given:</span>
<span class="org-doc">    - surface_fireline_intensity :: kW/m</span>
<span class="org-doc">    - canopy_cover               :: 0-1</span>
<span class="org-doc">    - canopy_base_height         :: m</span>
<span class="org-doc">    - foliar_moisture            :: kg moisture/kg ovendry weight</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> (
        surface_fireline_intensity <span class="org-operator">&gt;</span> 0.0
        <span class="org-keyword">and</span>
        canopy_cover <span class="org-operator">&gt;</span> 0.4
        <span class="org-keyword">and</span>
        surface_fireline_intensity <span class="org-operator">&gt;=</span> van_wagner_critical_fireline_intensity(canopy_base_height, foliar_moisture)
    )
</pre>
</div>
</div>
</div>

<div id="outline-container-passive-and-active-crown-fire-spread-rate-functions" class="outline-4">
<h4 id="passive-and-active-crown-fire-spread-rate-functions"><span class="section-number-4">6.1.3.</span> Passive and Active Crown Fire Spread Rate Functions</h4>
<div class="outline-text-4" id="text-passive-and-active-crown-fire-spread-rate-functions">
<p>
If crowning occurs, then the active crown fire spread rate is
calculated from the following formula given in Cruz
2005:<sup><a id="fnr.28" class="footref" href="#fn.28" role="doc-backlink">28</a></sup>
</p>

\begin{align}
  \text{CROS}_A = 11.02 \, U_{10\text{m}}^{0.90} \, B_m^{0.19} \, e^{-17 \, \text{EFFM}} \\
\end{align}

<p>
where \(\text{CROS}_A\) is the active crown fire spread rate in
\(\text{m}/\min\), \(U_{10\text{m}}\) is the 10 meter windspeed in
\(\text{km/hr}\), \(B_m\) is the canopy bulk density in \(\text{kg/m}^3\),
and \(\text{EFFM}\) is the estimated fine fuel moisture in \(\text{kg moisture/kg ovendry weight}\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="cruz-active-crown-fire-spread-rate"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">cruz_active_crown_fire_spread_rate</span>(wind_speed_10m              : cy.<span class="org-builtin">float</span>,
                                       canopy_bulk_density         : cy.<span class="org-builtin">float</span>,
                                       estimated_fine_fuel_moisture: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the active crown fire spread rate (m/min) given:</span>
<span class="org-doc">    - wind_speed_10m                                   :: km/hr</span>
<span class="org-doc">    - canopy_bulk_density                              :: kg/m^3</span>
<span class="org-doc">    - estimated_fine_fuel_moisture (M_f[0] "dead-1hr") :: kg moisture/kg ovendry weight</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> (11.02
            <span class="org-operator">*</span> <span class="org-builtin">pow</span>(wind_speed_10m, 0.90)
            <span class="org-operator">*</span> <span class="org-builtin">pow</span>(canopy_bulk_density, 0.19)
            <span class="org-operator">*</span> exp(<span class="org-operator">-</span>17.0 <span class="org-operator">*</span> estimated_fine_fuel_moisture))
</pre>
</div>

<p>
Next, we need to calculate the <i>critical spread rate</i> from Van Wagner
1977<sup><a id="fnr.29" class="footref" href="#fn.29" role="doc-backlink">29</a></sup> as follows:
</p>

\begin{align}
  R^* = \frac{3.0}{B_m}
\end{align}

<p>
where \(R^*\) is the critical spread rate in \(\text{m}/\min\) and \(B_m\)
is the canopy bulk density in \(\text{kg/m}^3\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="van-wagner-critical-spread-rate"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">van_wagner_critical_spread_rate</span>(canopy_bulk_density: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the critical spread rate (m/min) given:</span>
<span class="org-doc">    - canopy_bulk_density :: kg/m^3</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> 3.0 <span class="org-operator">/</span> canopy_bulk_density
</pre>
</div>

<p>
If the active crown fire spread rate \(\text{CROS}_A\) is greater than
the critical spread rate \(R^*\), then the crown fire will be active,
otherwise passive. In the event of a passive crown fire, its spread
rate is calculated using the following formula from Cruz
2005:<sup><a id="fnr.30" class="footref" href="#fn.30" role="doc-backlink">30</a></sup>
</p>

\begin{align}
  \text{CROS}_P = \text{CROS}_A \, e^{-\text{CROS}_A / R^*}
\end{align}

<p>
where \(\text{CROS}_P\) is the passive crown fire spread rate in
\(\text{m}/\min\), \(\text{CROS}_A\) is the active crown fire spread rate
in \(\text{m}/\min\), and \(R^*\) is the critical spread rate in
\(\text{m}/\min\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="cruz-passive-crown-fire-spread-rate"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">cruz_passive_crown_fire_spread_rate</span>(active_spread_rate: cy.<span class="org-builtin">float</span>, critical_spread_rate: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the passive crown fire spread rate (m/min) given:</span>
<span class="org-doc">    - active_spread_rate   :: m/min</span>
<span class="org-doc">    - critical_spread_rate :: m/min</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> active_spread_rate <span class="org-operator">*</span> exp(<span class="org-operator">-</span>active_spread_rate <span class="org-operator">/</span> critical_spread_rate)
</pre>
</div>

<p>
Putting it all together, the following function calculates the
critical spread rate, whether a crown fire will become passive or
active, and its associated passive or active spread rate.
</p>

<div class="org-src-container">
<pre class="src src-python" id="cruz-crown-fire-spread-info"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">cruz_crown_fire_spread_info</span>(wind_speed_10m              : cy.<span class="org-builtin">float</span>,
                                canopy_bulk_density         : cy.<span class="org-builtin">float</span>,
                                estimated_fine_fuel_moisture: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> CrownSpreadInfo:
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - wind_speed_10m                                   :: km/hr</span>
<span class="org-doc">    - canopy_bulk_density                              :: kg/m^3</span>
<span class="org-doc">    - estimated_fine_fuel_moisture (M_f[0] "dead-1hr") :: kg moisture/kg ovendry weight</span>

<span class="org-doc">    return a CrownSpreadInfo struct containing these keys:</span>
<span class="org-doc">    - fire_type            :: 2 (passive_crown) or 3 (active_crown)</span>
<span class="org-doc">    - spread_rate          :: m/min</span>
<span class="org-doc">    - critical_spread_rate :: m/min</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">active_spread_rate</span>  : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cruz_active_crown_fire_spread_rate(wind_speed_10m,
                                                                        canopy_bulk_density,
                                                                        estimated_fine_fuel_moisture) <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
    <span class="org-variable-name">critical_spread_rate</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> van_wagner_critical_spread_rate(canopy_bulk_density) <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
    <span class="org-keyword">if</span> (active_spread_rate <span class="org-operator">&gt;</span> critical_spread_rate):
        <span class="org-keyword">return</span> CrownSpreadInfo(
            fire_type            <span class="org-operator">=</span> 3, <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: NAMED CONSTANT</span>
            spread_rate          <span class="org-operator">=</span> active_spread_rate,
            critical_spread_rate <span class="org-operator">=</span> critical_spread_rate,
        )
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> CrownSpreadInfo(
            fire_type            <span class="org-operator">=</span> 2, <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: NAMED CONSTANT</span>
            spread_rate          <span class="org-operator">=</span> cruz_passive_crown_fire_spread_rate(active_spread_rate, critical_spread_rate),
            critical_spread_rate <span class="org-operator">=</span> critical_spread_rate,
        )
</pre>
</div>
</div>
</div>

<div id="outline-container-crown-fire-intensity-functions" class="outline-4">
<h4 id="crown-fire-intensity-functions"><span class="section-number-4">6.1.4.</span> Crown Fire Intensity Functions</h4>
<div class="outline-text-4" id="text-crown-fire-intensity-functions">
<p>
Once the crown fire spread rate is determined, the crown fireline
intensity may be calculated using the following formula:
</p>

\begin{align}
  I_c = \frac{R_c \, B \, (Z - Z_b) \, h}{60}
\end{align}

<p>
where \(I_c\) is the crown fireline intensity in \(\text{Btu/ft/s}\),
\(R_c\) is the crown fire spread rate (either \(\text{CROS}_A\) or
\(\text{CROS}_P\)) in \(\text{ft}/\min\), \(B\) is the canopy bulk density
in \(\text{lb/ft}^3\), \(Z\) is the canopy height in \(\text{ft}\), \(Z_b\) is
the canopy base height in \(\text{ft}\), and \(h\) is the fuel model heat
of combustion (generally 8000 \(\text{Btu/lb}\)).
</p>

<p>
Note that \(I_c\) is only the fireline intensity generated by the canopy
fuels under the influence of the crown fire spread rate \(R_c\).
However, crown fires are typically coupled with the surface fires that
ignited them, and so the combined surface and crown fireline intensity
\(I_{s+c}\) is typically the value that should be reported in most
analyses along with the combined surface and crown flame length
\(L_{s+c}\). These terms are defined in section <a href="#combining-surface-and-crown-fire-behavior">6.1.8</a>.
</p>

<div class="org-src-container">
<pre class="src src-python" id="crown-fireline-intensity"><span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: heat_of_combustion is h from the fuel models (generally 8000 Btu/lb).</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: ELMFIRE hard-codes heat_of_combustion to 18000 kJ/kg = 7738.6 Btu/lb.</span>
<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_crown_fireline_intensity</span>(crown_spread_rate  : cy.<span class="org-builtin">float</span>,
                                  canopy_bulk_density: cy.<span class="org-builtin">float</span>,
                                  canopy_height      : cy.<span class="org-builtin">float</span>,
                                  canopy_base_height : cy.<span class="org-builtin">float</span>,
                                  heat_of_combustion : cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the crown fireline intensity (Btu/ft/s OR kW/m) given:</span>
<span class="org-doc">    - crown_spread_rate   :: ft/min  OR m/min</span>
<span class="org-doc">    - canopy_bulk_density :: lb/ft^3 OR kg/m^3</span>
<span class="org-doc">    - canopy_height       :: ft      OR m</span>
<span class="org-doc">    - canopy_base_height  :: ft      OR m</span>
<span class="org-doc">    - heat_of_combustion  :: Btu/lb  OR kJ/kg</span>

<span class="org-doc">    (ft/min * lb/ft^3 * ft * Btu/lb)/60 = (Btu/ft/min)/60 = Btu/ft/s</span>
<span class="org-doc">    OR</span>
<span class="org-doc">    (m/min * kg/m^3 * m * kJ/kg)/60 = (kJ/m*min)/60 = kJ/m*s = kW/m</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">canopy_height_difference</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> canopy_height <span class="org-operator">-</span> canopy_base_height
    <span class="org-keyword">return</span> (crown_spread_rate <span class="org-operator">*</span> canopy_bulk_density <span class="org-operator">*</span> canopy_height_difference <span class="org-operator">*</span> heat_of_combustion) <span class="org-operator">/</span> 60.0
</pre>
</div>
</div>
</div>

<div id="outline-container-crown-elliptical-eccentricity" class="outline-4">
<h4 id="crown-elliptical-eccentricity"><span class="section-number-4">6.1.5.</span> Crown Elliptical Eccentricity</h4>
<div class="outline-text-4" id="text-crown-elliptical-eccentricity">
<p>
As with surface fire spread, the wind speed (this time the 20-ft wind
speed \(U_{20}\)) is used to compute the length to width ratio
\(\frac{L}{W}\) of an ellipse that approximates the crown fire front
using equation 10 from Rothermel 1991.<sup><a id="fnr.31" class="footref" href="#fn.31" role="doc-backlink">31</a></sup> This length
to width ratio is then converted into an eccentricity measure of the
ellipse using equation 8 from Albini and Chase 1980.<sup><a id="fnr.32" class="footref" href="#fn.32" role="doc-backlink">32</a></sup>
Here are the formulas used:
</p>

\begin{align}
  \frac{L}{W} &= 1 + 0.125 \, U_{20} \\
  \nonumber \\
  E &= \frac{\sqrt{(\frac{L}{W})^2 - 1}}{\frac{L}{W}}
\end{align}

<p>
where \(U_{20}\) is the 20-ft wind speed in \(\text{mph}\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="crown-fire-eccentricity"><span class="org-comment-delimiter"># </span><span class="org-comment">Parameters for the linear model that computes LoW from wind speed.</span>
<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">crown_length_to_width_ratio</span>(wind_speed_10m: cy.<span class="org-builtin">float</span>, max_length_to_width_ratio: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 1e10) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the length_to_width_ratio of the crown fire front using eq. 9 from</span>
<span class="org-doc">    Rothermel 1991 given:</span>
<span class="org-doc">    - wind_speed_10m            :: km/hr (aligned with the slope-tangential plane)</span>
<span class="org-doc">    - max_length_to_width_ratio :: float &gt; 0.0 (Optional)</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">wind_speed_20ft</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> conv.wind_speed_10m_to_wind_speed_20ft(wind_speed_10m) <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-variable-name">wind_speed_20ft_mph</span>  : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> conv.km_hr_to_mph(wind_speed_20ft)                     <span class="org-comment-delimiter"># </span><span class="org-comment">mph</span>
    <span class="org-variable-name">length_to_width_ratio</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 1.0 <span class="org-operator">+</span> 0.125 <span class="org-operator">*</span> wind_speed_20ft_mph
    <span class="org-keyword">return</span> <span class="org-builtin">min</span>(length_to_width_ratio, max_length_to_width_ratio)


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">crown_fire_eccentricity</span>(length_to_width_ratio: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the eccentricity (E) of the crown fire front using eq. 8 from</span>
<span class="org-doc">    Albini and Chase 1980 given:</span>
<span class="org-doc">    - length_to_width_ratio :: (1: circular spread, &gt; 1: elliptical spread)</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> sqrt(length_to_width_ratio <span class="org-operator">*</span> length_to_width_ratio <span class="org-operator">-</span> 1.0) <span class="org-operator">/</span> length_to_width_ratio
</pre>
</div>
</div>
</div>

<div id="outline-container-crown-fire-behavior-in-the-direction-of-maximum-spread" class="outline-4">
<h4 id="crown-fire-behavior-in-the-direction-of-maximum-spread"><span class="section-number-4">6.1.6.</span> Crown Fire Behavior in the Direction of Maximum Spread</h4>
<div class="outline-text-4" id="text-crown-fire-behavior-in-the-direction-of-maximum-spread">
<p>
This section introduces a function that computes all of the crown fire
behavior values described in the previous sections. In order to
accurately compare the crown fire behavior values from this section
with the surface fire behavior values from section <a href="#surface-fire-behavior-in-the-direction-of-maximum-spread">5.1.10</a>, the 10 meter wind vector
must be projected onto the slope-tangential plane (using Waeselynck
2024<sup><a id="fnr.33" class="footref" href="#fn.33" role="doc-backlink">33</a></sup>) before the crown fire's maximum spread rate
and associated elliptical parameters are calculated. This ensures that
both the surface fire and crown fire ellipses are aligned with the
slope-tangential plane for later comparison in section <a href="#combining-surface-and-crown-fire-behavior">6.1.8</a>.
</p>

<div class="org-src-container">
<pre class="src src-python" id="crown-fire-behavior-max"><span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_crown_fire_behavior_max</span>(canopy_height               : cy.<span class="org-builtin">float</span>,
                                 canopy_base_height          : cy.<span class="org-builtin">float</span>,
                                 canopy_bulk_density         : cy.<span class="org-builtin">float</span>,
                                 heat_of_combustion          : cy.<span class="org-builtin">float</span>,
                                 estimated_fine_fuel_moisture: cy.<span class="org-builtin">float</span>,
                                 wind_speed_10m              : cy.<span class="org-builtin">float</span>,
                                 upwind_direction            : cy.<span class="org-builtin">float</span>,
                                 slope                       : cy.<span class="org-builtin">float</span>,
                                 aspect                      : cy.<span class="org-builtin">float</span>,
                                 crown_max_lw_ratio          : cy.<span class="org-builtin">float</span><span class="org-operator">=</span>1e10) <span class="org-operator">-&gt;</span> FireBehaviorMax:
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - canopy_height                                    :: m</span>
<span class="org-doc">    - canopy_base_height                               :: m</span>
<span class="org-doc">    - canopy_bulk_density                              :: kg/m^3</span>
<span class="org-doc">    - heat_of_combustion                               :: kJ/kg</span>
<span class="org-doc">    - estimated_fine_fuel_moisture (M_f[0] "dead-1hr") :: kg moisture/kg ovendry weight</span>
<span class="org-doc">    - wind_speed_10m                                   :: km/hr</span>
<span class="org-doc">    - upwind_direction                                 :: degrees clockwise from North</span>
<span class="org-doc">    - slope                                            :: rise/run</span>
<span class="org-doc">    - aspect                                           :: degrees clockwise from North</span>
<span class="org-doc">    - crown_max_lw_ratio                               :: float &gt; 0.0 (Optional)</span>

<span class="org-doc">    return a FireBehaviorMax struct containing these keys:</span>
<span class="org-doc">    - max_fire_type          :: 2 (passive_crown) or 3 (active_crown)</span>
<span class="org-doc">    - max_spread_rate        :: m/min</span>
<span class="org-doc">    - max_spread_direction   :: (x, y, z) unit vector</span>
<span class="org-doc">    - max_fireline_intensity :: kW/m</span>
<span class="org-doc">    - max_flame_length       :: m</span>
<span class="org-doc">    - length_to_width_ratio  :: unitless (1: circular spread, &gt; 1: elliptical spread)</span>
<span class="org-doc">    - eccentricity           :: unitless (0: circular spread, &gt; 0: elliptical spread)</span>
<span class="org-doc">    - critical_spread_rate   :: m/min</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Reverse the provided wind and slope directions</span>
    <span class="org-variable-name">downwind_direction</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> conv.opposite_direction(upwind_direction)
    <span class="org-variable-name">upslope_direction</span> : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> conv.opposite_direction(aspect)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Project wind and slope vectors onto the slope-tangential plane</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Let's just have these vectors as arguments to the function instead of re-computing them.</span>
    <span class="org-variable-name">vectors</span>: ProjectedVectors <span class="org-operator">=</span> sf.project_wind_and_slope_vectors_3d(wind_speed_10m, downwind_direction,
                                                                     slope, upslope_direction)
    <span class="org-variable-name">wind_vector_3d</span> : vec_xyz <span class="org-operator">=</span> vectors.wind_vector_3d  <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-variable-name">slope_vector_3d</span>: vec_xyz <span class="org-operator">=</span> vectors.slope_vector_3d <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Determine the max spread direction</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: REVIEW Should we make the max_spread_direction the combined wind and slope direction?</span>
    <span class="org-variable-name">wind_speed_10m_3d</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vu.vector_magnitude_3d(wind_vector_3d) <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    max_spread_direction: vec_xyz
    <span class="org-keyword">if</span> wind_speed_10m_3d <span class="org-operator">&gt;</span> 0.0:
        <span class="org-variable-name">max_spread_direction</span> <span class="org-operator">=</span> vu.as_unit_vector_3d(wind_vector_3d)  <span class="org-comment-delimiter"># </span><span class="org-comment">unit vector in the 3D downwind direction</span>
    <span class="org-keyword">elif</span> slope <span class="org-operator">&gt;</span> 0.0:
        <span class="org-variable-name">max_spread_direction</span> <span class="org-operator">=</span> vu.as_unit_vector_3d(slope_vector_3d) <span class="org-comment-delimiter"># </span><span class="org-comment">unit vector in the 3D upslope direction</span>
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">max_spread_direction</span> <span class="org-operator">=</span> (0.0, 1.0, 0.0)                       <span class="org-comment-delimiter"># </span><span class="org-comment">default: North</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the crown fire behavior in the max spread direction</span>
    <span class="org-variable-name">spread_info</span>          : CrownSpreadInfo <span class="org-operator">=</span> cruz_crown_fire_spread_info(wind_speed_10m_3d,
                                                                         canopy_bulk_density,
                                                                         estimated_fine_fuel_moisture)
    <span class="org-variable-name">spread_rate</span>          : cy.<span class="org-builtin">float</span>        <span class="org-operator">=</span> spread_info.spread_rate                           <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
    <span class="org-variable-name">fireline_intensity</span>   : cy.<span class="org-builtin">float</span>        <span class="org-operator">=</span> calc_crown_fireline_intensity(spread_rate,
                                                                           canopy_bulk_density,
                                                                           canopy_height,
                                                                           canopy_base_height,
                                                                           heat_of_combustion) <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
    <span class="org-variable-name">length_to_width_ratio</span>: cy.<span class="org-builtin">float</span>        <span class="org-operator">=</span> crown_length_to_width_ratio(wind_speed_10m_3d,
                                                                         crown_max_lw_ratio)   <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
    <span class="org-variable-name">eccentricity</span>         : cy.<span class="org-builtin">float</span>        <span class="org-operator">=</span> crown_fire_eccentricity(length_to_width_ratio)    <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
    <span class="org-keyword">return</span> FireBehaviorMax(
        max_fire_type          <span class="org-operator">=</span> spread_info.fire_type,
        max_spread_rate        <span class="org-operator">=</span> spread_rate,
        max_spread_direction   <span class="org-operator">=</span> max_spread_direction, <span class="org-comment-delimiter"># </span><span class="org-comment">unit vector</span>
        max_fireline_intensity <span class="org-operator">=</span> fireline_intensity,
        max_flame_length       <span class="org-operator">=</span> 0.0, <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: max_flame_length is not provided, as in the original unoptimized code.</span>
        length_to_width_ratio  <span class="org-operator">=</span> length_to_width_ratio,
        eccentricity           <span class="org-operator">=</span> eccentricity,
        critical_spread_rate   <span class="org-operator">=</span> spread_info.critical_spread_rate,
    )
</pre>
</div>
</div>
</div>

<div id="outline-container-crown-fire-behavior-in-any-direction" class="outline-4">
<h4 id="crown-fire-behavior-in-any-direction"><span class="section-number-4">6.1.7.</span> Crown Fire Behavior in Any Direction</h4>
<div class="outline-text-4" id="text-crown-fire-behavior-in-any-direction">
<p>
Once we have calculated the maximum crown fire behavior values
associated with a head fire, we can use the elliptical eccentricity
\(E\) to project the maximum spread rate \(R_c\) and maximum fireline
intensity \(I_c\) to any point along the fire front as follows:
</p>

\begin{align}
  \eta &= \frac{1-E}{1-E\cos\omega} \\
  \nonumber \\
  R_c(\omega) &= R_c \, \eta \\
  \nonumber \\
  I_c(\omega) &= I_c \, \eta
\end{align}

<p>
where \(\omega\) is the angular offset from the direction of maximum
fire spread and \(R_c(\omega)\) and \(I_c(\omega)\) are the spread rate
and fireline intensity in this direction respectively.
</p>

<p>
Since the crown fire ellipse is defined on the slope-tangential plane,
we must represent spread directions with three dimensional unit
vectors aligned with this plane rather than with angles. Fortunately,
we can use the relationship between the dot product of two vectors and
the cosine of the angle between them to rewrite the \(\eta\) function
above as follows:
</p>

\begin{align}
  \eta = \frac{1-E}{1-E(\vec{u_{\max}} \cdot \vec{u_{\omega}})}
\end{align}

<p>
where \(\vec{u_{\max}}\) is the slope-tangential unit vector in the
direction of maximum spread and \(\vec{u_{\omega}}\) is the
slope-tangential unit vector rotated \(\omega\) degrees clockwise along
this plane from \(\vec{u_{\max}}\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="crown-fire-behavior-in-direction"><span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_crown_fire_behavior_in_direction</span>(crown_fire_max  : FireBehaviorMax,
                                          spread_direction: vec_xyz) <span class="org-operator">-&gt;</span> SpreadBehavior:
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - crown_fire_max     :: a FireBehaviorMax struct of max crown fire behavior values</span>
<span class="org-doc">      - max_fire_type          :: 2 (passive_crown) or 3 (active_crown)</span>
<span class="org-doc">      - max_spread_rate        :: m/min</span>
<span class="org-doc">      - max_spread_direction   :: (x, y, z) unit vector</span>
<span class="org-doc">      - max_fireline_intensity :: kW/m</span>
<span class="org-doc">      - max_flame_length       :: m</span>
<span class="org-doc">      - length_to_width_ratio  :: unitless (1: circular spread, &gt; 1: elliptical spread)</span>
<span class="org-doc">      - eccentricity           :: unitless (0: circular spread, &gt; 0: elliptical spread)</span>
<span class="org-doc">      - critical_spread_rate   :: m/min</span>
<span class="org-doc">    - spread_direction   :: 3D unit vector on the slope-tangential plane</span>

<span class="org-doc">    return a SpreadBehavior struct containing these keys:</span>
<span class="org-doc">    - dphi_dt            :: phi/min</span>
<span class="org-doc">    - fire_type          :: 2 (passive_crown) or 3 (active_crown)</span>
<span class="org-doc">    - spread_rate        :: m/min</span>
<span class="org-doc">    - spread_direction   :: (x, y, z) unit vector</span>
<span class="org-doc">    - fireline_intensity :: kW/m</span>
<span class="org-doc">    - flame_length       :: m</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack max crown fire behavior values</span>
    <span class="org-variable-name">max_fire_type</span>         : cy.<span class="org-builtin">int</span>   <span class="org-operator">=</span> crown_fire_max.max_fire_type
    <span class="org-variable-name">max_spread_rate</span>       : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> crown_fire_max.max_spread_rate
    <span class="org-variable-name">max_spread_direction</span>  : vec_xyz  <span class="org-operator">=</span> crown_fire_max.max_spread_direction
    <span class="org-variable-name">max_fireline_intensity</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> crown_fire_max.max_fireline_intensity
    <span class="org-variable-name">eccentricity</span>          : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> crown_fire_max.eccentricity
    <span class="org-variable-name">critical_spread_rate</span>  : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> crown_fire_max.critical_spread_rate
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate cos(w), where w is the offset angle between these unit vectors on the slope-tangential plane</span>
    <span class="org-variable-name">cos_w</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vu.dot_3d(max_spread_direction, spread_direction)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate adjustment due to the offset angle from the max spread direction</span>
    <span class="org-variable-name">adjustment</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (1.0 <span class="org-operator">-</span> eccentricity) <span class="org-operator">/</span> (1.0 <span class="org-operator">-</span> eccentricity <span class="org-operator">*</span> cos_w)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Adjust the spread rate (possibly switching from an active to passive crown fire)</span>
    <span class="org-variable-name">spread_rate</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> max_spread_rate <span class="org-operator">*</span> adjustment
    <span class="org-keyword">if</span> spread_rate <span class="org-operator">&gt;</span> critical_spread_rate:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Max spread rate was active and directional spread rate remains active</span>
        <span class="org-keyword">return</span> SpreadBehavior(
            dphi_dt            <span class="org-operator">=</span> 0.0,
            fire_type          <span class="org-operator">=</span> 3, <span class="org-comment-delimiter"># </span><span class="org-comment">active_crown</span>
            spread_rate        <span class="org-operator">=</span> spread_rate,
            spread_direction   <span class="org-operator">=</span> spread_direction,
            fireline_intensity <span class="org-operator">=</span> max_fireline_intensity <span class="org-operator">*</span> adjustment,
            flame_length       <span class="org-operator">=</span> 0.0,
        )
    <span class="org-keyword">elif</span> max_fire_type <span class="org-operator">==</span> 2: <span class="org-comment-delimiter"># </span><span class="org-comment">passive_crown</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Max spread rate was passive and directional spread rate remains passive</span>
        <span class="org-keyword">return</span> SpreadBehavior(
            dphi_dt            <span class="org-operator">=</span> 0.0,
            fire_type          <span class="org-operator">=</span> 2, <span class="org-comment-delimiter"># </span><span class="org-comment">passive_crown</span>
            spread_rate        <span class="org-operator">=</span> spread_rate,
            spread_direction   <span class="org-operator">=</span> spread_direction,
            fireline_intensity <span class="org-operator">=</span> max_fireline_intensity <span class="org-operator">*</span> adjustment,
            flame_length       <span class="org-operator">=</span> 0.0,
        )
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Max spread rate was active and directional spread rate has become passive</span>
        <span class="org-keyword">return</span> SpreadBehavior(
            dphi_dt            <span class="org-operator">=</span> 0.0,
            fire_type          <span class="org-operator">=</span> 2, <span class="org-comment-delimiter"># </span><span class="org-comment">passive_crown</span>
            spread_rate        <span class="org-operator">=</span> cruz_passive_crown_fire_spread_rate(spread_rate, critical_spread_rate),
            spread_direction   <span class="org-operator">=</span> spread_direction,
            fireline_intensity <span class="org-operator">=</span> max_fireline_intensity <span class="org-operator">*</span> adjustment,
            flame_length       <span class="org-operator">=</span> 0.0,
        )
</pre>
</div>
</div>
</div>

<div id="outline-container-combining-surface-and-crown-fire-behavior" class="outline-4">
<h4 id="combining-surface-and-crown-fire-behavior"><span class="section-number-4">6.1.8.</span> Combining Surface and Crown Fire Behavior</h4>
<div class="outline-text-4" id="text-combining-surface-and-crown-fire-behavior">
<p>
When both surface fire and crown fire are present in the same
location, their combined behavior determines the fire type, spread
rate and direction, fireline intensity, and flame length values
associated with this location.
</p>

<p>
<b>Note:</b> Since the surface fire and crown fire each define separate
fire spread ellipses with potentially different maximum spread
directions, their relative spread rates and intensities should only be
compared in a given absolute direction in the slope-tangential plane.
In most applications, this will be the direction normal to the fire
front.
</p>
</div>

<ol class="org-ol">
<li><a id="combined-fire-type"></a>Combined Fire Type<br>
<div class="outline-text-5" id="text-combined-fire-type">
<p>
The fire type associated with the combined fire is the crown fire
type, either "passive_crown" or "active_crown".
</p>
</div>
</li>

<li><a id="combined-spread-rate-and-direction"></a>Combined Spread Rate and Direction<br>
<div class="outline-text-5" id="text-combined-spread-rate-and-direction">
<p>
The combined spread rate \(R_{s+c}\) (in \(\text{m}/\text{min}\)) is
defined to be the maximum of the surface spread rate \(R_s\) and the
crown spread rate \(R_c\) as follows:
</p>

\begin{align}
  R_{s+c} = \max(R_s, R_c)
\end{align}

<p>
The combined spread direction is the spread direction associated with
whichever fire front has the fastest spread rate.
</p>
</div>
</li>

<li><a id="combined-fireline-intensity"></a>Combined Fireline Intensity<br>
<div class="outline-text-5" id="text-combined-fireline-intensity">
<p>
Combining surface and crown fireline intensities is slightly more
complicated. From section <a href="#surface-fire-intensity-functions">5.1.4</a>, we can see
the following relationship between the surface fire spread rate \(R_s\)
(in \(\text{m}/\text{min}\)), the surface fireline intensity \(I_s\) (in
\(\text{kW}/\text{m}\)), and the heat per unit area of the burning
surface fuel \(H_s\) (in \(\text{kJ}/\text{m}^2\)), which we here
generalize to calculate the heat per unit area of a crown fire \(H_c\)
and a combined surface and crown fire \(H_{s+c}\):
</p>

\begin{align}
  H_s &= 60 \frac{I_s}{R_s} \\
  \nonumber \\
  H_c &= 60 \frac{I_c}{R_c} \\
  \nonumber \\
  H_{s+c} &= 60 \frac{I_{s+c}}{R_{s+c}} \\
\end{align}

<p>
When surface and canopy fuels both burn in the same area, their
combined heat per unit area \(H_{s+c}\) is their sum:
</p>

\begin{align}
  H_{s+c} = H_s + H_c = 60 \left(\frac{I_s}{R_s} + \frac{I_c}{R_c}\right)
\end{align}

<p>
Equating the two definitions for \(H_{s+c}\) above gives us the
following definition for the combined fireline intensity \(I_{s+c}\) (in
\(\text{kW}/\text{m}\)):
</p>

\begin{align}
  I_{s+c} = R_{s+c} \left(\frac{I_s}{R_s} + \frac{I_c}{R_c}\right)
\end{align}

<p>
Substituting in the definition of \(R_{s+c}\) gives us this piecewise
formula:
</p>

\begin{align}
  I_{s+c} &= \left\{
    \begin{array}{lr}
      I_s + I_c \frac{R_s}{R_c} & \text{when}\ R_s > R_c \\
      I_s \frac{R_c}{R_s} + I_c & \text{when}\  R_s < R_c \\
      I_s + I_c & \text{when}\ R_s = R_c \\
    \end{array}
  \right. \\
\end{align}

<p>
Some fire behavior models have calculated the combined fireline
intensity by simply adding the surface and crown fireline intensities
together as we do in the \(R_s = R_c\) case above. However, that would
misrepresent the physical behavior of the combined fire whenever \(R_s
\neq R_c\). For example, when the crown fire makes the fire front
spread faster, then the surface fireline intensity is amplified due to
more surface fuel burning simultaneously (i.e., greater flame depth).
Similarly, if the surface fire outpaces the crown fire, then it can
ignite a longer span of canopy fuels as it progresses, thereby
increasing the flame depth and fireline intensity of the crown fire in
the direction normal to the fire perimeter. The piecewise definition
of \(I_{s+c}\) above accounts for this co-amplification behavior.
</p>
</div>
</li>

<li><a id="combined-flame-length"></a>Combined Flame Length<br>
<div class="outline-text-5" id="text-combined-flame-length">
<p>
The combined flame length \(L_{s+c}\) (in meters) is the flame length of
the combined fireline intensity \(I_{s+c}\) (in \(\text{kW}/\text{m}\)) as
follows:
</p>

\begin{align}
  L_{s+c} = 0.07747042253266703 (I_{s+c})^{0.46}
\end{align}
</div>
</li>

<li><a id="combined-fire-behavior-implementation"></a>Combined Fire Behavior Implementation<br>
<div class="outline-text-5" id="text-combined-fire-behavior-implementation">
<div class="org-src-container">
<pre class="src src-python" id="combined-fire-behavior"><span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_combined_fire_behavior</span>(surface_fire_behavior: SpreadBehavior,
                                crown_fire_behavior  : SpreadBehavior) <span class="org-operator">-&gt;</span> SpreadBehavior:
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - surface_fire_behavior :: a SpreadBehavior struct of surface fire behavior values</span>
<span class="org-doc">      - dphi_dt                :: phi/min</span>
<span class="org-doc">      - fire_type              :: 1 (surface)</span>
<span class="org-doc">      - spread_rate            :: m/min</span>
<span class="org-doc">      - spread_direction       :: (x, y, z) unit vector</span>
<span class="org-doc">      - fireline_intensity     :: kW/m</span>
<span class="org-doc">      - flame_length           :: m</span>
<span class="org-doc">    - crown_fire_behavior   :: a SpreadBehavior struct of crown fire behavior values</span>
<span class="org-doc">      - dphi_dt                :: phi/min</span>
<span class="org-doc">      - fire_type              :: 2 (passive_crown) or 3 (active_crown)</span>
<span class="org-doc">      - spread_rate            :: m/min</span>
<span class="org-doc">      - spread_direction       :: (x, y, z) unit vector</span>
<span class="org-doc">      - fireline_intensity     :: kW/m</span>
<span class="org-doc">      - flame_length           :: m</span>

<span class="org-doc">    return a SpreadBehavior struct containing these keys:</span>
<span class="org-doc">    - dphi_dt            :: phi/min</span>
<span class="org-doc">    - fire_type          :: 1 (surface), 2 (passive_crown), or 3 (active_crown)</span>
<span class="org-doc">    - spread_rate        :: m/min</span>
<span class="org-doc">    - spread_direction   :: (x, y, z) unit vector</span>
<span class="org-doc">    - fireline_intensity :: kW/m</span>
<span class="org-doc">    - flame_length       :: m</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack the surface fire behavior values</span>
    <span class="org-variable-name">surface_dphi_dt</span>           : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> surface_fire_behavior.dphi_dt            <span class="org-comment-delimiter"># </span><span class="org-comment">phi/min</span>
    <span class="org-variable-name">surface_spread_rate</span>       : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> surface_fire_behavior.spread_rate        <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
    <span class="org-variable-name">surface_spread_direction</span>  : vec_xyz  <span class="org-operator">=</span> surface_fire_behavior.spread_direction   <span class="org-comment-delimiter"># </span><span class="org-comment">(x, y, z) unit vector</span>
    <span class="org-variable-name">surface_fireline_intensity</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> surface_fire_behavior.fireline_intensity <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
    <span class="org-variable-name">surface_flame_length</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> surface_fire_behavior.flame_length       <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack the crown fire behavior values</span>
    <span class="org-variable-name">crown_dphi_dt</span>           : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> crown_fire_behavior.dphi_dt            <span class="org-comment-delimiter"># </span><span class="org-comment">phi/min</span>
    <span class="org-variable-name">crown_fire_type</span>         : cy.<span class="org-builtin">int</span>   <span class="org-operator">=</span> crown_fire_behavior.fire_type          <span class="org-comment-delimiter"># </span><span class="org-comment">2 (passive_crown) or 3 (active_crown)</span>
    <span class="org-variable-name">crown_spread_rate</span>       : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> crown_fire_behavior.spread_rate        <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
    <span class="org-variable-name">crown_spread_direction</span>  : vec_xyz  <span class="org-operator">=</span> crown_fire_behavior.spread_direction   <span class="org-comment-delimiter"># </span><span class="org-comment">(x, y, z) unit vector</span>
    <span class="org-variable-name">crown_fireline_intensity</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> crown_fire_behavior.fireline_intensity <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Select the most quickly changing (i.e., lowest) dphi_dt value</span>
    <span class="org-variable-name">dphi_dt</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> <span class="org-builtin">min</span>(surface_dphi_dt, crown_dphi_dt)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Determine whether the surface or crown fire has the fastest spread rate</span>
    <span class="org-keyword">if</span> surface_spread_rate <span class="org-operator">==</span> 0.0:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Independent crown fire (NOTE: This is probably user error.)</span>
        <span class="org-keyword">return</span> crown_fire_behavior
    <span class="org-keyword">elif</span> crown_spread_rate <span class="org-operator">==</span> 0.0:
        <span class="org-keyword">if</span> crown_fire_type <span class="org-operator">==</span> 2:
            <span class="org-comment-delimiter"># </span><span class="org-comment">Passive crown fire</span>
            <span class="org-keyword">return</span> SpreadBehavior(
                dphi_dt            <span class="org-operator">=</span> dphi_dt,
                fire_type          <span class="org-operator">=</span> crown_fire_type,
                spread_rate        <span class="org-operator">=</span> surface_spread_rate,
                spread_direction   <span class="org-operator">=</span> surface_spread_direction,
                fireline_intensity <span class="org-operator">=</span> surface_fireline_intensity,
                flame_length       <span class="org-operator">=</span> surface_flame_length,
            )
        <span class="org-keyword">else</span>:
            <span class="org-comment-delimiter"># </span><span class="org-comment">No crown fire</span>
            <span class="org-keyword">return</span> surface_fire_behavior
    <span class="org-keyword">elif</span> surface_spread_rate <span class="org-operator">&gt;</span> crown_spread_rate:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Surface fire spreads faster</span>
        <span class="org-variable-name">combined_fireline_intensity</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (surface_fireline_intensity
                                                 <span class="org-operator">+</span> crown_fireline_intensity <span class="org-operator">*</span> surface_spread_rate <span class="org-operator">/</span> crown_spread_rate)
        <span class="org-keyword">return</span> SpreadBehavior(
            dphi_dt            <span class="org-operator">=</span> dphi_dt,
            fire_type          <span class="org-operator">=</span> crown_fire_type,
            spread_rate        <span class="org-operator">=</span> surface_spread_rate,
            spread_direction   <span class="org-operator">=</span> surface_spread_direction,
            fireline_intensity <span class="org-operator">=</span> combined_fireline_intensity,
            flame_length       <span class="org-operator">=</span> sf.calc_flame_length(combined_fireline_intensity),
        )
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Crown fire spreads faster</span>
        <span class="org-variable-name">combined_fireline_intensity</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (surface_fireline_intensity <span class="org-operator">*</span> crown_spread_rate <span class="org-operator">/</span> surface_spread_rate
                                                 <span class="org-operator">+</span> crown_fireline_intensity)
        <span class="org-keyword">return</span> SpreadBehavior(
            dphi_dt            <span class="org-operator">=</span> dphi_dt,
            fire_type          <span class="org-operator">=</span> crown_fire_type,
            spread_rate        <span class="org-operator">=</span> crown_spread_rate,
            spread_direction   <span class="org-operator">=</span> crown_spread_direction,
            fireline_intensity <span class="org-operator">=</span> combined_fireline_intensity,
            flame_length       <span class="org-operator">=</span> sf.calc_flame_length(combined_fireline_intensity),
        )
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-for-users-crown" class="outline-3">
<h3 id="for-users-crown"><span class="section-number-3">6.2.</span> For Users</h3>
<div class="outline-text-3" id="text-for-users-crown">
<p>
In the following sections, we will demonstrate how to calculate the
crown fire behavior values given a surface fire line intensity and
measurements of foliar moisture, fine fuel moisture, tree canopy
characteristics, wind speed, wind direction, slope, and aspect. This
will be done first for the max spread direction case and then in any
direction on the sloped surface using 3D vectors to specify absolute
directions.
</p>

<p>
Because wind speed and direction will often be provided from
measurements taken 10m or 20ft above the canopy and may be given in
either cartesion <code>(x,y)</code> or azimuthal <code>(r,azimuth)</code> coordinates, we
also demonstrate how to convert from cartesian to azimuthal
coordinates and from 10m to 20ft wind speeds.
</p>

<p>
See Appendix <a href="#units-conversion-functions-(pyretechnics.conversion)">10.2</a> for
the full list of available units conversion functions.
</p>

<p>
See Appendix <a href="#vector-utility-functions-(pyretechnics.vector_utils)">10.3</a> for
the full list of available vector manipulation functions.
</p>
</div>

<div id="outline-container-how-to-determine-whether-a-surface-fire-transitions-to-a-crown-fire" class="outline-4">
<h4 id="how-to-determine-whether-a-surface-fire-transitions-to-a-crown-fire"><span class="section-number-4">6.2.1.</span> How to Determine Whether a Surface Fire Transitions to a Crown Fire</h4>
<div class="outline-text-4" id="text-how-to-determine-whether-a-surface-fire-transitions-to-a-crown-fire">
<div class="org-src-container">
<pre class="src src-python" id="check-crown-fire-initiation"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.crown_fire <span class="org-keyword">as</span> cf

<span class="org-comment-delimiter"># </span><span class="org-comment">Set tree canopy characteristics</span>
<span class="org-variable-name">canopy_cover_low</span>   <span class="org-operator">=</span> 0.3 <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
<span class="org-variable-name">canopy_cover_high</span>  <span class="org-operator">=</span> 0.8 <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
<span class="org-variable-name">canopy_base_height</span> <span class="org-operator">=</span> 3.0 <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
<span class="org-variable-name">foliar_moisture</span>    <span class="org-operator">=</span> 1.0 <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Specify some surface fireline intensity values to check</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">These would normally be calculated by the functions in pyretechnics.surface_fire</span>
<span class="org-variable-name">surface_fireline_intensity_low</span>  <span class="org-operator">=</span> 500.0  <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
<span class="org-variable-name">surface_fireline_intensity_high</span> <span class="org-operator">=</span> 5000.0 <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">=================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Check for crown fire with canopy_cover_low and surface_fireline_intensity_low</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"Low Canopy Cover and Low Surface Fireline Intensity</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)

<span class="org-keyword">if</span> cf.van_wagner_crown_fire_initiation(surface_fireline_intensity_low,
                                       canopy_cover_low,
                                       canopy_base_height,
                                       foliar_moisture):
    <span class="org-comment-delimiter"># </span><span class="org-comment">Crown Fire</span>
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">A crown fire occurs with these input parameters:"</span>)
    pprint({
        <span class="org-string">"surface_fireline_intensity"</span>: surface_fireline_intensity_low,
        <span class="org-string">"canopy_cover"</span>              : canopy_cover_low,
        <span class="org-string">"canopy_base_height"</span>        : canopy_base_height,
        <span class="org-string">"foliar_moisture"</span>           : foliar_moisture,
    })
<span class="org-keyword">else</span>:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Surface Fire</span>
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">A surface fire occurs with these input parameters:"</span>)
    pprint({
        <span class="org-string">"surface_fireline_intensity"</span>: surface_fireline_intensity_low,
        <span class="org-string">"canopy_cover"</span>              : canopy_cover_low,
        <span class="org-string">"canopy_base_height"</span>        : canopy_base_height,
        <span class="org-string">"foliar_moisture"</span>           : foliar_moisture,
    })

<span class="org-comment-delimiter">#</span><span class="org-comment">=================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Check for crown fire with canopy_cover_low and surface_fireline_intensity_high</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Low Canopy Cover and High Surface Fireline Intensity</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)

<span class="org-keyword">if</span> cf.van_wagner_crown_fire_initiation(surface_fireline_intensity_high,
                                       canopy_cover_low,
                                       canopy_base_height,
                                       foliar_moisture):
    <span class="org-comment-delimiter"># </span><span class="org-comment">Crown Fire</span>
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">A crown fire occurs with these input parameters:"</span>)
    pprint({
        <span class="org-string">"surface_fireline_intensity"</span>: surface_fireline_intensity_high,
        <span class="org-string">"canopy_cover"</span>              : canopy_cover_low,
        <span class="org-string">"canopy_base_height"</span>        : canopy_base_height,
        <span class="org-string">"foliar_moisture"</span>           : foliar_moisture,
    })
<span class="org-keyword">else</span>:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Surface Fire</span>
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">A surface fire occurs with these input parameters:"</span>)
    pprint({
        <span class="org-string">"surface_fireline_intensity"</span>: surface_fireline_intensity_high,
        <span class="org-string">"canopy_cover"</span>              : canopy_cover_low,
        <span class="org-string">"canopy_base_height"</span>        : canopy_base_height,
        <span class="org-string">"foliar_moisture"</span>           : foliar_moisture,
    })

<span class="org-comment-delimiter">#</span><span class="org-comment">=================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Check for crown fire with canopy_cover_high and surface_fireline_intensity_low</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">High Canopy Cover and Low Surface Fireline Intensity</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)

<span class="org-keyword">if</span> cf.van_wagner_crown_fire_initiation(surface_fireline_intensity_low,
                                       canopy_cover_high,
                                       canopy_base_height,
                                       foliar_moisture):
    <span class="org-comment-delimiter"># </span><span class="org-comment">Crown Fire</span>
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">A crown fire occurs with these input parameters:"</span>)
    pprint({
        <span class="org-string">"surface_fireline_intensity"</span>: surface_fireline_intensity_low,
        <span class="org-string">"canopy_cover"</span>              : canopy_cover_high,
        <span class="org-string">"canopy_base_height"</span>        : canopy_base_height,
        <span class="org-string">"foliar_moisture"</span>           : foliar_moisture,
    })
<span class="org-keyword">else</span>:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Surface Fire</span>
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">A surface fire occurs with these input parameters:"</span>)
    pprint({
        <span class="org-string">"surface_fireline_intensity"</span>: surface_fireline_intensity_low,
        <span class="org-string">"canopy_cover"</span>              : canopy_cover_high,
        <span class="org-string">"canopy_base_height"</span>        : canopy_base_height,
        <span class="org-string">"foliar_moisture"</span>           : foliar_moisture,
    })

<span class="org-comment-delimiter">#</span><span class="org-comment">=================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Check for crown fire with canopy_cover_high and surface_fireline_intensity_high</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">High Canopy Cover and High Surface Fireline Intensity</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)

<span class="org-keyword">if</span> cf.van_wagner_crown_fire_initiation(surface_fireline_intensity_high,
                                       canopy_cover_high,
                                       canopy_base_height,
                                       foliar_moisture):
    <span class="org-comment-delimiter"># </span><span class="org-comment">Crown Fire</span>
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">A crown fire occurs with these input parameters:"</span>)
    pprint({
        <span class="org-string">"surface_fireline_intensity"</span>: surface_fireline_intensity_high,
        <span class="org-string">"canopy_cover"</span>              : canopy_cover_high,
        <span class="org-string">"canopy_base_height"</span>        : canopy_base_height,
        <span class="org-string">"foliar_moisture"</span>           : foliar_moisture,
    })
<span class="org-keyword">else</span>:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Surface Fire</span>
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">A surface fire occurs with these input parameters:"</span>)
    pprint({
        <span class="org-string">"surface_fireline_intensity"</span>: surface_fireline_intensity_high,
        <span class="org-string">"canopy_cover"</span>              : canopy_cover_high,
        <span class="org-string">"canopy_base_height"</span>        : canopy_base_height,
        <span class="org-string">"foliar_moisture"</span>           : foliar_moisture,
    })
</pre>
</div>

<pre class="example" id="check-crown-fire-initiation-results">
Low Canopy Cover and Low Surface Fireline Intensity
============================================================

A surface fire occurs with these input parameters:
{'canopy_base_height': 3.0,
 'canopy_cover': 0.3,
 'foliar_moisture': 1.0,
 'surface_fireline_intensity': 500.0}

Low Canopy Cover and High Surface Fireline Intensity
============================================================

A surface fire occurs with these input parameters:
{'canopy_base_height': 3.0,
 'canopy_cover': 0.3,
 'foliar_moisture': 1.0,
 'surface_fireline_intensity': 5000.0}

High Canopy Cover and Low Surface Fireline Intensity
============================================================

A surface fire occurs with these input parameters:
{'canopy_base_height': 3.0,
 'canopy_cover': 0.8,
 'foliar_moisture': 1.0,
 'surface_fireline_intensity': 500.0}

High Canopy Cover and High Surface Fireline Intensity
============================================================

A crown fire occurs with these input parameters:
{'canopy_base_height': 3.0,
 'canopy_cover': 0.8,
 'foliar_moisture': 1.0,
 'surface_fireline_intensity': 5000.0}
</pre>
</div>
</div>

<div id="outline-container-how-to-calculate-the-crown-fire-behavior-in-the-direction-of-maximum-spread" class="outline-4">
<h4 id="how-to-calculate-the-crown-fire-behavior-in-the-direction-of-maximum-spread"><span class="section-number-4">6.2.2.</span> How to Calculate the Crown Fire Behavior in the Direction of Maximum Spread</h4>
<div class="outline-text-4" id="text-how-to-calculate-the-crown-fire-behavior-in-the-direction-of-maximum-spread">
<div class="org-src-container">
<pre class="src src-python" id="compute-crown-fire-behavior-max"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.crown_fire <span class="org-keyword">as</span> cf

<span class="org-comment-delimiter"># </span><span class="org-comment">Set input parameters</span>
<span class="org-variable-name">canopy_height</span>                <span class="org-operator">=</span> 30.0    <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
<span class="org-variable-name">canopy_base_height</span>           <span class="org-operator">=</span> 3.0     <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
<span class="org-variable-name">canopy_bulk_density</span>          <span class="org-operator">=</span> 0.3     <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>
<span class="org-variable-name">heat_of_combustion</span>           <span class="org-operator">=</span> 18608.0 <span class="org-comment-delimiter"># </span><span class="org-comment">kJ/kg</span>
<span class="org-variable-name">estimated_fine_fuel_moisture</span> <span class="org-operator">=</span> 0.05    <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
<span class="org-variable-name">wind_speed_10m</span>               <span class="org-operator">=</span> 10.0    <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
<span class="org-variable-name">upwind_direction</span>             <span class="org-operator">=</span> 180.0   <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
<span class="org-variable-name">slope</span>                        <span class="org-operator">=</span> 0.5     <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
<span class="org-variable-name">aspect_parallel_to_wind</span>      <span class="org-operator">=</span> 180.0   <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
<span class="org-variable-name">aspect_perpendicular_to_wind</span> <span class="org-operator">=</span> 270.0   <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction of maximum spread with slope and wind aligned</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">====================================================================================================</span>

<span class="org-variable-name">crown_fire_max_aligned</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_max(canopy_height, canopy_base_height,
                                                         canopy_bulk_density, heat_of_combustion,
                                                         estimated_fine_fuel_moisture,
                                                         wind_speed_10m, upwind_direction,
                                                         slope, aspect_parallel_to_wind)

<span class="org-comment-delimiter"># </span><span class="org-comment">View results</span>
<span class="org-builtin">print</span>(<span class="org-string">"Crown Fire Behavior Max with Wind and Slope Aligned</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Inputs:"</span>)
pprint({
    <span class="org-string">"canopy_height"</span>               : canopy_height,
    <span class="org-string">"canopy_base_height"</span>          : canopy_base_height,
    <span class="org-string">"canopy_bulk_density"</span>         : canopy_bulk_density,
    <span class="org-string">"heat_of_combustion"</span>          : heat_of_combustion,
    <span class="org-string">"estimated_fine_fuel_moisture"</span>: estimated_fine_fuel_moisture,
    <span class="org-string">"wind_speed_10m"</span>              : wind_speed_10m,
    <span class="org-string">"upwind_direction"</span>            : upwind_direction,
    <span class="org-string">"slope"</span>                       : slope,
    <span class="org-string">"aspect"</span>                      : aspect_parallel_to_wind,
})

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Outputs:"</span>)
pprint(crown_fire_max_aligned)

<span class="org-comment-delimiter">#</span><span class="org-comment">====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction of maximum spread with slope and wind perpendicular</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">====================================================================================================</span>

<span class="org-variable-name">crown_fire_max_perpendicular</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_max(canopy_height, canopy_base_height,
                                                               canopy_bulk_density, heat_of_combustion,
                                                               estimated_fine_fuel_moisture,
                                                               wind_speed_10m, upwind_direction,
                                                               slope, aspect_perpendicular_to_wind)

<span class="org-comment-delimiter"># </span><span class="org-comment">View results</span>
<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Crown Fire Behavior Max with Wind and Slope Perpendicular</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Inputs:"</span>)
pprint({
    <span class="org-string">"canopy_height"</span>               : canopy_height,
    <span class="org-string">"canopy_base_height"</span>          : canopy_base_height,
    <span class="org-string">"canopy_bulk_density"</span>         : canopy_bulk_density,
    <span class="org-string">"heat_of_combustion"</span>          : heat_of_combustion,
    <span class="org-string">"estimated_fine_fuel_moisture"</span>: estimated_fine_fuel_moisture,
    <span class="org-string">"wind_speed_10m"</span>              : wind_speed_10m,
    <span class="org-string">"upwind_direction"</span>            : upwind_direction,
    <span class="org-string">"slope"</span>                       : slope,
    <span class="org-string">"aspect"</span>                      : aspect_perpendicular_to_wind,
})

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Outputs:"</span>)
pprint(crown_fire_max_perpendicular)
</pre>
</div>

<pre class="example" id="compute-crown-fire-behavior-max-results">
Crown Fire Behavior Max with Wind and Slope Aligned
============================================================

Inputs:
{'aspect': 180.0,
 'canopy_base_height': 3.0,
 'canopy_bulk_density': 0.3,
 'canopy_height': 30.0,
 'estimated_fine_fuel_moisture': 0.05,
 'heat_of_combustion': 18608.0,
 'slope': 0.5,
 'upwind_direction': 180.0,
 'wind_speed_10m': 10.0}

Outputs:
{'critical_spread_rate': 10.0,
 'eccentricity': 0.8218109607696533,
 'length_to_width_ratio': 1.7551240921020508,
 'max_fire_type': 3,
 'max_fireline_intensity': 82666.078125,
 'max_flame_length': 0.0,
 'max_spread_direction': (0.0, 0.8944271802902222, 0.4472135901451111),
 'max_spread_rate': 32.90742111206055}

Crown Fire Behavior Max with Wind and Slope Perpendicular
============================================================

Inputs:
{'aspect': 270.0,
 'canopy_base_height': 3.0,
 'canopy_bulk_density': 0.3,
 'canopy_height': 30.0,
 'estimated_fine_fuel_moisture': 0.05,
 'heat_of_combustion': 18608.0,
 'slope': 0.5,
 'upwind_direction': 180.0,
 'wind_speed_10m': 10.0}

Outputs:
{'critical_spread_rate': 10.0,
 'eccentricity': 0.802337110042572,
 'length_to_width_ratio': 1.6754034757614136,
 'max_fire_type': 3,
 'max_fireline_intensity': 74768.359375,
 'max_flame_length': 0.0,
 'max_spread_direction': (0.0, 1.0, -2.1855694143368964e-08),
 'max_spread_rate': 29.763521194458008}
</pre>
</div>
</div>

<div id="outline-container-how-to-calculate-the-crown-fire-behavior-in-any-direction" class="outline-4">
<h4 id="how-to-calculate-the-crown-fire-behavior-in-any-direction"><span class="section-number-4">6.2.3.</span> How to Calculate the Crown Fire Behavior in Any Direction</h4>
<div class="outline-text-4" id="text-how-to-calculate-the-crown-fire-behavior-in-any-direction">
<div class="org-src-container">
<pre class="src src-python" id="compute-crown-fire-behavior-in-direction"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.crown_fire <span class="org-keyword">as</span> cf
<span class="org-keyword">import</span> pyretechnics.vector_utils <span class="org-keyword">as</span> vu

<span class="org-comment-delimiter"># </span><span class="org-comment">Set input parameters</span>
<span class="org-variable-name">canopy_height</span>                <span class="org-operator">=</span> 30.0    <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
<span class="org-variable-name">canopy_base_height</span>           <span class="org-operator">=</span> 3.0     <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
<span class="org-variable-name">canopy_bulk_density</span>          <span class="org-operator">=</span> 0.3     <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>
<span class="org-variable-name">heat_of_combustion</span>           <span class="org-operator">=</span> 18608.0 <span class="org-comment-delimiter"># </span><span class="org-comment">kJ/kg</span>
<span class="org-variable-name">estimated_fine_fuel_moisture</span> <span class="org-operator">=</span> 0.05    <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
<span class="org-variable-name">wind_speed_10m</span>               <span class="org-operator">=</span> 10.0    <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
<span class="org-variable-name">upwind_direction</span>             <span class="org-operator">=</span> 180.0   <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
<span class="org-variable-name">slope</span>                        <span class="org-operator">=</span> 0.5     <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
<span class="org-variable-name">aspect</span>                       <span class="org-operator">=</span> 225.0   <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction of maximum spread</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

<span class="org-variable-name">crown_fire_max</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_max(canopy_height, canopy_base_height,
                                                 canopy_bulk_density, heat_of_combustion,
                                                 estimated_fine_fuel_moisture,
                                                 wind_speed_10m, upwind_direction,
                                                 slope, aspect)

<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior for the heading, flanking, and backing fires</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

<span class="org-variable-name">heading_fire_direction</span>  <span class="org-operator">=</span> crown_fire_max[<span class="org-string">"max_spread_direction"</span>]
<span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Change upstream functions to return max_spread_direction as type vec_xyz</span>
<span class="org-comment-delimiter">#        </span><span class="org-comment">and change downstream functions to accept spread_direction as type vec_xyz</span>
(<span class="org-variable-name">dx</span>, <span class="org-variable-name">dy</span>, <span class="org-variable-name">dz</span>)            <span class="org-operator">=</span> heading_fire_direction
<span class="org-variable-name">flanking_fire_direction</span> <span class="org-operator">=</span> np.asarray(vu.rotate_on_sloped_plane((dx, dy, dz), 90.0, slope, aspect))
<span class="org-variable-name">backing_fire_direction</span>  <span class="org-operator">=</span> np.asarray(vu.rotate_on_sloped_plane((dx, dy, dz), 180.0, slope, aspect))

<span class="org-variable-name">heading_fire_behavior</span>  <span class="org-operator">=</span> cf.calc_crown_fire_behavior_in_direction(crown_fire_max, heading_fire_direction)
<span class="org-variable-name">flanking_fire_behavior</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_in_direction(crown_fire_max, flanking_fire_direction)
<span class="org-variable-name">backing_fire_behavior</span>  <span class="org-operator">=</span> cf.calc_crown_fire_behavior_in_direction(crown_fire_max, backing_fire_direction)

<span class="org-comment-delimiter"># </span><span class="org-comment">View heading fire results</span>
<span class="org-builtin">print</span>(<span class="org-string">"Heading Fire Behavior</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)
pprint(heading_fire_behavior)

<span class="org-comment-delimiter"># </span><span class="org-comment">View flanking fire results</span>
<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Flanking Fire Behavior</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)
pprint(flanking_fire_behavior)

<span class="org-comment-delimiter"># </span><span class="org-comment">View backing fire results</span>
<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Backing Fire Behavior</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)
pprint(backing_fire_behavior)
</pre>
</div>

<pre class="example" id="compute-crown-fire-behavior-in-direction-results">
Heading Fire Behavior
============================================================
{'dphi_dt': 0.0,
 'fire_type': 3,
 'fireline_intensity': 78838.15625,
 'flame_length': 0.0,
 'spread_direction': (0.0, 0.9428090453147888, 0.3333333432674408),
 'spread_rate': 31.38361358642578}

Flanking Fire Behavior
============================================================
{'dphi_dt': 0.0,
 'fire_type': 2,
 'fireline_intensity': 14763.076171875,
 'flame_length': 0.0,
 'spread_direction': (0.9486833214759827,
                      -0.10540930181741714,
                      0.2981424033641815),
 'spread_rate': 3.265244722366333}

Backing Fire Behavior
============================================================
{'dphi_dt': 0.0,
 'fire_type': 2,
 'fireline_intensity': 8144.0576171875,
 'flame_length': 0.0,
 'spread_direction': (-8.293653053215166e-08,
                      -0.9428090453147888,
                      -0.3333333730697632),
 'spread_rate': 2.344287633895874}
</pre>
</div>
</div>

<div id="outline-container-how-to-calculate-the-combined-surface-and-crown-fire-behavior-in-any-direction" class="outline-4">
<h4 id="how-to-calculate-the-combined-surface-and-crown-fire-behavior-in-any-direction"><span class="section-number-4">6.2.4.</span> How to Calculate the Combined Surface and Crown Fire Behavior in Any Direction</h4>
<div class="outline-text-4" id="text-how-to-calculate-the-combined-surface-and-crown-fire-behavior-in-any-direction">
<div class="org-src-container">
<pre class="src src-python" id="compute-combined-fire-behavior-in-direction"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv
<span class="org-keyword">import</span> pyretechnics.crown_fire <span class="org-keyword">as</span> cf
<span class="org-keyword">import</span> pyretechnics.fuel_models <span class="org-keyword">as</span> fm
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf
<span class="org-keyword">import</span> pyretechnics.vector_utils <span class="org-keyword">as</span> vu

<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Set input parameters</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Landscape</span>
<span class="org-variable-name">fuel_model</span>          <span class="org-operator">=</span> fm.get_fuel_model(101) <span class="org-comment-delimiter"># </span><span class="org-comment">GR1</span>
<span class="org-variable-name">canopy_cover</span>        <span class="org-operator">=</span> 0.6                    <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
<span class="org-variable-name">canopy_height</span>       <span class="org-operator">=</span> 30.0                   <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
<span class="org-variable-name">canopy_base_height</span>  <span class="org-operator">=</span> 3.0                    <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
<span class="org-variable-name">canopy_bulk_density</span> <span class="org-operator">=</span> 0.3                    <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>
<span class="org-variable-name">slope</span>               <span class="org-operator">=</span> 0.8                    <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
<span class="org-variable-name">aspect</span>              <span class="org-operator">=</span> 225.0                  <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Weather</span>
<span class="org-variable-name">fuel_moisture</span>    <span class="org-operator">=</span> (
    0.05, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_1hr</span>
    0.10, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_10hr</span>
    0.15, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_100hr</span>
    0.00, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_herbaceous (will be set by moisturize for dynamic fuel models)</span>
    0.90, <span class="org-comment-delimiter"># </span><span class="org-comment">live_herbaceous</span>
    0.60, <span class="org-comment-delimiter"># </span><span class="org-comment">live_woody</span>
)                        <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
<span class="org-variable-name">foliar_moisture</span>  <span class="org-operator">=</span> 0.9   <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
<span class="org-variable-name">wind_speed_10m</span>   <span class="org-operator">=</span> 30.0  <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
<span class="org-variable-name">upwind_direction</span> <span class="org-operator">=</span> 180.0 <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Derived Parameters</span>
<span class="org-variable-name">fuel_bed_depth</span>               <span class="org-operator">=</span> fuel_model[<span class="org-string">"delta"</span>]                      <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
<span class="org-variable-name">heat_of_combustion</span>           <span class="org-operator">=</span> conv.Btu_lb_to_kJ_kg(fuel_model[<span class="org-string">"h"</span>][0]) <span class="org-comment-delimiter"># </span><span class="org-comment">kJ/kg</span>
<span class="org-variable-name">estimated_fine_fuel_moisture</span> <span class="org-operator">=</span> fuel_moisture[0]                         <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Fire Perimeter Normal Vector</span>
<span class="org-variable-name">fire_perimeter_normal_vector_2d</span> <span class="org-operator">=</span> (1.0, 0.0) <span class="org-comment-delimiter"># </span><span class="org-comment">(x,y) unit vector pointing East</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Project the 2D fire perimeter normal vector onto the slope-tangential plane</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

<span class="org-variable-name">upslope_direction</span>               <span class="org-operator">=</span> conv.opposite_direction(aspect)
<span class="org-variable-name">slope_vector_2d</span>                 <span class="org-operator">=</span> conv.azimuthal_to_cartesian(slope, upslope_direction)
<span class="org-variable-name">fire_perimeter_normal_vector_3d</span> <span class="org-operator">=</span> vu.as_unit_vector_3d(vu.to_slope_plane(fire_perimeter_normal_vector_2d,
                                                                         slope_vector_2d))

<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate midflame wind speed</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 10m wind speed to 20ft wind speed</span>
<span class="org-variable-name">wind_speed_20ft</span> <span class="org-operator">=</span> conv.wind_speed_10m_to_wind_speed_20ft(wind_speed_10m) <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Convert 20ft wind speed from km/hr to m/min</span>
<span class="org-variable-name">wind_speed_20ft_m_min</span> <span class="org-operator">=</span> conv.km_hr_to_m_min(wind_speed_20ft) <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 20ft wind speed to midflame wind speed in m/min</span>
<span class="org-variable-name">midflame_wind_speed</span> <span class="org-operator">=</span> sf.calc_midflame_wind_speed(wind_speed_20ft_m_min,       <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
                                                  fuel_bed_depth,              <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                  conv.m_to_ft(canopy_height), <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                  canopy_cover)                <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Apply fuel moisture to fuel model</span>
<span class="org-variable-name">moisturized_fuel_model</span> <span class="org-operator">=</span> fm.moisturize(fuel_model, fuel_moisture)

<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate no-wind-no-slope surface fire behavior</span>
<span class="org-variable-name">surface_fire_min</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model)

<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread with effective wind speed limit</span>
<span class="org-variable-name">surface_fire_max</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_max(surface_fire_min,
                                                     midflame_wind_speed,
                                                     upwind_direction,
                                                     slope,
                                                     aspect,
                                                     surface_lw_ratio_model<span class="org-operator">=</span><span class="org-string">"rothermel"</span>)

<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction normal to the fire perimeter</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

<span class="org-variable-name">surface_fire_normal</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_in_direction(surface_fire_max, fire_perimeter_normal_vector_3d)

<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Determine whether the surface fire transitions to a crown fire</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

<span class="org-keyword">if</span> cf.van_wagner_crown_fire_initiation(surface_fire_normal[<span class="org-string">"fireline_intensity"</span>],
                                       canopy_cover,
                                       canopy_base_height,
                                       foliar_moisture):

    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction of maximum spread</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

    <span class="org-variable-name">crown_fire_max</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_max(canopy_height, canopy_base_height,
                                                     canopy_bulk_density, heat_of_combustion,
                                                     estimated_fine_fuel_moisture,
                                                     wind_speed_10m, upwind_direction,
                                                     slope, aspect)

    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction normal to the fire perimeter</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

    <span class="org-variable-name">crown_fire_normal</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_in_direction(crown_fire_max, fire_perimeter_normal_vector_3d)

    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate combined fire behavior in the direction normal to the fire perimeter</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

    <span class="org-variable-name">combined_fire_normal</span> <span class="org-operator">=</span> cf.calc_combined_fire_behavior(surface_fire_normal, crown_fire_normal)

    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Display the combined fire behavior normal to the fire perimeter</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

    <span class="org-builtin">print</span>(<span class="org-string">"Fire Behavior from Combined Surface and Crown Fire</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)
    pprint(combined_fire_normal)

<span class="org-keyword">else</span>:

    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Display the surface fire behavior normal to the fire perimeter</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

    <span class="org-builtin">print</span>(<span class="org-string">"Fire Behavior from Surface Fire (No Crown Fire Occurred)</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)
    pprint(surface_fire_normal)
</pre>
</div>

<pre class="example">
Fire Behavior from Surface Fire (No Crown Fire Occurred)
============================================================
{'dphi_dt': 0.0,
 'fire_type': 1,
 'fireline_intensity': 11.63843822479248,
 'flame_length': 0.23957830667495728,
 'spread_direction': (0.8703882694244385, 0.0, 0.4923659861087799),
 'spread_rate': 0.821664035320282}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-spot-fire-equations-(pyretechnics.spot_fire)" class="outline-2">
<h2 id="spot-fire-equations-(pyretechnics.spot_fire)"><span class="section-number-2">7.</span> Spot Fire Equations (pyretechnics.spot_fire)</h2>
<div class="outline-text-2" id="text-spot-fire-equations-(pyretechnics.spot_fire)">
</div>
<div id="outline-container-for-developers-spot" class="outline-3">
<h3 id="for-developers-spot"><span class="section-number-3">7.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-for-developers-spot">
<p>
Whether a fire is spreading through surface or canopy fuels, it is
possible that small pieces of the burning fuels may be lofted by winds
ahead of the fire front. When these burning firebrands land in
sufficiently dry fuels, they may ignite new fires under the right
conditions. Fires created in this way are called "spot fires" and are
the subject of this chapter. The following sections provide functions
for calculating the probability and rate of firebrand generation from
burning fuels, the lofting distance and direction of these firebrands,
their likelihood of surviving their flight until landing, their
likelihood of igniting spot fires once deposited, and the time to grow
from a spark to a fire capable of spreading on its own.
</p>
</div>

<div id="outline-container-module-imports-spot-fire" class="outline-4">
<h4 id="module-imports-spot-fire"><span class="section-number-4">7.1.1.</span> Module Imports</h4>
<div class="outline-text-4" id="text-module-imports-spot-fire">
<div class="org-src-container">
<pre class="src src-python" id="spot-fire-imports"><span class="org-keyword">import</span> cython
<span class="org-keyword">import</span> cython <span class="org-keyword">as</span> cy
<span class="org-keyword">if</span> cython.compiled:
    <span class="org-keyword">from</span> cython.cimports.libc.math <span class="org-keyword">import</span> <span class="org-builtin">round</span>, sqrt, <span class="org-builtin">pow</span>, log, exp, sin, cos
    <span class="org-keyword">from</span> cython.cimports.pyretechnics.cy_types <span class="org-keyword">import</span> \
        pyidx, vec_xy, coord_yx, coord_tyx, SpreadBehavior, SpotConfig, JumpDistribution
    <span class="org-keyword">from</span> cython.cimports.pyretechnics.random <span class="org-keyword">import</span> BufferedRandGen
    <span class="org-keyword">from</span> cython.cimports.pyretechnics.space_time_cube <span class="org-keyword">import</span> ISpaceTimeCube
    <span class="org-keyword">import</span> cython.cimports.pyretechnics.conversion <span class="org-keyword">as</span> conv
    <span class="org-keyword">import</span> cython.cimports.pyretechnics.fuel_models <span class="org-keyword">as</span> fm
    <span class="org-keyword">import</span> cython.cimports.pyretechnics.surface_fire <span class="org-keyword">as</span> sf
<span class="org-keyword">else</span>:
    <span class="org-keyword">from</span> math <span class="org-keyword">import</span> sqrt, <span class="org-builtin">pow</span>, log, exp, sin, cos
    <span class="org-keyword">from</span> pyretechnics.py_types <span class="org-keyword">import</span> \
        pyidx, vec_xy, coord_yx, coord_tyx, SpreadBehavior, SpotConfig, JumpDistribution
    <span class="org-keyword">from</span> pyretechnics.random <span class="org-keyword">import</span> BufferedRandGen
    <span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> ISpaceTimeCube
    <span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv
    <span class="org-keyword">import</span> pyretechnics.fuel_models <span class="org-keyword">as</span> fm
    <span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf
</pre>
</div>
</div>
</div>

<div id="outline-container-expected-firebrand-production" class="outline-4">
<h4 id="expected-firebrand-production"><span class="section-number-4">7.1.2.</span> Expected Firebrand Production</h4>
<div class="outline-text-4" id="text-expected-firebrand-production">
<p>
When surface or canopy fuels burn, they emit a certain amount of heat
\(H_C\) (in \(\text{kJ}\)) before burning out as a function of their fuel
model and moisture values. In this section, we provide a function that
relates this total heat output per cell to the number of firebrands
that our spotting model will cast from that cell when it burns.
</p>

<p>
From section <a href="#surface-fire-intensity-functions">5.1.4</a>, we can see the
following relationship between a fire's spread rate \(R\) (in
\(\text{m}/\text{min}\)), fireline intensity \(I\) (in
\(\text{kW}/\text{m}\)), and heat per unit area \(H\) (in
\(\text{kJ}/\text{m}^2\)):
</p>

\begin{align}
  H = 60 \frac{I}{R}
\end{align}

<p>
We can calculate the total heat emitted by a cell on a gridded
landscape \(H_C\) by multiplying its \(H\) value by the slope-adjusted
area of the cell \(A_C\) (in \(\text{m}^2\)) as follows:
</p>

\begin{align}
  A_C &= \Delta x \, \Delta y \left[1 + \left(\frac{\partial z}{\partial x}\right)^2 + \left(\frac{\partial z}{\partial y}\right)^2 \right] \\
  \nonumber \\
  H_C &= H \, A_C \\
\end{align}

<p>
where \(\Delta x\) is the cell width (in \(\text{m}\)), \(\Delta y\) is the
cell height (in \(\text{m}\)), and \((\frac{\partial z}{\partial x}\),
\(\frac{\partial z}{\partial y})\) is the elevation gradient of the
cell.
</p>

<p>
A user-provided coefficient \(F_H\) ("firebrands_per_unit_heat" in
\(\text{firebrands}/\text{kJ}\)) is then combined with the total heat
per cell \(H_C\) (in \(\text{kJ}\)) to calculate the number of firebrands
to cast per cell \(F_C\):
</p>

\begin{align}
  F_C = F_H \, H_C
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="expected-firebrand-production"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">expected_firebrand_production</span>(fire_behavior           : SpreadBehavior,
                                  elevation_gradient      : vec_xy,
                                  cell_horizontal_area    : cy.<span class="org-builtin">float</span>,
                                  firebrands_per_unit_heat: cy.<span class="org-builtin">float</span><span class="org-operator">=</span>1e<span class="org-operator">-</span>6) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Return the expected number of firebrands produced by an entire cell when it burns given:</span>
<span class="org-doc">    - fire_behavior            :: a SpreadBehavior struct of surface or crown fire behavior values</span>
<span class="org-doc">      - dphi_dt                   :: phi/min</span>
<span class="org-doc">      - fire_type                 :: 0 (unburned), 1 (surface), 2 (passive_crown), or 3 (active_crown)</span>
<span class="org-doc">      - spread_rate               :: m/min</span>
<span class="org-doc">      - spread_direction          :: (x, y, z) unit vector on the slope-tangential plane</span>
<span class="org-doc">      - fireline_intensity        :: kW/m</span>
<span class="org-doc">      - flame_length              :: m</span>
<span class="org-doc">    - elevation_gradient       :: tuple with these fields</span>
<span class="org-doc">      - dz_dx                     :: rise/run</span>
<span class="org-doc">      - dz_dy                     :: rise/run</span>
<span class="org-doc">    - cell_horizontal_area     :: m^2</span>
<span class="org-doc">    - firebrands_per_unit_heat :: firebrands/kJ</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">if</span> fire_behavior.spread_rate <span class="org-operator">==</span> 0.0:
        <span class="org-keyword">return</span> 0.0
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the heat output per unit area</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

        <span class="org-variable-name">spread_rate</span>         : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> fire_behavior.spread_rate                                  <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
        <span class="org-variable-name">fireline_intensity</span>  : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> fire_behavior.fireline_intensity                           <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
        <span class="org-variable-name">heat_output_per_area</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> sf.calc_areal_heat_output(spread_rate, fireline_intensity) <span class="org-comment-delimiter"># </span><span class="org-comment">kJ/m^2</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the slope-adjusted cell area</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

        (<span class="org-variable-name">dz_dx</span>, <span class="org-variable-name">dz_dy</span>)         <span class="org-operator">=</span> elevation_gradient                            <span class="org-comment-delimiter"># </span><span class="org-comment">(rise/run, rise/run)</span>
        <span class="org-variable-name">slope_factor</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> sqrt(1.0 <span class="org-operator">+</span> (dz_dx <span class="org-operator">*</span> dz_dx) <span class="org-operator">+</span> (dz_dy <span class="org-operator">*</span> dz_dy)) <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
        <span class="org-variable-name">cell_area</span>   : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cell_horizontal_area <span class="org-operator">*</span> slope_factor           <span class="org-comment-delimiter"># </span><span class="org-comment">m^2</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the expected number of firebrands produced in this cell</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

        <span class="org-variable-name">cell_heat_output</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> heat_output_per_area <span class="org-operator">*</span> cell_area            <span class="org-comment-delimiter"># </span><span class="org-comment">kJ</span>
        <span class="org-variable-name">firebrand_count</span> : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> firebrands_per_unit_heat <span class="org-operator">*</span> cell_heat_output <span class="org-comment-delimiter"># </span><span class="org-comment">number of firebrands</span>
        <span class="org-keyword">return</span> firebrand_count
</pre>
</div>
</div>
</div>

<div id="outline-container-firebrand-dispersal-model" class="outline-4">
<h4 id="firebrand-dispersal-model"><span class="section-number-4">7.1.3.</span> Firebrand Dispersal Model</h4>
<div class="outline-text-4" id="text-firebrand-dispersal-model">
<p>
The Firebrand Dispersal model describes the distributions of
firebrands relative to the wind direction. The location where the
firebrand lands is represented by the random vector \(\vec{\Delta}\)
from the location of origin:
</p>

\begin{align}
  \vec{\Delta} := \Delta_X.\vec{w} + \Delta_Y.\vec{w}_\perp
\end{align}

<p>
in which \(\vec{w}, \vec{w}_\perp\) are unit vectors respectively
parallel and perpendicular to the wind direction, and \(\Delta_X,
\Delta_Y\) are the random variables for coordinates.
</p>

<p>
Following Perryman 2012, Sardoy 2008, and Himoto 2005, we model
\(\Delta_X\) and \(\Delta_Y\) to be independent, with \(\Delta_X\) following
a log-normal distribution, and \(\Delta_Y\) following a zero-mean normal
distribution, conditional on the fire behavior \(\Phi\) at the cell of
origin:<sup><a id="fnr.34" class="footref" href="#fn.34" role="doc-backlink">34</a></sup><sup>, </sup><sup><a id="fnr.35" class="footref" href="#fn.35" role="doc-backlink">35</a></sup><sup>, </sup><sup><a id="fnr.36" class="footref" href="#fn.36" role="doc-backlink">36</a></sup>
</p>

\begin{align}
  \ln (\Delta_X / \text{1m}) | \Phi \sim & \text{Normal}(\mu = \mu_X(\Phi), \sigma = \sigma_X(\Phi)) \\
  \nonumber \\
  \Delta_Y | \Phi \sim & \text{Normal}(\mu = 0, \sigma = \sigma_Y(\Phi)) \\
\end{align}

<p>
where \(\text{Normal}(\mu, \sigma)\) denotes a one-dimensional Gaussian
distribution with mean \(\mu\) and standard deviation \(\sigma\). Note
that \(\mu_X\) and \(\sigma_X\) are in log-space, therefore dimensionless.
For the sake of light notation, the conditioning on \(\Phi\) will be
implicit from now on, e.g. we will write \(\Delta_X\) instead of
\(\Delta_X | \Phi\).
</p>

<p>
Since the results are distance deltas relative to the wind direction,
we must convert this to deltas in our coordinate plane. We can convert
these deltas by using trigonometric functions.
</p>

<div class="org-src-container">
<pre class="src src-python" id="convert-deltas"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">delta_to_grid_dx</span>(cos_wdir: cy.<span class="org-builtin">float</span>, sin_wdir: cy.<span class="org-builtin">float</span>, delta_x: cy.<span class="org-builtin">float</span>, delta_y: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Computes the grid-aligned x coordinate of the delta vector, given the wind-aligned [&#916;X &#916;Y] coordinates.</span>
<span class="org-doc">    Returns a signed distance (same unit as &#916;X and &#916;Y).</span>

<span class="org-doc">    NOTE:</span>
<span class="org-doc">    - sin_wdir = wdir_x</span>
<span class="org-doc">    - cos_wdir = wdir_perp_x</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> delta_x <span class="org-operator">*</span> sin_wdir <span class="org-operator">+</span> delta_y <span class="org-operator">*</span> cos_wdir


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">delta_to_grid_dy</span>(cos_wdir: cy.<span class="org-builtin">float</span>, sin_wdir: cy.<span class="org-builtin">float</span>, delta_x: cy.<span class="org-builtin">float</span>, delta_y: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Computes the grid-aligned y coordinate of the delta vector, given the wind-aligned [&#916;X &#916;Y] coordinates.</span>
<span class="org-doc">    Returns a signed distance (same unit as &#916;X and &#916;Y).</span>

<span class="org-doc">    NOTE:</span>
<span class="org-doc">    - cos_wdir = wdir_y</span>
<span class="org-doc">    - sin_wdir = wdir_perp_y</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> delta_x <span class="org-operator">*</span> cos_wdir <span class="org-operator">+</span> delta_y <span class="org-operator">*</span> sin_wdir


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">distance_to_n_cells</span>(distance: cy.<span class="org-builtin">float</span>, cell_size: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">int</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Converts a delta expressed as a signed distance to one expressed as a number of grid cells.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> <span class="org-builtin">int</span>(<span class="org-builtin">round</span>(distance <span class="org-operator">/</span> cell_size))
</pre>
</div>
</div>
</div>

<div id="outline-container-resolution-of-log-normal-parameters" class="outline-4">
<h4 id="resolution-of-log-normal-parameters"><span class="section-number-4">7.1.4.</span> Resolution of Log-Normal Parameters</h4>
<div class="outline-text-4" id="text-resolution-of-log-normal-parameters">
<p>
We now need to define the functions \(\mu_X(\Phi)\) and
\(\sigma_X(\Phi)\). Here we depart from Sardoy 2008<sup><a id="fnr.37" class="footref" href="#fn.37" role="doc-backlink">37</a></sup> and
reproduce the model of ELMFIRE<sup><a id="fnr.38" class="footref" href="#fn.38" role="doc-backlink">38</a></sup>, which models
that dependency using the following relationships between the moments
of the distribution and the fireline intensity \(I\) and wind speed \(U\):
</p>

\begin{align}
  \mathbb{E}[\Delta_X] &= \Delta_1 \left(\frac{I}{\text{1 kW/m}}\right)^{e_I} \left(\frac{U}{\text{1 m/s}}\right)^{e_U} \\
  \nonumber \\
  \text{Var}[\Delta_X] &= r_\frac{V}{E} \mathbb{E}[\Delta_X] \\
\end{align}

<p>
in which \(\Delta_1, e_I, e_U, r_\frac{V}{E}\) are configured by the
keys shown in table <a href="#tab:spotting-elmfire-params">3</a>.
</p>

<table id="tab:spotting-elmfire-params">
<caption class="t-above"><span class="table-number">Table 3:</span> Spotting parameters for the downwind distribution per the ELMFIRE model</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Parameter</th>
<th scope="col" class="org-left">Unit</th>
<th scope="col" class="org-left">Description</th>
<th scope="col" class="org-left">Configuration Key</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">\(\Delta_1\)</td>
<td class="org-left">m</td>
<td class="org-left">Mean landing distance in unit conditions</td>
<td class="org-left">downwind_distance_mean</td>
</tr>

<tr>
<td class="org-left">\(e_I\)</td>
<td class="org-left">-</td>
<td class="org-left">Fireline intensity exponent</td>
<td class="org-left">fireline_intensity_exponent</td>
</tr>

<tr>
<td class="org-left">\(e_U\)</td>
<td class="org-left">-</td>
<td class="org-left">Wind speed exponent</td>
<td class="org-left">wind_speed_exponent</td>
</tr>

<tr>
<td class="org-left">\(r_\frac{V}{E}\)</td>
<td class="org-left">m</td>
<td class="org-left">Variance-over-Mean ratio</td>
<td class="org-left">downwind_variance_mean_ratio</td>
</tr>
</tbody>
</table>

<p>
<b>Note:</b> One potential way in which this model can misbehave is that
the variance is proportional to the expected value, and therefore the
coefficient of variation is driven to zero as the expected value goes
to infinity, making the distribution less and less dispersed around
its mean. This means that, in high-wind/high-intensity conditions, all
the firebrands will tend to land at approximately the same (large)
distance, following a narrow near-normal distribution.
</p>

<p>
From the above moments, \(\mu_X\) and \(\sigma_X\) can be obtained using
the properties of the log-normal distribution:
</p>

\begin{align}
  \mu_X &= \ln \frac{\mathbb{E}[\Delta_X]^2}{\sqrt{\text{Var}[\Delta_X] + \mathbb{E}[\Delta_X]^2}} \\
  \nonumber \\
  \sigma_X^2 &= \ln \left(1 + \frac{\text{Var}[\Delta_X]}{\mathbb{E}[\Delta_X]^2}\right) \\
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="resolve-spotting-lognormal-elmfire"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">resolve_exp_delta_x</span>(spot_config: SpotConfig, fireline_intensity: cy.<span class="org-builtin">float</span>, wind_speed_20ft: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Computes the expected value E[&#916;X] (in meters) of the downwind spotting distance &#916;X given:</span>
<span class="org-doc">    - spot_config        :: a SpotConfig struct of spotting parameters</span>
<span class="org-doc">      - random_seed                  :: seed for a numpy.random.Generator object</span>
<span class="org-doc">      - firebrands_per_unit_heat     :: firebrands/kJ</span>
<span class="org-doc">      - downwind_distance_mean       :: meters</span>
<span class="org-doc">      - fireline_intensity_exponent  :: downwind_distance_mean multiplier [I^fireline_intensity_exponent]</span>
<span class="org-doc">      - wind_speed_exponent          :: downwind_distance_mean multiplier [U^wind_speed_exponent]</span>
<span class="org-doc">      - downwind_variance_mean_ratio :: meters^2 / meter [downwind_variance_mean_ratio = Var(X) / E(X)]</span>
<span class="org-doc">      - crosswind_distance_stdev     :: meters</span>
<span class="org-doc">      - decay_distance               :: meters</span>
<span class="org-doc">    - fireline_intensity :: kW/m</span>
<span class="org-doc">    - wind_speed_20ft    :: m/s</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">downwind_distance_mean</span>     : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> spot_config.downwind_distance_mean
    <span class="org-variable-name">fireline_intensity_exponent</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> spot_config.fireline_intensity_exponent
    <span class="org-variable-name">wind_speed_exponent</span>        : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> spot_config.wind_speed_exponent
    <span class="org-keyword">return</span> (downwind_distance_mean
            <span class="org-operator">*</span> <span class="org-builtin">pow</span>(fireline_intensity, fireline_intensity_exponent)
            <span class="org-operator">*</span> <span class="org-builtin">pow</span>(wind_speed_20ft, wind_speed_exponent))


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">resolve_var_delta_x</span>(spot_config: SpotConfig, exp_delta_x: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Computes the variance Var[&#916;X] (in m^2) of the downwind spotting distance &#916;X given:</span>
<span class="org-doc">    - spot_config :: a SpotConfig struct of spotting parameters</span>
<span class="org-doc">      - random_seed                  :: seed for a numpy.random.Generator object</span>
<span class="org-doc">      - firebrands_per_unit_heat     :: firebrands/kJ</span>
<span class="org-doc">      - downwind_distance_mean       :: meters</span>
<span class="org-doc">      - fireline_intensity_exponent  :: downwind_distance_mean multiplier [I^fireline_intensity_exponent]</span>
<span class="org-doc">      - wind_speed_exponent          :: downwind_distance_mean multiplier [U^wind_speed_exponent]</span>
<span class="org-doc">      - downwind_variance_mean_ratio :: meters^2 / meter [downwind_variance_mean_ratio = Var(X) / E(X)]</span>
<span class="org-doc">      - crosswind_distance_stdev     :: meters</span>
<span class="org-doc">      - decay_distance               :: meters</span>
<span class="org-doc">    - exp_delta_x :: meters (E[&#916;X])</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">downwind_variance_mean_ratio</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> spot_config.downwind_variance_mean_ratio
    <span class="org-keyword">return</span> downwind_variance_mean_ratio <span class="org-operator">*</span> exp_delta_x


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">lognormal_mu_from_moments</span>(mean: cy.<span class="org-builtin">float</span>, variance: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">m2</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> mean <span class="org-operator">*</span> mean
    <span class="org-keyword">return</span> log(m2 <span class="org-operator">/</span> sqrt(m2 <span class="org-operator">+</span> variance))


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">lognormal_sigma_from_moments</span>(mean: cy.<span class="org-builtin">float</span>, variance: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> sqrt(log(1.0 <span class="org-operator">+</span> variance <span class="org-operator">/</span> (mean <span class="org-operator">*</span> mean)))


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">resolve_lognormal_params</span>(spot_config       : SpotConfig,
                             fireline_intensity: cy.<span class="org-builtin">float</span>,
                             wind_speed_20ft   : cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> <span class="org-builtin">tuple</span>[cy.<span class="org-builtin">float</span>, cy.<span class="org-builtin">float</span>]:
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">exp_delta_x</span>         : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> resolve_exp_delta_x(spot_config, fireline_intensity, wind_speed_20ft)
    <span class="org-variable-name">var_delta_x</span>         : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> resolve_var_delta_x(spot_config, exp_delta_x)
    <span class="org-variable-name">prob_lognormal_mu</span>   : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> lognormal_mu_from_moments(exp_delta_x, var_delta_x)
    <span class="org-variable-name">prob_lognormal_sigma</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> lognormal_sigma_from_moments(exp_delta_x, var_delta_x)
    <span class="org-keyword">return</span> (prob_lognormal_mu, prob_lognormal_sigma)
</pre>
</div>
</div>
</div>

<div id="outline-container-wind-perpendicular-dispersal" class="outline-4">
<h4 id="wind-perpendicular-dispersal"><span class="section-number-4">7.1.5.</span> Wind-Perpendicular Dispersal</h4>
<div class="outline-text-4" id="text-wind-perpendicular-dispersal">
<p>
For \(\sigma_Y\), we either let the user specify an explicit value with
key <b>crosswind_distance_stdev</b> (in meters), which makes it equivalent
to the model of Perryman 2012<sup><a id="fnr.39" class="footref" href="#fn.39" role="doc-backlink">39</a></sup>, or we default to
deriving them from equation (28) of Himoto 2005<sup><a id="fnr.40" class="footref" href="#fn.40" role="doc-backlink">40</a></sup>, which
is equivalent to:
</p>

\begin{align}
  \sigma_Y = 0.92 D = 0.92 \frac{0.47}{0.88^2}\frac{\text{Var}[\Delta_X]}{\mathbb{E}[\Delta_X]}
\end{align}

<p>
\(\text{Var}[\Delta_X]\) and \(\mathbb{E}[\Delta_X]\) can be calculated
from the properties of the log-normal distribution:
</p>

\begin{align}
  \mathbb{E}[\Delta_X] &= \text{1m} \times \exp \left(\mu_X + \frac{1}{2}\sigma_X^2 \right) \\
  \nonumber \\
  \text{Var}[\Delta_X] &= \mathbb{E}[\Delta_X]^2 \left(e^{\sigma_X^2} - 1\right) \\
\end{align}

<p>
Combining the above equations and applying some algebra yields a
formula for \(\sigma_Y\):
</p>

\begin{align}
  \sigma_Y = 0.92 D = \text{1m} \times 0.5584 \times e^{\mu_X} \times e^{\frac{1}{2}\sigma_X^2} \left(e^{\frac{1}{2}\sigma_X^2} - 1\right) \left(e^{\frac{1}{2}\sigma_X^2} + 1\right)
\end{align}

<p>
Typical values are shown in table <a href="#tab:himoto2005-example-values">4</a>.
</p>

<table id="tab:himoto2005-example-values">
<caption class="t-above"><span class="table-number">Table 4:</span> Typical values for \(\vec{\Delta}\) distribution characteristics derived from Himoto2005</caption>

<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(B^*\)</th>
<th scope="col" class="org-right">\(\text{CV}[\Delta_X]\)</th>
<th scope="col" class="org-right">\(\sigma_X\)</th>
<th scope="col" class="org-right">\(\sigma_Y/\mathbb{E}[\Delta_X]\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">20</td>
<td class="org-right">69%</td>
<td class="org-right">0.72</td>
<td class="org-right">0.27</td>
</tr>

<tr>
<td class="org-right">50</td>
<td class="org-right">51%</td>
<td class="org-right">0.64</td>
<td class="org-right">0.14</td>
</tr>

<tr>
<td class="org-right">100</td>
<td class="org-right">40%</td>
<td class="org-right">0.58</td>
<td class="org-right">0.09</td>
</tr>

<tr>
<td class="org-right">150</td>
<td class="org-right">35%</td>
<td class="org-right">0.55</td>
<td class="org-right">0.07</td>
</tr>

<tr>
<td class="org-right">200</td>
<td class="org-right">32%</td>
<td class="org-right">0.53</td>
<td class="org-right">0.06</td>
</tr>
</tbody>
</table>

<p>
See section <a href="#how-to-estimate-typical-ranges-for-the-$\vec{\delta}$-distribution-characteristics">7.2.3</a> for more information on how these values
were obtained.
</p>

<p>
<b>CAUTION:</b> (FIXME REVIEW) We have found the above formula to be
problematic when applied to the parameters values found in Sardoy
2008<sup><a id="fnr.41" class="footref" href="#fn.41" role="doc-backlink">41</a></sup> because it tends to yield nonsensical \(\sigma_Y >
\mathbb{E}[\Delta_X]\). In fact, it can be seen that \(\sigma_Y > s
\mathbb{E}[\Delta_X]\) if and only if \(\sigma_X > \sqrt{\ln \left(1 +
\frac{.88^2}{.92 \times .47} s \right)}\), in particular \(\sigma_X >
1.013\) for \(s = 1\), which is unfortunately the case with the range of
\(\sigma_X\) values in Sardoy 2008<sup><a id="fnr.42" class="footref" href="#fn.42" role="doc-backlink">42</a></sup>. This reflects a
divergence between Himoto 2005<sup><a id="fnr.43" class="footref" href="#fn.43" role="doc-backlink">43</a></sup> and Sardoy
2008<sup><a id="fnr.44" class="footref" href="#fn.44" role="doc-backlink">44</a></sup>, the latter allowing for more dispersed
\(\Delta_X\) distributions (higher coefficient of variation
\(\text{Var}[\Delta_X]^{\frac{1}{2}}/\mathbb{E}[\Delta_X] =
\sqrt{e^{\sigma_X^2} - 1}\)), whereas the former typically predicts a
low coefficient of variation, as is perceptible in figure 6 of Himoto
2005<sup><a id="fnr.45" class="footref" href="#fn.45" role="doc-backlink">45</a></sup>. Figure 10 of Sardoy 2008<sup><a id="fnr.46" class="footref" href="#fn.46" role="doc-backlink">46</a></sup>
suggests coefficients of variation ranging from 95% to 210%, whereas
Figure 6 of Himoto 2005<sup><a id="fnr.47" class="footref" href="#fn.47" role="doc-backlink">47</a></sup> suggests coefficients of
variation ranging from 30% to 70%. For this reason, we <b>strongly
recommend to supply \(\sigma_Y\) directly</b> through the configuration key
<b>crosswind_distance_stdev</b>.
</p>

<div class="org-src-container">
<pre class="src src-python" id="resolve-spotting-normal-elmfire"><span class="org-comment-delimiter"># </span><span class="org-comment">When will we have the default sigma_Y &gt; E[&#916;X]?</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">It can be seen that this nonsensical situation</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">happens iff sigma_X exceeds the following number:</span>
<span class="org-comment-delimiter">#</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">sqrt(log(1.0 + (0.88 ** 2.0) / (0.92 * 0.47))</span>
<span class="org-comment-delimiter">#</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">=&gt; 1.0131023746492023</span>
<span class="org-variable-name">sigma_y_scalar_m</span> <span class="org-operator">=</span> cy.declare(cy.double, 0.92 <span class="org-operator">*</span> 0.47 <span class="org-operator">/</span> (0.88 <span class="org-operator">*</span> 0.88))


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">himoto_resolve_default_sigma_y_from_lognormal_params</span>(mu_x: cy.<span class="org-builtin">float</span>, sigma_x: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-variable-name">es2h</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> exp((sigma_x <span class="org-operator">*</span> sigma_x) <span class="org-operator">/</span> 2.0)
    <span class="org-variable-name">avg_deltax</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> exp(mu_x) <span class="org-operator">*</span> es2h
    <span class="org-keyword">return</span> sigma_y_scalar_m <span class="org-operator">*</span> avg_deltax <span class="org-operator">*</span> (es2h <span class="org-operator">+</span> 1.0) <span class="org-operator">*</span> (es2h <span class="org-operator">-</span> 1.0) <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">himoto_resolve_default_sigma_y</span>(spot_config       : SpotConfig,
                                   fireline_intensity: cy.<span class="org-builtin">float</span>,
                                   wind_speed_20ft   : cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-variable-name">ln_params</span>: <span class="org-builtin">tuple</span>[cy.<span class="org-builtin">float</span>, cy.<span class="org-builtin">float</span>] <span class="org-operator">=</span> resolve_lognormal_params(spot_config, fireline_intensity, wind_speed_20ft)
    <span class="org-variable-name">mu_x</span>     : cy.<span class="org-builtin">float</span>                  <span class="org-operator">=</span> ln_params[0] <span class="org-comment-delimiter"># </span><span class="org-comment">dimensionless (log-space)</span>
    <span class="org-variable-name">sigma_x</span>  : cy.<span class="org-builtin">float</span>                  <span class="org-operator">=</span> ln_params[1] <span class="org-comment-delimiter"># </span><span class="org-comment">dimensionless (log-space)</span>
    <span class="org-keyword">return</span> himoto_resolve_default_sigma_y_from_lognormal_params(mu_x, sigma_x) <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">resolve_crosswind_distance_stdev</span>(spot_config       : SpotConfig,
                                     fireline_intensity: cy.<span class="org-builtin">float</span>,
                                     wind_speed_20ft   : cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-variable-name">crosswind_distance_stdev</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> spot_config.crosswind_distance_stdev
    <span class="org-keyword">if</span> crosswind_distance_stdev <span class="org-operator">!=</span> 0.0:
        <span class="org-keyword">return</span> crosswind_distance_stdev <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> himoto_resolve_default_sigma_y(spot_config, fireline_intensity, wind_speed_20ft) <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sampling-firebrand-casting-distances" class="outline-4">
<h4 id="sampling-firebrand-casting-distances"><span class="section-number-4">7.1.6.</span> Sampling Firebrand Casting Distances</h4>
<div class="outline-text-4" id="text-sampling-firebrand-casting-distances">
<p>
Having computed the \(\mu_X\), \(\sigma_X\) and \(\sigma_Y\) parameters, it
remains to draw values of \(\Delta_X\) and \(\Delta_Y\) by sampling from
log-normal and normal distributions. This can be done by sampling from
a standard normal distribution, then transforming by affine and
exponential functions:
</p>

<div class="org-src-container">
<pre class="src src-python" id="sardoy-firebrand-dispersal"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">sample_normal</span>(rng: BufferedRandGen, mu: cy.<span class="org-builtin">float</span>, sd: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns sample from normal/gaussian distribution given mu and sd.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> mu <span class="org-operator">+</span> sd <span class="org-operator">*</span> rng.next_normal()


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">sample_lognormal</span>(rng: BufferedRandGen, mu: cy.<span class="org-builtin">float</span>, sd: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns sample from log-normal distribution given mu and sd.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> exp(sample_normal(rng, mu, sd))


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">resolve_JumpDistribution</span>(spot_config       : SpotConfig,
                             fireline_intensity: cy.<span class="org-builtin">float</span>,
                             wind_speed_20ft   : cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> JumpDistribution:
    <span class="org-variable-name">ln_params</span>: <span class="org-builtin">tuple</span>[cy.<span class="org-builtin">float</span>, cy.<span class="org-builtin">float</span>] <span class="org-operator">=</span> resolve_lognormal_params(spot_config, fireline_intensity, wind_speed_20ft)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Initialize a new JumpDistribution</span>
    <span class="org-keyword">return</span> JumpDistribution(
        mu_x    <span class="org-operator">=</span> ln_params[0], <span class="org-comment-delimiter"># </span><span class="org-comment">dimensionless (log-space)</span>
        sigma_x <span class="org-operator">=</span> ln_params[1], <span class="org-comment-delimiter"># </span><span class="org-comment">dimensionless (log-space)</span>
        sigma_y <span class="org-operator">=</span> resolve_crosswind_distance_stdev(spot_config, fireline_intensity, wind_speed_20ft), <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
    )


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">sample_downwind_jump</span>(jd: JumpDistribution, random_generator: BufferedRandGen) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-keyword">return</span> sample_lognormal(random_generator, jd.mu_x, jd.sigma_x)


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">sample_crosswind_jump</span>(jd: JumpDistribution, random_generator: BufferedRandGen) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-keyword">return</span> sample_normal(random_generator, 0.0, jd.sigma_y)
</pre>
</div>
</div>
</div>

<div id="outline-container-spot-ignition-model" class="outline-4">
<h4 id="spot-ignition-model"><span class="section-number-4">7.1.7.</span> Spot Ignition Model</h4>
<div class="outline-text-4" id="text-spot-ignition-model">
<p>
The spot ignition model (Schroeder 1969)<sup><a id="fnr.48" class="footref" href="#fn.48" role="doc-backlink">48</a></sup> describes
the probability of a spot ignition based on the temperature and fine
fuel moisture at the firebrand landing location as follows:
</p>

\begin{align}
  Q_{\text{ig}} &= 144.512 - 0.266 \, T_o - 0.00058 \, (T_o)^2 - T_o \, M + 18.54 \, (1 - \exp(-15.1 \, M)) + 640 \, M \\
  \nonumber \\
  X &= \frac{400 - Q_{\text{ig}}}{10} \\
  \nonumber \\
  P(I) &= \frac{0.000048 \, X^{4.3}}{50} \\
\end{align}

<p>
where \(P(I)\) is the probability of a spot ignition, \(Q_{\text{ig}}\) is
the heat of preignition in degrees Celsius, \(T_o\) is the temperature
in degrees Celsius, and \(M\) is the fine fuel moisture in \(\text{kg moisture}/\text{kg ovendry weight}\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="schroeder-ignition-probability"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">heat_of_preignition</span>(temperature: cy.<span class="org-builtin">float</span>, fine_fuel_moisture: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns heat of preignition given:</span>
<span class="org-doc">    - temperature        :: degrees Celsius</span>
<span class="org-doc">    - fine_fuel_moisture :: 0-1</span>

<span class="org-doc">    Q_ig = 144.512 - 0.266 * T_o - 0.00058 * (T_o)^2 - T_o * M + 18.54 * (1 - exp(-15.1 * M)) + 640 * M (eq. 10)</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">T_o</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> temperature
    <span class="org-variable-name">M</span>  : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> fine_fuel_moisture
    <span class="org-comment-delimiter"># </span><span class="org-comment">Heat required to reach ignition temperature</span>
    <span class="org-variable-name">Q_a</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 144.512 <span class="org-operator">-</span> 0.266 <span class="org-operator">*</span> T_o <span class="org-operator">-</span> 0.00058 <span class="org-operator">*</span> (T_o <span class="org-operator">*</span> T_o)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Heat required to raise moisture to the boiling point</span>
    <span class="org-variable-name">Q_b</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> <span class="org-operator">-</span>T_o <span class="org-operator">*</span> M
    <span class="org-comment-delimiter"># </span><span class="org-comment">Heat of desorption</span>
    <span class="org-variable-name">Q_c</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 18.54 <span class="org-operator">*</span> (1.0 <span class="org-operator">-</span> exp(<span class="org-operator">-</span>15.1 <span class="org-operator">*</span> M))
    <span class="org-comment-delimiter"># </span><span class="org-comment">Heat required to vaporize moisture</span>
    <span class="org-variable-name">Q_d</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 640.0 <span class="org-operator">*</span> M
    <span class="org-keyword">return</span> Q_a <span class="org-operator">+</span> Q_b <span class="org-operator">+</span> Q_c <span class="org-operator">+</span> Q_d


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">schroeder_ignition_probability</span>(temperature: cy.<span class="org-builtin">float</span>, fine_fuel_moisture: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the probability of spot fire ignition (Schroeder 1969) given:</span>
<span class="org-doc">    - temperature        :: degrees Celsius</span>
<span class="org-doc">    - fine_fuel_moisture :: 0-1</span>

<span class="org-doc">    X    = (400 - Q_ig) / 10</span>
<span class="org-doc">    P(I) = (0.000048 * X^4.3) / 50 (pg. 15)</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">Q_ig</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> heat_of_preignition(temperature, fine_fuel_moisture)
    <span class="org-variable-name">X</span>   : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> <span class="org-builtin">max</span>(0.0, 400.0 <span class="org-operator">-</span> Q_ig) <span class="org-operator">*</span> 0.1
    <span class="org-variable-name">P_I</span> : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 0.000048 <span class="org-operator">*</span> <span class="org-builtin">pow</span>(X, 4.3) <span class="org-operator">*</span> 0.02
    <span class="org-keyword">return</span> <span class="org-builtin">min</span>(P_I, 1.0)
</pre>
</div>

<p>
Perryman 2012 uses this ignition probability but multiplies it by a
flight survival probability based on the distance a firebrand lands
from its casting source (using Albini 1979) and the number of
firebrands that land in a cell (using Stauffer
2008).<sup><a id="fnr.49" class="footref" href="#fn.49" role="doc-backlink">49</a></sup><sup>, </sup><sup><a id="fnr.50" class="footref" href="#fn.50" role="doc-backlink">50</a></sup><sup>, </sup><sup><a id="fnr.51" class="footref" href="#fn.51" role="doc-backlink">51</a></sup>
</p>

\begin{align}
  P(I)_l &= P(I)\exp(-\lambda_s l) \\
  \nonumber \\
  P(I)_l^{FB} &= 1 - (1 - P(I)_l)^{n_b} \\
\end{align}

<p>
where \(\lambda_s\) is a positive number representing the decay
constant, \(l\) is the firebrand's landing distance away from the source
cell. \(P(I)_l\) is the probability of spot ignition taking into
consideration \(l\). \(P(I)_l^{FB}\) is the probability of spot fire
ignition taking into consideration \(n_b\), the number of firebrands
landing in a cell.
</p>

<p>
We observe that the second formula is equivalent to a model where the
firebrands are i.i.d causes of ignition (this is consistent with the
goal of making the model insensitive to grid resolution). Therefore,
Pyretechnics will simply draw an independent Bernoulli trial for each
firebrand rather than apply the above formula.
</p>

<p>
The first formula simply says that the per-firebrand probability
decays exponentially with distance (i.e. adding \(1/\lambda_s\) to the
distance divides the probability by \(e\), or equivalently \(l \mapsto
P(I)_l\) has derivative \(\lambda_s P(I)_l\)). Yet another way to say
this is that, if \(\lambda_s = \text{0.005 m}^{-1}\), then each added
meter decreases \(P(I)_l\) by 0.5%.
</p>

<div class="org-src-container">
<pre class="src src-python" id="firebrand-flight-survival-probability"><span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">firebrand_flight_survival_probability</span>(spotting_distance: cy.<span class="org-builtin">float</span>, decay_distance: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the probability that a firebrand will survive its flight (Perryman 2012) given:</span>
<span class="org-doc">    - spotting_distance :: meters (d)</span>
<span class="org-doc">    - decay_distance    :: meters (1/lambda)</span>

<span class="org-doc">    P(Survival) = exp(-d * lambda)</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> exp(<span class="org-operator">-</span>spotting_distance <span class="org-operator">/</span> decay_distance)
</pre>
</div>

<p>
A firebrand will cause an unburned cell to transition to a burned
state if the cell receives at least one firebrand and the cell's
probability of ignition as calculated by the above equations is
greater than a randomly generated uniform number.
</p>
</div>
</div>

<div id="outline-container-time-to-spot-ignition" class="outline-4">
<h4 id="time-to-spot-ignition"><span class="section-number-4">7.1.8.</span> Time to Spot Ignition</h4>
<div class="outline-text-4" id="text-time-to-spot-ignition">
<p>
Once a cell has been determined to ignite, then the time until
ignition is calculated. The time until ignition is a sum of three time
intervals: the amount of time required for the firebrand to reach its
maximum vertical height \(t_v\), the amount of time required for the
firebrand to descend from the maximum vertical height to the forest
floor \(t_g\), and the amount of time required for a spot fire to ignite
and build up to the steady-state \(t_I\). Perryman
2012<sup><a id="fnr.52" class="footref" href="#fn.52" role="doc-backlink">52</a></sup> assumes \(t_v\) and \(t_g\) to be equal and uses
the formula from Albini 1979<sup><a id="fnr.53" class="footref" href="#fn.53" role="doc-backlink">53</a></sup> to calculate it.
\(t_I\) is also assumed to be 20 min as used in McAlpine
1991<sup><a id="fnr.54" class="footref" href="#fn.54" role="doc-backlink">54</a></sup>.
</p>

<p>
By Albini 1979<sup><a id="fnr.55" class="footref" href="#fn.55" role="doc-backlink">55</a></sup>, the time \(t_v\) for a firebrand to
reach height \(z\) when the flame length is \(z_F\) is given by:
</p>

\begin{align}
  t_v &= \frac{2 z_F}{w_F} \left(1.2 + \frac{a}{3} \left[ \left(\frac{b + (z/z_F)}{a}\right)^\frac{3}{2} - 1 \right] \right) & \\
  \nonumber \\
  w_F &= 2.3 \text{ m/s} \sqrt{\frac{z_F}{1 \text{ m}}} & \\
  \nonumber \\
  a   &= 5.963 & \\
  \nonumber \\
  b   &=  a - 1.4 & \\
\end{align}

<p>
In the notation of Albini 1979<sup><a id="fnr.56" class="footref" href="#fn.56" role="doc-backlink">56</a></sup>, we would have \(t_v
= \frac{2 z_F}{w_F}(t_T - t_o)\).
</p>

<p>
Albini 1979<sup><a id="fnr.57" class="footref" href="#fn.57" role="doc-backlink">57</a></sup> also provides a formula - (D44) - for
the maximum height \(z_\text{max}\) that a firebrand can reach while
still glowing when it hits the ground, as a function of the firebrand
diameter \(D\) in a cylinder model:
</p>

\begin{align}
  z_\text{max} = D \times 0.39 \times 10^5
\end{align}

<p>
To estimate firebrand travel time, Pyretechnics makes the assumption
that each firebrand will reach \(z_\text{max}\), where \(z_\text{max}\) is
computed for \(D = 3\text{mm}\), yielding \(z_\text{max} = 117 \text{m}\).
</p>

<p>
To make the above formulas more tangible, observe that when the flame
length is small enough that \(z_F \ll z_\text{max}\), the above formulas
simplify into the following approximation:
</p>

\begin{align}
  t_v \underset{z_F \ll z_\text{max}}{\approx} \frac{2}{3 \sqrt{a}} \frac{\sqrt{z_\text{max} \times 1Â \text{m}}}{2.3 \text{m/s}}\frac{z_\text{max}}{z_F}
\end{align}

<p>
Plugging in Pyretechnics' choice of \(z_\text{max} = 117 \text{m}\)
yields:
</p>

\begin{align}
  t_v \underset{z_F \ll z_\text{max}}{\approx} 1.28 \text{s} \times \frac{117 \text{m}}{z_F}
\end{align}

<p>
In other words, in the limit of small-enough flame lengths, the
firebrand is assumed to elevate at a constant vertical speed
\((z_F/1.28 \text{s})\) which is proportional to the flame length, until
it reaches \(z_\text{max} = 117 \text{m}\). For example, if the flame
length is 1.17m (100x smaller than \(z_\text{max}\)), \(t_v\) is about
128s.
</p>

<div class="org-src-container">
<pre class="src src-python" id="firebrands-time-of-ignition"><span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: unused</span>
<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">albini_firebrand_maximum_height</span>(firebrand_diameter: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-keyword">return</span> 0.39e5 <span class="org-operator">*</span> firebrand_diameter


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">albini_t_max</span>(flame_length: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the time of spot ignition using Albini1979spot in minutes given:</span>
<span class="org-doc">    - flame_length :: meters [z_F]</span>

<span class="org-doc">    a           = 5.963                                                             (D33)</span>
<span class="org-doc">    b           = a - 1.4                                                           (D34)</span>
<span class="org-doc">    D           = 0.003</span>
<span class="org-doc">    z           = 0.39 * D * 10^5</span>
<span class="org-doc">    w_F         = 2.3 * z_F^0.5                                                     (A58)</span>
<span class="org-doc">    t_c         = 1</span>
<span class="org-doc">    t_o         = t_c / (2 * z_F / w_F)</span>
<span class="org-doc">    travel_time = t_1 + t_2 + t_3 = 1.2 + (a / 3) * (((b + (z/z_F)) / a)^3/2 - 1)   (D43)</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">a</span>        : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 5.963  <span class="org-comment-delimiter"># </span><span class="org-comment">dimensionless constant from (D33)</span>
    <span class="org-variable-name">b</span>        : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 4.563  <span class="org-comment-delimiter"># </span><span class="org-comment">dimensionless constant from (D34)</span>
    <span class="org-variable-name">z</span>        : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 117.0  <span class="org-comment-delimiter"># </span><span class="org-comment">maximum altitude of firebrands in meters [derived for (D44) in (Albini1979spot)]</span>
    <span class="org-variable-name">z_F</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> flame_length                      <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-variable-name">w_F</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 2.3 <span class="org-operator">*</span> sqrt(flame_length)          <span class="org-comment-delimiter"># </span><span class="org-comment">m/s</span>
    <span class="org-variable-name">charact_t</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> conv.sec_to_min(2.0 <span class="org-operator">*</span> z_F <span class="org-operator">/</span> w_F)  <span class="org-comment-delimiter"># </span><span class="org-comment">min</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">The following dimensionless factor is equal to t_T - t_o, with t_T defined by (D43) in Albini1979spot.</span>
    <span class="org-variable-name">u</span>          : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (b <span class="org-operator">+</span> z <span class="org-operator">/</span> z_F) <span class="org-operator">/</span> a
    <span class="org-variable-name">u3_2</span>       : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> u <span class="org-operator">*</span> sqrt(u) <span class="org-comment-delimiter"># </span><span class="org-comment">Faster than ** 1.5</span>
    <span class="org-variable-name">travel_time</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 1.2 <span class="org-operator">+</span> (a <span class="org-operator">/</span> 3.0) <span class="org-operator">*</span> (u3_2 <span class="org-operator">-</span> 1.0)
    <span class="org-keyword">return</span> charact_t <span class="org-operator">*</span> travel_time


<span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Consider removing t_max from this calculation for performance.</span>
<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">spot_ignition_time</span>(time_of_arrival: cy.<span class="org-builtin">float</span>, flame_length: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the time of spot ignition using Albini 1979 and Perryman 2012 in minutes given:</span>
<span class="org-doc">    - time_of_arrival :: minutes</span>
<span class="org-doc">    - flame_length    :: meters</span>

<span class="org-doc">    t_spot = time_of_arrival + (2 * t_max) + t_ss</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">t_max</span>         : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> albini_t_max(flame_length)
    <span class="org-variable-name">t_steady_state</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 20.0 <span class="org-comment-delimiter"># </span><span class="org-comment">period of building up to steady state from ignition (min)</span>
    <span class="org-keyword">return</span> time_of_arrival <span class="org-operator">+</span> 2.0 <span class="org-operator">*</span> t_max <span class="org-operator">+</span> t_steady_state
</pre>
</div>
</div>
</div>

<div id="outline-container-spreading-firebrands" class="outline-4">
<h4 id="spreading-firebrands"><span class="section-number-4">7.1.9.</span> Spreading Firebrands</h4>
<div class="outline-text-4" id="text-spreading-firebrands">
<p>
Once the locations, ignition probabilities, and times of ignition have
been calculated for each of the firebrands, a tuple of
<b>(spot_ignition_time, ignition_locations)</b> are returned, to be
processed in the fire spread algorithm (see section <a href="#fire-spread-algorithm:-eulerian-level-set-method-(pyretechnics.eulerian_level_set)">9</a>), where <b>spot_ignition_time</b> is
the ignition time of the spot fire in minutes, and
<b>ignition_locations</b> is a list of <b>(y,x)</b> grid coordinates in which
spot fires will be ignited.
</p>


<div class="org-src-container">
<pre class="src src-python" id="spread-firebrands"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">is_in_bounds</span>(y: pyidx, x: pyidx, rows: pyidx, cols: pyidx) <span class="org-operator">-&gt;</span> cy.bint:
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns True if the grid coordinate (y,x) lies within the bounds [0,rows) by [0,cols).</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> (y <span class="org-operator">&gt;=</span> 0) <span class="org-keyword">and</span> (x <span class="org-operator">&gt;=</span> 0) <span class="org-keyword">and</span> (y <span class="org-operator">&lt;</span> rows) <span class="org-keyword">and</span> (x <span class="org-operator">&lt;</span> cols)


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">is_burnable_cell</span>(fuel_model_cube: ISpaceTimeCube, t: pyidx, y: pyidx, x: pyidx) <span class="org-operator">-&gt;</span> cy.bint:
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns True if the space-time coordinate (t,y,x) contains a burnable fuel model.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">fuel_model_number</span>: cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> cy.cast(cy.<span class="org-builtin">int</span>, fuel_model_cube.get(t,y,x))
    <span class="org-keyword">return</span> fm.is_burnable_fuel_model_number(fuel_model_number)


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">cast_firebrand</span>(rng                        : BufferedRandGen,
                   fuel_model_cube            : ISpaceTimeCube,
                   temperature_cube           : ISpaceTimeCube,
                   fuel_moisture_dead_1hr_cube: ISpaceTimeCube,
                   fire_type_matrix           : cy.uchar[:,::1],
                   rows                       : pyidx,
                   cols                       : pyidx,
                   cell_height                : cy.<span class="org-builtin">float</span>,
                   cell_width                 : cy.<span class="org-builtin">float</span>,
                   source_t                   : pyidx,
                   source_y                   : pyidx,
                   source_x                   : pyidx,
                   decay_distance             : cy.<span class="org-builtin">float</span>,
                   cos_wdir                   : cy.<span class="org-builtin">float</span>,
                   sin_wdir                   : cy.<span class="org-builtin">float</span>,
                   jd                         : JumpDistribution) <span class="org-operator">-&gt;</span> coord_yx:
    <span class="org-doc">"""</span>
<span class="org-doc">    Draws a random [&#916;X, &#916;Y] pair of signed distances (in meters) from</span>
<span class="org-doc">    the supplied cell, representing the coordinates of the spotting jump in the directions</span>
<span class="org-doc">    parallel and perpendicular to the wind. &#916;X will typically be positive (downwind),</span>
<span class="org-doc">    and positive &#916;Y means to the right of the downwind direction.</span>

<span class="org-doc">    NOTE: If the random draw yields no spot ignition, the source cell coordinates will be returned.</span>
<span class="org-doc">          Calling code should check for that.</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Determine where the firebrand will land</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>

    <span class="org-variable-name">delta_y</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> sample_crosswind_jump(jd, rng)                         <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
    <span class="org-variable-name">delta_x</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> sample_downwind_jump(jd, rng)                          <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
    <span class="org-variable-name">grid_dy</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> delta_to_grid_dy(cos_wdir, sin_wdir, delta_x, delta_y) <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
    <span class="org-variable-name">grid_dx</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> delta_to_grid_dx(cos_wdir, sin_wdir, delta_x, delta_y) <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: It would cause a bug to type the following as pyidx.</span>
    <span class="org-variable-name">target_y</span>: cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> source_y <span class="org-operator">+</span> distance_to_n_cells(grid_dy, cell_height)
    <span class="org-variable-name">target_x</span>: cy.<span class="org-builtin">int</span> <span class="org-operator">=</span> source_x <span class="org-operator">+</span> distance_to_n_cells(grid_dx, cell_width)

    <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Determine whether the firebrand will start a fire or fizzle out</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>

    <span class="org-keyword">if</span> is_in_bounds(target_y, target_x, rows, cols) <span class="org-keyword">and</span> fire_type_matrix[target_y,target_x] <span class="org-operator">==</span> 0:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Firebrand landed on the grid in an unburned cell</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the probability that the firebrand survived its flight and landed while still burning</span>
        <span class="org-variable-name">spotting_distance</span>          : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> sqrt(grid_dx <span class="org-operator">*</span> grid_dx <span class="org-operator">+</span> grid_dy <span class="org-operator">*</span> grid_dy) <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
        <span class="org-variable-name">flight_survival_probability</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> firebrand_flight_survival_probability(spotting_distance,
                                                                                      decay_distance)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Roll the dice</span>
        <span class="org-variable-name">uniform_sample</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> rng.next_uniform()

        <span class="org-keyword">if</span> (uniform_sample <span class="org-operator">&lt;=</span> flight_survival_probability
            <span class="org-keyword">and</span> is_burnable_cell(fuel_model_cube, source_t, target_y, target_x)):
            <span class="org-comment-delimiter"># </span><span class="org-comment">Firebrand landed in a cell with a burnable fuel model, so calculate its ignition probability</span>
            <span class="org-variable-name">temperature</span>         : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> temperature_cube.get(source_t, target_y, target_x) <span class="org-comment-delimiter"># </span><span class="org-comment">degrees Celsius</span>
            <span class="org-variable-name">fine_fuel_moisture</span>  : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> fuel_moisture_dead_1hr_cube.get(source_t, target_y, target_x) <span class="org-comment-delimiter"># </span><span class="org-comment">%</span>
            <span class="org-variable-name">ignition_probability</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> schroeder_ignition_probability(temperature, fine_fuel_moisture)

            <span class="org-keyword">if</span> uniform_sample <span class="org-operator">&lt;=</span> flight_survival_probability <span class="org-operator">*</span> ignition_probability:
                <span class="org-comment-delimiter"># </span><span class="org-comment">Firebrand ignited the target cell, so return its coordinates for later processing</span>
                <span class="org-keyword">return</span> (target_y, target_x)
    <span class="org-comment-delimiter"># </span><span class="org-comment">This code is only reached if the spotting ignition fails.</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">For efficiency, the source cell is used as a sentinel value for a failed spot ignition.</span>
    <span class="org-keyword">return</span> (source_y, source_x)


<span class="org-type">@cy.cfunc</span>
<span class="org-keyword">def</span> <span class="org-function-name">spread_firebrands</span>(fuel_model_cube            : ISpaceTimeCube,
                      temperature_cube           : ISpaceTimeCube,
                      fuel_moisture_dead_1hr_cube: ISpaceTimeCube,
                      fire_type_matrix           : cy.uchar[:,::1],
                      sim_area_bounds            : coord_yx,
                      cell_height                : cy.<span class="org-builtin">float</span>,
                      cell_width                 : cy.<span class="org-builtin">float</span>,
                      space_time_coordinate      : coord_tyx,
                      wind_speed_10m             : cy.<span class="org-builtin">float</span>, <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr (for shame!)</span>
                      upwind_direction           : cy.<span class="org-builtin">float</span>, <span class="org-comment-delimiter"># </span><span class="org-comment">degrees</span>
                      fireline_intensity         : cy.<span class="org-builtin">float</span>,
                      flame_length               : cy.<span class="org-builtin">float</span>,
                      time_of_arrival            : cy.<span class="org-builtin">float</span>,
                      random_generator           : BufferedRandGen,
                      num_firebrands             : cy.longlong,
                      spot_config                : SpotConfig) <span class="org-operator">-&gt;</span> <span class="org-builtin">tuple</span>: <span class="org-comment-delimiter"># </span><span class="org-comment">tuple[float, set]|None</span>
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - fuel_model_cube             :: (Lazy)SpaceTimeCube (integer index in fm.fuel_model_table)</span>
<span class="org-doc">    - temperature_cube            :: (Lazy)SpaceTimeCube (degrees Celsius)</span>
<span class="org-doc">    - fuel_moisture_dead_1hr_cube :: (Lazy)SpaceTimeCube (kg moisture/kg ovendry weight)</span>
<span class="org-doc">    - fire_type_matrix            :: 2D byte array (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)</span>
<span class="org-doc">    - sim_area_bounds             :: tuple with these fields</span>
<span class="org-doc">      - rows                         :: number of rows on the simulation grid</span>
<span class="org-doc">      - cols                         :: number of columns on the simulation grid</span>
<span class="org-doc">    - cell_height                 :: meters</span>
<span class="org-doc">    - cell_width                  :: meters</span>
<span class="org-doc">    - space_time_coordinate       :: (t,y,x) coordinate in which the source cell burns</span>
<span class="org-doc">    - upwind_direction            :: degrees clockwise from North</span>
<span class="org-doc">    - wind_speed_10m              :: km/hr</span>
<span class="org-doc">    - fireline_intensity          :: kW/m</span>
<span class="org-doc">    - flame_length                :: m</span>
<span class="org-doc">    - time_of_arrival             :: min</span>
<span class="org-doc">    - random_generator            :: BufferedRandGen</span>
<span class="org-doc">    - num_firebrands              :: number of firebrands to emit from the space_time_coordinate</span>
<span class="org-doc">    - spot_config                 :: SpotConfig struct of spotting parameters</span>
<span class="org-doc">      - downwind_distance_mean       :: meters</span>
<span class="org-doc">      - fireline_intensity_exponent  :: downwind_distance_mean multiplier [I^fireline_intensity_exponent]</span>
<span class="org-doc">      - wind_speed_exponent          :: downwind_distance_mean multiplier [U^wind_speed_exponent]</span>
<span class="org-doc">      - downwind_variance_mean_ratio :: meters^2 / meter [downwind_variance_mean_ratio = Var(X) / E(X)]</span>
<span class="org-doc">      - crosswind_distance_stdev     :: meters</span>
<span class="org-doc">      - decay_distance               :: meters</span>

<span class="org-doc">    casts num_firebrands from the space_time_coordinate into grid cells in the space-time cube, filters out</span>
<span class="org-doc">    all of the firebrands that fizzle out in either burnable or non-burnable fuels, and returns any that ignite</span>
<span class="org-doc">    new spot fires in a tuple with these fields:</span>

<span class="org-doc">    - ignition_time :: minutes</span>
<span class="org-doc">    - ignited_cells :: set of (y,x) grid coordinates</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that the source cell is casting firebrands</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>

    <span class="org-keyword">if</span> num_firebrands <span class="org-operator">&gt;</span> 0:

        <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that there is wind to transport the firebrands</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>

        <span class="org-keyword">if</span> wind_speed_10m <span class="org-operator">&gt;</span> 0.0:

            <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack all firebrand-related features of the source cell</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>

            <span class="org-comment-delimiter"># </span><span class="org-comment">TODO: OPTIM Get rid of trigonometry here if possible by having callers pass vectors.</span>
            (<span class="org-variable-name">rows</span>, <span class="org-variable-name">cols</span>)                          <span class="org-operator">=</span> sim_area_bounds
            (<span class="org-variable-name">t</span>, <span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>)                             <span class="org-operator">=</span> space_time_coordinate
            <span class="org-variable-name">decay_distance</span>     : cy.<span class="org-builtin">float</span>         <span class="org-operator">=</span> spot_config.decay_distance
            <span class="org-variable-name">downwind_direction</span> : cy.<span class="org-builtin">float</span>         <span class="org-operator">=</span> conv.deg_to_rad(conv.opposite_direction(upwind_direction))
            <span class="org-variable-name">cos_wdir</span>           : cy.<span class="org-builtin">float</span>         <span class="org-operator">=</span> cos(downwind_direction)
            <span class="org-variable-name">sin_wdir</span>           : cy.<span class="org-builtin">float</span>         <span class="org-operator">=</span> sin(downwind_direction)
            <span class="org-variable-name">wind_speed_20ft</span>    : cy.<span class="org-builtin">float</span>         <span class="org-operator">=</span> conv.wind_speed_10m_to_wind_speed_20ft(wind_speed_10m) <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
            <span class="org-variable-name">wind_speed_20ft_mps</span>: cy.<span class="org-builtin">float</span>         <span class="org-operator">=</span> conv.km_hr_to_mps(wind_speed_20ft)                     <span class="org-comment-delimiter"># </span><span class="org-comment">m/s</span>
            <span class="org-variable-name">jd</span>                 : JumpDistribution <span class="org-operator">=</span> resolve_JumpDistribution(spot_config,
                                                                             fireline_intensity,
                                                                             wind_speed_20ft_mps)

            <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Cast each firebrand and accumulate any ignited cells</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>

            <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: A set is slow, so use a list instead. Collisions can happen with other source cells anyway.</span>
            <span class="org-variable-name">ignited_cells</span>: <span class="org-builtin">set</span> <span class="org-operator">=</span> <span class="org-builtin">set</span>()
            i: cy.longlong
            <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(num_firebrands):
                <span class="org-variable-name">ignited_cell</span>: coord_yx <span class="org-operator">=</span> cast_firebrand(random_generator,
                                                        fuel_model_cube,
                                                        temperature_cube,
                                                        fuel_moisture_dead_1hr_cube,
                                                        fire_type_matrix,
                                                        rows,
                                                        cols,
                                                        cell_height,
                                                        cell_width,
                                                        t,
                                                        y,
                                                        x,
                                                        decay_distance,
                                                        cos_wdir,
                                                        sin_wdir,
                                                        jd)
                <span class="org-keyword">if</span> (ignited_cell[0] <span class="org-operator">!=</span> y) <span class="org-keyword">or</span> (ignited_cell[1] <span class="org-operator">!=</span> x):
                    ignited_cells.add(ignited_cell)

            <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Return any cells ignited by firebrands along with their time of ignition</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>

            <span class="org-keyword">if</span> <span class="org-builtin">len</span>(ignited_cells) <span class="org-operator">&gt;</span> 0:
                <span class="org-variable-name">ignition_time</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> spot_ignition_time(time_of_arrival, flame_length) <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>
                <span class="org-keyword">return</span> (ignition_time, ignited_cells)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-for-users-spot" class="outline-3">
<h3 id="for-users-spot"><span class="section-number-3">7.2.</span> For Users</h3>
<div class="outline-text-3" id="text-for-users-spot">
</div>

<div id="outline-container-how-to-estimate-the-areal-heat-output-for-all-surface-fuel-models" class="outline-4">
<h4 id="how-to-estimate-the-areal-heat-output-for-all-surface-fuel-models"><span class="section-number-4">7.2.1.</span> How to Estimate the Areal Heat Output for All Surface Fuel Models</h4>
<div class="outline-text-4" id="text-how-to-estimate-the-areal-heat-output-for-all-surface-fuel-models">
<div class="org-src-container">
<pre class="src src-python" id="estimate-areal-heat-output"><span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.fuel_models <span class="org-keyword">as</span> fm
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf

<span class="org-keyword">def</span> <span class="org-function-name">calc_areal_heat_output_from_fuel_model</span>(moisturized_fuel_model):
    <span class="org-variable-name">fire_behavior</span>      <span class="org-operator">=</span> sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model)
    <span class="org-variable-name">spread_rate</span>        <span class="org-operator">=</span> fire_behavior[<span class="org-string">"base_spread_rate"</span>]            <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
    <span class="org-variable-name">fireline_intensity</span> <span class="org-operator">=</span> fire_behavior[<span class="org-string">"base_fireline_intensity"</span>]     <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
    <span class="org-keyword">return</span> sf.calc_areal_heat_output(spread_rate, fireline_intensity) <span class="org-comment-delimiter"># </span><span class="org-comment">kJ/m^2</span>

<span class="org-keyword">def</span> <span class="org-function-name">save_areal_heat_output_as_histogram</span>(areal_heat_output, moisture_category):
    plt.hist(areal_heat_output[moisture_category],
             <span class="org-builtin">range</span><span class="org-operator">=</span>(0, 60000),
             bins<span class="org-operator">=</span>12,
             density<span class="org-operator">=</span><span class="org-constant">True</span>,
             histtype<span class="org-operator">=</span><span class="org-string">"bar"</span>,
             color<span class="org-operator">=</span><span class="org-string">"darkred"</span>,
             edgecolor<span class="org-operator">=</span><span class="org-string">"black"</span>)
    plt.title(<span class="org-string">"Areal Heat Output for All Surface Fuel Models - "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>.capitalize(moisture_category) <span class="org-operator">+</span> <span class="org-string">" Conditions"</span>)
    plt.xlabel(<span class="org-string">"Areal Heat Output (kJ/m^2)"</span>)
    plt.ylabel(<span class="org-string">"Probability Density"</span>)
    plt.savefig(<span class="org-string">"org/pics/fm_areal_heat_output_"</span> <span class="org-operator">+</span> moisture_category <span class="org-operator">+</span> <span class="org-string">".png"</span>)
    plt.close(<span class="org-string">"all"</span>)

<span class="org-variable-name">fuel_moisture_dry</span> <span class="org-operator">=</span> (
    0.025, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_1hr</span>
    0.050, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_10hr</span>
    0.075, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_100hr</span>
    0.00, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_herbaceous (will be set by moisturize for dynamic fuel models)</span>
    0.45, <span class="org-comment-delimiter"># </span><span class="org-comment">live_herbaceous</span>
    0.30, <span class="org-comment-delimiter"># </span><span class="org-comment">live_woody</span>
)

<span class="org-variable-name">fuel_moisture_mod</span> <span class="org-operator">=</span> (
    0.05, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_1hr</span>
    0.10, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_10hr</span>
    0.15, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_100hr</span>
    0.00, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_herbaceous (will be set by moisturize for dynamic fuel models)</span>
    0.90, <span class="org-comment-delimiter"># </span><span class="org-comment">live_herbaceous</span>
    0.60, <span class="org-comment-delimiter"># </span><span class="org-comment">live_woody</span>
)

<span class="org-variable-name">fuel_moisture_wet</span> <span class="org-operator">=</span> (
    0.10, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_1hr</span>
    0.20, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_10hr</span>
    0.30, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_100hr</span>
    0.00, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_herbaceous (will be set by moisturize for dynamic fuel models)</span>
    1.80, <span class="org-comment-delimiter"># </span><span class="org-comment">live_herbaceous</span>
    1.20, <span class="org-comment-delimiter"># </span><span class="org-comment">live_woody</span>
)

<span class="org-variable-name">areal_heat_output</span> <span class="org-operator">=</span> {
    <span class="org-string">"dry"</span>: [calc_areal_heat_output_from_fuel_model(fm.moisturize(v, fuel_moisture_dry))
            <span class="org-keyword">for</span> v <span class="org-keyword">in</span> fm.list_fuel_models()],
    <span class="org-string">"mod"</span>: [calc_areal_heat_output_from_fuel_model(fm.moisturize(v, fuel_moisture_mod))
            <span class="org-keyword">for</span> v <span class="org-keyword">in</span> fm.list_fuel_models()],
    <span class="org-string">"wet"</span>: [calc_areal_heat_output_from_fuel_model(fm.moisturize(v, fuel_moisture_wet))
            <span class="org-keyword">for</span> v <span class="org-keyword">in</span> fm.list_fuel_models()],
}

<span class="org-keyword">for</span> moisture_category <span class="org-keyword">in</span> [<span class="org-string">"dry"</span>, <span class="org-string">"mod"</span>, <span class="org-string">"wet"</span>]:
    save_areal_heat_output_as_histogram(areal_heat_output, moisture_category)

<span class="org-builtin">print</span>(<span class="org-string">"Median Areal Heat Output (kJ/m^2) for All Surface Fuel Models</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 80)
pprint({
    <span class="org-string">"dry"</span>: np.median(areal_heat_output[<span class="org-string">"dry"</span>]),
    <span class="org-string">"mod"</span>: np.median(areal_heat_output[<span class="org-string">"mod"</span>]),
    <span class="org-string">"wet"</span>: np.median(areal_heat_output[<span class="org-string">"wet"</span>]),
})

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Mean Areal Heat Output (kJ/m^2) for All Surface Fuel Models</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 80)
pprint({
    <span class="org-string">"dry"</span>: np.mean(areal_heat_output[<span class="org-string">"dry"</span>]),
    <span class="org-string">"mod"</span>: np.mean(areal_heat_output[<span class="org-string">"mod"</span>]),
    <span class="org-string">"wet"</span>: np.mean(areal_heat_output[<span class="org-string">"wet"</span>]),
})

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Max Areal Heat Output (kJ/m^2) for All Surface Fuel Models</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 80)
pprint({
    <span class="org-string">"dry"</span>: np.<span class="org-builtin">max</span>(areal_heat_output[<span class="org-string">"dry"</span>]),
    <span class="org-string">"mod"</span>: np.<span class="org-builtin">max</span>(areal_heat_output[<span class="org-string">"mod"</span>]),
    <span class="org-string">"wet"</span>: np.<span class="org-builtin">max</span>(areal_heat_output[<span class="org-string">"wet"</span>]),
})
</pre>
</div>

<pre class="example" id="run-estimate-areal-heat-output">
Median Areal Heat Output (kJ/m^2) for All Surface Fuel Models
================================================================================
{'dry': 9517.75048828125, 'mod': 7050.16748046875, 'wet': 3533.8206787109375}

Mean Areal Heat Output (kJ/m^2) for All Surface Fuel Models
================================================================================
{'dry': 14270.339441759834, 'mod': 10954.33150508486, 'wet': 5705.411192269161}

Max Areal Heat Output (kJ/m^2) for All Surface Fuel Models
================================================================================
{'dry': 54285.28515625, 'mod': 45108.625, 'wet': 32325.0390625}
</pre>


<div id="areal-heat-output-all-fm-dry" class="figure">
<p><img src="pics/fm_areal_heat_output_dry.png" alt="fm_areal_heat_output_dry.png">
</p>
<p><span class="figure-number">Figure 1: </span>Areal Heat Output for All Surface Fuel Models - Dry Conditions</p>
</div>


<div id="areal-heat-output-all-fm-mod" class="figure">
<p><img src="pics/fm_areal_heat_output_mod.png" alt="fm_areal_heat_output_mod.png">
</p>
<p><span class="figure-number">Figure 2: </span>Areal Heat Output for All Surface Fuel Models - Mod Conditions</p>
</div>


<div id="areal-heat-output-all-fm-wet" class="figure">
<p><img src="pics/fm_areal_heat_output_wet.png" alt="fm_areal_heat_output_wet.png">
</p>
<p><span class="figure-number">Figure 3: </span>Areal Heat Output for All Surface Fuel Models - Wet Conditions</p>
</div>
</div>
</div>

<div id="outline-container-how-to-estimate-the-number-of-firebrands-cast-per-burned-cell" class="outline-4">
<h4 id="how-to-estimate-the-number-of-firebrands-cast-per-burned-cell"><span class="section-number-4">7.2.2.</span> How to Estimate the Number of Firebrands Cast per Burned Cell</h4>
<div class="outline-text-4" id="text-how-to-estimate-the-number-of-firebrands-cast-per-burned-cell">
<p>
Several spotting parameters can be adjusted by the user:
</p>

<table id="tab:spotting-parameters">
<caption class="t-above"><span class="table-number">Table 5:</span> User adjustable spotting parameters</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Parameter</th>
<th scope="col" class="org-left">Units</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">random_seed</td>
<td class="org-left">\(\text{integer}\) or \(\text{Generator}\)</td>
<td class="org-left">seed for a numpy.random.Generator object</td>
</tr>

<tr>
<td class="org-left">firebrands_per_unit_heat</td>
<td class="org-left">\(\text{firebrands}/\text{kJ}\)</td>
<td class="org-left">number of firebrands to emit per kilojoule</td>
</tr>

<tr>
<td class="org-left">downwind_distance_mean</td>
<td class="org-left">\(\text{m}\)</td>
<td class="org-left">normal distribution mean underpinning lognormal distribution</td>
</tr>

<tr>
<td class="org-left">fireline_intensity_exponent</td>
<td class="org-left">\(\text{-}\)</td>
<td class="org-left">downwind_distance_mean multiplier [I^fireline_intensity_exponent]</td>
</tr>

<tr>
<td class="org-left">wind_speed_exponent</td>
<td class="org-left">\(\text{-}\)</td>
<td class="org-left">downwind_distance_mean multiplier [U^wind_speed_exponent]</td>
</tr>

<tr>
<td class="org-left">downwind_variance_mean_ratio</td>
<td class="org-left">\(\text{m}^2/\text{m}\)</td>
<td class="org-left">normal distribution variance divided by expected value [Var(X) / E(X)]</td>
</tr>

<tr>
<td class="org-left">crosswind_distance_stdev</td>
<td class="org-left">\(\text{m}\)</td>
<td class="org-left">crosswind normal distribution standard deviation (mean = 0)</td>
</tr>

<tr>
<td class="org-left">decay_distance</td>
<td class="org-left">\(\text{m}\)</td>
<td class="org-left">spotting distance at which ignition probability is divided by \(e\)</td>
</tr>
</tbody>
</table>

<p>
In this section, we will look at <b>firebrands_per_unit_heat</b> and
<b>decay_distance</b> specifically as they have the most direct bearing on
the number of firebrands produced from each burning cell as well as
how many of these will ignite new spot fires rather than fizzle out.
</p>

<p>
From section <a href="#how-to-estimate-the-areal-heat-output-for-all-surface-fuel-models">7.2.1</a>, we can see that heat outputs across all surface fuel
models under moderately dry conditions range from about 0-45,000
\(\text{kJ}/\text{m}^2\).
</p>

<p>
Here, we will calculate some representative ignition probabilities and
expected spot fire counts per burning cell given the following input
variable ranges:
</p>

<ul class="org-ul">
<li><b>heat output per area</b>: 0-45,000 \(\text{kJ}/\text{m}^2\)</li>
<li><b>heat per firebrand</b>: 500,000-2,000,000 \(\text{kJ}/\text{firebrand}\)</li>
<li><b>spotting distance from burning cell</b>: 30-900 meters (e.g., 1-30 cells @ 30m resolution)</li>
<li><b>decay distance</b>: 30-900 meters (e.g., 1-30 cells @ 30m resolution)</li>
<li><b>temperature at target cell</b>: 20-40 degrees Celsius</li>
<li><b>fine fuel moisture at target cell</b>: 5-20%</li>
</ul>

<p>
In this example, we will assume a flat landscape (no slope) with 30
meter resolution grid cells. This gives us a cell area of 900 \(\text{m}^2\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="estimate-spot-fire-ignition-probability"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.spot_fire <span class="org-keyword">as</span> spot


<span class="org-variable-name">cell_area</span> <span class="org-operator">=</span> 900 <span class="org-comment-delimiter"># </span><span class="org-comment">m^2</span>


<span class="org-variable-name">firebrand_counts</span> <span class="org-operator">=</span> <span class="org-builtin">sorted</span>([heat_output_per_area <span class="org-operator">*</span> cell_area <span class="org-operator">*</span> firebrands_per_unit_heat
                           <span class="org-keyword">for</span> heat_output_per_area <span class="org-keyword">in</span> <span class="org-builtin">range</span>(0, 45001, 5000)
                           <span class="org-keyword">for</span> firebrands_per_unit_heat <span class="org-keyword">in</span> <span class="org-builtin">map</span>(<span class="org-keyword">lambda</span> x: 1<span class="org-operator">/</span>x, <span class="org-builtin">range</span>(<span class="org-builtin">int</span>(5e5), <span class="org-builtin">int</span>(2e6)<span class="org-operator">+</span>1, <span class="org-builtin">int</span>(5e5)))])


<span class="org-variable-name">distance_penalties</span> <span class="org-operator">=</span> <span class="org-builtin">sorted</span>([spot.firebrand_flight_survival_probability(spotting_distance, decay_distance)
                             <span class="org-keyword">for</span> spotting_distance <span class="org-keyword">in</span> <span class="org-builtin">range</span>(30, 901, 30)
                             <span class="org-keyword">for</span> decay_distance <span class="org-keyword">in</span> <span class="org-builtin">range</span>(30, 901, 30)])


<span class="org-variable-name">schroeder_probs</span> <span class="org-operator">=</span> <span class="org-builtin">sorted</span>([spot.schroeder_ignition_probability(temperature, moisture <span class="org-operator">/</span> 100)
                          <span class="org-keyword">for</span> temperature <span class="org-keyword">in</span> <span class="org-builtin">range</span>(20, 41, 5)
                          <span class="org-keyword">for</span> moisture <span class="org-keyword">in</span> <span class="org-builtin">range</span>(5, 21, 5)])


<span class="org-variable-name">ignition_probs</span> <span class="org-operator">=</span> <span class="org-builtin">sorted</span>([dp <span class="org-operator">*</span> sp
                         <span class="org-keyword">for</span> dp <span class="org-keyword">in</span> distance_penalties
                         <span class="org-keyword">for</span> sp <span class="org-keyword">in</span> schroeder_probs])


<span class="org-variable-name">spot_fire_counts</span> <span class="org-operator">=</span> <span class="org-builtin">sorted</span>([fb <span class="org-operator">*</span> ip
                           <span class="org-keyword">for</span> fb <span class="org-keyword">in</span> firebrand_counts
                           <span class="org-keyword">for</span> ip <span class="org-keyword">in</span> ignition_probs])


<span class="org-keyword">def</span> <span class="org-function-name">percentile_indices</span>(coll):
    <span class="org-doc">"""</span>
<span class="org-doc">    Return the 0th, 25th, 50th, 75th, and 100th percentile indices for coll.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">max_index</span> <span class="org-operator">=</span> <span class="org-builtin">len</span>(coll) <span class="org-operator">-</span> 1
    <span class="org-keyword">return</span> <span class="org-builtin">map</span>(<span class="org-keyword">lambda</span> p: (p, <span class="org-builtin">int</span>(p <span class="org-operator">*</span> max_index)),
               [0.0, 0.25, 0.5, 0.75, 1.0])


<span class="org-variable-name">firebrand_count_percs</span> <span class="org-operator">=</span> {<span class="org-builtin">int</span>(100 <span class="org-operator">*</span> p_v[0]): firebrand_counts[p_v[1]]
                         <span class="org-keyword">for</span> p_v <span class="org-keyword">in</span> percentile_indices(firebrand_counts)}


<span class="org-variable-name">distance_penalty_percs</span> <span class="org-operator">=</span> {<span class="org-builtin">int</span>(100 <span class="org-operator">*</span> p_v[0]): distance_penalties[p_v[1]]
                          <span class="org-keyword">for</span> p_v <span class="org-keyword">in</span> percentile_indices(distance_penalties)}


<span class="org-variable-name">schroeder_prob_percs</span> <span class="org-operator">=</span> {<span class="org-builtin">int</span>(100 <span class="org-operator">*</span> p_v[0]): schroeder_probs[p_v[1]]
                        <span class="org-keyword">for</span> p_v <span class="org-keyword">in</span> percentile_indices(schroeder_probs)}


<span class="org-variable-name">ignition_prob_percs</span> <span class="org-operator">=</span> {<span class="org-builtin">int</span>(100 <span class="org-operator">*</span> p_v[0]): ignition_probs[p_v[1]]
                       <span class="org-keyword">for</span> p_v <span class="org-keyword">in</span> percentile_indices(ignition_probs)}


<span class="org-variable-name">spot_fire_count_percs</span> <span class="org-operator">=</span> {<span class="org-builtin">int</span>(100 <span class="org-operator">*</span> p_v[0]): spot_fire_counts[p_v[1]]
                         <span class="org-keyword">for</span> p_v <span class="org-keyword">in</span> percentile_indices(spot_fire_counts)}


pprint({
    <span class="org-string">"firebrand_count_percentiles"</span>               : firebrand_count_percs,
    <span class="org-string">"flight_distance_penalty_percentiles"</span>       : distance_penalty_percs,
    <span class="org-string">"schroeder_ignition_probability_percentiles"</span>: schroeder_prob_percs,
    <span class="org-string">"spot_ignition_probability_percentiles"</span>     : ignition_prob_percs,
    <span class="org-string">"spot_fire_count_percentiles"</span>               : spot_fire_count_percs,
}, sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)
</pre>
</div>

<pre class="example" id="estimate-spot-fire-ignition-probability-results">
{'firebrand_count_percentiles': {0: 0.0,
                                 25: 6.75,
                                 50: 15.75,
                                 75: 27.0,
                                 100: 81.0},
 'flight_distance_penalty_percentiles': {0: 9.357622912219837e-14,
                                         25: 0.1353352814912796,
                                         50: 0.3678794503211975,
                                         75: 0.5961628556251526,
                                         100: 0.9672160744667053},
 'schroeder_ignition_probability_percentiles': {0: 0.041064321994781494,
                                                25: 0.05806152522563934,
                                                50: 0.14626064896583557,
                                                75: 0.3209269940853119,
                                                100: 0.6532412171363831},
 'spot_ignition_probability_percentiles': {0: 3.842644403731403e-15,
                                           25: 0.01667532404047145,
                                           50: 0.05110364729968131,
                                           75: 0.14566152291234502,
                                           100: 0.6318254057185051},
 'spot_fire_count_percentiles': {0: 0.0,
                                 25: 0.09538073616268317,
                                 50: 0.662820466042433,
                                 75: 2.3768363731988043,
                                 100: 51.17785786319891}}
</pre>

<p>
We can see that depending on the surface fuel model and weather
conditions at the cells receiving firebrands, we can get anywhere from
0-51 spot fires ignited by one burning cell per timestep using the
ranges for <b>firebrands_per_unit_heat</b> and <b>decay_distance</b> provided
above.
</p>
</div>
</div>

<div id="outline-container-how-to-estimate-typical-ranges-for-the-$\vec{\delta}$-distribution-characteristics" class="outline-4">
<h4 id="how-to-estimate-typical-ranges-for-the-$\vec{\delta}$-distribution-characteristics"><span class="section-number-4">7.2.3.</span> How to Estimate Typical Ranges for the \(\vec{\Delta}\) Distribution Characteristics</h4>
<div class="outline-text-4" id="text-how-to-estimate-typical-ranges-for-the-$\vec{\delta}$-distribution-characteristics">
<div class="org-src-container">
<pre class="src src-python" id="himoto-typical-ranges"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> sqrt, log

<span class="org-keyword">def</span> <span class="org-function-name">himoto_eq_28_values</span>(B_star):
    <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: The following value for D seems absurdly low, and so does</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">the predicted E[&#916;X]. I suspect a typo in the Himoto2005 paper.</span>
    <span class="org-variable-name">D</span>                  <span class="org-operator">=</span> 0.08
    <span class="org-variable-name">std_delta_x_over_D</span> <span class="org-operator">=</span> 0.88 <span class="org-operator">*</span> (B_star <span class="org-operator">**</span> (1.0 <span class="org-operator">/</span> 3.0))
    <span class="org-variable-name">exp_delta_x_over_D</span> <span class="org-operator">=</span> 0.47 <span class="org-operator">*</span> (B_star <span class="org-operator">**</span> (2.0 <span class="org-operator">/</span> 3.0))
    <span class="org-variable-name">cv_delta_x</span>         <span class="org-operator">=</span> std_delta_x_over_D <span class="org-operator">/</span> exp_delta_x_over_D
    <span class="org-variable-name">sigma_x</span>            <span class="org-operator">=</span> sqrt(log(1.0 <span class="org-operator">+</span> cv_delta_x))
    <span class="org-variable-name">exp_delta_x</span>        <span class="org-operator">=</span> exp_delta_x_over_D <span class="org-operator">*</span> D
    <span class="org-variable-name">mu_x</span>               <span class="org-operator">=</span> log(exp_delta_x) <span class="org-operator">-</span> (sigma_x <span class="org-operator">**</span> 2.0) <span class="org-operator">/</span> 2.0
    <span class="org-variable-name">sigma_y</span>            <span class="org-operator">=</span> D <span class="org-operator">*</span> 0.92
    <span class="org-keyword">return</span> {
        <span class="org-string">"$B^*$"</span>                             : B_star,
        <span class="org-string">"$</span><span class="org-constant">\\</span><span class="org-string">text{CV}[</span><span class="org-constant">\\</span><span class="org-string">Delta_X]$"</span>           : <span class="org-string">"{:.0f}%"</span>.<span class="org-builtin">format</span>(100.0 <span class="org-operator">*</span> cv_delta_x),
        <span class="org-string">"$</span><span class="org-constant">\\</span><span class="org-string">sigma_X$"</span>                       : <span class="org-string">"{:.2f}"</span>.<span class="org-builtin">format</span>(sigma_x),
        <span class="org-string">"$</span><span class="org-constant">\\</span><span class="org-string">sigma_Y/</span><span class="org-constant">\\</span><span class="org-string">mathbb{E}[</span><span class="org-constant">\\</span><span class="org-string">Delta_X]$"</span>: <span class="org-string">"{:.2f}"</span>.<span class="org-builtin">format</span>(sigma_y <span class="org-operator">/</span> exp_delta_x),
        <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE the following ended up being nonsensical:</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">"E[&#916;X] (m)" exp_delta_x</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">"&#956;_X"       mu_x</span>
    }

<span class="org-variable-name">himoto_typical_ranges</span> <span class="org-operator">=</span> [himoto_eq_28_values(B_star) <span class="org-keyword">for</span> B_star <span class="org-keyword">in</span> [20, 50, 100, 150, 200]]
<span class="org-variable-name">table_header</span>          <span class="org-operator">=</span> <span class="org-builtin">list</span>(himoto_typical_ranges[0].keys())
<span class="org-variable-name">table_rows</span>            <span class="org-operator">=</span> [<span class="org-builtin">list</span>(d.values()) <span class="org-keyword">for</span> d <span class="org-keyword">in</span> himoto_typical_ranges]

<span class="org-builtin">print</span>([table_header, <span class="org-operator">*</span>table_rows])
</pre>
</div>

<table id="run-himoto-typical-ranges">


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-right">\(B^*\)</td>
<td class="org-right">\(\text{CV}[\Delta_X]\)</td>
<td class="org-right">\(\sigma_X\)</td>
<td class="org-right">\(\sigma_Y/\mathbb{E}[\Delta_X]\)</td>
</tr>

<tr>
<td class="org-right">20</td>
<td class="org-right">69%</td>
<td class="org-right">0.72</td>
<td class="org-right">0.27</td>
</tr>

<tr>
<td class="org-right">50</td>
<td class="org-right">51%</td>
<td class="org-right">0.64</td>
<td class="org-right">0.14</td>
</tr>

<tr>
<td class="org-right">100</td>
<td class="org-right">40%</td>
<td class="org-right">0.58</td>
<td class="org-right">0.09</td>
</tr>

<tr>
<td class="org-right">150</td>
<td class="org-right">35%</td>
<td class="org-right">0.55</td>
<td class="org-right">0.07</td>
</tr>

<tr>
<td class="org-right">200</td>
<td class="org-right">32%</td>
<td class="org-right">0.53</td>
<td class="org-right">0.06</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>

<div id="outline-container-burning-cells-on-a-grid-(pyretechnics.burn_cells)" class="outline-2">
<h2 id="burning-cells-on-a-grid-(pyretechnics.burn_cells)"><span class="section-number-2">8.</span> Burning Cells on a Grid (pyretechnics.burn_cells)</h2>
<div class="outline-text-2" id="text-burning-cells-on-a-grid-(pyretechnics.burn_cells)">
</div>
<div id="outline-container-for-developers-burn-cells" class="outline-3">
<h3 id="for-developers-burn-cells"><span class="section-number-3">8.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-for-developers-burn-cells">
<p>
This module provides convenience functions that apply the fuel model
and moisture definitions from section <a href="#fuel-model-and-moisture-definitions-(pyretechnics.fuel_models)">4</a>, surface fire equations from
section <a href="#surface-fire-equations-(pyretechnics.surface_fire)">5</a>, and crown
fire equations from section <a href="#crown-fire-equations-(pyretechnics.crown_fire)">6</a> to cells within a space-time cube, returning
their combined surface and crown fire behavior.
</p>
</div>

<div id="outline-container-module-imports-burn-cells" class="outline-4">
<h4 id="module-imports-burn-cells"><span class="section-number-4">8.1.1.</span> Module Imports</h4>
<div class="outline-text-4" id="text-module-imports-burn-cells">
<div class="org-src-container">
<pre class="src src-python" id="burn-cells-imports"><span class="org-keyword">import</span> cython
<span class="org-keyword">import</span> cython <span class="org-keyword">as</span> cy
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">if</span> cython.compiled:
    <span class="org-keyword">from</span> cython.cimports.numpy <span class="org-keyword">import</span> ndarray
    <span class="org-keyword">from</span> cython.cimports.pyretechnics.cy_types <span class="org-keyword">import</span> \
        pyidx, vec_xy, vec_xyz, coord_tyx, fclaarr, FuelModel, FireBehaviorMin, FireBehaviorMax, SpreadBehavior
    <span class="org-keyword">from</span> cython.cimports.pyretechnics.space_time_cube <span class="org-keyword">import</span> ISpaceTimeCube, to_positive_index_range
    <span class="org-keyword">import</span> cython.cimports.pyretechnics.conversion <span class="org-keyword">as</span> conv
    <span class="org-keyword">import</span> cython.cimports.pyretechnics.vector_utils <span class="org-keyword">as</span> vu
    <span class="org-keyword">import</span> cython.cimports.pyretechnics.fuel_models <span class="org-keyword">as</span> fm
    <span class="org-keyword">import</span> cython.cimports.pyretechnics.surface_fire <span class="org-keyword">as</span> sf
    <span class="org-keyword">import</span> cython.cimports.pyretechnics.crown_fire <span class="org-keyword">as</span> cf
<span class="org-keyword">else</span>:
    <span class="org-keyword">from</span> numpy <span class="org-keyword">import</span> ndarray
    <span class="org-keyword">from</span> pyretechnics.py_types <span class="org-keyword">import</span> \
        pyidx, vec_xy, vec_xyz, coord_tyx, fclaarr, FuelModel, FireBehaviorMin, FireBehaviorMax, SpreadBehavior
    <span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> ISpaceTimeCube, to_positive_index_range
    <span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv
    <span class="org-keyword">import</span> pyretechnics.vector_utils <span class="org-keyword">as</span> vu
    <span class="org-keyword">import</span> pyretechnics.fuel_models <span class="org-keyword">as</span> fm
    <span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf
    <span class="org-keyword">import</span> pyretechnics.crown_fire <span class="org-keyword">as</span> cf
</pre>
</div>
</div>
</div>

<div id="outline-container-burn-cells-as-a-head-fire" class="outline-4">
<h4 id="burn-cells-as-a-head-fire"><span class="section-number-4">8.1.2.</span> Burn Cells as a Head Fire</h4>
<div class="outline-text-4" id="text-burn-cells-as-a-head-fire">
<p>
Sometimes the goal of a fire behavior analysis is to determine the
most extreme behavior to be expected, given static measurements of
surface fuels, tree canopy characteristics, topography, wind, and
moisture. The following function computes the maximum surface fire
behavior and checks to see whether its maximum surface fireline
intensity causes a crown fire. If so, the maximum crown fire behavior
is computed and combined with the maximum surface fire behavior as per
section <a href="#combining-surface-and-crown-fire-behavior">6.1.8</a>. If not, the maximum
surface fire behavior is returned.
</p>

<div class="org-src-container">
<pre class="src src-python" id="burn-cells-as-head-fire"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-keyword">def</span> <span class="org-function-name">SpreadBehavior_to_dict</span>(sb: SpreadBehavior) <span class="org-operator">-&gt;</span> <span class="org-builtin">dict</span>:
    <span class="org-keyword">return</span> {
        <span class="org-string">"fire_type"</span>         : sb.fire_type,
        <span class="org-string">"spread_rate"</span>       : sb.spread_rate,
        <span class="org-string">"spread_direction"</span>  : sb.spread_direction,
        <span class="org-string">"fireline_intensity"</span>: sb.fireline_intensity,
        <span class="org-string">"flame_length"</span>      : sb.flame_length,
    }


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">burn_cell_as_head_fire</span>(space_time_cubes      : <span class="org-builtin">dict</span>[<span class="org-builtin">str</span>, ISpaceTimeCube],
                           space_time_coordinate : coord_tyx,
                           use_wind_limit        : cy.bint <span class="org-operator">=</span> <span class="org-constant">True</span>,
                           surface_lw_ratio_model: <span class="org-builtin">str</span> <span class="org-operator">=</span> <span class="org-string">"behave"</span>,
                           crown_max_lw_ratio    : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 1e10) <span class="org-operator">-&gt;</span> <span class="org-builtin">dict</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - space_time_cubes             :: dictionary of (Lazy)SpaceTimeCube objects with these cell types</span>
<span class="org-doc">      - slope                         :: rise/run</span>
<span class="org-doc">      - aspect                        :: degrees clockwise from North</span>
<span class="org-doc">      - fuel_model                    :: integer index in fm.fuel_model_table</span>
<span class="org-doc">      - canopy_cover                  :: 0-1</span>
<span class="org-doc">      - canopy_height                 :: m</span>
<span class="org-doc">      - canopy_base_height            :: m</span>
<span class="org-doc">      - canopy_bulk_density           :: kg/m^3</span>
<span class="org-doc">      - wind_speed_10m                :: km/hr</span>
<span class="org-doc">      - upwind_direction              :: degrees clockwise from North</span>
<span class="org-doc">      - fuel_moisture_dead_1hr        :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_dead_10hr       :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_dead_100hr      :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_live_herbaceous :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_live_woody      :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - foliar_moisture               :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_spread_adjustment        :: float &gt;= 0.0 (Optional: defaults to 1.0)</span>
<span class="org-doc">      - weather_spread_adjustment     :: float &gt;= 0.0 (Optional: defaults to 1.0)</span>
<span class="org-doc">    - space_time_coordinate        :: (t,y,x)</span>
<span class="org-doc">    - use_wind_limit               :: boolean (Optional)</span>
<span class="org-doc">    - surface_lw_ratio_model       :: "rothermel" or "behave" (Optional)</span>
<span class="org-doc">    - crown_max_lw_ratio           :: float &gt; 0.0 (Optional)</span>

<span class="org-doc">    return a dictionary with these fire behavior values for the space-time coordinate (t,y,x):</span>
<span class="org-doc">    - fire_type          :: 0 (unburned), 1 (surface), 2 (passive_crown), or 3 (active_crown)</span>
<span class="org-doc">    - spread_rate        :: m/min</span>
<span class="org-doc">    - spread_direction   :: (x, y, z) unit vector on the slope-tangential plane</span>
<span class="org-doc">    - fireline_intensity :: kW/m</span>
<span class="org-doc">    - flame_length       :: m</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the space_time_coordinate</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    (<span class="org-variable-name">t</span>, <span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>) <span class="org-operator">=</span> space_time_coordinate

    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack the space_time_cubes dictionary</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Topography, Fuel Model, and Vegetation</span>
    <span class="org-variable-name">slope</span>              : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"slope"</span>]).get(t, y, x)
    <span class="org-variable-name">aspect</span>             : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"aspect"</span>]).get(t, y, x)
    <span class="org-variable-name">fuel_model_number</span>  : cy.<span class="org-builtin">int</span>   <span class="org-operator">=</span> cy.cast(cy.<span class="org-builtin">int</span>, cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"fuel_model"</span>]).get(t, y, x))
    <span class="org-variable-name">canopy_cover</span>       : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"canopy_cover"</span>]).get(t, y, x)
    <span class="org-variable-name">canopy_height</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"canopy_height"</span>]).get(t, y, x)
    <span class="org-variable-name">canopy_base_height</span> : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"canopy_base_height"</span>]).get(t, y, x)
    <span class="org-variable-name">canopy_bulk_density</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"canopy_bulk_density"</span>]).get(t, y, x)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Wind, Surface Moisture, and Foliar Moisture</span>
    <span class="org-variable-name">wind_speed_10m</span>               : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"wind_speed_10m"</span>]).get(t, y, x)
    <span class="org-variable-name">upwind_direction</span>             : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"upwind_direction"</span>]).get(t, y, x)
    <span class="org-variable-name">fuel_moisture_dead_1hr</span>       : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"fuel_moisture_dead_1hr"</span>]).get(t, y, x)
    <span class="org-variable-name">fuel_moisture_dead_10hr</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"fuel_moisture_dead_10hr"</span>]).get(t, y, x)
    <span class="org-variable-name">fuel_moisture_dead_100hr</span>     : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"fuel_moisture_dead_100hr"</span>]).get(t, y, x)
    <span class="org-variable-name">fuel_moisture_live_herbaceous</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"fuel_moisture_live_herbaceous"</span>]).get(t, y, x)
    <span class="org-variable-name">fuel_moisture_live_woody</span>     : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"fuel_moisture_live_woody"</span>]).get(t, y, x)
    <span class="org-variable-name">foliar_moisture</span>              : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"foliar_moisture"</span>]).get(t, y, x)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Spread Rate Adjustments (Optional)</span>
    <span class="org-variable-name">fuel_spread_adjustment</span>   : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"fuel_spread_adjustment"</span>]).get(t, y, x)
                                           <span class="org-keyword">if</span> <span class="org-string">"fuel_spread_adjustment"</span> <span class="org-keyword">in</span> space_time_cubes
                                           <span class="org-keyword">else</span> 1.0)                                         <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>
    <span class="org-variable-name">weather_spread_adjustment</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"weather_spread_adjustment"</span>]).get(t, y, x)
                                           <span class="org-keyword">if</span> <span class="org-string">"weather_spread_adjustment"</span> <span class="org-keyword">in</span> space_time_cubes
                                           <span class="org-keyword">else</span> 1.0)                                         <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>
    <span class="org-variable-name">spread_rate_adjustment</span>   : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> fuel_spread_adjustment <span class="org-operator">*</span> weather_spread_adjustment <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>

    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Check whether cell is burnable</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    fuel_model      : FuelModel
    maybe_fuel_model: FuelModel<span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> fm.fuel_model_table.get(fuel_model_number)

    <span class="org-keyword">if</span> maybe_fuel_model:
        <span class="org-variable-name">fuel_model</span> <span class="org-operator">=</span> maybe_fuel_model

    <span class="org-keyword">if</span> (maybe_fuel_model <span class="org-keyword">is</span> <span class="org-constant">None</span> <span class="org-keyword">or</span> <span class="org-keyword">not</span>(fuel_model.burnable)):
        <span class="org-comment-delimiter"># </span><span class="org-comment">Encountered unknown or non-burnable fuel model</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Create a 3D unit vector pointing upslope on the slope-tangential plane</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

        <span class="org-variable-name">upslope_direction</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> conv.opposite_direction(aspect)
        <span class="org-variable-name">slope_vector_2d</span>  : vec_xy   <span class="org-operator">=</span> conv.azimuthal_to_cartesian(slope, upslope_direction)
        <span class="org-variable-name">slope_vector_3d</span>  : vec_xyz  <span class="org-operator">=</span> vu.to_slope_plane(slope_vector_2d, slope_vector_2d)
        <span class="org-variable-name">default_direction</span>: vec_xyz  <span class="org-operator">=</span> (0.0, 1.0, 0.0) <span class="org-comment-delimiter"># </span><span class="org-comment">default: North</span>
        <span class="org-variable-name">spread_direction</span> : vec_xyz  <span class="org-operator">=</span> vu.as_unit_vector_3d(slope_vector_3d) <span class="org-keyword">if</span> slope <span class="org-operator">&gt;</span> 0.0 <span class="org-keyword">else</span> default_direction

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Return zero surface fire behavior</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-keyword">return</span> {
            <span class="org-string">"fire_type"</span>         : 0, <span class="org-comment-delimiter"># </span><span class="org-comment">unburned</span>
            <span class="org-string">"spread_rate"</span>       : 0.0,
            <span class="org-string">"spread_direction"</span>  : spread_direction,
            <span class="org-string">"fireline_intensity"</span>: 0.0,
            <span class="org-string">"flame_length"</span>      : 0.0,
        }

    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Encountered burnable fuel model</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Compute derived parameters</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-variable-name">fuel_moisture</span>               : fclaarr  <span class="org-operator">=</span> (fuel_moisture_dead_1hr,
                                                  fuel_moisture_dead_10hr,
                                                  fuel_moisture_dead_100hr,
                                                  0.0, <span class="org-comment-delimiter"># </span><span class="org-comment">fuel_moisture_dead_herbaceous</span>
                                                  fuel_moisture_live_herbaceous,
                                                  fuel_moisture_live_woody) <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
        <span class="org-variable-name">fuel_bed_depth</span>              : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> fuel_model.delta                      <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
        <span class="org-variable-name">heat_of_combustion</span>          : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> conv.Btu_lb_to_kJ_kg(fuel_model.h[0]) <span class="org-comment-delimiter"># </span><span class="org-comment">kJ/kg</span>
        <span class="org-variable-name">estimated_fine_fuel_moisture</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> fuel_moisture_dead_1hr                <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate midflame wind speed</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 10m wind speed to 20ft wind speed</span>
        <span class="org-variable-name">wind_speed_20ft</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> conv.wind_speed_10m_to_wind_speed_20ft(wind_speed_10m) <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Convert 20ft wind speed from km/hr to m/min</span>
        <span class="org-variable-name">wind_speed_20ft_m_min</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> conv.km_hr_to_m_min(wind_speed_20ft) <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 20ft wind speed to midflame wind speed in m/min</span>
        <span class="org-variable-name">midflame_wind_speed</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> sf.calc_midflame_wind_speed(wind_speed_20ft_m_min,       <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
                                                                    fuel_bed_depth,              <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                                    conv.m_to_ft(canopy_height), <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                                    canopy_cover)                <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Apply fuel moisture to fuel model</span>
        <span class="org-variable-name">moisturized_fuel_model</span>: FuelModel <span class="org-operator">=</span> fm.moisturize(fuel_model, fuel_moisture)

        <span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Memoize calc_surface_fire_behavior_no_wind_no_slope</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate no-wind-no-slope surface fire behavior</span>
        <span class="org-variable-name">surface_fire_min</span>: FireBehaviorMin <span class="org-operator">=</span> sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model,
                                                                                           spread_rate_adjustment)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread</span>
        <span class="org-variable-name">surface_fire_max</span>: FireBehaviorMax <span class="org-operator">=</span> sf.calc_surface_fire_behavior_max(surface_fire_min,
                                                                              midflame_wind_speed,
                                                                              upwind_direction,
                                                                              slope,
                                                                              aspect,
                                                                              use_wind_limit,
                                                                              surface_lw_ratio_model)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Simplify the surface fire behavior fields for future combination with the crown fire behavior values</span>
        <span class="org-variable-name">spread_direction</span>       : vec_xyz        <span class="org-operator">=</span> surface_fire_max.max_spread_direction
        <span class="org-variable-name">surface_fire_max_simple</span>: SpreadBehavior <span class="org-operator">=</span> sf.calc_surface_fire_behavior_in_direction(surface_fire_max,
                                                                                             spread_direction)

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Determine whether the surface fire transitions to a crown fire</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-keyword">if</span> cf.van_wagner_crown_fire_initiation(surface_fire_max_simple.fireline_intensity,
                                               canopy_cover,
                                               canopy_base_height,
                                               foliar_moisture):

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction of maximum spread</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction of maximum spread</span>
            <span class="org-variable-name">crown_fire_max</span>: FireBehaviorMax <span class="org-operator">=</span> cf.calc_crown_fire_behavior_max(canopy_height, canopy_base_height,
                                                                              canopy_bulk_density, heat_of_combustion,
                                                                              estimated_fine_fuel_moisture,
                                                                              wind_speed_10m, upwind_direction,
                                                                              slope, aspect, crown_max_lw_ratio)

            <span class="org-comment-delimiter"># </span><span class="org-comment">Simplify the crown fire behavior fields for future combination with the surface fire behavior values</span>
            <span class="org-variable-name">spread_direction</span>     : vec_xyz        <span class="org-operator">=</span> crown_fire_max.max_spread_direction
            <span class="org-variable-name">crown_fire_max_simple</span>: SpreadBehavior <span class="org-operator">=</span> cf.calc_crown_fire_behavior_in_direction(crown_fire_max,
                                                                                             spread_direction)

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate combined fire behavior in the direction of maximum spread</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-variable-name">combined_fire_max</span>: SpreadBehavior <span class="org-operator">=</span> cf.calc_combined_fire_behavior(surface_fire_max_simple,
                                                                               crown_fire_max_simple)

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Return the combined fire behavior in the direction of maximum spread</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-keyword">return</span> SpreadBehavior_to_dict(combined_fire_max)

        <span class="org-keyword">else</span>:

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Return the surface fire behavior in the direction of maximum spread</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-keyword">return</span> SpreadBehavior_to_dict(surface_fire_max_simple)


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Make a more efficient version that avoids space_time_cubes dictionary lookups for each cell</span>
<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">burn_all_cells_as_head_fire</span>(space_time_cubes      : <span class="org-builtin">dict</span>[<span class="org-builtin">str</span>, ISpaceTimeCube],
                                t                     : pyidx,
                                y_range               : <span class="org-builtin">tuple</span>[pyidx, pyidx]<span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> <span class="org-constant">None</span>,
                                x_range               : <span class="org-builtin">tuple</span>[pyidx, pyidx]<span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> <span class="org-constant">None</span>,
                                use_wind_limit        : cy.bint <span class="org-operator">=</span> <span class="org-constant">True</span>,
                                surface_lw_ratio_model: <span class="org-builtin">str</span> <span class="org-operator">=</span> <span class="org-string">"behave"</span>,
                                crown_max_lw_ratio    : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 1e10) <span class="org-operator">-&gt;</span> <span class="org-builtin">dict</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - space_time_cubes             :: dictionary of (Lazy)SpaceTimeCube objects with these cell types</span>
<span class="org-doc">      - slope                         :: rise/run</span>
<span class="org-doc">      - aspect                        :: degrees clockwise from North</span>
<span class="org-doc">      - fuel_model                    :: integer index in fm.fuel_model_table</span>
<span class="org-doc">      - canopy_cover                  :: 0-1</span>
<span class="org-doc">      - canopy_height                 :: m</span>
<span class="org-doc">      - canopy_base_height            :: m</span>
<span class="org-doc">      - canopy_bulk_density           :: kg/m^3</span>
<span class="org-doc">      - wind_speed_10m                :: km/hr</span>
<span class="org-doc">      - upwind_direction              :: degrees clockwise from North</span>
<span class="org-doc">      - fuel_moisture_dead_1hr        :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_dead_10hr       :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_dead_100hr      :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_live_herbaceous :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_live_woody      :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - foliar_moisture               :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_spread_adjustment        :: float &gt;= 0.0 (Optional: defaults to 1.0)</span>
<span class="org-doc">      - weather_spread_adjustment     :: float &gt;= 0.0 (Optional: defaults to 1.0)</span>
<span class="org-doc">    - t                            :: temporal integer index into the ISpaceTimeCube objects</span>
<span class="org-doc">    - y_range                      :: (min_y, max_y) spatial integer index into the ISpaceTimeCube objects (Optional)</span>
<span class="org-doc">    - x_range                      :: (min_x, max_x) spatial integer index into the ISpaceTimeCube objects (Optional)</span>
<span class="org-doc">    - use_wind_limit               :: boolean (Optional)</span>
<span class="org-doc">    - surface_lw_ratio_model       :: "rothermel" or "behave" (Optional)</span>
<span class="org-doc">    - crown_max_lw_ratio           :: float &gt; 0.0 (Optional)</span>

<span class="org-doc">    return a dictionary with these keys:</span>
<span class="org-doc">    - fire_type          :: 2D byte array (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)</span>
<span class="org-doc">    - spread_rate        :: 2D float array (m/min)</span>
<span class="org-doc">    - spread_direction   :: 2D float array (degrees clockwise from North)</span>
<span class="org-doc">    - fireline_intensity :: 2D float array (kW/m)</span>
<span class="org-doc">    - flame_length       :: 2D float array (m)</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">slope_cube</span>  : ISpaceTimeCube      <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"slope"</span>])
    <span class="org-variable-name">bands</span>       : pyidx               <span class="org-operator">=</span> slope_cube.shape[0]
    <span class="org-variable-name">rows</span>        : pyidx               <span class="org-operator">=</span> slope_cube.shape[1]
    <span class="org-variable-name">cols</span>        : pyidx               <span class="org-operator">=</span> slope_cube.shape[2]
    <span class="org-variable-name">grid_shape</span>  : <span class="org-builtin">tuple</span>[<span class="org-builtin">int</span>, <span class="org-builtin">int</span>]     <span class="org-operator">=</span> (rows, cols)
    <span class="org-variable-name">y_range_real</span>: <span class="org-builtin">tuple</span>[<span class="org-variable-name">pyidx</span>, <span class="org-variable-name">pyidx</span>] <span class="org-operator">=</span> to_positive_index_range(y_range, rows)
    <span class="org-variable-name">x_range_real</span>: <span class="org-builtin">tuple</span>[<span class="org-variable-name">pyidx</span>, <span class="org-variable-name">pyidx</span>] <span class="org-operator">=</span> to_positive_index_range(x_range, cols)
    <span class="org-variable-name">min_y</span>       : pyidx               <span class="org-operator">=</span> y_range_real[0]
    <span class="org-variable-name">max_y</span>       : pyidx               <span class="org-operator">=</span> y_range_real[1]
    <span class="org-variable-name">min_x</span>       : pyidx               <span class="org-operator">=</span> x_range_real[0]
    <span class="org-variable-name">max_x</span>       : pyidx               <span class="org-operator">=</span> x_range_real[1]

    <span class="org-keyword">if</span> <span class="org-keyword">not</span>(0 <span class="org-operator">&lt;=</span> t <span class="org-operator">&lt;</span> bands):
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The t value is out of range of the space_time_cubes."</span>)

    <span class="org-keyword">if</span> <span class="org-keyword">not</span>(0 <span class="org-operator">&lt;=</span> min_y <span class="org-operator">&lt;</span> max_y <span class="org-operator">&lt;=</span> rows):
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The y_range values are out of range of the space_time_cubes."</span>)

    <span class="org-keyword">if</span> <span class="org-keyword">not</span>(0 <span class="org-operator">&lt;=</span> min_x <span class="org-operator">&lt;</span> max_x <span class="org-operator">&lt;=</span> rows):
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The x_range values are out of range of the space_time_cubes."</span>)

    <span class="org-variable-name">fire_type_matrix</span>          : ndarray         <span class="org-operator">=</span> np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"uint8"</span>)
    <span class="org-variable-name">spread_rate_matrix</span>        : ndarray         <span class="org-operator">=</span> np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)
    <span class="org-variable-name">spread_direction_matrix</span>   : ndarray         <span class="org-operator">=</span> np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)
    <span class="org-variable-name">fireline_intensity_matrix</span> : ndarray         <span class="org-operator">=</span> np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)
    <span class="org-variable-name">flame_length_matrix</span>       : ndarray         <span class="org-operator">=</span> np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)
    <span class="org-variable-name">fire_type_memview</span>         : cy.uchar[:,::1] <span class="org-operator">=</span> fire_type_matrix
    <span class="org-variable-name">spread_rate_memview</span>       : cy.<span class="org-builtin">float</span>[:,::1] <span class="org-operator">=</span> spread_rate_matrix
    <span class="org-variable-name">spread_direction_memview</span>  : cy.<span class="org-builtin">float</span>[:,::1] <span class="org-operator">=</span> spread_direction_matrix
    <span class="org-variable-name">fireline_intensity_memview</span>: cy.<span class="org-builtin">float</span>[:,::1] <span class="org-operator">=</span> fireline_intensity_matrix
    <span class="org-variable-name">flame_length_memview</span>      : cy.<span class="org-builtin">float</span>[:,::1] <span class="org-operator">=</span> flame_length_matrix

    y                    : pyidx
    x                    : pyidx
    space_time_coordinate: coord_tyx
    <span class="org-keyword">for</span> y <span class="org-keyword">in</span> <span class="org-builtin">range</span>(min_y, max_y):
        <span class="org-keyword">for</span> x <span class="org-keyword">in</span> <span class="org-builtin">range</span>(min_x, max_x):
            <span class="org-variable-name">space_time_coordinate</span>          <span class="org-operator">=</span> (t, y, x)
            <span class="org-variable-name">spread_behavior</span>                <span class="org-operator">=</span> burn_cell_as_head_fire(space_time_cubes,
                                                                    space_time_coordinate,
                                                                    use_wind_limit,
                                                                    surface_lw_ratio_model,
                                                                    crown_max_lw_ratio)
            <span class="org-variable-name">fire_type_memview</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]          <span class="org-operator">=</span> spread_behavior[<span class="org-string">"fire_type"</span>]
            <span class="org-variable-name">spread_rate_memview</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]        <span class="org-operator">=</span> spread_behavior[<span class="org-string">"spread_rate"</span>]
            <span class="org-variable-name">spread_direction_memview</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]   <span class="org-operator">=</span> vu.spread_direction_vector_to_angle(spread_behavior[<span class="org-string">"spread_direction"</span>])
            <span class="org-variable-name">fireline_intensity_memview</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>] <span class="org-operator">=</span> spread_behavior[<span class="org-string">"fireline_intensity"</span>]
            <span class="org-variable-name">flame_length_memview</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]       <span class="org-operator">=</span> spread_behavior[<span class="org-string">"flame_length"</span>]

    <span class="org-keyword">return</span> {
        <span class="org-string">"fire_type"</span>         : fire_type_matrix,
        <span class="org-string">"spread_rate"</span>       : spread_rate_matrix,
        <span class="org-string">"spread_direction"</span>  : spread_direction_matrix,
        <span class="org-string">"fireline_intensity"</span>: fireline_intensity_matrix,
        <span class="org-string">"flame_length"</span>      : flame_length_matrix,
    }
</pre>
</div>
</div>
</div>

<div id="outline-container-burn-cells-in-any-direction" class="outline-4">
<h4 id="burn-cells-in-any-direction"><span class="section-number-4">8.1.3.</span> Burn Cells in Any Direction</h4>
<div class="outline-text-4" id="text-burn-cells-in-any-direction">
<p>
When the goal of a fire behavior analysis is to evolve a burn scar
from its point of ignition into a generally conical shape in
space-time, then it is necessary to evaluate the combined surface and
crown fire behavior in the direction normal to the fire front. In
order to facilitate this calculation, the following function takes an
azimuth (degrees clockwise from North), meant to represent the spatial
direction in which the fire front is spreading from a given grid cell.
It first projects this 2D direction onto the local slope-tangential
plane and computes the surface fire behavior in this direction. If a
crown fire occurs, the crown fire behavior is also calculated in the
azimuth direction, and the combined surface and crown fire behavior
(as per section <a href="#combining-surface-and-crown-fire-behavior">6.1.8</a>) is
returned. If no crown fire occurs, the surface fire behavior in the
azimuth direction is returned.
</p>

<div class="org-src-container">
<pre class="src src-python" id="burn-cells-toward-azimuth"><span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">burn_cell_toward_azimuth</span>(space_time_cubes      : <span class="org-builtin">dict</span>[<span class="org-builtin">str</span>, ISpaceTimeCube],
                             space_time_coordinate : coord_tyx,
                             azimuth               : cy.<span class="org-builtin">float</span>,
                             use_wind_limit        : cy.bint <span class="org-operator">=</span> <span class="org-constant">True</span>,
                             surface_lw_ratio_model: <span class="org-builtin">str</span> <span class="org-operator">=</span> <span class="org-string">"behave"</span>,
                             crown_max_lw_ratio    : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 1e10) <span class="org-operator">-&gt;</span> <span class="org-builtin">dict</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - space_time_cubes             :: dictionary of (Lazy)SpaceTimeCube objects with these cell types</span>
<span class="org-doc">      - slope                         :: rise/run</span>
<span class="org-doc">      - aspect                        :: degrees clockwise from North</span>
<span class="org-doc">      - fuel_model                    :: integer index in fm.fuel_model_table</span>
<span class="org-doc">      - canopy_cover                  :: 0-1</span>
<span class="org-doc">      - canopy_height                 :: m</span>
<span class="org-doc">      - canopy_base_height            :: m</span>
<span class="org-doc">      - canopy_bulk_density           :: kg/m^3</span>
<span class="org-doc">      - wind_speed_10m                :: km/hr</span>
<span class="org-doc">      - upwind_direction              :: degrees clockwise from North</span>
<span class="org-doc">      - fuel_moisture_dead_1hr        :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_dead_10hr       :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_dead_100hr      :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_live_herbaceous :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_live_woody      :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - foliar_moisture               :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_spread_adjustment        :: float &gt;= 0.0 (Optional: defaults to 1.0)</span>
<span class="org-doc">      - weather_spread_adjustment     :: float &gt;= 0.0 (Optional: defaults to 1.0)</span>
<span class="org-doc">    - space_time_coordinate        :: (t,y,x)</span>
<span class="org-doc">    - azimuth                      :: degrees clockwise from North on the horizontal plane</span>
<span class="org-doc">    - use_wind_limit               :: boolean (Optional)</span>
<span class="org-doc">    - surface_lw_ratio_model       :: "rothermel" or "behave" (Optional)</span>
<span class="org-doc">    - crown_max_lw_ratio           :: float &gt; 0.0 (Optional)</span>

<span class="org-doc">    return a dictionary with these fire behavior values for the space-time coordinate (t,y,x):</span>
<span class="org-doc">    - fire_type          :: 0 (unburned), 1 (surface), 2 (passive_crown), or 3 (active_crown)</span>
<span class="org-doc">    - spread_rate        :: m/min</span>
<span class="org-doc">    - spread_direction   :: (x, y, z) unit vector on the slope-tangential plane</span>
<span class="org-doc">    - fireline_intensity :: kW/m</span>
<span class="org-doc">    - flame_length       :: m</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the space_time_coordinate</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    (<span class="org-variable-name">t</span>, <span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>) <span class="org-operator">=</span> space_time_coordinate

    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack the space_time_cubes dictionary</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Topography, Fuel Model, and Vegetation</span>
    <span class="org-variable-name">slope</span>              : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"slope"</span>]).get(t, y, x)
    <span class="org-variable-name">aspect</span>             : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"aspect"</span>]).get(t, y, x)
    <span class="org-variable-name">fuel_model_number</span>  : cy.<span class="org-builtin">int</span>   <span class="org-operator">=</span> cy.cast(cy.<span class="org-builtin">int</span>, cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"fuel_model"</span>]).get(t, y, x))
    <span class="org-variable-name">canopy_cover</span>       : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"canopy_cover"</span>]).get(t, y, x)
    <span class="org-variable-name">canopy_height</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"canopy_height"</span>]).get(t, y, x)
    <span class="org-variable-name">canopy_base_height</span> : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"canopy_base_height"</span>]).get(t, y, x)
    <span class="org-variable-name">canopy_bulk_density</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"canopy_bulk_density"</span>]).get(t, y, x)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Wind, Surface Moisture, and Foliar Moisture</span>
    <span class="org-variable-name">wind_speed_10m</span>               : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"wind_speed_10m"</span>]).get(t, y, x)
    <span class="org-variable-name">upwind_direction</span>             : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"upwind_direction"</span>]).get(t, y, x)
    <span class="org-variable-name">fuel_moisture_dead_1hr</span>       : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"fuel_moisture_dead_1hr"</span>]).get(t, y, x)
    <span class="org-variable-name">fuel_moisture_dead_10hr</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"fuel_moisture_dead_10hr"</span>]).get(t, y, x)
    <span class="org-variable-name">fuel_moisture_dead_100hr</span>     : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"fuel_moisture_dead_100hr"</span>]).get(t, y, x)
    <span class="org-variable-name">fuel_moisture_live_herbaceous</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"fuel_moisture_live_herbaceous"</span>]).get(t, y, x)
    <span class="org-variable-name">fuel_moisture_live_woody</span>     : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"fuel_moisture_live_woody"</span>]).get(t, y, x)
    <span class="org-variable-name">foliar_moisture</span>              : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"foliar_moisture"</span>]).get(t, y, x)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Spread Rate Adjustments (Optional)</span>
    <span class="org-variable-name">fuel_spread_adjustment</span>   : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"fuel_spread_adjustment"</span>]).get(t, y, x)
                                           <span class="org-keyword">if</span> <span class="org-string">"fuel_spread_adjustment"</span> <span class="org-keyword">in</span> space_time_cubes
                                           <span class="org-keyword">else</span> 1.0)                                         <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>
    <span class="org-variable-name">weather_spread_adjustment</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"weather_spread_adjustment"</span>]).get(t, y, x)
                                           <span class="org-keyword">if</span> <span class="org-string">"weather_spread_adjustment"</span> <span class="org-keyword">in</span> space_time_cubes
                                           <span class="org-keyword">else</span> 1.0)                                         <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>
    <span class="org-variable-name">spread_rate_adjustment</span>   : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> fuel_spread_adjustment <span class="org-operator">*</span> weather_spread_adjustment <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>

    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Project a 2D unit vector pointing toward the azimuth onto the slope-tangential plane</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    <span class="org-variable-name">upslope_direction</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> conv.opposite_direction(aspect)
    <span class="org-variable-name">slope_vector_2d</span>  : vec_xy   <span class="org-operator">=</span> conv.azimuthal_to_cartesian(slope, upslope_direction)
    <span class="org-variable-name">azimuth_vector_2d</span>: vec_xy   <span class="org-operator">=</span> conv.azimuthal_to_cartesian(1.0, azimuth)
    <span class="org-variable-name">spread_direction</span> : vec_xyz  <span class="org-operator">=</span> vu.as_unit_vector_3d(vu.to_slope_plane(azimuth_vector_2d, slope_vector_2d))

    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Check whether cell is burnable</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    fuel_model      : FuelModel
    maybe_fuel_model: FuelModel<span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> fm.fuel_model_table.get(fuel_model_number)

    <span class="org-keyword">if</span> maybe_fuel_model:
        <span class="org-variable-name">fuel_model</span> <span class="org-operator">=</span> maybe_fuel_model

    <span class="org-keyword">if</span> (maybe_fuel_model <span class="org-keyword">is</span> <span class="org-constant">None</span> <span class="org-keyword">or</span> <span class="org-keyword">not</span>(fuel_model.burnable)):
        <span class="org-comment-delimiter"># </span><span class="org-comment">Encountered unknown or non-burnable fuel model</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Return zero surface fire behavior in the direction of the azimuth vector</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-keyword">return</span> {
            <span class="org-string">"fire_type"</span>         : 0, <span class="org-comment-delimiter"># </span><span class="org-comment">unburned</span>
            <span class="org-string">"spread_rate"</span>       : 0.0,
            <span class="org-string">"spread_direction"</span>  : spread_direction,
            <span class="org-string">"fireline_intensity"</span>: 0.0,
            <span class="org-string">"flame_length"</span>      : 0.0,
        }

    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Encountered burnable fuel model</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Compute derived parameters</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-variable-name">fuel_moisture</span>               : fclaarr  <span class="org-operator">=</span> (fuel_moisture_dead_1hr,
                                                  fuel_moisture_dead_10hr,
                                                  fuel_moisture_dead_100hr,
                                                  0.0, <span class="org-comment-delimiter"># </span><span class="org-comment">fuel_moisture_dead_herbaceous</span>
                                                  fuel_moisture_live_herbaceous,
                                                  fuel_moisture_live_woody) <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
        <span class="org-variable-name">fuel_bed_depth</span>              : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> fuel_model.delta                      <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
        <span class="org-variable-name">heat_of_combustion</span>          : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> conv.Btu_lb_to_kJ_kg(fuel_model.h[0]) <span class="org-comment-delimiter"># </span><span class="org-comment">kJ/kg</span>
        <span class="org-variable-name">estimated_fine_fuel_moisture</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> fuel_moisture_dead_1hr                <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate midflame wind speed</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 10m wind speed to 20ft wind speed</span>
        <span class="org-variable-name">wind_speed_20ft</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> conv.wind_speed_10m_to_wind_speed_20ft(wind_speed_10m) <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Convert 20ft wind speed from km/hr to m/min</span>
        <span class="org-variable-name">wind_speed_20ft_m_min</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> conv.km_hr_to_m_min(wind_speed_20ft) <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 20ft wind speed to midflame wind speed in m/min</span>
        <span class="org-variable-name">midflame_wind_speed</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> sf.calc_midflame_wind_speed(wind_speed_20ft_m_min,       <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
                                                                    fuel_bed_depth,              <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                                    conv.m_to_ft(canopy_height), <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                                    canopy_cover)                <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Apply fuel moisture to fuel model</span>
        <span class="org-variable-name">moisturized_fuel_model</span>: FuelModel <span class="org-operator">=</span> fm.moisturize(fuel_model, fuel_moisture)

        <span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Memoize calc_surface_fire_behavior_no_wind_no_slope</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate no-wind-no-slope surface fire behavior</span>
        <span class="org-variable-name">surface_fire_min</span>: FireBehaviorMin <span class="org-operator">=</span> sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model,
                                                                                           spread_rate_adjustment)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread</span>
        <span class="org-variable-name">surface_fire_max</span>: FireBehaviorMax <span class="org-operator">=</span> sf.calc_surface_fire_behavior_max(surface_fire_min,
                                                                              midflame_wind_speed,
                                                                              upwind_direction,
                                                                              slope,
                                                                              aspect,
                                                                              use_wind_limit,
                                                                              surface_lw_ratio_model)

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of the azimuth vector</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-variable-name">surface_fire_azimuth</span>: SpreadBehavior <span class="org-operator">=</span> sf.calc_surface_fire_behavior_in_direction(surface_fire_max,
                                                                                          spread_direction)

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Determine whether the surface fire transitions to a crown fire</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-keyword">if</span> cf.van_wagner_crown_fire_initiation(surface_fire_azimuth.fireline_intensity,
                                               canopy_cover,
                                               canopy_base_height,
                                               foliar_moisture):

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction of maximum spread</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-variable-name">crown_fire_max</span>: FireBehaviorMax <span class="org-operator">=</span> cf.calc_crown_fire_behavior_max(canopy_height, canopy_base_height,
                                                                              canopy_bulk_density, heat_of_combustion,
                                                                              estimated_fine_fuel_moisture,
                                                                              wind_speed_10m, upwind_direction,
                                                                              slope, aspect, crown_max_lw_ratio)

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction of the azimuth vector</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-variable-name">crown_fire_azimuth</span>: SpreadBehavior <span class="org-operator">=</span> cf.calc_crown_fire_behavior_in_direction(crown_fire_max,
                                                                                          spread_direction)

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate combined fire behavior in the direction of the azimuth vector</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-variable-name">combined_fire_azimuth</span>: SpreadBehavior <span class="org-operator">=</span> cf.calc_combined_fire_behavior(surface_fire_azimuth,
                                                                                   crown_fire_azimuth)

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Return the combined fire behavior in the direction of the azimuth vector</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-keyword">return</span> SpreadBehavior_to_dict(combined_fire_azimuth)

        <span class="org-keyword">else</span>:

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Return the surface fire behavior in the direction of the azimuth vector</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-keyword">return</span> SpreadBehavior_to_dict(surface_fire_azimuth)


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Make a more efficient version that avoids space_time_cubes dictionary lookups for each cell</span>
<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">burn_all_cells_toward_azimuth</span>(space_time_cubes      : <span class="org-builtin">dict</span>[<span class="org-builtin">str</span>, ISpaceTimeCube],
                                  azimuth               : cy.<span class="org-builtin">float</span>,
                                  t                     : pyidx,
                                  y_range               : <span class="org-builtin">tuple</span>[pyidx, pyidx]<span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> <span class="org-constant">None</span>,
                                  x_range               : <span class="org-builtin">tuple</span>[pyidx, pyidx]<span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> <span class="org-constant">None</span>,
                                  use_wind_limit        : cy.bint <span class="org-operator">=</span> <span class="org-constant">True</span>,
                                  surface_lw_ratio_model: <span class="org-builtin">str</span> <span class="org-operator">=</span> <span class="org-string">"behave"</span>,
                                  crown_max_lw_ratio    : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 1e10) <span class="org-operator">-&gt;</span> <span class="org-builtin">dict</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - space_time_cubes             :: dictionary of (Lazy)SpaceTimeCube objects with these cell types</span>
<span class="org-doc">      - slope                         :: rise/run</span>
<span class="org-doc">      - aspect                        :: degrees clockwise from North</span>
<span class="org-doc">      - fuel_model                    :: integer index in fm.fuel_model_table</span>
<span class="org-doc">      - canopy_cover                  :: 0-1</span>
<span class="org-doc">      - canopy_height                 :: m</span>
<span class="org-doc">      - canopy_base_height            :: m</span>
<span class="org-doc">      - canopy_bulk_density           :: kg/m^3</span>
<span class="org-doc">      - wind_speed_10m                :: km/hr</span>
<span class="org-doc">      - upwind_direction              :: degrees clockwise from North</span>
<span class="org-doc">      - fuel_moisture_dead_1hr        :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_dead_10hr       :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_dead_100hr      :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_live_herbaceous :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_live_woody      :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - foliar_moisture               :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_spread_adjustment        :: float &gt;= 0.0 (Optional: defaults to 1.0)</span>
<span class="org-doc">      - weather_spread_adjustment     :: float &gt;= 0.0 (Optional: defaults to 1.0)</span>
<span class="org-doc">    - azimuth                      :: degrees clockwise from North on the horizontal plane</span>
<span class="org-doc">    - t                            :: temporal integer index into the ISpaceTimeCube objects</span>
<span class="org-doc">    - y_range                      :: (min_y, max_y) spatial integer index into the ISpaceTimeCube objects (Optional)</span>
<span class="org-doc">    - x_range                      :: (min_x, max_x) spatial integer index into the ISpaceTimeCube objects (Optional)</span>
<span class="org-doc">    - use_wind_limit               :: boolean (Optional)</span>
<span class="org-doc">    - surface_lw_ratio_model       :: "rothermel" or "behave" (Optional)</span>
<span class="org-doc">    - crown_max_lw_ratio           :: float &gt; 0.0 (Optional)</span>

<span class="org-doc">    return a dictionary with these keys:</span>
<span class="org-doc">    - fire_type          :: 2D byte array (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)</span>
<span class="org-doc">    - spread_rate        :: 2D float array (m/min)</span>
<span class="org-doc">    - spread_direction   :: 2D float array (degrees clockwise from North)</span>
<span class="org-doc">    - fireline_intensity :: 2D float array (kW/m)</span>
<span class="org-doc">    - flame_length       :: 2D float array (m)</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">slope_cube</span>  : ISpaceTimeCube      <span class="org-operator">=</span> cy.cast(ISpaceTimeCube, space_time_cubes[<span class="org-string">"slope"</span>])
    <span class="org-variable-name">bands</span>       : pyidx               <span class="org-operator">=</span> slope_cube.shape[0]
    <span class="org-variable-name">rows</span>        : pyidx               <span class="org-operator">=</span> slope_cube.shape[1]
    <span class="org-variable-name">cols</span>        : pyidx               <span class="org-operator">=</span> slope_cube.shape[2]
    <span class="org-variable-name">grid_shape</span>  : <span class="org-builtin">tuple</span>[<span class="org-builtin">int</span>, <span class="org-builtin">int</span>]     <span class="org-operator">=</span> (rows, cols)
    <span class="org-variable-name">y_range_real</span>: <span class="org-builtin">tuple</span>[<span class="org-variable-name">pyidx</span>, <span class="org-variable-name">pyidx</span>] <span class="org-operator">=</span> to_positive_index_range(y_range, rows)
    <span class="org-variable-name">x_range_real</span>: <span class="org-builtin">tuple</span>[<span class="org-variable-name">pyidx</span>, <span class="org-variable-name">pyidx</span>] <span class="org-operator">=</span> to_positive_index_range(x_range, cols)
    <span class="org-variable-name">min_y</span>       : pyidx               <span class="org-operator">=</span> y_range_real[0]
    <span class="org-variable-name">max_y</span>       : pyidx               <span class="org-operator">=</span> y_range_real[1]
    <span class="org-variable-name">min_x</span>       : pyidx               <span class="org-operator">=</span> x_range_real[0]
    <span class="org-variable-name">max_x</span>       : pyidx               <span class="org-operator">=</span> x_range_real[1]

    <span class="org-keyword">if</span> <span class="org-keyword">not</span>(0 <span class="org-operator">&lt;=</span> t <span class="org-operator">&lt;</span> bands):
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The t value is out of range of the space_time_cubes."</span>)

    <span class="org-keyword">if</span> <span class="org-keyword">not</span>(0 <span class="org-operator">&lt;=</span> min_y <span class="org-operator">&lt;</span> max_y <span class="org-operator">&lt;=</span> rows):
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The y_range values are out of range of the space_time_cubes."</span>)

    <span class="org-keyword">if</span> <span class="org-keyword">not</span>(0 <span class="org-operator">&lt;=</span> min_x <span class="org-operator">&lt;</span> max_x <span class="org-operator">&lt;=</span> rows):
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The x_range values are out of range of the space_time_cubes."</span>)

    <span class="org-variable-name">fire_type_matrix</span>          : ndarray         <span class="org-operator">=</span> np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"uint8"</span>)
    <span class="org-variable-name">spread_rate_matrix</span>        : ndarray         <span class="org-operator">=</span> np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)
    <span class="org-variable-name">spread_direction_matrix</span>   : ndarray         <span class="org-operator">=</span> np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)
    <span class="org-variable-name">fireline_intensity_matrix</span> : ndarray         <span class="org-operator">=</span> np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)
    <span class="org-variable-name">flame_length_matrix</span>       : ndarray         <span class="org-operator">=</span> np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)
    <span class="org-variable-name">fire_type_memview</span>         : cy.uchar[:,::1] <span class="org-operator">=</span> fire_type_matrix
    <span class="org-variable-name">spread_rate_memview</span>       : cy.<span class="org-builtin">float</span>[:,::1] <span class="org-operator">=</span> spread_rate_matrix
    <span class="org-variable-name">spread_direction_memview</span>  : cy.<span class="org-builtin">float</span>[:,::1] <span class="org-operator">=</span> spread_direction_matrix
    <span class="org-variable-name">fireline_intensity_memview</span>: cy.<span class="org-builtin">float</span>[:,::1] <span class="org-operator">=</span> fireline_intensity_matrix
    <span class="org-variable-name">flame_length_memview</span>      : cy.<span class="org-builtin">float</span>[:,::1] <span class="org-operator">=</span> flame_length_matrix

    y                    : pyidx
    x                    : pyidx
    space_time_coordinate: coord_tyx
    <span class="org-keyword">for</span> y <span class="org-keyword">in</span> <span class="org-builtin">range</span>(min_y, max_y):
        <span class="org-keyword">for</span> x <span class="org-keyword">in</span> <span class="org-builtin">range</span>(min_x, max_x):
            <span class="org-variable-name">space_time_coordinate</span>          <span class="org-operator">=</span> (t, y, x)
            <span class="org-variable-name">spread_behavior</span>                <span class="org-operator">=</span> burn_cell_toward_azimuth(space_time_cubes,
                                                                      space_time_coordinate,
                                                                      azimuth,
                                                                      use_wind_limit,
                                                                      surface_lw_ratio_model,
                                                                      crown_max_lw_ratio)
            <span class="org-variable-name">fire_type_memview</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]          <span class="org-operator">=</span> spread_behavior[<span class="org-string">"fire_type"</span>]
            <span class="org-variable-name">spread_rate_memview</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]        <span class="org-operator">=</span> spread_behavior[<span class="org-string">"spread_rate"</span>]
            <span class="org-variable-name">spread_direction_memview</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]   <span class="org-operator">=</span> vu.spread_direction_vector_to_angle(spread_behavior[<span class="org-string">"spread_direction"</span>])
            <span class="org-variable-name">fireline_intensity_memview</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>] <span class="org-operator">=</span> spread_behavior[<span class="org-string">"fireline_intensity"</span>]
            <span class="org-variable-name">flame_length_memview</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]       <span class="org-operator">=</span> spread_behavior[<span class="org-string">"flame_length"</span>]

    <span class="org-keyword">return</span> {
        <span class="org-string">"fire_type"</span>         : fire_type_matrix,
        <span class="org-string">"spread_rate"</span>       : spread_rate_matrix,
        <span class="org-string">"spread_direction"</span>  : spread_direction_matrix,
        <span class="org-string">"fireline_intensity"</span>: fireline_intensity_matrix,
        <span class="org-string">"flame_length"</span>      : flame_length_matrix,
    }
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-for-users-burn-cells" class="outline-3">
<h3 id="for-users-burn-cells"><span class="section-number-3">8.2.</span> For Users</h3>
<div class="outline-text-3" id="text-for-users-burn-cells">
<p>
In the following sections, we will demonstrate how to calculate the
combined surface and crown fire behavior first in the direction of
maximum spread and then in any direction.
</p>
</div>

<div id="outline-container-how-to-burn-a-single-cell-as-a-head-fire" class="outline-4">
<h4 id="how-to-burn-a-single-cell-as-a-head-fire"><span class="section-number-4">8.2.1.</span> How to Burn a Single Cell as a Head Fire</h4>
<div class="outline-text-4" id="text-how-to-burn-a-single-cell-as-a-head-fire">
<div class="org-src-container">
<pre class="src src-python" id="run-burn-cell-as-head-fire"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube
<span class="org-keyword">import</span> pyretechnics.burn_cells <span class="org-keyword">as</span> bc

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (
    240,  <span class="org-comment-delimiter"># </span><span class="org-comment">bands: 10 days @ 1 hour/band</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">rows:  30 km @ 30 meters/row</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">cols:  30 km @ 30 meters/col</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Create an input dictionary of SpaceTimeCubes (using constant data for this example)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">space_time_cubes</span> <span class="org-operator">=</span> {
    <span class="org-string">"slope"</span>                        : SpaceTimeCube(cube_shape, 0.8),   <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-string">"aspect"</span>                       : SpaceTimeCube(cube_shape, 225.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_model"</span>                   : SpaceTimeCube(cube_shape, 101),   <span class="org-comment-delimiter"># </span><span class="org-comment">integer index in fm.fuel_model_table</span>
    <span class="org-string">"canopy_cover"</span>                 : SpaceTimeCube(cube_shape, 0.6),   <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
    <span class="org-string">"canopy_height"</span>                : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_base_height"</span>           : SpaceTimeCube(cube_shape, 3.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_bulk_density"</span>          : SpaceTimeCube(cube_shape, 0.3),   <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>
    <span class="org-string">"wind_speed_10m"</span>               : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-string">"upwind_direction"</span>             : SpaceTimeCube(cube_shape, 180.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_moisture_dead_1hr"</span>       : SpaceTimeCube(cube_shape, 0.05),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_10hr"</span>      : SpaceTimeCube(cube_shape, 0.10),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_100hr"</span>     : SpaceTimeCube(cube_shape, 0.15),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_herbaceous"</span>: SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_woody"</span>     : SpaceTimeCube(cube_shape, 0.60),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"foliar_moisture"</span>              : SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_spread_adjustment"</span>       : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
    <span class="org-string">"weather_spread_adjustment"</span>    : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
}

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify a space-time coordinate (t,y,x) within the extent of the SpaceTimeCube dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">space_time_coordinate</span> <span class="org-operator">=</span> (24, 100, 100)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate combined fire behavior in the direction of maximum spread (with wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">combined_behavior_limited</span> <span class="org-operator">=</span> bc.burn_cell_as_head_fire(space_time_cubes,
                                                      space_time_coordinate,
                                                      surface_lw_ratio_model<span class="org-operator">=</span><span class="org-string">"rothermel"</span>)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate combined fire behavior in the direction of maximum spread (without wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">combined_behavior_unlimited</span> <span class="org-operator">=</span> bc.burn_cell_as_head_fire(space_time_cubes,
                                                        space_time_coordinate,
                                                        use_wind_limit<span class="org-operator">=</span><span class="org-constant">False</span>,
                                                        surface_lw_ratio_model<span class="org-operator">=</span><span class="org-string">"rothermel"</span>)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Display combined fire behavior in the direction of maximum spread (with wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"Fire Behavior from Combined Surface and Crown Fire (with Wind Limit) at Coordinate "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(space_time_coordinate) <span class="org-operator">+</span> <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 100)
pprint(combined_behavior_limited)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Display combined fire behavior in the direction of maximum spread (without wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Fire Behavior from Combined Surface and Crown Fire (without Wind Limit) at Coordinate "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(space_time_coordinate) <span class="org-operator">+</span> <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 100)
pprint(combined_behavior_unlimited)
</pre>
</div>

<pre class="example" id="run-burn-cell-as-head-fire-results">
Fire Behavior from Combined Surface and Crown Fire (with Wind Limit) at Coordinate (24, 100, 100)
====================================================================================================
{'fire_type': 1,
 'fireline_intensity': 32.52825927734375,
 'flame_length': 0.3843933939933777,
 'spread_direction': (0.4869149327278137,
                      0.6130024194717407,
                      0.6222072243690491),
 'spread_rate': 2.2964677810668945}

Fire Behavior from Combined Surface and Crown Fire (without Wind Limit) at Coordinate (24, 100, 100)
====================================================================================================
{'fire_type': 1,
 'fireline_intensity': 50.6082878112793,
 'flame_length': 0.4710617959499359,
 'spread_direction': (0.4869149327278137,
                      0.6130024194717407,
                      0.6222072243690491),
 'spread_rate': 3.5729029178619385}
</pre>
</div>
</div>

<div id="outline-container-how-to-burn-a-region-of-cells-as-a-head-fire" class="outline-4">
<h4 id="how-to-burn-a-region-of-cells-as-a-head-fire"><span class="section-number-4">8.2.2.</span> How to Burn a Region of Cells as a Head Fire</h4>
<div class="outline-text-4" id="text-how-to-burn-a-region-of-cells-as-a-head-fire">
<div class="org-src-container">
<pre class="src src-python" id="run-burn-all-cells-as-head-fire"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube
<span class="org-keyword">import</span> pyretechnics.burn_cells <span class="org-keyword">as</span> bc

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (
    240,  <span class="org-comment-delimiter"># </span><span class="org-comment">bands: 10 days @ 1 hour/band</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">rows:  30 km @ 30 meters/row</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">cols:  30 km @ 30 meters/col</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Create an input dictionary of SpaceTimeCubes (using constant data for this example)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">space_time_cubes</span> <span class="org-operator">=</span> {
    <span class="org-string">"slope"</span>                        : SpaceTimeCube(cube_shape, 0.8),   <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-string">"aspect"</span>                       : SpaceTimeCube(cube_shape, 225.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_model"</span>                   : SpaceTimeCube(cube_shape, 101),   <span class="org-comment-delimiter"># </span><span class="org-comment">integer index in fm.fuel_model_table</span>
    <span class="org-string">"canopy_cover"</span>                 : SpaceTimeCube(cube_shape, 0.6),   <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
    <span class="org-string">"canopy_height"</span>                : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_base_height"</span>           : SpaceTimeCube(cube_shape, 3.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_bulk_density"</span>          : SpaceTimeCube(cube_shape, 0.3),   <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>
    <span class="org-string">"wind_speed_10m"</span>               : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-string">"upwind_direction"</span>             : SpaceTimeCube(cube_shape, 180.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_moisture_dead_1hr"</span>       : SpaceTimeCube(cube_shape, 0.05),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_10hr"</span>      : SpaceTimeCube(cube_shape, 0.10),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_100hr"</span>     : SpaceTimeCube(cube_shape, 0.15),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_herbaceous"</span>: SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_woody"</span>     : SpaceTimeCube(cube_shape, 0.60),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"foliar_moisture"</span>              : SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_spread_adjustment"</span>       : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
    <span class="org-string">"weather_spread_adjustment"</span>    : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
}

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify a space-time region (t, (y_min, y_max), (x_min, x_max))</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">within the extent of the SpaceTimeCube dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">t</span>       <span class="org-operator">=</span> 24
<span class="org-variable-name">y_range</span> <span class="org-operator">=</span> (100,105)
<span class="org-variable-name">x_range</span> <span class="org-operator">=</span> (100,105)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate combined fire behavior in the direction of maximum spread (with wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">combined_behavior_limited</span> <span class="org-operator">=</span> bc.burn_all_cells_as_head_fire(space_time_cubes,
                                                           t,
                                                           y_range,
                                                           x_range,
                                                           surface_lw_ratio_model<span class="org-operator">=</span><span class="org-string">"rothermel"</span>)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate combined fire behavior in the direction of maximum spread (without wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">combined_behavior_unlimited</span> <span class="org-operator">=</span> bc.burn_all_cells_as_head_fire(space_time_cubes,
                                                             t,
                                                             y_range,
                                                             x_range,
                                                             use_wind_limit<span class="org-operator">=</span><span class="org-constant">False</span>,
                                                             surface_lw_ratio_model<span class="org-operator">=</span><span class="org-string">"rothermel"</span>)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Display combined fire behavior in the direction of maximum spread (with wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"Fire Behavior from Combined Surface and Crown Fire (with Wind Limit) at Space-Time Region "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>((t, y_range, x_range)) <span class="org-operator">+</span> <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 121)
<span class="org-keyword">for</span> (name, matrix) <span class="org-keyword">in</span> combined_behavior_limited.items():
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Layer: "</span> <span class="org-operator">+</span> name)
    <span class="org-builtin">print</span>(matrix[100:105,100:105])

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Display combined fire behavior in the direction of maximum spread (without wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Fire Behavior from Combined Surface and Crown Fire (without Wind Limit) at Space-Time Region "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>((t, y_range, x_range)) <span class="org-operator">+</span> <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 121)
<span class="org-keyword">for</span> (name, matrix) <span class="org-keyword">in</span> combined_behavior_unlimited.items():
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Layer: "</span> <span class="org-operator">+</span> name)
    <span class="org-builtin">print</span>(matrix[100:105,100:105])
</pre>
</div>

<pre class="example" id="run-burn-all-cells-as-head-fire-results">
Fire Behavior from Combined Surface and Crown Fire (with Wind Limit) at Space-Time Region (24, (100, 105), (100, 105))
=========================================================================================================================

Layer: fire_type
[[1 1 1 1 1]
 [1 1 1 1 1]
 [1 1 1 1 1]
 [1 1 1 1 1]
 [1 1 1 1 1]]

Layer: spread_rate
[[2.2964678 2.2964678 2.2964678 2.2964678 2.2964678]
 [2.2964678 2.2964678 2.2964678 2.2964678 2.2964678]
 [2.2964678 2.2964678 2.2964678 2.2964678 2.2964678]
 [2.2964678 2.2964678 2.2964678 2.2964678 2.2964678]
 [2.2964678 2.2964678 2.2964678 2.2964678 2.2964678]]

Layer: spread_direction
[[38.46052 38.46052 38.46052 38.46052 38.46052]
 [38.46052 38.46052 38.46052 38.46052 38.46052]
 [38.46052 38.46052 38.46052 38.46052 38.46052]
 [38.46052 38.46052 38.46052 38.46052 38.46052]
 [38.46052 38.46052 38.46052 38.46052 38.46052]]

Layer: fireline_intensity
[[32.52826 32.52826 32.52826 32.52826 32.52826]
 [32.52826 32.52826 32.52826 32.52826 32.52826]
 [32.52826 32.52826 32.52826 32.52826 32.52826]
 [32.52826 32.52826 32.52826 32.52826 32.52826]
 [32.52826 32.52826 32.52826 32.52826 32.52826]]

Layer: flame_length
[[0.3843934 0.3843934 0.3843934 0.3843934 0.3843934]
 [0.3843934 0.3843934 0.3843934 0.3843934 0.3843934]
 [0.3843934 0.3843934 0.3843934 0.3843934 0.3843934]
 [0.3843934 0.3843934 0.3843934 0.3843934 0.3843934]
 [0.3843934 0.3843934 0.3843934 0.3843934 0.3843934]]

Fire Behavior from Combined Surface and Crown Fire (without Wind Limit) at Space-Time Region (24, (100, 105), (100, 105))
=========================================================================================================================

Layer: fire_type
[[1 1 1 1 1]
 [1 1 1 1 1]
 [1 1 1 1 1]
 [1 1 1 1 1]
 [1 1 1 1 1]]

Layer: spread_rate
[[3.572903 3.572903 3.572903 3.572903 3.572903]
 [3.572903 3.572903 3.572903 3.572903 3.572903]
 [3.572903 3.572903 3.572903 3.572903 3.572903]
 [3.572903 3.572903 3.572903 3.572903 3.572903]
 [3.572903 3.572903 3.572903 3.572903 3.572903]]

Layer: spread_direction
[[38.46052 38.46052 38.46052 38.46052 38.46052]
 [38.46052 38.46052 38.46052 38.46052 38.46052]
 [38.46052 38.46052 38.46052 38.46052 38.46052]
 [38.46052 38.46052 38.46052 38.46052 38.46052]
 [38.46052 38.46052 38.46052 38.46052 38.46052]]

Layer: fireline_intensity
[[50.608288 50.608288 50.608288 50.608288 50.608288]
 [50.608288 50.608288 50.608288 50.608288 50.608288]
 [50.608288 50.608288 50.608288 50.608288 50.608288]
 [50.608288 50.608288 50.608288 50.608288 50.608288]
 [50.608288 50.608288 50.608288 50.608288 50.608288]]

Layer: flame_length
[[0.4710618 0.4710618 0.4710618 0.4710618 0.4710618]
 [0.4710618 0.4710618 0.4710618 0.4710618 0.4710618]
 [0.4710618 0.4710618 0.4710618 0.4710618 0.4710618]
 [0.4710618 0.4710618 0.4710618 0.4710618 0.4710618]
 [0.4710618 0.4710618 0.4710618 0.4710618 0.4710618]]
</pre>
</div>
</div>

<div id="outline-container-how-to-burn-a-single-cell-in-any-direction" class="outline-4">
<h4 id="how-to-burn-a-single-cell-in-any-direction"><span class="section-number-4">8.2.3.</span> How to Burn a Single Cell in Any Direction</h4>
<div class="outline-text-4" id="text-how-to-burn-a-single-cell-in-any-direction">
<div class="org-src-container">
<pre class="src src-python" id="run-burn-cell-toward-azimuth"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube
<span class="org-keyword">import</span> pyretechnics.burn_cells <span class="org-keyword">as</span> bc

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (
    240,  <span class="org-comment-delimiter"># </span><span class="org-comment">bands: 10 days @ 1 hour/band</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">rows:  30 km @ 30 meters/row</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">cols:  30 km @ 30 meters/col</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Create an input dictionary of SpaceTimeCubes (using constant data for this example)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">space_time_cubes</span> <span class="org-operator">=</span> {
    <span class="org-string">"slope"</span>                        : SpaceTimeCube(cube_shape, 0.8),   <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-string">"aspect"</span>                       : SpaceTimeCube(cube_shape, 225.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_model"</span>                   : SpaceTimeCube(cube_shape, 101),   <span class="org-comment-delimiter"># </span><span class="org-comment">integer index in fm.fuel_model_table</span>
    <span class="org-string">"canopy_cover"</span>                 : SpaceTimeCube(cube_shape, 0.6),   <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
    <span class="org-string">"canopy_height"</span>                : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_base_height"</span>           : SpaceTimeCube(cube_shape, 3.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_bulk_density"</span>          : SpaceTimeCube(cube_shape, 0.3),   <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>
    <span class="org-string">"wind_speed_10m"</span>               : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-string">"upwind_direction"</span>             : SpaceTimeCube(cube_shape, 180.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_moisture_dead_1hr"</span>       : SpaceTimeCube(cube_shape, 0.05),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_10hr"</span>      : SpaceTimeCube(cube_shape, 0.10),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_100hr"</span>     : SpaceTimeCube(cube_shape, 0.15),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_herbaceous"</span>: SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_woody"</span>     : SpaceTimeCube(cube_shape, 0.60),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"foliar_moisture"</span>              : SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_spread_adjustment"</span>       : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
    <span class="org-string">"weather_spread_adjustment"</span>    : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
}

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify a space-time coordinate (t,y,x) within the extent of the SpaceTimeCube dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">space_time_coordinate</span> <span class="org-operator">=</span> (24, 100, 100)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify an azimuth to spread the fire towards</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">spread_azimuth</span> <span class="org-operator">=</span> 90.0 <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North on the horizontal plane</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate combined fire behavior in the direction of the azimuth (with wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">combined_behavior_limited</span> <span class="org-operator">=</span> bc.burn_cell_toward_azimuth(space_time_cubes,
                                                        space_time_coordinate,
                                                        spread_azimuth,
                                                        surface_lw_ratio_model<span class="org-operator">=</span><span class="org-string">"rothermel"</span>)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate combined fire behavior in the direction of the azimuth (without wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">combined_behavior_unlimited</span> <span class="org-operator">=</span> bc.burn_cell_toward_azimuth(space_time_cubes,
                                                          space_time_coordinate,
                                                          spread_azimuth,
                                                          use_wind_limit<span class="org-operator">=</span><span class="org-constant">False</span>,
                                                          surface_lw_ratio_model<span class="org-operator">=</span><span class="org-string">"rothermel"</span>)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Display combined fire behavior in the direction of the azimuth (with wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"Fire Behavior from Combined Surface and Crown Fire (with Wind Limit) at Coordinate "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(space_time_coordinate) <span class="org-operator">+</span> <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 100)
pprint(combined_behavior_limited)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Display combined fire behavior in the direction of the azimuth (without wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Fire Behavior from Combined Surface and Crown Fire (without Wind Limit) at Coordinate "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(space_time_coordinate) <span class="org-operator">+</span> <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 100)
pprint(combined_behavior_unlimited)
</pre>
</div>

<pre class="example" id="run-burn-cell-toward-azimuth-results">
Fire Behavior from Combined Surface and Crown Fire (with Wind Limit) at Coordinate (24, 100, 100)
====================================================================================================
{'fire_type': 1,
 'fireline_intensity': 11.638436317443848,
 'flame_length': 0.23957829177379608,
 'spread_direction': (0.8703882694244385,
                      -3.804587933586845e-08,
                      0.4923659861087799),
 'spread_rate': 0.8216638565063477}

Fire Behavior from Combined Surface and Crown Fire (without Wind Limit) at Coordinate (24, 100, 100)
====================================================================================================
{'fire_type': 1,
 'fireline_intensity': 13.899334907531738,
 'flame_length': 0.2599639892578125,
 'spread_direction': (0.8703882694244385,
                      -3.804587933586845e-08,
                      0.4923659861087799),
 'spread_rate': 0.9812814593315125}
</pre>
</div>
</div>

<div id="outline-container-how-to-burn-a-region-of-cells-in-any-direction" class="outline-4">
<h4 id="how-to-burn-a-region-of-cells-in-any-direction"><span class="section-number-4">8.2.4.</span> How to Burn a Region of Cells in Any Direction</h4>
<div class="outline-text-4" id="text-how-to-burn-a-region-of-cells-in-any-direction">
<div class="org-src-container">
<pre class="src src-python" id="run-burn-all-cells-toward-azimuth"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube
<span class="org-keyword">import</span> pyretechnics.burn_cells <span class="org-keyword">as</span> bc

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (
    240,  <span class="org-comment-delimiter"># </span><span class="org-comment">bands: 10 days @ 1 hour/band</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">rows:  30 km @ 30 meters/row</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">cols:  30 km @ 30 meters/col</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Create an input dictionary of SpaceTimeCubes (using constant data for this example)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">space_time_cubes</span> <span class="org-operator">=</span> {
    <span class="org-string">"slope"</span>                        : SpaceTimeCube(cube_shape, 0.8),   <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-string">"aspect"</span>                       : SpaceTimeCube(cube_shape, 225.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_model"</span>                   : SpaceTimeCube(cube_shape, 101),   <span class="org-comment-delimiter"># </span><span class="org-comment">integer index in fm.fuel_model_table</span>
    <span class="org-string">"canopy_cover"</span>                 : SpaceTimeCube(cube_shape, 0.6),   <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
    <span class="org-string">"canopy_height"</span>                : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_base_height"</span>           : SpaceTimeCube(cube_shape, 3.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_bulk_density"</span>          : SpaceTimeCube(cube_shape, 0.3),   <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>
    <span class="org-string">"wind_speed_10m"</span>               : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-string">"upwind_direction"</span>             : SpaceTimeCube(cube_shape, 180.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_moisture_dead_1hr"</span>       : SpaceTimeCube(cube_shape, 0.05),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_10hr"</span>      : SpaceTimeCube(cube_shape, 0.10),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_100hr"</span>     : SpaceTimeCube(cube_shape, 0.15),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_herbaceous"</span>: SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_woody"</span>     : SpaceTimeCube(cube_shape, 0.60),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"foliar_moisture"</span>              : SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_spread_adjustment"</span>       : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
    <span class="org-string">"weather_spread_adjustment"</span>    : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
}

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify a space-time region (t, (y_min, y_max), (x_min, x_max))</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">within the extent of the SpaceTimeCube dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">t</span>       <span class="org-operator">=</span> 24
<span class="org-variable-name">y_range</span> <span class="org-operator">=</span> (100,105)
<span class="org-variable-name">x_range</span> <span class="org-operator">=</span> (100,105)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify an azimuth to spread the fire towards</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">spread_azimuth</span> <span class="org-operator">=</span> 90.0 <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North on the horizontal plane</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate combined fire behavior in the direction of the azimuth (with wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">combined_behavior_limited</span> <span class="org-operator">=</span> bc.burn_all_cells_toward_azimuth(space_time_cubes,
                                                             spread_azimuth,
                                                             t,
                                                             y_range,
                                                             x_range,
                                                             surface_lw_ratio_model<span class="org-operator">=</span><span class="org-string">"rothermel"</span>)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate combined fire behavior in the direction of the azimuth (without wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">combined_behavior_unlimited</span> <span class="org-operator">=</span> bc.burn_all_cells_toward_azimuth(space_time_cubes,
                                                               spread_azimuth,
                                                               t,
                                                               y_range,
                                                               x_range,
                                                               use_wind_limit<span class="org-operator">=</span><span class="org-constant">False</span>,
                                                               surface_lw_ratio_model<span class="org-operator">=</span><span class="org-string">"rothermel"</span>)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Display combined fire behavior in the direction of the azimuth (with wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"Fire Behavior from Combined Surface and Crown Fire (with Wind Limit) at Space-Time Region "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>((t, y_range, x_range)) <span class="org-operator">+</span> <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 121)
<span class="org-keyword">for</span> (name, matrix) <span class="org-keyword">in</span> combined_behavior_limited.items():
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Layer: "</span> <span class="org-operator">+</span> name)
    <span class="org-builtin">print</span>(matrix[100:105,100:105])

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Display combined fire behavior in the direction of the azimuth (without wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Fire Behavior from Combined Surface and Crown Fire (without Wind Limit) at Space-Time Region "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>((t, y_range, x_range)) <span class="org-operator">+</span> <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 121)
<span class="org-keyword">for</span> (name, matrix) <span class="org-keyword">in</span> combined_behavior_unlimited.items():
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Layer: "</span> <span class="org-operator">+</span> name)
    <span class="org-builtin">print</span>(matrix[100:105,100:105])
</pre>
</div>

<pre class="example" id="run-burn-all-cells-toward-azimuth-results">
Fire Behavior from Combined Surface and Crown Fire (with Wind Limit) at Space-Time Region (24, (100, 105), (100, 105))
=========================================================================================================================

Layer: fire_type
[[1 1 1 1 1]
 [1 1 1 1 1]
 [1 1 1 1 1]
 [1 1 1 1 1]
 [1 1 1 1 1]]

Layer: spread_rate
[[0.82166386 0.82166386 0.82166386 0.82166386 0.82166386]
 [0.82166386 0.82166386 0.82166386 0.82166386 0.82166386]
 [0.82166386 0.82166386 0.82166386 0.82166386 0.82166386]
 [0.82166386 0.82166386 0.82166386 0.82166386 0.82166386]
 [0.82166386 0.82166386 0.82166386 0.82166386 0.82166386]]

Layer: spread_direction
[[90. 90. 90. 90. 90.]
 [90. 90. 90. 90. 90.]
 [90. 90. 90. 90. 90.]
 [90. 90. 90. 90. 90.]
 [90. 90. 90. 90. 90.]]

Layer: fireline_intensity
[[11.638436 11.638436 11.638436 11.638436 11.638436]
 [11.638436 11.638436 11.638436 11.638436 11.638436]
 [11.638436 11.638436 11.638436 11.638436 11.638436]
 [11.638436 11.638436 11.638436 11.638436 11.638436]
 [11.638436 11.638436 11.638436 11.638436 11.638436]]

Layer: flame_length
[[0.23957829 0.23957829 0.23957829 0.23957829 0.23957829]
 [0.23957829 0.23957829 0.23957829 0.23957829 0.23957829]
 [0.23957829 0.23957829 0.23957829 0.23957829 0.23957829]
 [0.23957829 0.23957829 0.23957829 0.23957829 0.23957829]
 [0.23957829 0.23957829 0.23957829 0.23957829 0.23957829]]

Fire Behavior from Combined Surface and Crown Fire (without Wind Limit) at Space-Time Region (24, (100, 105), (100, 105))
=========================================================================================================================

Layer: fire_type
[[1 1 1 1 1]
 [1 1 1 1 1]
 [1 1 1 1 1]
 [1 1 1 1 1]
 [1 1 1 1 1]]

Layer: spread_rate
[[0.98128146 0.98128146 0.98128146 0.98128146 0.98128146]
 [0.98128146 0.98128146 0.98128146 0.98128146 0.98128146]
 [0.98128146 0.98128146 0.98128146 0.98128146 0.98128146]
 [0.98128146 0.98128146 0.98128146 0.98128146 0.98128146]
 [0.98128146 0.98128146 0.98128146 0.98128146 0.98128146]]

Layer: spread_direction
[[90. 90. 90. 90. 90.]
 [90. 90. 90. 90. 90.]
 [90. 90. 90. 90. 90.]
 [90. 90. 90. 90. 90.]
 [90. 90. 90. 90. 90.]]

Layer: fireline_intensity
[[13.899335 13.899335 13.899335 13.899335 13.899335]
 [13.899335 13.899335 13.899335 13.899335 13.899335]
 [13.899335 13.899335 13.899335 13.899335 13.899335]
 [13.899335 13.899335 13.899335 13.899335 13.899335]
 [13.899335 13.899335 13.899335 13.899335 13.899335]]

Layer: flame_length
[[0.259964 0.259964 0.259964 0.259964 0.259964]
 [0.259964 0.259964 0.259964 0.259964 0.259964]
 [0.259964 0.259964 0.259964 0.259964 0.259964]
 [0.259964 0.259964 0.259964 0.259964 0.259964]
 [0.259964 0.259964 0.259964 0.259964 0.259964]]
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-fire-spread-algorithm:-eulerian-level-set-method-(pyretechnics.eulerian_level_set)" class="outline-2">
<h2 id="fire-spread-algorithm:-eulerian-level-set-method-(pyretechnics.eulerian_level_set)"><span class="section-number-2">9.</span> Fire Spread Algorithm (ELMFIRE): Eulerian Level Set Method (pyretechnics.eulerian_level_set)</h2>
<div class="outline-text-2" id="text-fire-spread-algorithm:-eulerian-level-set-method-(pyretechnics.eulerian_level_set)">
</div>
<div id="outline-container-for-developers-fire-spread" class="outline-3">
<h3 id="for-developers-fire-spread"><span class="section-number-3">9.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-for-developers-fire-spread">
<p>
In order to simulate the spread of a fire from a starting point or
perimeter, we will need to implement a model that projects the
one-dimensional spread and intensity equations presented in sections
<a href="#surface-fire-equations-(pyretechnics.surface_fire)">5</a> and <a href="#crown-fire-equations-(pyretechnics.crown_fire)">6</a> into the three-dimensional
space-time cube introduced in section <a href="#data-model">2</a>.
</p>

<p>
This section introduces the equations used in the Eulerian level set
method of fire spread, operationalized in Chris Lautenberger's ELMFIRE
model<sup><a id="fnr.58" class="footref" href="#fn.58" role="doc-backlink">58</a></sup>.
</p>
</div>

<div id="outline-container-module-imports-eulerian-level-set" class="outline-4">
<h4 id="module-imports-eulerian-level-set"><span class="section-number-4">9.1.1.</span> Module Imports</h4>
<div class="outline-text-4" id="text-module-imports-eulerian-level-set">
<div class="org-src-container">
<pre class="src src-python" id="eulerian-level-set-imports"><span class="org-keyword">import</span> cython
<span class="org-keyword">import</span> cython <span class="org-keyword">as</span> cy
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> sortedcontainers <span class="org-keyword">import</span> SortedDict
<span class="org-keyword">if</span> cython.compiled:
    <span class="org-keyword">from</span> cython.cimports.numpy <span class="org-keyword">import</span> ndarray
    <span class="org-keyword">from</span> cython.cimports.libc.stdlib <span class="org-keyword">import</span> malloc, realloc, free
    <span class="org-keyword">from</span> cython.cimports.libc.math <span class="org-keyword">import</span> pi, floor, sqrt, <span class="org-builtin">pow</span>, atan
    <span class="org-keyword">from</span> cython.cimports.pyretechnics.cy_types <span class="org-keyword">import</span> pyidx, vec_xy, vec_xyz, coord_yx, coord_tyx, \
        fclaarr, FuelModel, FireBehaviorMin, FireBehaviorMax, SpreadBehavior, SpotConfig, \
        PartialedEllWavelet, CellInputs, EllipticalInfo, Pass1CellOutput
    <span class="org-keyword">from</span> cython.cimports.pyretechnics.random <span class="org-keyword">import</span> BufferedRandGen
    <span class="org-keyword">from</span> cython.cimports.pyretechnics.space_time_cube <span class="org-keyword">import</span> ISpaceTimeCube, SpaceTimeCube
    <span class="org-keyword">import</span> cython.cimports.pyretechnics.conversion <span class="org-keyword">as</span> conv
    <span class="org-keyword">import</span> cython.cimports.pyretechnics.vector_utils <span class="org-keyword">as</span> vu
    <span class="org-keyword">import</span> cython.cimports.pyretechnics.fuel_models <span class="org-keyword">as</span> fm
    <span class="org-keyword">import</span> cython.cimports.pyretechnics.surface_fire <span class="org-keyword">as</span> sf
    <span class="org-keyword">import</span> cython.cimports.pyretechnics.crown_fire <span class="org-keyword">as</span> cf
    <span class="org-keyword">import</span> cython.cimports.pyretechnics.spot_fire <span class="org-keyword">as</span> spot
    <span class="org-keyword">import</span> cython.cimports.pyretechnics.narrow_band_tracking <span class="org-keyword">as</span> nbt
<span class="org-keyword">else</span>:
    <span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Create equivalent Python functions for malloc, realloc, free</span>
    <span class="org-keyword">from</span> numpy <span class="org-keyword">import</span> ndarray
    <span class="org-keyword">from</span> math <span class="org-keyword">import</span> pi, floor, sqrt, <span class="org-builtin">pow</span>, atan
    <span class="org-keyword">from</span> pyretechnics.py_types <span class="org-keyword">import</span> pyidx, vec_xy, vec_xyz, coord_yx, coord_tyx, \
        fclaarr, FuelModel, FireBehaviorMin, FireBehaviorMax, SpreadBehavior, SpotConfig, \
        PartialedEllWavelet, CellInputs, EllipticalInfo, Pass1CellOutput
    <span class="org-keyword">from</span> pyretechnics.random <span class="org-keyword">import</span> BufferedRandGen
    <span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> ISpaceTimeCube, SpaceTimeCube
    <span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv
    <span class="org-keyword">import</span> pyretechnics.vector_utils <span class="org-keyword">as</span> vu
    <span class="org-keyword">import</span> pyretechnics.fuel_models <span class="org-keyword">as</span> fm
    <span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf
    <span class="org-keyword">import</span> pyretechnics.crown_fire <span class="org-keyword">as</span> cf
    <span class="org-keyword">import</span> pyretechnics.spot_fire <span class="org-keyword">as</span> spot
    <span class="org-keyword">import</span> pyretechnics.narrow_band_tracking <span class="org-keyword">as</span> nbt
</pre>
</div>
</div>
</div>

<div id="outline-container-the-$\phi$-field" class="outline-4">
<h4 id="the-$\phi$-field"><span class="section-number-4">9.1.2.</span> The \(\phi\) Field</h4>
<div class="outline-text-4" id="text-the-$\phi$-field">
<p>
In this model, a continuous field called \(\phi\) fills the simulation
space and is used to track the progression of the fire front through
space and time. Within Pyretechnics, the \(\phi\) field is discretized
into grid cells and initialized with the following values:
</p>

<ul class="org-ul">
<li>-1 for cells that have already been burned and are inside the fire perimeter</li>
<li>1 for cells that have not been burned and are outside the fire perimeter</li>
</ul>

<p>
If a fire is being simulated starting from an actively burning
perimeter, the \(\phi\) grid cells indicate the initially burning region.
If a point fire is being simulated, then a single \(\phi\) cell will be
set to -1 and the remaining cells will have the value 1.
</p>
</div>
</div>

<div id="outline-container-fire-front-normal-vector" class="outline-4">
<h4 id="fire-front-normal-vector"><span class="section-number-4">9.1.3.</span> Fire Front Normal Vector</h4>
<div class="outline-text-4" id="text-fire-front-normal-vector">
<p>
In this fire spread algorithm, the fire front only propagates normal
to itself. Given a \(\phi\) raster, we can calculate the normal vector to
the \(\phi\) field by using the following formula:
</p>

\begin{align}
  \hat{n} &= n_x\hat{i} + n_y\hat{j} = \frac{1}{|\nabla\phi|}\left(\frac{\partial \phi}{\partial x}\hat{i} + \frac{\partial \phi}{\partial y}\hat{j}\right) \\
  \nonumber \\
  |\nabla\phi| &= \sqrt{\left(\frac{\partial \phi}{\partial x}\right)^2 + \left(\frac{\partial \phi}{\partial y}\right)^2}
\end{align}

<p>
We begin by approximating the spatial gradients of the \(\phi\) field with
node-centered central differences, represented by the values in the
\(\phi\) raster's grid cells.
</p>

\begin{align}
  \left(\frac{\partial \phi}{\partial x}\right)_{i,j} &\approx \frac{\phi_{i+1,j} - \phi_{i-1,j}}{2 \Delta x} \\
  \nonumber \\
  \left(\frac{\partial \phi}{\partial y}\right)_{i,j} &\approx \frac{\phi_{i,j+1} - \phi_{i,j-1}}{2 \Delta y}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="phi-field-spatial-gradients-approx"><span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: No longer used in tight loops.</span>
<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_dphi_dx_approx</span>(phi_matrix: cy.<span class="org-builtin">float</span>[:,::1], dx: cy.<span class="org-builtin">float</span>, x: pyidx, y: pyidx) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the spatial gradient of `phi_matrix` in the x (west-&gt;east)</span>
<span class="org-doc">    direction at grid cell (x,y) given the cell width `dx`.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">east_x</span>: pyidx <span class="org-operator">=</span> x <span class="org-operator">+</span> 1
    <span class="org-variable-name">west_x</span>: pyidx <span class="org-operator">=</span> x <span class="org-operator">-</span> 1
    <span class="org-keyword">return</span> (phi_matrix[2<span class="org-operator">+</span>y, 2<span class="org-operator">+</span>east_x] <span class="org-operator">-</span> phi_matrix[2<span class="org-operator">+</span>y, 2<span class="org-operator">+</span>west_x]) <span class="org-operator">/</span> (2.0 <span class="org-operator">*</span> dx)


<span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: No longer used in tight loops.</span>
<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_dphi_dy_approx</span>(phi_matrix: cy.<span class="org-builtin">float</span>[:,::1], dy: cy.<span class="org-builtin">float</span>, x: pyidx, y: pyidx) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the spatial gradient of `phi_matrix` in the y (south-&gt;north)</span>
<span class="org-doc">    direction at grid cell (x,y) given the cell height `dy`.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">north_y</span>: pyidx <span class="org-operator">=</span> y <span class="org-operator">+</span> 1
    <span class="org-variable-name">south_y</span>: pyidx <span class="org-operator">=</span> y <span class="org-operator">-</span> 1
    <span class="org-keyword">return</span> (phi_matrix[2<span class="org-operator">+</span>north_y, 2<span class="org-operator">+</span>x] <span class="org-operator">-</span> phi_matrix[2<span class="org-operator">+</span>south_y, 2<span class="org-operator">+</span>x]) <span class="org-operator">/</span> (2.0 <span class="org-operator">*</span> dy)


<span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: No longer used in tight loops.</span>
<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_phi_gradient_approx</span>(phi_matrix: cy.<span class="org-builtin">float</span>[:,::1], dx: cy.<span class="org-builtin">float</span>, dy: cy.<span class="org-builtin">float</span>, x: pyidx, y: pyidx) <span class="org-operator">-&gt;</span> vec_xy:
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the spatial gradient of `phi_matrix` at grid cell (x,y)</span>
<span class="org-doc">    given the cell width `dx` and the cell height `dy`.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">dphi_dx</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_dphi_dx_approx(phi_matrix, dx, x, y)
    <span class="org-variable-name">dphi_dy</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_dphi_dy_approx(phi_matrix, dy, x, y)
    <span class="org-keyword">return</span> (dphi_dx, dphi_dy)
</pre>
</div>

<p>
We can now combine these spatial gradients with the magnitude of the
gradient of the \(\phi\) field at any location on the grid to compute
the fire front normal vector as follows:
</p>

<div class="org-src-container">
<pre class="src src-python" id="phi-field-normal-vector"><span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Remove unused function</span>
<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_phi_normal_vector</span>(phi_matrix: cy.<span class="org-builtin">float</span>[:,::1], dx: cy.<span class="org-builtin">float</span>, dy: cy.<span class="org-builtin">float</span>, x: pyidx, y: pyidx) <span class="org-operator">-&gt;</span> vec_xy:
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the phi field normal vector in the x and y dimensions.</span>

<span class="org-doc">    - n_x: eastward component of the unit normal vector</span>
<span class="org-doc">    - n_y: northward component of the unit normal vector</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> vu.as_unit_vector_2d(calc_phi_gradient_approx(phi_matrix, dx, dy, x, y)) <span class="org-comment-delimiter"># </span><span class="org-comment">(n_x, n_y)</span>
</pre>
</div>

<p>
Next, we can use the following geometrical relations to calculate the
angle \(\theta_n\) (measured clockwise from North) to which the normal
vector points:
</p>

\begin{equation}
  \theta_n =
  \begin{cases}
    \frac{1}{2}\pi - \tan^{-1}(\frac{n_y}{n_x}) & \text{for}\ n_x > 0 & \text{and}\ n_y \geq 0 \\
    \frac{1}{2}\pi + \tan^{-1}(\frac{|n_y|}{n_x}) & \text{for}\ n_x > 0 & \text{and}\ n_y < 0 \\
    \frac{3}{2}\pi + \tan^{-1}(\frac{n_y}{|n_x|}) & \text{for}\ n_x < 0 & \text{and}\ n_y \geq 0 \\
    \frac{3}{2}\pi - \tan^{-1}(\frac{n_y}{n_x}) & \text{for}\ n_x < 0 & \text{and}\ n_y < 0 \\
    0 & \text{for}\ n_x = 0 & \text{and}\ n_y \geq 0 \\
    \pi & \text{for}\ n_x = 0 & \text{and}\ n_y < 0
  \end{cases}
\end{equation}

<div class="org-src-container">
<pre class="src src-python" id="phi-field-normal-vector-angle"><span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Remove unused function</span>
<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_phi_normal_azimuth</span>(phi_normal_vector: vec_xy) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the angle (measured in degrees clockwise from North)</span>
<span class="org-doc">    to which the phi field's normal vector points.</span>
<span class="org-doc">    """</span>
    (<span class="org-variable-name">n_x</span>, <span class="org-variable-name">n_y</span>) <span class="org-operator">=</span> phi_normal_vector
    angle: cy.<span class="org-builtin">float</span>
    <span class="org-keyword">if</span> n_x <span class="org-operator">&gt;</span> 0.0:
        <span class="org-keyword">if</span> n_y <span class="org-operator">&gt;=</span> 0.0:
            <span class="org-variable-name">angle</span> <span class="org-operator">=</span> 0.5 <span class="org-operator">*</span> pi <span class="org-operator">-</span> atan(n_y <span class="org-operator">/</span> n_x)
        <span class="org-keyword">elif</span> n_y <span class="org-operator">&lt;</span> 0.0:
            <span class="org-variable-name">angle</span> <span class="org-operator">=</span> 0.5 <span class="org-operator">*</span> pi <span class="org-operator">+</span> atan(<span class="org-builtin">abs</span>(n_y) <span class="org-operator">/</span> n_x)
    <span class="org-keyword">elif</span> n_x <span class="org-operator">&lt;</span> 0.0:
        <span class="org-keyword">if</span> n_y <span class="org-operator">&gt;=</span> 0.0:
            <span class="org-variable-name">angle</span> <span class="org-operator">=</span> 1.5 <span class="org-operator">*</span> pi <span class="org-operator">+</span> atan(n_y <span class="org-operator">/</span> <span class="org-builtin">abs</span>(n_x))
        <span class="org-keyword">elif</span> n_y <span class="org-operator">&lt;</span> 0.0:
            <span class="org-variable-name">angle</span> <span class="org-operator">=</span> 1.5 <span class="org-operator">*</span> pi <span class="org-operator">-</span> atan(n_y <span class="org-operator">/</span> n_x)
    <span class="org-keyword">else</span>:
        <span class="org-keyword">if</span> n_y <span class="org-operator">&gt;=</span> 0.0:
            <span class="org-variable-name">angle</span> <span class="org-operator">=</span> 0.0
        <span class="org-keyword">elif</span> n_y <span class="org-operator">&lt;</span> 0.0:
            <span class="org-variable-name">angle</span> <span class="org-operator">=</span> pi
    <span class="org-keyword">return</span> conv.rad_to_deg(angle)
</pre>
</div>

<p>
Now that we can compute the fire front normal vector, we can find the
spread rate in this direction by combining this vector with the
maximum spread rate vector and elliptical eccentricity values
calculated for each grid cell, using the approaches described in
sections <a href="#surface-fire-equations-(pyretechnics.surface_fire)">5</a> and <a href="#crown-fire-equations-(pyretechnics.crown_fire)">6</a>.
</p>

<p>
We will refer to the spread rate vector normal to the fire front in
the following sections as \(U\) with spatial components \(U_x\) and \(U_y\).
</p>
</div>
</div>

<div id="outline-container-numerical-solution-of-the-$\phi$-field-equation" class="outline-4">
<h4 id="numerical-solution-of-the-$\phi$-field-equation"><span class="section-number-4">9.1.4.</span> Numerical Solution of the \(\phi\) Field Equation</h4>
<div class="outline-text-4" id="text-numerical-solution-of-the-$\phi$-field-equation">
<p>
In order to evolve the \(\phi\) field through time and space, we must
solve the following hyperbolic differential equation for the scalar
variable \(\phi\).
</p>

\begin{align}
  \frac{\partial \phi}{\partial t} + U_x \frac{\partial \phi}{\partial x} + U_y \frac{\partial \phi}{\partial y} = 0
\end{align}

<p>
This is accomplished after applying a flux limiter to the convective
terms, in order to ensure solution monotonicity and prevent spurious
oscillations that can be induced in its absence.
</p>

<p>
First, we define the parameter \(r\) and the Superbee flux limiter
\(B(r)\) as follows:
</p>

\begin{align}
  r &= \frac{\delta\phi_{\text{up}}}{\delta\phi_{\text{loc}}} \\
  \nonumber \\
  B(r) &= \max(0, \min(2r, 1), \min(r, 2))
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="superbee-flux-limiter"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">half_superbee_dphi_up</span>(dphi_up: cy.<span class="org-builtin">float</span>, dphi_loc: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Logically like calc_superbee_flux_limiter() but returns a result multiplied by (0.5 * dphi_loc).</span>

<span class="org-doc">    NOTE: This is more numerically stable than calc_superbee_flux_limiter().</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">s_loc</span>             : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 1.0 <span class="org-keyword">if</span> dphi_loc <span class="org-operator">&gt;=</span> 0.0 <span class="org-keyword">else</span> <span class="org-operator">-</span>1.0
    <span class="org-variable-name">are_opposite_signs</span>: cy.bint  <span class="org-operator">=</span> (s_loc <span class="org-operator">*</span> dphi_up) <span class="org-operator">&lt;=</span> 0.0
    <span class="org-keyword">if</span> are_opposite_signs:
        <span class="org-keyword">return</span> 0.0
    <span class="org-variable-name">a_up</span> : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> <span class="org-builtin">abs</span>(dphi_up)
    <span class="org-variable-name">a_loc</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> <span class="org-builtin">abs</span>(dphi_loc)
    <span class="org-keyword">return</span> s_loc <span class="org-operator">*</span> <span class="org-builtin">max</span>(<span class="org-builtin">min</span>(a_up <span class="org-operator">/</span> 2.0, a_loc),
                       <span class="org-builtin">min</span>(a_up, a_loc <span class="org-operator">/</span> 2.0))
</pre>
</div>

<p>
To compute the inputs to this function, we build up the partial
derivatives of the \(\phi\) field in terms of "east", "west", "north",
and "south" values as follows:
</p>

\begin{align}
  \frac{\partial \phi}{\partial x} &\approx \frac{\phi_{\text{east}} - \phi_{\text{west}}}{\Delta x} \\
  \nonumber \\
  \frac{\partial \phi}{\partial y} &\approx \frac{\phi_{\text{north}} - \phi_{\text{south}}}{\Delta y}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="phi-field-spatial-gradients"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_dphi_flim_x</span>(p00: cy.<span class="org-builtin">float</span>, pw2: cy.<span class="org-builtin">float</span>, pw1: cy.<span class="org-builtin">float</span>, pe1: cy.<span class="org-builtin">float</span>, pe2: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    dphi_up : cy.<span class="org-builtin">float</span>
    dphi_loc: cy.<span class="org-builtin">float</span>
    phi_east: cy.<span class="org-builtin">float</span>
    phi_west: cy.<span class="org-builtin">float</span>

    <span class="org-variable-name">dphi_loc</span> <span class="org-operator">=</span> pe1 <span class="org-operator">-</span> p00
    <span class="org-keyword">if</span> pe1 <span class="org-operator">&gt;=</span> pw1:
        <span class="org-variable-name">dphi_up</span>  <span class="org-operator">=</span> p00 <span class="org-operator">-</span> pw1
        <span class="org-variable-name">phi_east</span> <span class="org-operator">=</span> p00 <span class="org-operator">+</span> half_superbee_dphi_up(dphi_up, dphi_loc)
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">dphi_up</span>  <span class="org-operator">=</span> pe2 <span class="org-operator">-</span> pe1
        <span class="org-variable-name">phi_east</span> <span class="org-operator">=</span> pe1 <span class="org-operator">-</span> half_superbee_dphi_up(dphi_up, dphi_loc)

    <span class="org-variable-name">dphi_loc</span> <span class="org-operator">=</span> pw1 <span class="org-operator">-</span> p00
    <span class="org-keyword">if</span> pe1 <span class="org-operator">&gt;=</span> pw1:
        <span class="org-variable-name">dphi_up</span>  <span class="org-operator">=</span> pw2 <span class="org-operator">-</span> pw1
        <span class="org-variable-name">phi_west</span> <span class="org-operator">=</span> pw1 <span class="org-operator">-</span> half_superbee_dphi_up(dphi_up, dphi_loc)
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">dphi_up</span>  <span class="org-operator">=</span> p00 <span class="org-operator">-</span> pe1
        <span class="org-variable-name">phi_west</span> <span class="org-operator">=</span> p00 <span class="org-operator">+</span> half_superbee_dphi_up(dphi_up, dphi_loc)
    <span class="org-keyword">return</span> (phi_east <span class="org-operator">-</span> phi_west)


<span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: This is actually the same function as the previous one. But</span>
<span class="org-comment-delimiter">#       </span><span class="org-comment">who knows, maybe we get a performance gain by differentiating</span>
<span class="org-comment-delimiter">#       </span><span class="org-comment">code sites.</span>
<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_dphi_flim_y</span>(p00: cy.<span class="org-builtin">float</span>, ps2: cy.<span class="org-builtin">float</span>, ps1: cy.<span class="org-builtin">float</span>, pn1: cy.<span class="org-builtin">float</span>, pn2: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    dphi_up  : cy.<span class="org-builtin">float</span>
    dphi_loc : cy.<span class="org-builtin">float</span>
    phi_north: cy.<span class="org-builtin">float</span>
    phi_south: cy.<span class="org-builtin">float</span>

    <span class="org-variable-name">dphi_loc</span> <span class="org-operator">=</span> pn1 <span class="org-operator">-</span> p00
    <span class="org-keyword">if</span> pn1 <span class="org-operator">&gt;=</span> ps1:
        <span class="org-variable-name">dphi_up</span>   <span class="org-operator">=</span> p00 <span class="org-operator">-</span> ps1
        <span class="org-variable-name">phi_north</span> <span class="org-operator">=</span> p00 <span class="org-operator">+</span> half_superbee_dphi_up(dphi_up, dphi_loc)
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">dphi_up</span>   <span class="org-operator">=</span> pn2 <span class="org-operator">-</span> pn1
        <span class="org-variable-name">phi_north</span> <span class="org-operator">=</span> pn1 <span class="org-operator">-</span> half_superbee_dphi_up(dphi_up, dphi_loc)

    <span class="org-variable-name">dphi_loc</span> <span class="org-operator">=</span> ps1 <span class="org-operator">-</span> p00
    <span class="org-keyword">if</span> pn1 <span class="org-operator">&gt;=</span> ps1:
        <span class="org-variable-name">dphi_up</span>   <span class="org-operator">=</span> ps2 <span class="org-operator">-</span> ps1
        <span class="org-variable-name">phi_south</span> <span class="org-operator">=</span> ps1 <span class="org-operator">-</span> half_superbee_dphi_up(dphi_up, dphi_loc)
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">dphi_up</span>   <span class="org-operator">=</span> p00 <span class="org-operator">-</span> pn1
        <span class="org-variable-name">phi_south</span> <span class="org-operator">=</span> p00 <span class="org-operator">+</span> half_superbee_dphi_up(dphi_up, dphi_loc)

    <span class="org-keyword">return</span> (phi_north <span class="org-operator">-</span> phi_south)
</pre>
</div>

<p>
For the east face:
</p>

\begin{align}
  \delta\phi_{\text{loc}} &= \phi_{i+1,j} - \phi{i,j} \\
  \nonumber \\
  \delta\phi_{\text{up}} &= \begin{cases}
                              \phi_{i,j} - \phi_{i-1,j} & \text{for}\ u_{x,i,j} \ge 0 \\
                              \phi_{i+2,j} - \phi_{i+1,j} & \text{for}\ u_{x,i,j} < 0
                            \end{cases} \\
  \nonumber \\
  \phi_{\text{east}} &= \begin{cases}
                          \phi_{i,j} + \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{x,i,j} \ge 0 \\
                          \phi_{i+1,j} - \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{x,i,j} < 0
                        \end{cases}
\end{align}

<p>
For the west face:
</p>

\begin{align}
  \delta\phi_{\text{loc}} &= \phi_{i-1,j} - \phi{i,j} \\
  \nonumber \\
  \delta\phi_{\text{up}} &= \begin{cases}
                              \phi_{i-2,j} - \phi_{i-1,j} & \text{for}\ u_{x,i,j} \ge 0 \\
                              \phi_{i,j} - \phi_{i+1,j} & \text{for}\ u_{x,i,j} < 0
                            \end{cases} \\
  \nonumber \\
  \phi_{\text{west}} &= \begin{cases}
                          \phi_{i-1,j} - \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{x,i,j} \ge 0 \\
                          \phi_{i,j} + \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{x,i,j} < 0
                        \end{cases}
\end{align}

<p>
For the north face:
</p>

\begin{align}
  \delta\phi_{\text{loc}} &= \phi_{i,j+1} - \phi{i,j} \\
  \nonumber \\
  \delta\phi_{\text{up}} &= \begin{cases}
                              \phi_{i,j} - \phi_{i,j-1} & \text{for}\ u_{y,i,j} \ge 0 \\
                              \phi_{i,j+2} - \phi_{i,j+1} & \text{for}\ u_{y,i,j} < 0
                            \end{cases} \\
  \nonumber \\
  \phi_{\text{north}} &= \begin{cases}
                           \phi_{i,j} + \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{y,i,j} \ge 0 \\
                           \phi_{i,j+1} - \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{y,i,j} < 0
                         \end{cases}
\end{align}

<p>
For the south face:
</p>

\begin{align}
  \delta\phi_{\text{loc}} &= \phi_{i,j-1} - \phi{i,j} \\
  \nonumber \\
  \delta\phi_{\text{up}} &= \begin{cases}
                              \phi_{i,j-2} - \phi_{i,j-1} & \text{for}\ u_{y,i,j} \ge 0 \\
                              \phi_{i,j} - \phi_{i,j+1} & \text{for}\ u_{y,i,j} < 0
                            \end{cases} \\
  \nonumber \\
  \phi_{\text{south}} &= \begin{cases}
                           \phi_{i,j-1} - \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{y,i,j} \ge 0 \\
                           \phi_{i,j} + \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{y,i,j} < 0
                         \end{cases}
\end{align}

<p>
Once the various spatial partial derivatives have been calculated, we
can march the \(\phi\) field solution forward in time using a second
order Runge Kutta method as follows:
</p>

\begin{align}
  \phi^* &= \phi^t - \Delta t \left(U_x \frac{\phi^t_{\text{east}} - \phi^t_{\text{west}}}{\Delta x} + U_y \frac{\phi^t_{\text{north}} - \phi^t_{\text{south}}}{\Delta y} \right) \\
  \nonumber \\
  \phi^{t + \Delta t} &= \frac{1}{2}\phi^t + \frac{1}{2} \left( \phi^* - \Delta t \left(U_x \frac{\phi^*_{\text{east}} - \phi^*_{\text{west}}}{\Delta x} + U_y \frac{\phi^*_{\text{north}} - \phi^*_{\text{south}}}{\Delta y} \right) \right)
\end{align}

<p>
In the above equations, timestep (\(\Delta t\)) is constrained by the
Courant-Friedrichs-Lewy (CFL) condition. The location of the fire
perimeter is determined by interpolation of the \(\phi\) field as the
level set corresponding to \(\phi = 0\).
</p>
</div>
</div>

<div id="outline-container-calculate-the-surface/crown-fireline-normal-behavior" class="outline-4">
<h4 id="calculate-the-surface/crown-fireline-normal-behavior"><span class="section-number-4">9.1.5.</span> Calculate the Surface/Crown Fireline Normal Behavior</h4>
<div class="outline-text-4" id="text-calculate-the-surface/crown-fireline-normal-behavior">
<p>
Since the fire front only propagates normal to itself in this fire
spread algorithm, we need a method to translate the surface and/or
crown fire behavior associated with a heading fire into the surface
and/or crown fire behavior normal to the fire front. This process is
illustrated below.
</p>

<div class="org-src-container">
<pre class="src src-python" id="calc-fireline-normal-behavior"><span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Move these to a shared module and use throughout the literate program</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: It would be better to use a cython enum here, but that's not supported in pure python syntax.</span>
<span class="org-variable-name">fire_type_unburned</span>      <span class="org-operator">=</span> cy.declare(cy.<span class="org-builtin">int</span>, 0)
<span class="org-variable-name">fire_type_surface</span>       <span class="org-operator">=</span> cy.declare(cy.<span class="org-builtin">int</span>, 1)
<span class="org-variable-name">fire_type_crown_passive</span> <span class="org-operator">=</span> cy.declare(cy.<span class="org-builtin">int</span>, 2)
<span class="org-variable-name">fire_type_crown_active</span>  <span class="org-operator">=</span> cy.declare(cy.<span class="org-builtin">int</span>, 3)


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Move this to pyretechnics.vector_utils and use throughout the literate program</span>
<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_elevation_gradient</span>(slope: cy.<span class="org-builtin">float</span>, aspect: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> vec_xy:
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the elevation gradient (dz_dx: rise/run, dz_dy: rise/run) given:</span>
<span class="org-doc">    - slope  :: rise/run</span>
<span class="org-doc">    - aspect :: degrees clockwise from North</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> conv.azimuthal_to_cartesian(slope, conv.opposite_direction(aspect))


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_phi_gradient_on_slope</span>(phi_gradient_xy: vec_xy, elevation_gradient: vec_xy) <span class="org-operator">-&gt;</span> vec_xyz:
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the gradient of phi projected onto the slope-tangential plane as a 3D (x,y,z) vector (in phi/m) given:</span>
<span class="org-doc">    - phi_gradient_xy    :: (dphi_dx: phi/m, dphi_dy: phi/m) 2D vector on the horizontal plane</span>
<span class="org-doc">    - elevation_gradient :: (dz_dx: rise/run, dz_dy: rise/run)</span>
<span class="org-doc">    """</span>
    (<span class="org-variable-name">dphi_dx</span>, <span class="org-variable-name">dphi_dy</span>)        <span class="org-operator">=</span> phi_gradient_xy
    <span class="org-variable-name">phi_gradient_xyz</span>: vec_xyz <span class="org-operator">=</span> (dphi_dx, dphi_dy, 0.0)
    <span class="org-keyword">if</span> vu.vector_magnitude_2d(elevation_gradient) <span class="org-operator">==</span> 0.0:
        <span class="org-keyword">return</span> phi_gradient_xyz
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">slope_normal_vector</span>: vec_xyz  <span class="org-operator">=</span> vu.get_slope_normal_vector(elevation_gradient) <span class="org-comment-delimiter"># </span><span class="org-comment">(x,y,z) unit vector</span>
        <span class="org-variable-name">phi_slope_agreement</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vu.dot_3d(phi_gradient_xyz, slope_normal_vector)
        <span class="org-variable-name">dphi_dx_on_slope</span>   : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi_gradient_xyz[0] <span class="org-operator">-</span> phi_slope_agreement <span class="org-operator">*</span> slope_normal_vector[0]
        <span class="org-variable-name">dphi_dy_on_slope</span>   : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi_gradient_xyz[1] <span class="org-operator">-</span> phi_slope_agreement <span class="org-operator">*</span> slope_normal_vector[1]
        <span class="org-variable-name">dphi_dz_on_slope</span>   : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi_gradient_xyz[2] <span class="org-operator">-</span> phi_slope_agreement <span class="org-operator">*</span> slope_normal_vector[2]
        <span class="org-keyword">return</span> (dphi_dx_on_slope, dphi_dy_on_slope, dphi_dz_on_slope)


<span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Do I switch to cruz_passive_crown_fire_spread_rate() if the normal_spread_rate &lt; critical_spread_rate?</span>
<span class="org-comment-delimiter">#        </span><span class="org-comment">Did I do this correctly in calc_crown_fire_behavior_in_direction?</span>
<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_fireline_normal_behavior</span>(fire_behavior_max: FireBehaviorMax, phi_gradient_xyz: vec_xyz) <span class="org-operator">-&gt;</span> SpreadBehavior:
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - fire_behavior_max  :: FireBehaviorMax struct of max surface or crown fire behavior values</span>
<span class="org-doc">      - max_fire_type          :: 0 (unburned), 1 (surface), 2 (passive_crown), or 3 (active_crown)</span>
<span class="org-doc">      - max_spread_rate        :: m/min</span>
<span class="org-doc">      - max_spread_direction   :: (x, y, z) unit vector</span>
<span class="org-doc">      - max_fireline_intensity :: kW/m</span>
<span class="org-doc">      - max_flame_length       :: m</span>
<span class="org-doc">      - length_to_width_ratio  :: unitless (1: circular spread, &gt; 1: elliptical spread)</span>
<span class="org-doc">      - eccentricity           :: unitless (0: circular spread, &gt; 0: elliptical spread)</span>
<span class="org-doc">      - critical_spread_rate   :: m/min (Required for crown fires only)</span>
<span class="org-doc">    - phi_gradient_xyz   :: (dphi_dx: phi/m, dphi_dy: phi/m, dphi_dz: phi/m) 3D vector on the slope-tangential plane</span>

<span class="org-doc">    return a SpreadBehavior struct containing these keys:</span>
<span class="org-doc">    - dphi_dt            :: phi/min (on the slope-tangential plane)</span>
<span class="org-doc">    - fire_type          :: 0 (unburned), 1 (surface), 2 (passive_crown), or 3 (active_crown)</span>
<span class="org-doc">    - spread_rate        :: m/min</span>
<span class="org-doc">    - spread_direction   :: (x, y, z) unit vector</span>
<span class="org-doc">    - fireline_intensity :: kW/m</span>
<span class="org-doc">    - flame_length       :: m</span>

<span class="org-doc">    NOTE: This function should work for surface or crown fires interchangeably.</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the magnitude of the phi gradient</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    <span class="org-variable-name">phi_magnitude</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vu.vector_magnitude_3d(phi_gradient_xyz) <span class="org-comment-delimiter"># </span><span class="org-comment">phi/m</span>

    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Check whether cell is on the fire perimeter and burning</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    <span class="org-keyword">if</span> (phi_magnitude <span class="org-operator">==</span> 0.0 <span class="org-keyword">or</span> fire_behavior_max.max_spread_rate <span class="org-operator">==</span> 0.0):
        <span class="org-comment-delimiter"># </span><span class="org-comment">This location is not on the fire perimeter and/or is not burning</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Set the spread direction to the phi gradient direction, max spread direction, upslope, or North</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

        <span class="org-variable-name">spread_direction</span>: vec_xyz <span class="org-operator">=</span> (vu.scale_3d(1.0 <span class="org-operator">/</span> phi_magnitude, phi_gradient_xyz)
                                     <span class="org-keyword">if</span> phi_magnitude <span class="org-operator">&gt;</span> 0.0
                                     <span class="org-keyword">else</span> fire_behavior_max.max_spread_direction)

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Return zero surface/crown fire behavior</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-keyword">return</span> SpreadBehavior(
            dphi_dt            <span class="org-operator">=</span> 0.0,
            fire_type          <span class="org-operator">=</span> fire_type_unburned,
            spread_rate        <span class="org-operator">=</span> 0.0,
            spread_direction   <span class="org-operator">=</span> spread_direction,
            fireline_intensity <span class="org-operator">=</span> 0.0,
            flame_length       <span class="org-operator">=</span> 0.0,
        )

    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">This location is on the fire perimeter and is burning</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack the fire_behavior_max struct</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-variable-name">heading_fire_type</span>         : cy.<span class="org-builtin">int</span>   <span class="org-operator">=</span> fire_behavior_max.max_fire_type
        <span class="org-variable-name">heading_spread_rate</span>       : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> fire_behavior_max.max_spread_rate        <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
        <span class="org-variable-name">heading_spread_direction</span>  : vec_xyz  <span class="org-operator">=</span> fire_behavior_max.max_spread_direction   <span class="org-comment-delimiter"># </span><span class="org-comment">(x,y,z) unit vector</span>
        <span class="org-variable-name">heading_spread_vector</span>     : vec_xyz  <span class="org-operator">=</span> vu.scale_3d(heading_spread_rate,
                                                           heading_spread_direction)    <span class="org-comment-delimiter"># </span><span class="org-comment">(x,y,z) m/min vector</span>
        <span class="org-variable-name">heading_fireline_intensity</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> fire_behavior_max.max_fireline_intensity <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
        <span class="org-variable-name">length_to_width_ratio</span>     : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> fire_behavior_max.length_to_width_ratio  <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
        <span class="org-variable-name">eccentricity</span>              : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> fire_behavior_max.eccentricity           <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
        <span class="org-variable-name">critical_spread_rate</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> fire_behavior_max.critical_spread_rate   <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the backing and flanking fire spread rates</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-variable-name">backing_adjustment</span>  : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (1.0 <span class="org-operator">-</span> eccentricity) <span class="org-operator">/</span> (1.0 <span class="org-operator">+</span> eccentricity)  <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
        <span class="org-variable-name">backing_spread_rate</span> : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> heading_spread_rate <span class="org-operator">*</span> backing_adjustment     <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
        <span class="org-variable-name">flanking_spread_rate</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> ((heading_spread_rate <span class="org-operator">+</span> backing_spread_rate)
                                          <span class="org-operator">/</span> (2.0 <span class="org-operator">*</span> length_to_width_ratio))            <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate dphi/dt</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-variable-name">A</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (heading_spread_rate <span class="org-operator">-</span> backing_spread_rate) <span class="org-operator">/</span> (2.0 <span class="org-operator">*</span> heading_spread_rate) <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
        <span class="org-variable-name">B</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vu.dot_3d(heading_spread_vector, phi_gradient_xyz)                        <span class="org-comment-delimiter"># </span><span class="org-comment">phi/min</span>
        <span class="org-variable-name">C</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> flanking_spread_rate <span class="org-operator">/</span> heading_spread_rate                                <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
        <span class="org-variable-name">D</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> <span class="org-builtin">pow</span>((heading_spread_rate <span class="org-operator">*</span> phi_magnitude), 2.0)                           <span class="org-comment-delimiter"># </span><span class="org-comment">(phi/min)^2</span>
        <span class="org-variable-name">E</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> ((length_to_width_ratio <span class="org-operator">*</span> length_to_width_ratio) <span class="org-operator">-</span> 1.0) <span class="org-operator">*</span> (B <span class="org-operator">*</span> B)         <span class="org-comment-delimiter"># </span><span class="org-comment">(phi/min)^2</span>
        <span class="org-variable-name">dphi_dt</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> <span class="org-operator">-</span>(A <span class="org-operator">*</span> B <span class="org-operator">+</span> C <span class="org-operator">*</span> sqrt(D <span class="org-operator">+</span> E))                                                <span class="org-comment-delimiter"># </span><span class="org-comment">phi/min</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate fire behavior normal to the fire perimeter</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-variable-name">normal_spread_rate</span>       : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> <span class="org-operator">-</span>dphi_dt <span class="org-operator">/</span> phi_magnitude                        <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
        <span class="org-variable-name">normal_spread_direction</span>  : vec_xyz  <span class="org-operator">=</span> vu.as_unit_vector_3d(phi_gradient_xyz)          <span class="org-comment-delimiter"># </span><span class="org-comment">(x,y,z) unit vector</span>
        <span class="org-variable-name">normal_adjustment</span>        : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> normal_spread_rate <span class="org-operator">/</span> heading_spread_rate        <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
        <span class="org-variable-name">normal_fireline_intensity</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> heading_fireline_intensity <span class="org-operator">*</span> normal_adjustment  <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
        <span class="org-variable-name">normal_flame_length</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> sf.calc_flame_length(normal_fireline_intensity) <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
        <span class="org-variable-name">normal_fire_type</span>         : cy.<span class="org-builtin">int</span>   <span class="org-operator">=</span> (fire_type_surface <span class="org-keyword">if</span> heading_fire_type <span class="org-operator">==</span> fire_type_surface
                                               <span class="org-keyword">else</span> fire_type_crown_active <span class="org-keyword">if</span> normal_spread_rate <span class="org-operator">&gt;</span> critical_spread_rate
                                               <span class="org-keyword">else</span> fire_type_crown_passive)

        <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Return the surface/crown fire behavior normal to the fire perimeter</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

        <span class="org-keyword">return</span> SpreadBehavior(
            dphi_dt            <span class="org-operator">=</span> dphi_dt,                   <span class="org-comment-delimiter"># </span><span class="org-comment">phi/min</span>
            fire_type          <span class="org-operator">=</span> normal_fire_type,          <span class="org-comment-delimiter"># </span><span class="org-comment">surface, passive_crown, or active_crown</span>
            spread_rate        <span class="org-operator">=</span> normal_spread_rate,        <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
            spread_direction   <span class="org-operator">=</span> normal_spread_direction,   <span class="org-comment-delimiter"># </span><span class="org-comment">(x,y,z) unit vector</span>
            fireline_intensity <span class="org-operator">=</span> normal_fireline_intensity, <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
            flame_length       <span class="org-operator">=</span> normal_flame_length,       <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
        )
</pre>
</div>
</div>
</div>

<div id="outline-container-burn-cell-normal-to-the-fire-perimeter" class="outline-4">
<h4 id="burn-cell-normal-to-the-fire-perimeter"><span class="section-number-4">9.1.6.</span> Burn Cell Normal to the Fire Perimeter</h4>
<div class="outline-text-4" id="text-burn-cell-normal-to-the-fire-perimeter">
<p>
When the goal of a fire behavior analysis is to evolve a burn scar
from its point of ignition into a generally conical shape in
space-time, then it is necessary to evaluate the combined surface and
crown fire behavior in the direction normal to the fire front. In
order to facilitate this calculation, the following function uses the
horizontal \(\phi\) gradient, which denotes the maximum rate of change
in the \(\phi\) field at each grid cell in the horizontal (spatial)
plane. This 2D vector is first projected onto the 3D local
slope-tangential plane and used to compute the surface fire behavior
in this direction. If a crown fire occurs, the crown fire behavior is
also calculated in the direction of the 3D \(\phi\) gradient, and the
combined surface and crown fire behavior (as per section <a href="#combining-surface-and-crown-fire-behavior">6.1.8</a>) is returned. If no crown fire occurs,
the surface fire behavior in the direction of the 3D \(\phi\) gradient
is returned.
</p>

<div class="org-src-container">
<pre class="src src-python" id="burn-cell-toward-phi-gradient"><span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Turn this into a struct once its methods have been removed</span>
<span class="org-type">@cy.cclass</span>
<span class="org-keyword">class</span> <span class="org-type">SpreadInputs</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    A fast-access data structure for reading inputs in performance-critical code.</span>
<span class="org-doc">    """</span>
    rows                         : pyidx
    cols                         : pyidx
    band_duration                : cy.<span class="org-builtin">float</span> <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>
    cell_height                  : cy.<span class="org-builtin">float</span> <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
    cell_width                   : cy.<span class="org-builtin">float</span> <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
    slope                        : ISpaceTimeCube
    aspect                       : ISpaceTimeCube
    fuel_model                   : ISpaceTimeCube
    canopy_cover                 : ISpaceTimeCube
    canopy_height                : ISpaceTimeCube
    canopy_base_height           : ISpaceTimeCube
    canopy_bulk_density          : ISpaceTimeCube
    wind_speed_10m               : ISpaceTimeCube
    upwind_direction             : ISpaceTimeCube
    fuel_moisture_dead_1hr       : ISpaceTimeCube
    fuel_moisture_dead_10hr      : ISpaceTimeCube
    fuel_moisture_dead_100hr     : ISpaceTimeCube
    fuel_moisture_live_herbaceous: ISpaceTimeCube
    fuel_moisture_live_woody     : ISpaceTimeCube
    foliar_moisture              : ISpaceTimeCube
    temperature                  : ISpaceTimeCube
    fuel_spread_adjustment       : ISpaceTimeCube
    weather_spread_adjustment    : ISpaceTimeCube
    fuel_model_cache             : cy.pointer(FuelModel)


    <span class="org-keyword">def</span> <span class="org-function-name">__cinit__</span>(<span class="org-keyword">self</span>,
                  cube_resolution              : <span class="org-builtin">tuple</span>[cy.<span class="org-builtin">float</span>, cy.<span class="org-builtin">float</span>, cy.<span class="org-builtin">float</span>],
                  slope                        : ISpaceTimeCube,
                  aspect                       : ISpaceTimeCube,
                  fuel_model                   : ISpaceTimeCube,
                  canopy_cover                 : ISpaceTimeCube,
                  canopy_height                : ISpaceTimeCube,
                  canopy_base_height           : ISpaceTimeCube,
                  canopy_bulk_density          : ISpaceTimeCube,
                  wind_speed_10m               : ISpaceTimeCube,
                  upwind_direction             : ISpaceTimeCube,
                  fuel_moisture_dead_1hr       : ISpaceTimeCube,
                  fuel_moisture_dead_10hr      : ISpaceTimeCube,
                  fuel_moisture_dead_100hr     : ISpaceTimeCube,
                  fuel_moisture_live_herbaceous: ISpaceTimeCube,
                  fuel_moisture_live_woody     : ISpaceTimeCube,
                  foliar_moisture              : ISpaceTimeCube,
                  temperature                  : ISpaceTimeCube,
                  fuel_spread_adjustment       : ISpaceTimeCube,
                  weather_spread_adjustment    : ISpaceTimeCube) <span class="org-operator">-&gt;</span> cy.void:
        (<span class="org-variable-name">_bands</span>, <span class="org-variable-name">rows</span>, <span class="org-variable-name">cols</span>)               <span class="org-operator">=</span> slope.shape
        <span class="org-keyword">self</span>.<span class="org-variable-name">rows</span>                          <span class="org-operator">=</span> rows
        <span class="org-keyword">self</span>.<span class="org-variable-name">cols</span>                          <span class="org-operator">=</span> cols
        <span class="org-keyword">self</span>.<span class="org-variable-name">band_duration</span>                 <span class="org-operator">=</span> cube_resolution[0]
        <span class="org-keyword">self</span>.<span class="org-variable-name">cell_height</span>                   <span class="org-operator">=</span> cube_resolution[1]
        <span class="org-keyword">self</span>.<span class="org-variable-name">cell_width</span>                    <span class="org-operator">=</span> cube_resolution[2]
        <span class="org-keyword">self</span>.<span class="org-variable-name">slope</span>                         <span class="org-operator">=</span> slope
        <span class="org-keyword">self</span>.<span class="org-variable-name">aspect</span>                        <span class="org-operator">=</span> aspect
        <span class="org-keyword">self</span>.<span class="org-variable-name">fuel_model</span>                    <span class="org-operator">=</span> fuel_model
        <span class="org-keyword">self</span>.<span class="org-variable-name">canopy_cover</span>                  <span class="org-operator">=</span> canopy_cover
        <span class="org-keyword">self</span>.<span class="org-variable-name">canopy_height</span>                 <span class="org-operator">=</span> canopy_height
        <span class="org-keyword">self</span>.<span class="org-variable-name">canopy_base_height</span>            <span class="org-operator">=</span> canopy_base_height
        <span class="org-keyword">self</span>.<span class="org-variable-name">canopy_bulk_density</span>           <span class="org-operator">=</span> canopy_bulk_density
        <span class="org-keyword">self</span>.<span class="org-variable-name">wind_speed_10m</span>                <span class="org-operator">=</span> wind_speed_10m
        <span class="org-keyword">self</span>.<span class="org-variable-name">upwind_direction</span>              <span class="org-operator">=</span> upwind_direction
        <span class="org-keyword">self</span>.<span class="org-variable-name">fuel_moisture_dead_1hr</span>        <span class="org-operator">=</span> fuel_moisture_dead_1hr
        <span class="org-keyword">self</span>.<span class="org-variable-name">fuel_moisture_dead_10hr</span>       <span class="org-operator">=</span> fuel_moisture_dead_10hr
        <span class="org-keyword">self</span>.<span class="org-variable-name">fuel_moisture_dead_100hr</span>      <span class="org-operator">=</span> fuel_moisture_dead_100hr
        <span class="org-keyword">self</span>.<span class="org-variable-name">fuel_moisture_live_herbaceous</span> <span class="org-operator">=</span> fuel_moisture_live_herbaceous
        <span class="org-keyword">self</span>.<span class="org-variable-name">fuel_moisture_live_woody</span>      <span class="org-operator">=</span> fuel_moisture_live_woody
        <span class="org-keyword">self</span>.<span class="org-variable-name">foliar_moisture</span>               <span class="org-operator">=</span> foliar_moisture
        <span class="org-keyword">self</span>.<span class="org-variable-name">temperature</span>                   <span class="org-operator">=</span> temperature
        <span class="org-keyword">self</span>.<span class="org-variable-name">fuel_spread_adjustment</span>        <span class="org-operator">=</span> fuel_spread_adjustment
        <span class="org-keyword">self</span>.<span class="org-variable-name">weather_spread_adjustment</span>     <span class="org-operator">=</span> weather_spread_adjustment
        <span class="org-keyword">self</span>.__init_fuel_models()


    <span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Move this code to fuel_models.py</span>
    <span class="org-type">@cy.cfunc</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__init_fuel_models</span>(<span class="org-keyword">self</span>) <span class="org-operator">-&gt;</span> cy.void:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Allocate an empty FuelModel array in memory</span>
        <span class="org-variable-name">fuel_model_cache</span>: cy.pointer(FuelModel) <span class="org-operator">=</span> cy.cast(cy.pointer(FuelModel),
                                                          malloc(300 <span class="org-operator">*</span> cy.sizeof(FuelModel)))
        <span class="org-comment-delimiter"># </span><span class="org-comment">Verify that it was created</span>
        <span class="org-keyword">if</span> <span class="org-keyword">not</span> fuel_model_cache:
            <span class="org-comment-delimiter"># </span><span class="org-comment">Something went wrong with malloc</span>
            <span class="org-keyword">raise</span> <span class="org-type">MemoryError</span>()
        <span class="org-keyword">else</span>:
            <span class="org-comment-delimiter"># </span><span class="org-comment">Copy FuelModels from fm.fuel_model_table into fuel_model_cache</span>
            fuel_model: FuelModel
            <span class="org-keyword">for</span> fuel_model <span class="org-keyword">in</span> fm.fuel_model_table.values():
                <span class="org-variable-name">fuel_model_cache</span>[fuel_model.number] <span class="org-operator">=</span> fuel_model
            <span class="org-comment-delimiter"># </span><span class="org-comment">Save fuel_model_cache in the SpreadInputs object</span>
            <span class="org-keyword">self</span>.<span class="org-variable-name">fuel_model_cache</span> <span class="org-operator">=</span> fuel_model_cache


    <span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Inline this code at its call sites</span>
    <span class="org-type">@cy.cfunc</span>
    <span class="org-type">@cy.inline</span>
    <span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
    <span class="org-keyword">def</span> <span class="org-function-name">get_fm_struct</span>(<span class="org-keyword">self</span>, fm_number: pyidx) <span class="org-operator">-&gt;</span> FuelModel:
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>.fuel_model_cache[fm_number]


    <span class="org-keyword">def</span> <span class="org-function-name">__dealloc__</span>(<span class="org-keyword">self</span>) <span class="org-operator">-&gt;</span> cy.void:
        free(<span class="org-keyword">self</span>.fuel_model_cache) <span class="org-comment-delimiter"># </span><span class="org-comment">no-op if self.fuel_model_cache is NULL</span>


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Inline this code at its call sites</span>
<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-keyword">def</span> <span class="org-function-name">make_SpreadInputs</span>(cube_shape      : <span class="org-builtin">tuple</span>[pyidx, pyidx, pyidx],
                      cube_resolution : <span class="org-builtin">tuple</span>[cy.<span class="org-builtin">float</span>, cy.<span class="org-builtin">float</span>, cy.<span class="org-builtin">float</span>],
                      space_time_cubes: <span class="org-builtin">dict</span>) <span class="org-operator">-&gt;</span> SpreadInputs:
    <span class="org-keyword">return</span> SpreadInputs(cube_resolution,
                        space_time_cubes[<span class="org-string">"slope"</span>],
                        space_time_cubes[<span class="org-string">"aspect"</span>],
                        space_time_cubes[<span class="org-string">"fuel_model"</span>],
                        space_time_cubes[<span class="org-string">"canopy_cover"</span>],
                        space_time_cubes[<span class="org-string">"canopy_height"</span>],
                        space_time_cubes[<span class="org-string">"canopy_base_height"</span>],
                        space_time_cubes[<span class="org-string">"canopy_bulk_density"</span>],
                        space_time_cubes[<span class="org-string">"wind_speed_10m"</span>],
                        space_time_cubes[<span class="org-string">"upwind_direction"</span>],
                        space_time_cubes[<span class="org-string">"fuel_moisture_dead_1hr"</span>],
                        space_time_cubes[<span class="org-string">"fuel_moisture_dead_10hr"</span>],
                        space_time_cubes[<span class="org-string">"fuel_moisture_dead_100hr"</span>],
                        space_time_cubes[<span class="org-string">"fuel_moisture_live_herbaceous"</span>],
                        space_time_cubes[<span class="org-string">"fuel_moisture_live_woody"</span>],
                        space_time_cubes[<span class="org-string">"foliar_moisture"</span>],
                        space_time_cubes.get(<span class="org-string">"temperature"</span>, SpaceTimeCube(cube_shape, <span class="org-operator">-</span>1.0)),
                        space_time_cubes.get(<span class="org-string">"fuel_spread_adjustment"</span>, SpaceTimeCube(cube_shape, 1.0)),
                        space_time_cubes.get(<span class="org-string">"weather_spread_adjustment"</span>, SpaceTimeCube(cube_shape, 1.0)))


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">lookup_cell_inputs</span>(spread_inputs: SpreadInputs, space_time_coordinate: coord_tyx) <span class="org-operator">-&gt;</span> CellInputs:
    <span class="org-doc">"""</span>
<span class="org-doc">    Reads the inputs for a given cell from the space-time cubes, returning a `CellInputs` struct.</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack the space_time_coordinate</span>
    <span class="org-variable-name">t</span>: pyidx <span class="org-operator">=</span> space_time_coordinate[0]
    <span class="org-variable-name">y</span>: pyidx <span class="org-operator">=</span> space_time_coordinate[1]
    <span class="org-variable-name">x</span>: pyidx <span class="org-operator">=</span> space_time_coordinate[2]

    <span class="org-comment-delimiter"># </span><span class="org-comment">Topography, Fuel Model, and Vegetation</span>
    <span class="org-variable-name">slope</span>              : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> spread_inputs.slope.get(t, y, x)               <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-variable-name">aspect</span>             : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> spread_inputs.aspect.get(t, y, x)              <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-variable-name">fuel_model_number</span>  : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> spread_inputs.fuel_model.get(t, y, x)          <span class="org-comment-delimiter"># </span><span class="org-comment">integer index in fm.fuel_model_table</span>
    <span class="org-variable-name">canopy_cover</span>       : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> spread_inputs.canopy_cover.get(t, y, x)        <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
    <span class="org-variable-name">canopy_height</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> spread_inputs.canopy_height.get(t, y, x)       <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-variable-name">canopy_base_height</span> : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> spread_inputs.canopy_base_height.get(t, y, x)  <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-variable-name">canopy_bulk_density</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> spread_inputs.canopy_bulk_density.get(t, y, x) <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Wind, Surface Moisture, and Foliar Moisture</span>
    <span class="org-variable-name">wind_speed_10m</span>               : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> spread_inputs.wind_speed_10m.get(t, y, x)                <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-variable-name">upwind_direction</span>             : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> spread_inputs.upwind_direction.get(t, y, x)              <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-variable-name">fuel_moisture_dead_1hr</span>       : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> spread_inputs.fuel_moisture_dead_1hr.get(t, y, x)        <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_dead_10hr</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> spread_inputs.fuel_moisture_dead_10hr.get(t, y, x)       <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_dead_100hr</span>     : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> spread_inputs.fuel_moisture_dead_100hr.get(t, y, x)      <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_live_herbaceous</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> spread_inputs.fuel_moisture_live_herbaceous.get(t, y, x) <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_live_woody</span>     : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> spread_inputs.fuel_moisture_live_woody.get(t, y, x)      <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">foliar_moisture</span>              : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> spread_inputs.foliar_moisture.get(t, y, x)               <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Spread Rate Adjustments (Optional)</span>
    <span class="org-variable-name">fuel_spread_adjustment</span>   : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (spread_inputs.fuel_spread_adjustment.get(t, y, x)
                                           <span class="org-keyword">if</span> spread_inputs.fuel_spread_adjustment <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>
                                           <span class="org-keyword">else</span> 1.0)                                         <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>
    <span class="org-variable-name">weather_spread_adjustment</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (spread_inputs.weather_spread_adjustment.get(t, y, x)
                                           <span class="org-keyword">if</span> spread_inputs.weather_spread_adjustment <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>
                                           <span class="org-keyword">else</span> 1.0)                                         <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Pack values into a CellInputs struct and return</span>
    <span class="org-keyword">return</span> CellInputs(
        slope                         <span class="org-operator">=</span> slope,
        aspect                        <span class="org-operator">=</span> aspect,
        fuel_model_number             <span class="org-operator">=</span> fuel_model_number,
        canopy_cover                  <span class="org-operator">=</span> canopy_cover,
        canopy_height                 <span class="org-operator">=</span> canopy_height,
        canopy_base_height            <span class="org-operator">=</span> canopy_base_height,
        canopy_bulk_density           <span class="org-operator">=</span> canopy_bulk_density,
        wind_speed_10m                <span class="org-operator">=</span> wind_speed_10m,
        upwind_direction              <span class="org-operator">=</span> upwind_direction,
        fuel_moisture_dead_1hr        <span class="org-operator">=</span> fuel_moisture_dead_1hr,
        fuel_moisture_dead_10hr       <span class="org-operator">=</span> fuel_moisture_dead_10hr,
        fuel_moisture_dead_100hr      <span class="org-operator">=</span> fuel_moisture_dead_100hr,
        fuel_moisture_live_herbaceous <span class="org-operator">=</span> fuel_moisture_live_herbaceous,
        fuel_moisture_live_woody      <span class="org-operator">=</span> fuel_moisture_live_woody,
        foliar_moisture               <span class="org-operator">=</span> foliar_moisture,
        fuel_spread_adjustment        <span class="org-operator">=</span> fuel_spread_adjustment,
        weather_spread_adjustment     <span class="org-operator">=</span> weather_spread_adjustment,
    )


<span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: We're only going through these annoying calculations because</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">we are required to return a spread_direction unit vector, which is</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">of questionable value.</span>
<span class="org-comment-delimiter">#</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">IMPROVEMENT: We wouldn't have to go through this trouble if we simply</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">returned a Cartesian speed vector instead, which would play more</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">nicely with the rest of the code.</span>
<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">unburned_SpreadBehavior</span>(elevation_gradient: vec_xy, phi_gradient_xyz: vec_xyz) <span class="org-operator">-&gt;</span> SpreadBehavior:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Create a 3D unit vector pointing...</span>
    spread_direction: vec_xyz
    <span class="org-keyword">if</span> (phi_gradient_xyz[0] <span class="org-operator">!=</span> 0.0 <span class="org-keyword">and</span> phi_gradient_xyz[1] <span class="org-operator">!=</span> 0.0 <span class="org-keyword">and</span> phi_gradient_xyz[2] <span class="org-operator">!=</span> 0.0):
        <span class="org-comment-delimiter"># </span><span class="org-comment">...in the direction of the spatial phi gradient</span>
        <span class="org-variable-name">spread_direction</span> <span class="org-operator">=</span> vu.as_unit_vector_3d(phi_gradient_xyz)
    <span class="org-keyword">elif</span> (elevation_gradient[0] <span class="org-operator">!=</span> 0.0 <span class="org-keyword">and</span> elevation_gradient[1] <span class="org-operator">!=</span> 0.0):
        <span class="org-comment-delimiter"># </span><span class="org-comment">...upslope on the slope-tangential plane</span>
        <span class="org-variable-name">slope_vector_3d</span>: vec_xyz <span class="org-operator">=</span> vu.to_slope_plane(elevation_gradient, elevation_gradient)
        <span class="org-variable-name">spread_direction</span>         <span class="org-operator">=</span> vu.as_unit_vector_3d(slope_vector_3d)
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">...to the North</span>
        <span class="org-variable-name">spread_direction</span> <span class="org-operator">=</span> (0.0, 1.0, 0.0)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Return zero surface fire behavior</span>
    <span class="org-keyword">return</span> SpreadBehavior(
        dphi_dt            <span class="org-operator">=</span> 0.0,
        fire_type          <span class="org-operator">=</span> fire_type_unburned,
        spread_rate        <span class="org-operator">=</span> 0.0,
        spread_direction   <span class="org-operator">=</span> spread_direction,
        fireline_intensity <span class="org-operator">=</span> 0.0,
        flame_length       <span class="org-operator">=</span> 0.0,
    )


<span class="org-type">@cy.cclass</span>
<span class="org-keyword">class</span> <span class="org-type">SpreadState</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Stores the stateful data associated with a fire spread simulation.</span>
<span class="org-doc">    """</span>
    cube_shape        : <span class="org-builtin">tuple</span>[pyidx, pyidx, pyidx]
    phi               : cy.<span class="org-builtin">float</span>[:,::1] <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array of values in [-1,1]</span>
    phi_star          : cy.<span class="org-builtin">float</span>[:,::1] <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array of values in [-1,1]</span>
    fire_type         : cy.uchar[:,::1] <span class="org-comment-delimiter"># </span><span class="org-comment">2D byte array (0-3)</span>
    spread_rate       : cy.<span class="org-builtin">float</span>[:,::1] <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array (m/min)</span>
    spread_direction  : cy.<span class="org-builtin">float</span>[:,::1] <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array (degrees clockwise from North)</span>
    fireline_intensity: cy.<span class="org-builtin">float</span>[:,::1] <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array (kW/m)</span>
    flame_length      : cy.<span class="org-builtin">float</span>[:,::1] <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array (m)</span>
    time_of_arrival   : cy.<span class="org-builtin">float</span>[:,::1] <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array (min)</span>


    <span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Initialize output matrices to NaN if possible</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, cube_shape: <span class="org-builtin">tuple</span>[pyidx, pyidx, pyidx]) <span class="org-operator">-&gt;</span> cy.void:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Extract the grid_shape from the cube_shape</span>
        <span class="org-variable-name">grid_rows</span> : pyidx               <span class="org-operator">=</span> cube_shape[1]
        <span class="org-variable-name">grid_cols</span> : pyidx               <span class="org-operator">=</span> cube_shape[2]
        <span class="org-variable-name">grid_shape</span>: <span class="org-builtin">tuple</span>[<span class="org-variable-name">pyidx</span>, <span class="org-variable-name">pyidx</span>] <span class="org-operator">=</span> (grid_rows, grid_cols)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Create the initial 2D arrays</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: The phi matrix is padded by 2 cells on each side to avoid the cost of checking bounds.</span>
        <span class="org-keyword">self</span>.<span class="org-variable-name">cube_shape</span>         <span class="org-operator">=</span> cube_shape
        <span class="org-keyword">self</span>.<span class="org-variable-name">phi</span>                <span class="org-operator">=</span> np.ones((grid_rows <span class="org-operator">+</span> 4, grid_cols <span class="org-operator">+</span> 4), dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)
        <span class="org-keyword">self</span>.<span class="org-variable-name">phi_star</span>           <span class="org-operator">=</span> np.ones((grid_rows <span class="org-operator">+</span> 4, grid_cols <span class="org-operator">+</span> 4), dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)
        <span class="org-keyword">self</span>.<span class="org-variable-name">fire_type</span>          <span class="org-operator">=</span> np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"uint8"</span>)
        <span class="org-keyword">self</span>.<span class="org-variable-name">spread_rate</span>        <span class="org-operator">=</span> np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)
        <span class="org-keyword">self</span>.<span class="org-variable-name">spread_direction</span>   <span class="org-operator">=</span> np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)
        <span class="org-keyword">self</span>.<span class="org-variable-name">fireline_intensity</span> <span class="org-operator">=</span> np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)
        <span class="org-keyword">self</span>.<span class="org-variable-name">flame_length</span>       <span class="org-operator">=</span> np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)
        <span class="org-keyword">self</span>.<span class="org-variable-name">time_of_arrival</span>    <span class="org-operator">=</span> np.full(grid_shape, <span class="org-operator">-</span>1.0, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)


    <span class="org-type">@cy.ccall</span>
    <span class="org-keyword">def</span> <span class="org-function-name">ignite_cell</span>(<span class="org-keyword">self</span>, ignited_cell: coord_yx) <span class="org-operator">-&gt;</span> SpreadState:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Extract coords</span>
        <span class="org-variable-name">y</span>: pyidx <span class="org-operator">=</span> ignited_cell[0]
        <span class="org-variable-name">x</span>: pyidx <span class="org-operator">=</span> ignited_cell[1]
        <span class="org-comment-delimiter"># </span><span class="org-comment">Overwrite phi and phi_star state</span>
        <span class="org-keyword">self</span>.<span class="org-variable-name">phi</span>[2<span class="org-operator">+</span>y,2<span class="org-operator">+</span>x]      <span class="org-operator">=</span> <span class="org-operator">-</span>1.0
        <span class="org-keyword">self</span>.<span class="org-variable-name">phi_star</span>[2<span class="org-operator">+</span>y,2<span class="org-operator">+</span>x] <span class="org-operator">=</span> <span class="org-operator">-</span>1.0
        <span class="org-comment-delimiter"># </span><span class="org-comment">Return the updated SpreadState object</span>
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>


    <span class="org-type">@cy.ccall</span>
    <span class="org-keyword">def</span> <span class="org-function-name">ignite_cells</span>(<span class="org-keyword">self</span>, lower_left_corner: coord_yx, ignition_matrix: cy.<span class="org-builtin">float</span>[:,::1]) <span class="org-operator">-&gt;</span> SpreadState:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Extract coords</span>
        <span class="org-variable-name">rows</span> : pyidx <span class="org-operator">=</span> ignition_matrix.shape[0]
        <span class="org-variable-name">cols</span> : pyidx <span class="org-operator">=</span> ignition_matrix.shape[1]
        <span class="org-variable-name">min_y</span>: pyidx <span class="org-operator">=</span> lower_left_corner[0]
        <span class="org-variable-name">min_x</span>: pyidx <span class="org-operator">=</span> lower_left_corner[1]
        <span class="org-variable-name">max_y</span>: pyidx <span class="org-operator">=</span> min_y <span class="org-operator">+</span> rows
        <span class="org-variable-name">max_x</span>: pyidx <span class="org-operator">=</span> min_x <span class="org-operator">+</span> cols
        <span class="org-comment-delimiter"># </span><span class="org-comment">Overwrite phi and phi_star state</span>
        <span class="org-keyword">self</span>.<span class="org-variable-name">phi</span>[2<span class="org-operator">+</span>min_y:2<span class="org-operator">+</span>max_y,2<span class="org-operator">+</span>min_x:2<span class="org-operator">+</span>max_x]      <span class="org-operator">=</span> ignition_matrix
        <span class="org-keyword">self</span>.<span class="org-variable-name">phi_star</span>[2<span class="org-operator">+</span>min_y:2<span class="org-operator">+</span>max_y,2<span class="org-operator">+</span>min_x:2<span class="org-operator">+</span>max_x] <span class="org-operator">=</span> ignition_matrix
        <span class="org-comment-delimiter"># </span><span class="org-comment">Return the updated SpreadState object</span>
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>


    <span class="org-type">@cy.ccall</span>
    <span class="org-keyword">def</span> <span class="org-function-name">get_burned_matrices</span>(<span class="org-keyword">self</span>, layers: <span class="org-builtin">list</span>[<span class="org-builtin">str</span>]<span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> <span class="org-constant">None</span>) <span class="org-operator">-&gt;</span> <span class="org-builtin">dict</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Find bounding box of burned area</span>
        <span class="org-variable-name">burned_mask</span>: <span class="org-builtin">tuple</span>[<span class="org-variable-name">ndarray</span>, <span class="org-variable-name">ndarray</span>] <span class="org-operator">=</span> np.nonzero(<span class="org-keyword">self</span>.fire_type)
        <span class="org-variable-name">min_y</span>      : pyidx                   <span class="org-operator">=</span> burned_mask[0].<span class="org-builtin">min</span>()
        <span class="org-variable-name">max_y</span>      : pyidx                   <span class="org-operator">=</span> burned_mask[0].<span class="org-builtin">max</span>()
        <span class="org-variable-name">min_x</span>      : pyidx                   <span class="org-operator">=</span> burned_mask[1].<span class="org-builtin">min</span>()
        <span class="org-variable-name">max_x</span>      : pyidx                   <span class="org-operator">=</span> burned_mask[1].<span class="org-builtin">max</span>()
        <span class="org-comment-delimiter"># </span><span class="org-comment">Prepare the 2D arrays in a dict</span>
        <span class="org-variable-name">available_matrices</span>: <span class="org-builtin">dict</span>[<span class="org-builtin">str</span>, <span class="org-variable-name">ndarray</span>] <span class="org-operator">=</span> {
            <span class="org-string">"phi"</span>               : <span class="org-keyword">self</span>.phi,
            <span class="org-string">"fire_type"</span>         : <span class="org-keyword">self</span>.fire_type,
            <span class="org-string">"spread_rate"</span>       : <span class="org-keyword">self</span>.spread_rate,
            <span class="org-string">"spread_direction"</span>  : <span class="org-keyword">self</span>.spread_direction,
            <span class="org-string">"fireline_intensity"</span>: <span class="org-keyword">self</span>.fireline_intensity,
            <span class="org-string">"flame_length"</span>      : <span class="org-keyword">self</span>.flame_length,
            <span class="org-string">"time_of_arrival"</span>   : <span class="org-keyword">self</span>.time_of_arrival,
        }
        <span class="org-comment-delimiter"># </span><span class="org-comment">Set selected_layers to layers if specified and otherwise to all available layers</span>
        <span class="org-variable-name">selected_layers</span>: <span class="org-builtin">list</span>[<span class="org-builtin">str</span>] <span class="org-operator">=</span> layers <span class="org-keyword">if</span> layers <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span> <span class="org-keyword">else</span> <span class="org-builtin">list</span>(available_matrices.keys())
        <span class="org-comment-delimiter"># </span><span class="org-comment">Clip the 2D arrays from selected_layers to the bounding box</span>
        <span class="org-variable-name">clipped_matrices</span>: <span class="org-builtin">dict</span>[<span class="org-builtin">str</span>, <span class="org-variable-name">ndarray</span>] <span class="org-operator">=</span> {
            k: np.copy(available_matrices[k][min_y:max_y<span class="org-operator">+</span>1, min_x:max_x<span class="org-operator">+</span>1]) <span class="org-keyword">for</span> k <span class="org-keyword">in</span> selected_layers
        }
        <span class="org-comment-delimiter"># </span><span class="org-comment">Return the clipped_matrices along with their lower_left_corner for reference</span>
        <span class="org-keyword">return</span> {
            <span class="org-string">"cube_shape"</span>       : <span class="org-keyword">self</span>.cube_shape,
            <span class="org-string">"lower_left_corner"</span>: (min_y, min_x),
            <span class="org-string">"clipped_matrices"</span> : clipped_matrices,
        }


    <span class="org-type">@cy.ccall</span>
    <span class="org-keyword">def</span> <span class="org-function-name">get_full_matrices</span>(<span class="org-keyword">self</span>, layers: <span class="org-builtin">list</span>[<span class="org-builtin">str</span>]<span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> <span class="org-constant">None</span>) <span class="org-operator">-&gt;</span> <span class="org-builtin">dict</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Prepare the 2D arrays in a dict</span>
        <span class="org-variable-name">available_matrices</span>: <span class="org-builtin">dict</span>[<span class="org-builtin">str</span>, <span class="org-variable-name">ndarray</span>] <span class="org-operator">=</span> {
            <span class="org-string">"phi"</span>               : np.asarray(<span class="org-keyword">self</span>.phi),
            <span class="org-string">"fire_type"</span>         : np.asarray(<span class="org-keyword">self</span>.fire_type),
            <span class="org-string">"spread_rate"</span>       : np.asarray(<span class="org-keyword">self</span>.spread_rate),
            <span class="org-string">"spread_direction"</span>  : np.asarray(<span class="org-keyword">self</span>.spread_direction),
            <span class="org-string">"fireline_intensity"</span>: np.asarray(<span class="org-keyword">self</span>.fireline_intensity),
            <span class="org-string">"flame_length"</span>      : np.asarray(<span class="org-keyword">self</span>.flame_length),
            <span class="org-string">"time_of_arrival"</span>   : np.asarray(<span class="org-keyword">self</span>.time_of_arrival),
        }
        <span class="org-comment-delimiter"># </span><span class="org-comment">Return the matrices in layers if specified and otherwise return all available layers</span>
        <span class="org-keyword">if</span> layers <span class="org-keyword">is</span> <span class="org-constant">None</span>:
            <span class="org-keyword">return</span> available_matrices
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> {
                k: available_matrices[k] <span class="org-keyword">for</span> k <span class="org-keyword">in</span> layers
            }


    <span class="org-type">@cy.ccall</span>
    <span class="org-keyword">def</span> <span class="org-function-name">copy</span>(<span class="org-keyword">self</span>) <span class="org-operator">-&gt;</span> SpreadState:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Create an empty SpreadState object</span>
        <span class="org-variable-name">new_spread_state</span>: SpreadState <span class="org-operator">=</span> SpreadState.__new__(SpreadState, <span class="org-keyword">self</span>.cube_shape)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Initialize its fields with copies of the base object's fields</span>
        new_spread_state.<span class="org-variable-name">cube_shape</span>         <span class="org-operator">=</span> <span class="org-keyword">self</span>.cube_shape <span class="org-comment-delimiter"># </span><span class="org-comment">tuples are immutable</span>
        new_spread_state.<span class="org-variable-name">phi</span>                <span class="org-operator">=</span> np.copy(<span class="org-keyword">self</span>.phi)
        new_spread_state.<span class="org-variable-name">phi_star</span>           <span class="org-operator">=</span> np.copy(<span class="org-keyword">self</span>.phi_star)
        new_spread_state.<span class="org-variable-name">fire_type</span>          <span class="org-operator">=</span> np.copy(<span class="org-keyword">self</span>.fire_type)
        new_spread_state.<span class="org-variable-name">spread_rate</span>        <span class="org-operator">=</span> np.copy(<span class="org-keyword">self</span>.spread_rate)
        new_spread_state.<span class="org-variable-name">spread_direction</span>   <span class="org-operator">=</span> np.copy(<span class="org-keyword">self</span>.spread_direction)
        new_spread_state.<span class="org-variable-name">fireline_intensity</span> <span class="org-operator">=</span> np.copy(<span class="org-keyword">self</span>.fireline_intensity)
        new_spread_state.<span class="org-variable-name">flame_length</span>       <span class="org-operator">=</span> np.copy(<span class="org-keyword">self</span>.flame_length)
        new_spread_state.<span class="org-variable-name">time_of_arrival</span>    <span class="org-operator">=</span> np.copy(<span class="org-keyword">self</span>.time_of_arrival)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Return the initialized SpreadState object</span>
        <span class="org-keyword">return</span> new_spread_state
</pre>
</div>
</div>
</div>

<div id="outline-container-identify-cells-near-the-fire-perimeter-($\phi-=-0$)" class="outline-4">
<h4 id="identify-cells-near-the-fire-perimeter-($\phi-=-0$)"><span class="section-number-4">9.1.7.</span> Identify Cells Near the Fire Perimeter (\(\phi = 0\))</h4>
<div class="outline-text-4" id="text-identify-cells-near-the-fire-perimeter-($\phi-=-0$)">
</div>
<ol class="org-ol">
<li><a id="a-proposed-algorithm-for-narrow-band-tracking"></a>A proposed algorithm for narrow band tracking<br>
<div class="outline-text-5" id="text-a-proposed-algorithm-for-narrow-band-tracking">
</div>
<ol class="org-ol">
<li><a id="problem-statement"></a>Problem statement<br>
<div class="outline-text-6" id="text-problem-statement">
<p>
To make the level-set method efficient, an important optimization
consists of updating only those cells in a narrow band around the fire
front (e.g., within a width of 3 cells). This way fire behavior gets
computed (and \(\phi\) gets updated) only on a sparse subset of the
landscape at each timestep.
</p>
</div>
</li>

<li><a id="definitions"></a>Definitions<br>
<div class="outline-text-6" id="text-definitions">
<p>
At a given time step:
</p>

<ol class="org-ol">
<li>a <span class="underline">frontier</span> cell is a cell that has a neighbor of opposite \(\phi\)
sign.</li>

<li>a <span class="underline">tracked</span> cell is a cell for which we will compute the fire
behavior and update the \(\phi\) field.</li>
</ol>
</div>
</li>

<li><a id="suggested-algorithm"></a>Suggested algorithm<br>
<div class="outline-text-6" id="text-suggested-algorithm">
<dl class="org-dl">
<dt>Detecting Frontier Cells</dt><dd>iterate through cell pairs (N/S, E/W),
computing the products of their \(\phi\) values and match when these
are negative.</dd>

<dt>Invariant</dt><dd>at each time step, the set of tracked cells is the set
of cells within 3 cells of a frontier cell using the Chebyshev
distance.</dd>

<dt>State</dt><dd>we maintain a "reference counting" map, mapping each
tracked cell to the number of frontier cells to which it is near
(_near_ means "within 3 cells" using the Chebyshev distance). In
particular, the keyset of this map is the set of tracked cells.</dd>

<dt>Iteration</dt><dd>at the end of timestep \(t\), we know the values of
\(\phi(t)\) and \(\phi(t+\Delta t)\) for all tracked cells. We now must
compute the new set of tracked cells, which involves updating the
reference-counting map. We do so by taking the following steps:

<ol class="org-ol">
<li>Scan the set of tracked cells, and compute two subsets of them:
(A) those that have become frontier cells and (B) those that are
no longer frontier cells.</li>

<li>For each cell in A (new frontier cell), list the cells near it,
and increment their tracking counter by 1.</li>

<li>For each cell in B (no longer a frontier cell), list the cells
near it, and decrement their tracking counter by 1. Upon reaching
0, remove the map entry.</li>
</ol></dd>
</dl>

<div class="org-src-container">
<pre class="src src-python" id="phi-field-perimeter-tracking"><span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-keyword">def</span> <span class="org-function-name">encode_cell_index</span>(y: pyidx, x: pyidx) <span class="org-operator">-&gt;</span> <span class="org-builtin">object</span>: <span class="org-comment-delimiter"># </span><span class="org-comment">ulong</span>
    <span class="org-doc">"""</span>
<span class="org-doc">    Encodes a (y, x) tuple into a single Python integer object.</span>
<span class="org-doc">    This enables a more efficient memory layout than a tuple of Python integers.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> (cy.cast(cy.ulonglong, y) <span class="org-operator">&lt;&lt;</span> 32) <span class="org-operator">+</span> cy.cast(cy.ulonglong, x)


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">decode_cell_index</span>(encoded_cell_index: <span class="org-builtin">object</span>) <span class="org-operator">-&gt;</span> coord_yx:
    <span class="org-variable-name">cell_index</span>: cy.ulonglong <span class="org-operator">=</span> encoded_cell_index
    <span class="org-variable-name">y</span>         : pyidx        <span class="org-operator">=</span> cell_index <span class="org-operator">&gt;&gt;</span> 32
    <span class="org-variable-name">x</span>         : pyidx        <span class="org-operator">=</span> cy.cast(cy.uint, cell_index) <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: faster than (cell_index &amp; 0xFFFFFFFF)</span>
    <span class="org-keyword">return</span> (y, x)


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">opposite_phi_signs</span>(phi_matrix: cy.<span class="org-builtin">float</span>[:,::1], y1: pyidx, x1: pyidx, y2: pyidx, x2: pyidx) <span class="org-operator">-&gt;</span> cy.bint:
    <span class="org-doc">"""</span>
<span class="org-doc">    Return True if the phi values at cells (x1,y1) and (x2,y2) have opposite signs.</span>

<span class="org-doc">    NOTE: phi_matrix has a 2 cell buffer on all 4 sides, so we have to add (2,2) to each cell index.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> phi_matrix[2<span class="org-operator">+</span>y1, 2<span class="org-operator">+</span>x1] <span class="org-operator">*</span> phi_matrix[2<span class="org-operator">+</span>y2, 2<span class="org-operator">+</span>x2] <span class="org-operator">&lt;</span> 0.0


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Pass a 2D fuel_model_array instead for speed</span>
<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">is_frontier_cell</span>(phi_matrix     : cy.<span class="org-builtin">float</span>[:,::1],
                     fuel_model_cube: ISpaceTimeCube,
                     t              : pyidx,
                     y              : pyidx,
                     x              : pyidx) <span class="org-operator">-&gt;</span> cy.bint:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Compare (north, south, east, west) neighboring cell pairs for opposite phi signs</span>
    <span class="org-variable-name">north_y</span>: pyidx <span class="org-operator">=</span> y<span class="org-operator">+</span>1
    <span class="org-variable-name">south_y</span>: pyidx <span class="org-operator">=</span> y<span class="org-operator">-</span>1
    <span class="org-variable-name">east_x</span> : pyidx <span class="org-operator">=</span> x<span class="org-operator">+</span>1
    <span class="org-variable-name">west_x</span> : pyidx <span class="org-operator">=</span> x<span class="org-operator">-</span>1
    <span class="org-keyword">return</span> ((
        <span class="org-comment-delimiter"># </span><span class="org-comment">Check north</span>
        opposite_phi_signs(phi_matrix, y, x, north_y, x) <span class="org-keyword">and</span> spot.is_burnable_cell(fuel_model_cube, t, north_y, x)
    ) <span class="org-keyword">or</span> (
        <span class="org-comment-delimiter"># </span><span class="org-comment">Check south</span>
        opposite_phi_signs(phi_matrix, y, x, south_y, x) <span class="org-keyword">and</span> spot.is_burnable_cell(fuel_model_cube, t, south_y, x)
    ) <span class="org-keyword">or</span> (
        <span class="org-comment-delimiter"># </span><span class="org-comment">Check east</span>
        opposite_phi_signs(phi_matrix, y, x, y, east_x) <span class="org-keyword">and</span> spot.is_burnable_cell(fuel_model_cube, t, y, east_x)
    ) <span class="org-keyword">or</span> (
        <span class="org-comment-delimiter"># </span><span class="org-comment">Check west</span>
        opposite_phi_signs(phi_matrix, y, x, y, west_x) <span class="org-keyword">and</span> spot.is_burnable_cell(fuel_model_cube, t, y, west_x)
    )) <span class="org-keyword">and</span> (
        <span class="org-comment-delimiter"># </span><span class="org-comment">Is this cell burnable?</span>
        spot.is_burnable_cell(fuel_model_cube, t, y, x)
    )


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Is it faster to build up a list or a set?</span>
<span class="org-type">@cy.cfunc</span>
<span class="org-keyword">def</span> <span class="org-function-name">identify_all_frontier_cells</span>(phi_matrix     : cy.<span class="org-builtin">float</span>[:,::1],
                                fuel_model_cube: ISpaceTimeCube,
                                t              : pyidx,
                                rows           : pyidx,
                                cols           : pyidx) <span class="org-operator">-&gt;</span> <span class="org-builtin">set</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">frontier_cells</span>: <span class="org-builtin">set</span> <span class="org-operator">=</span> <span class="org-builtin">set</span>()
    y             : pyidx
    x             : pyidx
    <span class="org-keyword">for</span> y <span class="org-keyword">in</span> <span class="org-builtin">range</span>(rows):
        <span class="org-keyword">for</span> x <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cols):
            <span class="org-keyword">if</span> is_frontier_cell(phi_matrix, fuel_model_cube, t, y, x):
                frontier_cells.add(encode_cell_index(y, x))
    <span class="org-keyword">return</span> frontier_cells


<span class="org-type">@cy.cfunc</span>
<span class="org-keyword">def</span> <span class="org-function-name">identify_tracked_cells</span>(frontier_cells: <span class="org-builtin">set</span>,
                           buffer_width  : pyidx,
                           rows          : pyidx,
                           cols          : pyidx) <span class="org-operator">-&gt;</span> nbt.NarrowBandTracker:
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">tracked_cells</span>     : nbt.NarrowBandTracker <span class="org-operator">=</span> nbt.new_NarrowBandTracker(rows, cols)
    encoded_cell_index: <span class="org-builtin">object</span>
    y                 : pyidx
    x                 : pyidx
    <span class="org-keyword">for</span> encoded_cell_index <span class="org-keyword">in</span> frontier_cells:
        (<span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>) <span class="org-operator">=</span> decode_cell_index(encoded_cell_index)
        nbt.inc_square_around(tracked_cells, y, x, buffer_width)
    <span class="org-keyword">return</span> tracked_cells
</pre>
</div>
</div>
</li>
</ol>
</li>
</ol>
</div>

<div id="outline-container-spread-phi-field" class="outline-4">
<h4 id="spread-phi-field"><span class="section-number-4">9.1.8.</span> Spread Phi Field</h4>
<div class="outline-text-4" id="text-spread-phi-field">
<p>
\(\hat{\nabla} \varphi \cdot U = (\hat{\nabla} \varphi \cdot \frac{\ddot{\nabla} \varphi}{|\ddot{\nabla} \varphi|}) (\frac{\ddot{\nabla} \varphi}{|\ddot{\nabla} \varphi|}\cdot U) = (\hat{\nabla} \varphi \cdot \frac{\ddot{\nabla} \varphi}{|\ddot{\nabla} \varphi|^2}) (\ddot{\nabla} \varphi \cdot U)\)
</p>

<p>
Compute dt at each timestep using the Courant-Friedrichs Lewy condition simplified to the one-dimensional case by computing `UMAX`:
<a href="https://en.wikipedia.org/wiki/Courant%E2%80%93Friedrichs%E2%80%93Lewy_condition">https://en.wikipedia.org/wiki/Courant%E2%80%93Friedrichs%E2%80%93Lewy_condition</a>
</p>

<p>
Here's how to do the correct computation for the \(U_x\) and \(U_y\) horizontal spread rates used in the CFL calculation.
</p>

<p>
Denote \(\bar{U} := (\bar{U}_x, \bar{U}_y)\) the horizontal vector that we need for the CFL. This vector is defined as being front-normal in the horizontal plane, with magnitude \(|\bar{U}| = - \frac{d \varphi}{dt}/|\nabla \varphi|\). It follows that its coordinates can be obtained as:
</p>

<p>
$ \bar{U}_x = - \frac{d \varphi}{dt} \frac{1}{|\nabla \varphi|^2}  \frac{\partial \varphi}{\partial x}$
</p>

<p>
&#x2026; and similarly for \(\bar{U}_y\). The spatial gradient is not flux-limited.
</p>

<div class="org-src-container">
<pre class="src src-python" id="spread-phi-field"><span class="org-comment-delimiter"># </span><span class="org-comment">TODO: OPTIM We might want to pass in the CellInputs and avoid looking up the SpreadInputs again here.</span>
<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">spot_from_burned_cell</span>(spread_inputs   : SpreadInputs,
                          fire_type_matrix: cy.uchar[:,::1],
                          y               : pyidx,
                          x               : pyidx,
                          fire_behavior   : SpreadBehavior,
                          time_of_arrival : cy.<span class="org-builtin">float</span>,
                          random_generator: BufferedRandGen,
                          spot_config     : SpotConfig,
                          spot_ignitions  : SortedDict[<span class="org-builtin">float</span>, <span class="org-builtin">set</span>]) <span class="org-operator">-&gt;</span> cy.void:
    <span class="org-doc">"""</span>
<span class="org-doc">    Schedules the future spot ignitions following from burning the given cell.</span>
<span class="org-doc">    Mutates `spot_ignitions` (and `random_generator`).</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">t_cast</span>                  : pyidx       <span class="org-operator">=</span> <span class="org-builtin">int</span>(time_of_arrival <span class="org-operator">//</span> spread_inputs.band_duration)
    <span class="org-variable-name">slope</span>                   : cy.<span class="org-builtin">float</span>    <span class="org-operator">=</span> spread_inputs.slope.get(t_cast, y, x)
    <span class="org-variable-name">aspect</span>                  : cy.<span class="org-builtin">float</span>    <span class="org-operator">=</span> spread_inputs.aspect.get(t_cast, y, x)
    <span class="org-variable-name">elevation_gradient</span>      : vec_xy      <span class="org-operator">=</span> calc_elevation_gradient(slope, aspect)
    <span class="org-variable-name">cell_height</span>             : cy.<span class="org-builtin">float</span>    <span class="org-operator">=</span> spread_inputs.cell_height
    <span class="org-variable-name">cell_width</span>              : cy.<span class="org-builtin">float</span>    <span class="org-operator">=</span> spread_inputs.cell_width
    <span class="org-variable-name">cell_horizontal_area</span>    : cy.<span class="org-builtin">float</span>    <span class="org-operator">=</span> cell_height <span class="org-operator">*</span> cell_width
    <span class="org-variable-name">expected_firebrand_count</span>: cy.<span class="org-builtin">float</span>    <span class="org-operator">=</span> spot.expected_firebrand_production(fire_behavior,
                                                                               elevation_gradient,
                                                                               cell_horizontal_area,
                                                                               spot_config.firebrands_per_unit_heat)
    <span class="org-variable-name">num_firebrands</span>          : cy.longlong <span class="org-operator">=</span> random_generator.next_poisson(expected_firebrand_count)
    <span class="org-keyword">if</span> num_firebrands <span class="org-operator">&gt;</span> 0:
        <span class="org-variable-name">wind_speed_10m</span>  : cy.<span class="org-builtin">float</span>               <span class="org-operator">=</span> spread_inputs.wind_speed_10m.get(t_cast, y, x)
        <span class="org-variable-name">upwind_direction</span>: cy.<span class="org-builtin">float</span>               <span class="org-operator">=</span> spread_inputs.upwind_direction.get(t_cast, y, x)
        new_ignitions   : <span class="org-builtin">tuple</span>[<span class="org-builtin">float</span>, <span class="org-builtin">set</span>]<span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> spot.spread_firebrands(spread_inputs.fuel_model,
                                                                          spread_inputs.temperature,
                                                                          spread_inputs.fuel_moisture_dead_1hr,
                                                                          fire_type_matrix,
                                                                          (spread_inputs.rows,
                                                                           spread_inputs.cols),
                                                                          cell_height,
                                                                          cell_width,
                                                                          (t_cast, y, x),
                                                                          wind_speed_10m,
                                                                          upwind_direction,
                                                                          fire_behavior.fireline_intensity,
                                                                          fire_behavior.flame_length,
                                                                          time_of_arrival,
                                                                          random_generator,
                                                                          num_firebrands,
                                                                          spot_config)
        <span class="org-keyword">if</span> new_ignitions:
            <span class="org-variable-name">ignition_time</span>           : <span class="org-builtin">float</span>    <span class="org-operator">=</span> new_ignitions[0]
            <span class="org-variable-name">ignited_cells</span>           : <span class="org-builtin">set</span>      <span class="org-operator">=</span> new_ignitions[1]
            concurrent_ignited_cells: <span class="org-builtin">set</span><span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> spot_ignitions.get(ignition_time)
            <span class="org-keyword">if</span> concurrent_ignited_cells:
                <span class="org-variable-name">spot_ignitions</span>[ignition_time] <span class="org-operator">=</span> <span class="org-builtin">set</span>.union(ignited_cells, concurrent_ignited_cells)
            <span class="org-keyword">else</span>:
                <span class="org-variable-name">spot_ignitions</span>[ignition_time] <span class="org-operator">=</span> ignited_cells


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">calc_phi_magnitude_xyz_2</span>(phi_gradient_xy   : vec_xy,
                             elevation_gradient: vec_xy) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculates the squared magnitude of the 3D slope-tangential phi gradient given:</span>
<span class="org-doc">    - phi_gradient_xy    :: (dphi_dx: phi/m, dphi_dy: phi/m) 2D vector on the horizontal plane</span>
<span class="org-doc">    - elevation_gradient :: (dz_dx: rise/run, dz_dy: rise/run)</span>
<span class="org-doc">    """</span>
    (<span class="org-variable-name">dz_dx</span>, <span class="org-variable-name">dz_dy</span>)     <span class="org-operator">=</span> elevation_gradient
    (<span class="org-variable-name">dphi_dx</span>, <span class="org-variable-name">dphi_dy</span>) <span class="org-operator">=</span> phi_gradient_xy
    <span class="org-variable-name">dphi_dz</span>: cy.<span class="org-builtin">float</span>  <span class="org-operator">=</span> vu.dot_2d(phi_gradient_xy, elevation_gradient)
    <span class="org-keyword">return</span> (dphi_dx <span class="org-operator">*</span> dphi_dx <span class="org-operator">+</span> dphi_dy <span class="org-operator">*</span> dphi_dy <span class="org-operator">-</span> dphi_dz <span class="org-operator">*</span> dphi_dz <span class="org-operator">/</span> (1.0 <span class="org-operator">+</span> dz_dx <span class="org-operator">*</span> dz_dx <span class="org-operator">+</span> dz_dy <span class="org-operator">*</span> dz_dy))


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Is it faster if we save this as a top-level constant?</span>
<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">zero_partialed_wavelet</span>() <span class="org-operator">-&gt;</span> PartialedEllWavelet:
    <span class="org-keyword">return</span> PartialedEllWavelet(
        Vh_3d <span class="org-operator">=</span> (0.0, 0.0, 0.0),
        ewc_A <span class="org-operator">=</span> 0.0,
        ewc_B <span class="org-operator">=</span> 0.0,
        ewc_C <span class="org-operator">=</span> 0.0,
    )


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">prepare_partialed_wavelet</span>(heading_spread_vector: vec_xyz,
                              flanking_spread_rate : cy.<span class="org-builtin">float</span>,
                              backing_spread_rate  : cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> PartialedEllWavelet:
    <span class="org-doc">"""</span>
<span class="org-doc">    Partially evaluates the elliptical wavelet calculation given:</span>
<span class="org-doc">    - heading_spread_vector :: (x: m/min, y: m/min, z: m/min)</span>
<span class="org-doc">    - flanking_spread_rate  :: m/min</span>
<span class="org-doc">    - backing_spread_rate   :: m/min</span>

<span class="org-doc">    The returned data is meant to be passed to function `dphi_dt_from_partialed_wavelet()`.</span>

<span class="org-doc">    NOTE: Accepting the (flanking_spread_rate, backing_spread_rate) pair is more robust than just eccentricity</span>
<span class="org-doc">          (or equivalently length_to_width_ratio) because not all fire models use elliptical wavelets</span>
<span class="org-doc">          that grow around their focus. For example, ELMFIRE defaults to something else.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">heading_spread_rate</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vu.vector_magnitude_3d(heading_spread_vector)
    <span class="org-keyword">if</span> heading_spread_rate <span class="org-operator">&gt;</span> 0.0:
        <span class="org-variable-name">heading_spread_rate_inv</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 1.0 <span class="org-operator">/</span> heading_spread_rate
        <span class="org-variable-name">length_to_width_ratio</span>  : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (heading_spread_rate <span class="org-operator">+</span> backing_spread_rate) <span class="org-operator">/</span> (2.0 <span class="org-operator">*</span> flanking_spread_rate)
        <span class="org-keyword">return</span> PartialedEllWavelet(
            Vh_3d <span class="org-operator">=</span> heading_spread_vector,
            ewc_A <span class="org-operator">=</span> <span class="org-operator">-</span>0.5 <span class="org-operator">*</span> (heading_spread_rate <span class="org-operator">-</span> backing_spread_rate) <span class="org-operator">*</span> heading_spread_rate_inv,
            ewc_B <span class="org-operator">=</span> <span class="org-operator">-</span>(flanking_spread_rate <span class="org-operator">*</span> heading_spread_rate_inv),
            ewc_C <span class="org-operator">=</span> (length_to_width_ratio <span class="org-operator">*</span> length_to_width_ratio <span class="org-operator">-</span> 1.0),
        )
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> zero_partialed_wavelet()


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">wavelet_from_FireBehaviorMax</span>(fire_behavior_max: FireBehaviorMax) <span class="org-operator">-&gt;</span> PartialedEllWavelet:
    <span class="org-variable-name">heading_spread_rate</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> fire_behavior_max.max_spread_rate <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
    <span class="org-keyword">if</span> heading_spread_rate <span class="org-operator">&gt;</span> 0.0:
        <span class="org-variable-name">heading_spread_direction</span>: vec_xyz  <span class="org-operator">=</span> fire_behavior_max.max_spread_direction      <span class="org-comment-delimiter"># </span><span class="org-comment">(x,y,z) unit vector</span>
        <span class="org-variable-name">heading_spread_vector</span>   : vec_xyz  <span class="org-operator">=</span> vu.scale_3d(heading_spread_rate,
                                                         heading_spread_direction)       <span class="org-comment-delimiter"># </span><span class="org-comment">(x,y,z) m/min vector</span>
        <span class="org-variable-name">length_to_width_ratio</span>   : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> fire_behavior_max.length_to_width_ratio     <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
        <span class="org-variable-name">eccentricity</span>            : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> fire_behavior_max.eccentricity              <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
        <span class="org-variable-name">backing_adjustment</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (1.0 <span class="org-operator">-</span> eccentricity) <span class="org-operator">/</span> (1.0 <span class="org-operator">+</span> eccentricity) <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
        <span class="org-variable-name">backing_spread_rate</span>     : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> heading_spread_rate <span class="org-operator">*</span> backing_adjustment    <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
        <span class="org-variable-name">flanking_spread_rate</span>    : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> ((heading_spread_rate <span class="org-operator">+</span> backing_spread_rate)
                                              <span class="org-operator">/</span> (2.0 <span class="org-operator">*</span> length_to_width_ratio))           <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
        <span class="org-keyword">return</span> prepare_partialed_wavelet(heading_spread_vector, flanking_spread_rate, backing_spread_rate)
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> zero_partialed_wavelet()


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Change local variable names</span>
<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">dphi_dt_from_partialed_wavelet</span>(wavelet            : PartialedEllWavelet,
                                   phi_gradient_xy    : vec_xy,
                                   phi_magnitude_xyz_2: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculates the dphi/dt (a negative number in phi/min) of one elliptical wavelet given:</span>
<span class="org-doc">    - wavelet             :: PartialedEllWavelet struct</span>
<span class="org-doc">      - Vh_3d                :: (m/min, m/min, m/min)</span>
<span class="org-doc">      - ewc_A                :: unitless</span>
<span class="org-doc">      - ewc_B                :: unitless</span>
<span class="org-doc">      - ewc_C                :: unitless</span>
<span class="org-doc">    - phi_gradient_xy     :: (dphi_dx: phi/m, dphi_dy: phi/m) 2D vector on the horizontal plane</span>
<span class="org-doc">    - phi_magnitude_xyz_2 :: (phi/m)^2 squared magnitude of the 3D slope-tangential phi gradient</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack vectors</span>
    (<span class="org-variable-name">Vx</span>, <span class="org-variable-name">Vy</span>, <span class="org-variable-name">Vz</span>)       <span class="org-operator">=</span> wavelet.Vh_3d
    (<span class="org-variable-name">dphi_dx</span>, <span class="org-variable-name">dphi_dy</span>) <span class="org-operator">=</span> phi_gradient_xy
    <span class="org-comment-delimiter"># </span><span class="org-comment">Compute intermediate values</span>
    <span class="org-variable-name">Vh2</span>    : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (Vx <span class="org-operator">*</span> Vx <span class="org-operator">+</span> Vy <span class="org-operator">*</span> Vy <span class="org-operator">+</span> Vz <span class="org-operator">*</span> Vz) <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: Pre-computing this doesn't appear to make it faster.</span>
    <span class="org-variable-name">delta</span>  : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (Vx <span class="org-operator">*</span> dphi_dx <span class="org-operator">+</span> Vy <span class="org-operator">*</span> dphi_dy) <span class="org-comment-delimiter"># </span><span class="org-comment">dot-product between Vh_3d and slope-tangential phi gradient</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Compute dphi_dt</span>
    <span class="org-keyword">return</span> (
        wavelet.ewc_A <span class="org-operator">*</span> delta <span class="org-operator">+</span>
        wavelet.ewc_B <span class="org-operator">*</span> sqrt(
            Vh2 <span class="org-operator">*</span> phi_magnitude_xyz_2 <span class="org-operator">+</span>
            wavelet.ewc_C <span class="org-operator">*</span> (delta <span class="org-operator">*</span> delta)
        )
    )


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">phi_aware_crowning_check</span>(phi_magnitude_xyz_2 : cy.<span class="org-builtin">float</span>,
                             surface_dphi_dt     : cy.<span class="org-builtin">float</span>,
                             crowning_spread_rate: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.bint:
    <span class="org-doc">"""</span>
<span class="org-doc">    Logically equivalent to: (surface_spread_rate &gt; crowning_spread_rate)</span>
<span class="org-doc">    but faster to compute and robust to zero phi gradient.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> (surface_dphi_dt <span class="org-operator">*</span> surface_dphi_dt) <span class="org-operator">&gt;</span> (crowning_spread_rate <span class="org-operator">*</span> crowning_spread_rate <span class="org-operator">*</span> phi_magnitude_xyz_2)


<span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: Changing this function to accept a pointer to an EllipticalInfo did not yield appreciable performance gains.</span>
<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">dphi_dt_from_ellipses</span>(ellipses: EllipticalInfo, phi_gradient_xy: vec_xy) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculates the dphi/dt (a negative number in phi/min) of the combined surface and crown elliptical wavelets.</span>

<span class="org-doc">    NOTE: The reason for computing and returning only dphi/dt is efficiency.</span>
<span class="org-doc">          Nothing else is needed in the front-propagating tight loop that iterates over tracked cells.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">phi_magnitude_xyz_2</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> calc_phi_magnitude_xyz_2(phi_gradient_xy, ellipses.elevation_gradient)
    <span class="org-variable-name">surface_dphi_dt</span>    : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> dphi_dt_from_partialed_wavelet(ellipses.surface_wavelet,
                                                                   phi_gradient_xy,
                                                                   phi_magnitude_xyz_2)
    <span class="org-keyword">if</span> phi_aware_crowning_check(phi_magnitude_xyz_2, surface_dphi_dt, ellipses.crowning_spread_rate):
        <span class="org-variable-name">crown_dphi_dt</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> dphi_dt_from_partialed_wavelet(ellipses.crown_wavelet,
                                                                 phi_gradient_xy,
                                                                 phi_magnitude_xyz_2)
        <span class="org-keyword">return</span> <span class="org-builtin">min</span>(surface_dphi_dt, crown_dphi_dt) <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: dphi_dt &lt;= 0</span>
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> surface_dphi_dt


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Rename this constant</span>
<span class="org-variable-name">p_CellInputs</span> <span class="org-operator">=</span> cy.declare(pyidx, 17) <span class="org-comment-delimiter"># </span><span class="org-comment">the number of input columns</span>


<span class="org-type">@cy.cclass</span>
<span class="org-keyword">class</span> <span class="org-type">TrackedCellsArrays</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Arrays used as on-heap supporting data structures during spread, which:</span>
<span class="org-doc">    - provide an efficient memory layout for the data involved in the Runge-Kutta passes</span>
<span class="org-doc">    - should be read-only up to the number of tracked cells</span>
<span class="org-doc">    - have a greater length in order to implement dynamic resizing</span>

<span class="org-doc">    NOTE: The *_refreshed timestamps indicate when the data was last updated for each column.</span>

<span class="org-doc">    NOTE: The motivation for cube_cache being an array of floats and not of structs</span>
<span class="org-doc">          is to enable more generic processing when reading inputs.</span>
<span class="org-doc">    """</span>
    _array_length    : pyidx                       <span class="org-comment-delimiter"># </span><span class="org-comment">power of 2, doubles each time there is a dynamic resizing</span>
    num_tracked_cells: pyidx
    cube_cache       : cy.<span class="org-builtin">float</span>[:,::1]             <span class="org-comment-delimiter"># </span><span class="org-comment">shape: (_array_length, p_CellInputs)</span>
    phi_cache        : cy.<span class="org-builtin">float</span>[:,::1]             <span class="org-comment-delimiter"># </span><span class="org-comment">shape: (_array_length, 9)</span>
    sfmin_cache      : cy.pointer(FireBehaviorMin) <span class="org-comment-delimiter"># </span><span class="org-comment">array of structs, caching the FireBehaviorMin for each tracked cell</span>
    ellipse_cache    : cy.pointer(EllipticalInfo)  <span class="org-comment-delimiter"># </span><span class="org-comment">array of structs (needs to be iterated over very efficiently)</span>
    pass1_cache      : cy.pointer(Pass1CellOutput) <span class="org-comment-delimiter"># </span><span class="org-comment">per-cell data produced by the 1st Runge-Kutta pass</span>
    time_refreshed   : cy.<span class="org-builtin">float</span>[17]                <span class="org-comment-delimiter"># </span><span class="org-comment">an exact instant in minutes</span>
    t_refreshed      : pyidx[17]                   <span class="org-comment-delimiter"># </span><span class="org-comment">a rounded index into the space-time cubes</span>


    <span class="org-keyword">def</span> <span class="org-function-name">__cinit__</span>(<span class="org-keyword">self</span>,
                  time_refreshed_init: cy.<span class="org-builtin">float</span>,
                  t_refreshed_init   : pyidx,
                  array_length       : pyidx <span class="org-operator">=</span> 256) <span class="org-operator">-&gt;</span> cy.void:
        <span class="org-keyword">self</span>.<span class="org-variable-name">_array_length</span>     <span class="org-operator">=</span> array_length
        <span class="org-keyword">self</span>.<span class="org-variable-name">num_tracked_cells</span> <span class="org-operator">=</span> 0
        <span class="org-keyword">self</span>.<span class="org-variable-name">cube_cache</span>        <span class="org-operator">=</span> np.zeros((array_length, p_CellInputs), dtype<span class="org-operator">=</span>np.float32)
        <span class="org-keyword">self</span>.<span class="org-variable-name">phi_cache</span>         <span class="org-operator">=</span> np.zeros((array_length, 9), dtype<span class="org-operator">=</span>np.float32)
        <span class="org-keyword">self</span>.<span class="org-variable-name">sfmin_cache</span>       <span class="org-operator">=</span> cy.cast(cy.pointer(FireBehaviorMin),
                                         malloc(array_length <span class="org-operator">*</span> cy.sizeof(FireBehaviorMin)))
        <span class="org-keyword">self</span>.<span class="org-variable-name">ellipse_cache</span>     <span class="org-operator">=</span> cy.cast(cy.pointer(EllipticalInfo),
                                         malloc(array_length <span class="org-operator">*</span> cy.sizeof(EllipticalInfo)))
        <span class="org-keyword">self</span>.<span class="org-variable-name">pass1_cache</span>       <span class="org-operator">=</span> cy.cast(cy.pointer(Pass1CellOutput),
                                         malloc(array_length <span class="org-operator">*</span> cy.sizeof(Pass1CellOutput)))
        <span class="org-comment-delimiter"># </span><span class="org-comment">Verify that all arrays were created</span>
        <span class="org-keyword">if</span> <span class="org-keyword">not</span> (<span class="org-keyword">self</span>.sfmin_cache <span class="org-keyword">and</span> <span class="org-keyword">self</span>.ellipse_cache <span class="org-keyword">and</span> <span class="org-keyword">self</span>.pass1_cache):
            <span class="org-comment-delimiter"># </span><span class="org-comment">Something went wrong with malloc</span>
            <span class="org-keyword">raise</span> <span class="org-type">MemoryError</span>()
        <span class="org-comment-delimiter"># </span><span class="org-comment">Set all values in the time_refreshed and t_refreshed arrays to the passed in values</span>
        k: pyidx
        <span class="org-keyword">for</span> k <span class="org-keyword">in</span> <span class="org-builtin">range</span>(17):
            <span class="org-keyword">self</span>.<span class="org-variable-name">time_refreshed</span>[k] <span class="org-operator">=</span> time_refreshed_init
            <span class="org-keyword">self</span>.<span class="org-variable-name">t_refreshed</span>[k]    <span class="org-operator">=</span> t_refreshed_init


    <span class="org-type">@cy.cfunc</span>
    <span class="org-keyword">def</span> <span class="org-function-name">reset_size</span>(<span class="org-keyword">self</span>, num_tracked_cells: pyidx) <span class="org-operator">-&gt;</span> cy.void:
        <span class="org-doc">"""</span>
<span class="org-doc">        Ensures that this can hold at least `num_tracked_cells`, resizing the internal arrays if necessary.</span>
<span class="org-doc">        Also updates `self.num_tracked_cells`.</span>
<span class="org-doc">        This can erase any data present in this object, so callers must make sure this information is no longer needed.</span>
<span class="org-doc">        """</span>
        <span class="org-variable-name">array_length</span>: pyidx <span class="org-operator">=</span> <span class="org-keyword">self</span>._array_length
        <span class="org-keyword">if</span> num_tracked_cells <span class="org-operator">&gt;</span> array_length:
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate an array_length &gt;= num_tracked_cells</span>
            <span class="org-keyword">while</span> num_tracked_cells <span class="org-operator">&gt;</span> array_length:
                <span class="org-variable-name">array_length</span> <span class="org-operator">*=</span> 2
            <span class="org-comment-delimiter"># </span><span class="org-comment">Dynamically resize all internal arrays</span>
            <span class="org-variable-name">cube_cache</span>   : cy.<span class="org-builtin">float</span>[:,::1]             <span class="org-operator">=</span> np.zeros((array_length, p_CellInputs), dtype<span class="org-operator">=</span>np.float32)
            <span class="org-variable-name">phi_cache</span>    : cy.<span class="org-builtin">float</span>[:,::1]             <span class="org-operator">=</span> np.zeros((array_length, 9), dtype<span class="org-operator">=</span>np.float32)
            <span class="org-variable-name">sfmin_cache</span>  : cy.pointer(FireBehaviorMin) <span class="org-operator">=</span> cy.cast(cy.pointer(FireBehaviorMin),
                                                                 realloc(<span class="org-keyword">self</span>.sfmin_cache,
                                                                         array_length <span class="org-operator">*</span> cy.sizeof(FireBehaviorMin)))
            <span class="org-variable-name">ellipse_cache</span>: cy.pointer(EllipticalInfo)  <span class="org-operator">=</span> cy.cast(cy.pointer(EllipticalInfo),
                                                                 realloc(<span class="org-keyword">self</span>.ellipse_cache,
                                                                         array_length <span class="org-operator">*</span> cy.sizeof(EllipticalInfo)))
            <span class="org-variable-name">pass1_cache</span>  : cy.pointer(Pass1CellOutput) <span class="org-operator">=</span> cy.cast(cy.pointer(Pass1CellOutput),
                                                                 realloc(<span class="org-keyword">self</span>.pass1_cache,
                                                                         array_length <span class="org-operator">*</span> cy.sizeof(Pass1CellOutput)))
            <span class="org-comment-delimiter"># </span><span class="org-comment">Verify that all arrays were created</span>
            <span class="org-keyword">if</span> <span class="org-keyword">not</span> (sfmin_cache <span class="org-keyword">and</span> ellipse_cache <span class="org-keyword">and</span> pass1_cache):
                <span class="org-comment-delimiter"># </span><span class="org-comment">Something went wrong with malloc</span>
                <span class="org-keyword">raise</span> <span class="org-type">MemoryError</span>()
            <span class="org-keyword">else</span>:
                <span class="org-keyword">self</span>.<span class="org-variable-name">_array_length</span> <span class="org-operator">=</span> array_length
                <span class="org-keyword">self</span>.<span class="org-variable-name">cube_cache</span>    <span class="org-operator">=</span> cube_cache
                <span class="org-keyword">self</span>.<span class="org-variable-name">phi_cache</span>     <span class="org-operator">=</span> phi_cache
                <span class="org-keyword">self</span>.<span class="org-variable-name">sfmin_cache</span>   <span class="org-operator">=</span> sfmin_cache
                <span class="org-keyword">self</span>.<span class="org-variable-name">ellipse_cache</span> <span class="org-operator">=</span> ellipse_cache
                <span class="org-keyword">self</span>.<span class="org-variable-name">pass1_cache</span>   <span class="org-operator">=</span> pass1_cache
        <span class="org-comment-delimiter"># </span><span class="org-comment">Update num_tracked_cells</span>
        <span class="org-keyword">self</span>.<span class="org-variable-name">num_tracked_cells</span> <span class="org-operator">=</span> num_tracked_cells


    <span class="org-keyword">def</span> <span class="org-function-name">__dealloc__</span>(<span class="org-keyword">self</span>) <span class="org-operator">-&gt;</span> cy.void:
        free(<span class="org-keyword">self</span>.sfmin_cache)
        free(<span class="org-keyword">self</span>.ellipse_cache)
        free(<span class="org-keyword">self</span>.pass1_cache)


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">collect_phi_cache</span>(phi_matrix: cy.<span class="org-builtin">float</span>[:,::1], tca: TrackedCellsArrays) <span class="org-operator">-&gt;</span> cy.void:
    <span class="org-doc">"""</span>
<span class="org-doc">    Iterates over the tracked cells and stores their phi values in a cache.</span>
<span class="org-doc">    For each tracked cell, stores a row of 9 values in `tca.phi_cache`,</span>
<span class="org-doc">    corresponding to the 'cross' of cells required to compute flux-limited gradients.</span>
<span class="org-doc">    Reads from `phi_matrix` and mutates `tca.phi_cache`.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">phi_cache</span>    : cy.<span class="org-builtin">float</span>[:,::1]            <span class="org-operator">=</span> tca.phi_cache
    <span class="org-variable-name">ellipse_cache</span>: cy.pointer(EllipticalInfo) <span class="org-operator">=</span> tca.ellipse_cache
    i            : pyidx
    y            : pyidx
    x            : pyidx
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(tca.num_tracked_cells):
        (<span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>)          <span class="org-operator">=</span> ellipse_cache[i].cell_index
        <span class="org-variable-name">phi_cache</span>[i, 0] <span class="org-operator">=</span> phi_matrix[2<span class="org-operator">+</span>y  , 2<span class="org-operator">+</span>x]
        <span class="org-variable-name">phi_cache</span>[i, 1] <span class="org-operator">=</span> phi_matrix[2<span class="org-operator">+</span>y  , 2<span class="org-operator">+</span>x<span class="org-operator">-</span>2]
        <span class="org-variable-name">phi_cache</span>[i, 2] <span class="org-operator">=</span> phi_matrix[2<span class="org-operator">+</span>y  , 2<span class="org-operator">+</span>x<span class="org-operator">-</span>1]
        <span class="org-variable-name">phi_cache</span>[i, 3] <span class="org-operator">=</span> phi_matrix[2<span class="org-operator">+</span>y  , 2<span class="org-operator">+</span>x<span class="org-operator">+</span>1]
        <span class="org-variable-name">phi_cache</span>[i, 4] <span class="org-operator">=</span> phi_matrix[2<span class="org-operator">+</span>y  , 2<span class="org-operator">+</span>x<span class="org-operator">+</span>2]
        <span class="org-variable-name">phi_cache</span>[i, 5] <span class="org-operator">=</span> phi_matrix[2<span class="org-operator">+</span>y<span class="org-operator">-</span>2, 2<span class="org-operator">+</span>x]
        <span class="org-variable-name">phi_cache</span>[i, 6] <span class="org-operator">=</span> phi_matrix[2<span class="org-operator">+</span>y<span class="org-operator">-</span>1, 2<span class="org-operator">+</span>x]
        <span class="org-variable-name">phi_cache</span>[i, 7] <span class="org-operator">=</span> phi_matrix[2<span class="org-operator">+</span>y<span class="org-operator">+</span>1, 2<span class="org-operator">+</span>x]
        <span class="org-variable-name">phi_cache</span>[i, 8] <span class="org-operator">=</span> phi_matrix[2<span class="org-operator">+</span>y<span class="org-operator">+</span>2, 2<span class="org-operator">+</span>x]


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">compare_cell_indexes</span>(c0: coord_yx, c1: coord_yx) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">int</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Lexicographic comparison of (y, x) coordinates. Returns -1, 0, or 1.</span>
<span class="org-doc">    """</span>
    (<span class="org-variable-name">y0</span>, <span class="org-variable-name">x0</span>) <span class="org-operator">=</span> c0
    (<span class="org-variable-name">y1</span>, <span class="org-variable-name">x1</span>) <span class="org-operator">=</span> c1
    <span class="org-keyword">if</span> y0 <span class="org-operator">&lt;</span> y1:
        <span class="org-keyword">return</span> <span class="org-operator">-</span>1
    <span class="org-keyword">elif</span> y0 <span class="org-operator">&gt;</span> y1:
        <span class="org-keyword">return</span> 1
    <span class="org-comment-delimiter"># </span><span class="org-comment">Now we know both have the same y</span>
    <span class="org-keyword">elif</span> x0 <span class="org-operator">&lt;</span> x1:
        <span class="org-keyword">return</span> <span class="org-operator">-</span>1
    <span class="org-keyword">elif</span> x0 <span class="org-operator">&gt;</span> x1:
        <span class="org-keyword">return</span> 1
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> 0


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: OPTIM Maybe we want to use a native array directly instead of a MemoryView.</span>
<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">copy_tracked_cell_data</span>(i_old  : pyidx,
                           tca_old: TrackedCellsArrays,
                           i_new  : pyidx,
                           tca_new: TrackedCellsArrays) <span class="org-operator">-&gt;</span> cy.void:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Copy cube_cache</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: Unrolling this loop made the code 2x faster.</span>
    tca_new.<span class="org-variable-name">cube_cache</span>[i_new,  0] <span class="org-operator">=</span> tca_old.cube_cache[i_old,  0]
    tca_new.<span class="org-variable-name">cube_cache</span>[i_new,  1] <span class="org-operator">=</span> tca_old.cube_cache[i_old,  1]
    tca_new.<span class="org-variable-name">cube_cache</span>[i_new,  2] <span class="org-operator">=</span> tca_old.cube_cache[i_old,  2]
    tca_new.<span class="org-variable-name">cube_cache</span>[i_new,  3] <span class="org-operator">=</span> tca_old.cube_cache[i_old,  3]
    tca_new.<span class="org-variable-name">cube_cache</span>[i_new,  4] <span class="org-operator">=</span> tca_old.cube_cache[i_old,  4]
    tca_new.<span class="org-variable-name">cube_cache</span>[i_new,  5] <span class="org-operator">=</span> tca_old.cube_cache[i_old,  5]
    tca_new.<span class="org-variable-name">cube_cache</span>[i_new,  6] <span class="org-operator">=</span> tca_old.cube_cache[i_old,  6]
    tca_new.<span class="org-variable-name">cube_cache</span>[i_new,  7] <span class="org-operator">=</span> tca_old.cube_cache[i_old,  7]
    tca_new.<span class="org-variable-name">cube_cache</span>[i_new,  8] <span class="org-operator">=</span> tca_old.cube_cache[i_old,  8]
    tca_new.<span class="org-variable-name">cube_cache</span>[i_new,  9] <span class="org-operator">=</span> tca_old.cube_cache[i_old,  9]
    tca_new.<span class="org-variable-name">cube_cache</span>[i_new, 10] <span class="org-operator">=</span> tca_old.cube_cache[i_old, 10]
    tca_new.<span class="org-variable-name">cube_cache</span>[i_new, 11] <span class="org-operator">=</span> tca_old.cube_cache[i_old, 11]
    tca_new.<span class="org-variable-name">cube_cache</span>[i_new, 12] <span class="org-operator">=</span> tca_old.cube_cache[i_old, 12]
    tca_new.<span class="org-variable-name">cube_cache</span>[i_new, 13] <span class="org-operator">=</span> tca_old.cube_cache[i_old, 13]
    tca_new.<span class="org-variable-name">cube_cache</span>[i_new, 14] <span class="org-operator">=</span> tca_old.cube_cache[i_old, 14]
    tca_new.<span class="org-variable-name">cube_cache</span>[i_new, 15] <span class="org-operator">=</span> tca_old.cube_cache[i_old, 15]
    tca_new.<span class="org-variable-name">cube_cache</span>[i_new, 16] <span class="org-operator">=</span> tca_old.cube_cache[i_old, 16]
    <span class="org-comment-delimiter"># </span><span class="org-comment">Copy sfmin_cache and ellipse_cache</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: tca_old.pass1_cache does not need to be copied over given how it will get used.</span>
    tca_new.<span class="org-variable-name">sfmin_cache</span>[i_new]   <span class="org-operator">=</span> tca_old.sfmin_cache[i_old]
    tca_new.<span class="org-variable-name">ellipse_cache</span>[i_new] <span class="org-operator">=</span> tca_old.ellipse_cache[i_old]


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Is it faster if we save this as a top-level constant?</span>
<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-keyword">def</span> <span class="org-function-name">inputs_name_list</span>() <span class="org-operator">-&gt;</span> <span class="org-builtin">list</span>[<span class="org-builtin">str</span>]:
    <span class="org-keyword">return</span> [
        <span class="org-string">"slope"</span>,
        <span class="org-string">"aspect"</span>,
        <span class="org-string">"fuel_model"</span>,
        <span class="org-string">"canopy_cover"</span>,
        <span class="org-string">"canopy_height"</span>,
        <span class="org-string">"canopy_base_height"</span>,
        <span class="org-string">"canopy_bulk_density"</span>,
        <span class="org-string">"wind_speed_10m"</span>,
        <span class="org-string">"upwind_direction"</span>,
        <span class="org-string">"fuel_moisture_dead_1hr"</span>,
        <span class="org-string">"fuel_moisture_dead_10hr"</span>,
        <span class="org-string">"fuel_moisture_dead_100hr"</span>,
        <span class="org-string">"fuel_moisture_live_herbaceous"</span>,
        <span class="org-string">"fuel_moisture_live_woody"</span>,
        <span class="org-string">"foliar_moisture"</span>,
        <span class="org-string">"fuel_spread_adjustment"</span>,
        <span class="org-string">"weather_spread_adjustment"</span>,
    ]


<span class="org-type">@cy.cclass</span>
<span class="org-keyword">class</span> <span class="org-type">FireBehaviorSettings</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    A fast-access data structure for fire behavior parameters</span>
<span class="org-doc">    to reduce the number of arguments being passed around.</span>
<span class="org-doc">    """</span>
    max_cells_per_timestep: cy.<span class="org-builtin">float</span> <span class="org-comment-delimiter"># </span><span class="org-comment">CFL condition</span>
    buffer_width          : pyidx
    use_wind_limit        : cy.bint
    surface_lw_ratio_model: <span class="org-builtin">str</span>
    crown_max_lw_ratio    : cy.<span class="org-builtin">float</span>
    spot_config           : <span class="org-builtin">dict</span>
    cube_refresh_rates    : cy.<span class="org-builtin">float</span>[17] <span class="org-comment-delimiter"># </span><span class="org-comment">(min^-1) the rate at which each input column needs to be refreshed</span>


    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>,
                 max_cells_per_timestep: <span class="org-builtin">float</span><span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> 0.4,
                 buffer_width          : <span class="org-builtin">int</span><span class="org-operator">|</span><span class="org-constant">None</span>   <span class="org-operator">=</span> 3,
                 use_wind_limit        : <span class="org-builtin">bool</span><span class="org-operator">|</span><span class="org-constant">None</span>  <span class="org-operator">=</span> <span class="org-constant">True</span>,
                 surface_lw_ratio_model: <span class="org-builtin">str</span><span class="org-operator">|</span><span class="org-constant">None</span>   <span class="org-operator">=</span> <span class="org-string">"behave"</span>,
                 crown_max_lw_ratio    : <span class="org-builtin">float</span><span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> 1e10,
                 spot_config           : <span class="org-builtin">dict</span><span class="org-operator">|</span><span class="org-constant">None</span>  <span class="org-operator">=</span> <span class="org-constant">None</span>,
                 cube_refresh_rates    : <span class="org-builtin">dict</span><span class="org-operator">|</span><span class="org-constant">None</span>  <span class="org-operator">=</span> {}) <span class="org-operator">-&gt;</span> cy.void:
        <span class="org-keyword">self</span>.<span class="org-variable-name">max_cells_per_timestep</span> <span class="org-operator">=</span> max_cells_per_timestep
        <span class="org-keyword">self</span>.<span class="org-variable-name">buffer_width</span>           <span class="org-operator">=</span> buffer_width
        <span class="org-keyword">self</span>.<span class="org-variable-name">use_wind_limit</span>         <span class="org-operator">=</span> use_wind_limit
        <span class="org-keyword">self</span>.<span class="org-variable-name">surface_lw_ratio_model</span> <span class="org-operator">=</span> surface_lw_ratio_model
        <span class="org-keyword">self</span>.<span class="org-variable-name">crown_max_lw_ratio</span>     <span class="org-operator">=</span> crown_max_lw_ratio
        <span class="org-keyword">if</span> spot_config:
            <span class="org-keyword">self</span>.<span class="org-variable-name">spot_config</span> <span class="org-operator">=</span> SpotConfig(
                random_seed                  <span class="org-operator">=</span> spot_config.get(<span class="org-string">"random_seed"</span>),
                firebrands_per_unit_heat     <span class="org-operator">=</span> spot_config.get(<span class="org-string">"firebrands_per_unit_heat"</span>, 5e<span class="org-operator">-</span>11),
                downwind_distance_mean       <span class="org-operator">=</span> spot_config.get(<span class="org-string">"downwind_distance_mean"</span>, 11.7),
                fireline_intensity_exponent  <span class="org-operator">=</span> spot_config.get(<span class="org-string">"fireline_intensity_exponent"</span>),
                wind_speed_exponent          <span class="org-operator">=</span> spot_config.get(<span class="org-string">"wind_speed_exponent"</span>),
                downwind_variance_mean_ratio <span class="org-operator">=</span> spot_config.get(<span class="org-string">"downwind_variance_mean_ratio"</span>),
                crosswind_distance_stdev     <span class="org-operator">=</span> spot_config.get(<span class="org-string">"crosswind_distance_stdev"</span>, 10.0),
                decay_distance               <span class="org-operator">=</span> spot_config.get(<span class="org-string">"decay_distance"</span>, 500.0),
            )
        <span class="org-variable-name">inputs_names</span>: <span class="org-builtin">list</span> <span class="org-operator">=</span> inputs_name_list()
        <span class="org-keyword">for</span> k <span class="org-keyword">in</span> <span class="org-builtin">range</span>(17):
            <span class="org-keyword">self</span>.<span class="org-variable-name">cube_refresh_rates</span>[k] <span class="org-operator">=</span> cube_refresh_rates[inputs_names[k]]


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">load_cube_cache_for_cell</span>(spread_inputs   : SpreadInputs,
                             cell_index      : coord_yx,
                             tca             : TrackedCellsArrays,
                             i               : pyidx) <span class="org-operator">-&gt;</span> cy.void: <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: Maybe return the CellInputs struct instead?</span>
    <span class="org-doc">"""</span>
<span class="org-doc">    Reads variables from input ISpaceTimeCubes and saves them by mutating `tca.cube_cache`.</span>
<span class="org-doc">    """</span>
    (<span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>)                      <span class="org-operator">=</span> cell_index
    <span class="org-variable-name">tr</span>        : pyidx[17]       <span class="org-operator">=</span> tca.t_refreshed
    <span class="org-variable-name">cube_cache</span>: cy.<span class="org-builtin">float</span>[:,::1] <span class="org-operator">=</span> tca.cube_cache

    <span class="org-comment-delimiter"># </span><span class="org-comment">Topography, Fuel Model, and Vegetation</span>
    <span class="org-variable-name">cube_cache</span>[i,  0] <span class="org-operator">=</span> spread_inputs.slope.get(tr[0], y, x)               <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-variable-name">cube_cache</span>[i,  1] <span class="org-operator">=</span> spread_inputs.aspect.get(tr[1], y, x)              <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-variable-name">cube_cache</span>[i,  2] <span class="org-operator">=</span> spread_inputs.fuel_model.get(tr[2], y, x)          <span class="org-comment-delimiter"># </span><span class="org-comment">integer index in fm.fuel_model_table</span>
    <span class="org-variable-name">cube_cache</span>[i,  3] <span class="org-operator">=</span> spread_inputs.canopy_cover.get(tr[3], y, x)        <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
    <span class="org-variable-name">cube_cache</span>[i,  4] <span class="org-operator">=</span> spread_inputs.canopy_height.get(tr[4], y, x)       <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-variable-name">cube_cache</span>[i,  5] <span class="org-operator">=</span> spread_inputs.canopy_base_height.get(tr[5], y, x)  <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-variable-name">cube_cache</span>[i,  6] <span class="org-operator">=</span> spread_inputs.canopy_bulk_density.get(tr[6], y, x) <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Wind, Surface Moisture, and Foliar Moisture</span>
    <span class="org-variable-name">cube_cache</span>[i,  7] <span class="org-operator">=</span> spread_inputs.wind_speed_10m.get(tr[7], y, x)                 <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-variable-name">cube_cache</span>[i,  8] <span class="org-operator">=</span> spread_inputs.upwind_direction.get(tr[8], y, x)               <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-variable-name">cube_cache</span>[i,  9] <span class="org-operator">=</span> spread_inputs.fuel_moisture_dead_1hr.get(tr[9], y, x)         <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">cube_cache</span>[i, 10] <span class="org-operator">=</span> spread_inputs.fuel_moisture_dead_10hr.get(tr[10], y, x)       <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">cube_cache</span>[i, 11] <span class="org-operator">=</span> spread_inputs.fuel_moisture_dead_100hr.get(tr[11], y, x)      <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">cube_cache</span>[i, 12] <span class="org-operator">=</span> spread_inputs.fuel_moisture_live_herbaceous.get(tr[12], y, x) <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">cube_cache</span>[i, 13] <span class="org-operator">=</span> spread_inputs.fuel_moisture_live_woody.get(tr[13], y, x)      <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">cube_cache</span>[i, 14] <span class="org-operator">=</span> spread_inputs.foliar_moisture.get(tr[14], y, x)               <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Spread Rate Adjustments (Optional)</span>
    <span class="org-variable-name">cube_cache</span>[i, 15] <span class="org-operator">=</span> (spread_inputs.fuel_spread_adjustment.get(tr[15], y, x)
                         <span class="org-keyword">if</span> spread_inputs.fuel_spread_adjustment <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>
                         <span class="org-keyword">else</span> 1.0)                                                       <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>
    <span class="org-variable-name">cube_cache</span>[i, 16] <span class="org-operator">=</span> (spread_inputs.weather_spread_adjustment.get(tr[16], y, x)
                         <span class="org-keyword">if</span> spread_inputs.weather_spread_adjustment <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>
                         <span class="org-keyword">else</span> 1.0)                                                       <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-keyword">def</span> <span class="org-function-name">list_float_input_cubes</span>(spread_inputs: SpreadInputs) <span class="org-operator">-&gt;</span> <span class="org-builtin">list</span>[ISpaceTimeCube]:
    <span class="org-keyword">return</span> [
        spread_inputs.slope,
        spread_inputs.aspect,
        spread_inputs.fuel_model,
        spread_inputs.canopy_cover,
        spread_inputs.canopy_height,
        spread_inputs.canopy_base_height,
        spread_inputs.canopy_bulk_density,
        spread_inputs.wind_speed_10m,
        spread_inputs.upwind_direction,
        spread_inputs.fuel_moisture_dead_1hr,
        spread_inputs.fuel_moisture_dead_10hr,
        spread_inputs.fuel_moisture_dead_100hr,
        spread_inputs.fuel_moisture_live_herbaceous,
        spread_inputs.fuel_moisture_live_woody,
        spread_inputs.foliar_moisture,
        spread_inputs.fuel_spread_adjustment,
        spread_inputs.weather_spread_adjustment,
    ]


<span class="org-type">@cy.cfunc</span>
<span class="org-keyword">def</span> <span class="org-function-name">default_cube_refresh_rates</span>(band_duration: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> <span class="org-builtin">dict</span>:
    <span class="org-variable-name">refresh_rate</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 1.0 <span class="org-operator">/</span> band_duration
    <span class="org-keyword">return</span> {
        <span class="org-comment-delimiter"># </span><span class="org-comment">Non-weather inputs default to a refresh rate of 0.0 (never refreshed).</span>
        <span class="org-string">"slope"</span>              : 0.0,
        <span class="org-string">"aspect"</span>             : 0.0,
        <span class="org-string">"fuel_model"</span>         : 0.0,
        <span class="org-string">"canopy_cover"</span>       : 0.0,
        <span class="org-string">"canopy_height"</span>      : 0.0,
        <span class="org-string">"canopy_base_height"</span> : 0.0,
        <span class="org-string">"canopy_bulk_density"</span>: 0.0,
        <span class="org-comment-delimiter"># </span><span class="org-comment">Weather inputs default to have the same refresh rate as the base resolution of inputs.</span>
        <span class="org-string">"wind_speed_10m"</span>               : refresh_rate,
        <span class="org-string">"upwind_direction"</span>             : refresh_rate,
        <span class="org-string">"fuel_moisture_dead_1hr"</span>       : refresh_rate,
        <span class="org-string">"fuel_moisture_dead_10hr"</span>      : refresh_rate,
        <span class="org-string">"fuel_moisture_dead_100hr"</span>     : refresh_rate,
        <span class="org-string">"fuel_moisture_live_herbaceous"</span>: refresh_rate,
        <span class="org-string">"fuel_moisture_live_woody"</span>     : refresh_rate,
        <span class="org-string">"foliar_moisture"</span>              : refresh_rate,
        <span class="org-string">"fuel_spread_adjustment"</span>       : refresh_rate,
        <span class="org-string">"weather_spread_adjustment"</span>    : refresh_rate,
    }


<span class="org-variable-name">recompute_levels_list</span>: <span class="org-builtin">list</span> <span class="org-operator">=</span> [
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">slope</span>
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">aspect</span>
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">fuel_model</span>
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">canopy_cover</span>
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">canopy_height</span>
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">canopy_base_height</span>
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">canopy_bulk_density</span>
     10, <span class="org-comment-delimiter"># </span><span class="org-comment">wind_speed_10m</span>
     10, <span class="org-comment-delimiter"># </span><span class="org-comment">upwind_direction</span>
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">fuel_moisture_dead_1hr</span>
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">fuel_moisture_dead_10hr</span>
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">fuel_moisture_dead_100hr</span>
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">fuel_moisture_live_herbaceous</span>
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">fuel_moisture_live_woody</span>
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">foliar_moisture</span>
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">fuel_spread_adjustment</span>
    100  <span class="org-comment-delimiter"># </span><span class="org-comment">weather_spread_adjustment</span>
]


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Make this more efficient by replacing the list with an array of integers.</span>
<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">recompute_level_for_input</span>(input_k: pyidx) <span class="org-operator">-&gt;</span> cy.uint:
    <span class="org-keyword">return</span> recompute_levels_list[input_k]


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">refresh_inputs_if_needed</span>(spread_inputs: SpreadInputs,
                             fb_opts      : FireBehaviorSettings,
                             tca          : TrackedCellsArrays,
                             present_time : cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.uint:
    <span class="org-doc">"""</span>
<span class="org-doc">    Refreshes the data input columns and refresh timestamps if needed.</span>
<span class="org-doc">    Mutates `tca` and returns an integer indicating which downstream computations need to be recomputed.</span>
<span class="org-doc">    """</span>
    stc_list       : <span class="org-builtin">list</span>[ISpaceTimeCube]<span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> <span class="org-constant">None</span>
    <span class="org-variable-name">recompute_level</span>: cy.uint                   <span class="org-operator">=</span> 0
    k              : pyidx
    <span class="org-keyword">for</span> k <span class="org-keyword">in</span> <span class="org-builtin">range</span>(p_CellInputs):
        <span class="org-variable-name">refresh_rate</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> fb_opts.cube_refresh_rates[k]
        <span class="org-comment-delimiter"># </span><span class="org-comment">Check whether ISpaceTimeCube k needs to be refreshed</span>
        <span class="org-keyword">if</span> refresh_rate <span class="org-operator">*</span> (present_time <span class="org-operator">-</span> tca.time_refreshed[k]) <span class="org-operator">&gt;</span> 1.0:
            <span class="org-comment-delimiter"># </span><span class="org-comment">Retrieve the stc_list only the first time a ISpaceTimeCube needs to be refreshed</span>
            <span class="org-variable-name">stc_list</span> <span class="org-operator">=</span> list_float_input_cubes(spread_inputs) <span class="org-keyword">if</span> (stc_list <span class="org-keyword">is</span> <span class="org-constant">None</span>) <span class="org-keyword">else</span> stc_list
            <span class="org-comment-delimiter"># </span><span class="org-comment">Extract ISpaceTimeCube k</span>
            <span class="org-variable-name">space_time_cube</span>: ISpaceTimeCube <span class="org-operator">=</span> stc_list[k]
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate and store the new time_refreshed and t_refreshed values</span>
            <span class="org-comment-delimiter">#</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: The refresh time is always an integer multiple of</span>
            <span class="org-comment-delimiter">#       </span><span class="org-comment">the refresh interval. We might want to change this.</span>
            <span class="org-variable-name">refresh_interval</span>  : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 1.0 <span class="org-operator">/</span> refresh_rate
            <span class="org-variable-name">time_refreshed_new</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (present_time <span class="org-operator">//</span> refresh_interval) <span class="org-operator">*</span> refresh_interval
            <span class="org-variable-name">t_refreshed_new</span>   : pyidx    <span class="org-operator">=</span> <span class="org-builtin">int</span>(floor(time_refreshed_new <span class="org-operator">/</span> spread_inputs.band_duration))
            tca.<span class="org-variable-name">time_refreshed</span>[k]        <span class="org-operator">=</span> time_refreshed_new
            tca.<span class="org-variable-name">t_refreshed</span>[k]           <span class="org-operator">=</span> t_refreshed_new
            <span class="org-comment-delimiter"># </span><span class="org-comment">Update the cube_cache array with the latest ISpaceTimeCube values for all tracked cells</span>
            <span class="org-variable-name">cube_cache</span>: cy.<span class="org-builtin">float</span>[:,::1] <span class="org-operator">=</span> tca.cube_cache
            i         : pyidx
            y         : pyidx
            x         : pyidx
            <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(tca.num_tracked_cells):
                (<span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>)           <span class="org-operator">=</span> tca.ellipse_cache[i].cell_index
                <span class="org-variable-name">cube_cache</span>[<span class="org-variable-name">i</span>, <span class="org-variable-name">k</span>] <span class="org-operator">=</span> space_time_cube.get(t_refreshed_new, y, x)
            <span class="org-comment-delimiter"># </span><span class="org-comment">Reset the recompute_level</span>
            <span class="org-variable-name">recompute_level</span> <span class="org-operator">=</span> <span class="org-builtin">max</span>(recompute_level, recompute_level_for_input(k))
    <span class="org-keyword">return</span> recompute_level


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">load_saved_CellInputs</span>(cube_cache: cy.<span class="org-builtin">float</span>[:,::1], i: pyidx) <span class="org-operator">-&gt;</span> CellInputs:
    <span class="org-doc">"""</span>
<span class="org-doc">    Loads the CellInputs struct by reading the data saved in the the cube_cache array.</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Topography, Fuel Model, and Vegetation</span>
    <span class="org-variable-name">slope</span>              : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cube_cache[i, 0] <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-variable-name">aspect</span>             : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cube_cache[i, 1] <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-variable-name">fuel_model_number</span>  : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cube_cache[i, 2] <span class="org-comment-delimiter"># </span><span class="org-comment">integer index in fm.fuel_model_table</span>
    <span class="org-variable-name">canopy_cover</span>       : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cube_cache[i, 3] <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
    <span class="org-variable-name">canopy_height</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cube_cache[i, 4] <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-variable-name">canopy_base_height</span> : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cube_cache[i, 5] <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-variable-name">canopy_bulk_density</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cube_cache[i, 6] <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Wind, Surface Moisture, and Foliar Moisture</span>
    <span class="org-variable-name">wind_speed_10m</span>               : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cube_cache[i, 7]  <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-variable-name">upwind_direction</span>             : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cube_cache[i, 8]  <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-variable-name">fuel_moisture_dead_1hr</span>       : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cube_cache[i, 9]  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_dead_10hr</span>      : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cube_cache[i, 10] <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_dead_100hr</span>     : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cube_cache[i, 11] <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_live_herbaceous</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cube_cache[i, 12] <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_live_woody</span>     : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cube_cache[i, 13] <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">foliar_moisture</span>              : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cube_cache[i, 14] <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Spread Rate Adjustments (Optional)</span>
    <span class="org-variable-name">fuel_spread_adjustment</span>   : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cube_cache[i, 15] <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>
    <span class="org-variable-name">weather_spread_adjustment</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cube_cache[i, 16] <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>

    <span class="org-keyword">return</span> CellInputs(
        slope                         <span class="org-operator">=</span> slope,
        aspect                        <span class="org-operator">=</span> aspect,
        fuel_model_number             <span class="org-operator">=</span> fuel_model_number,
        canopy_cover                  <span class="org-operator">=</span> canopy_cover,
        canopy_height                 <span class="org-operator">=</span> canopy_height,
        canopy_base_height            <span class="org-operator">=</span> canopy_base_height,
        canopy_bulk_density           <span class="org-operator">=</span> canopy_bulk_density,
        wind_speed_10m                <span class="org-operator">=</span> wind_speed_10m,
        upwind_direction              <span class="org-operator">=</span> upwind_direction,
        fuel_moisture_dead_1hr        <span class="org-operator">=</span> fuel_moisture_dead_1hr,
        fuel_moisture_dead_10hr       <span class="org-operator">=</span> fuel_moisture_dead_10hr,
        fuel_moisture_dead_100hr      <span class="org-operator">=</span> fuel_moisture_dead_100hr,
        fuel_moisture_live_herbaceous <span class="org-operator">=</span> fuel_moisture_live_herbaceous,
        fuel_moisture_live_woody      <span class="org-operator">=</span> fuel_moisture_live_woody,
        foliar_moisture               <span class="org-operator">=</span> foliar_moisture,
        fuel_spread_adjustment        <span class="org-operator">=</span> fuel_spread_adjustment,
        weather_spread_adjustment     <span class="org-operator">=</span> weather_spread_adjustment,
    )


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">resolve_surface_no_wind_no_slope_behavior</span>(cell_inputs: CellInputs, fuel_model: FuelModel) <span class="org-operator">-&gt;</span> FireBehaviorMin:
    <span class="org-doc">"""</span>
<span class="org-doc">    Computes the no-wind/no-slope surface fire behavior for a single cell.</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Pack surface fuel moisture values into a tuple</span>
    <span class="org-variable-name">M_f</span>: fclaarr <span class="org-operator">=</span> (cell_inputs.fuel_moisture_dead_1hr,
                    cell_inputs.fuel_moisture_dead_10hr,
                    cell_inputs.fuel_moisture_dead_100hr,
                    0.0, <span class="org-comment-delimiter"># </span><span class="org-comment">fuel_moisture_dead_herbaceous</span>
                    cell_inputs.fuel_moisture_live_herbaceous,
                    cell_inputs.fuel_moisture_live_woody)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Apply fuel moisture to fuel model</span>
    <span class="org-variable-name">moisturized_fuel_model</span>: FuelModel <span class="org-operator">=</span> fm.moisturize(fuel_model, M_f)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Combine the fuel and weather spread rate adjustments</span>
    <span class="org-variable-name">spread_rate_adjustment</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cell_inputs.fuel_spread_adjustment <span class="org-operator">*</span> cell_inputs.weather_spread_adjustment

    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the no-wind/no-slope surface fire behavior</span>
    <span class="org-keyword">return</span> sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model, spread_rate_adjustment)


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">resolve_surface_max_behavior</span>(fb_opts         : FireBehaviorSettings,
                                 cell_inputs     : CellInputs,
                                 fuel_model      : FuelModel,
                                 surface_fire_min: FireBehaviorMin) <span class="org-operator">-&gt;</span> FireBehaviorMax:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 10m wind speed to 20ft wind speed</span>
    <span class="org-variable-name">wind_speed_20ft</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> conv.wind_speed_10m_to_wind_speed_20ft(cell_inputs.wind_speed_10m) <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Convert 20ft wind speed from km/hr to m/min</span>
    <span class="org-variable-name">wind_speed_20ft_m_min</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> conv.km_hr_to_m_min(wind_speed_20ft) <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 20ft wind speed to midflame wind speed in m/min</span>
    <span class="org-variable-name">midflame_wind_speed</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> sf.calc_midflame_wind_speed(wind_speed_20ft_m_min,                   <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
                                                                fuel_model.delta,                        <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                                conv.m_to_ft(cell_inputs.canopy_height), <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                                cell_inputs.canopy_cover)                <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread</span>
    <span class="org-keyword">return</span> sf.calc_surface_fire_behavior_max(surface_fire_min,
                                             midflame_wind_speed,
                                             cell_inputs.upwind_direction,
                                             cell_inputs.slope,
                                             cell_inputs.aspect,
                                             fb_opts.use_wind_limit,
                                             fb_opts.surface_lw_ratio_model)


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: OPTIM Use elevation_gradient to avoid some polar-to-cartesian conversion.</span>
<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">resolve_crown_max_behavior</span>(fb_opts    : FireBehaviorSettings,
                               cell_inputs: CellInputs,
                               fuel_model : FuelModel) <span class="org-operator">-&gt;</span> FireBehaviorMax:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Extract intermediate values</span>
    <span class="org-variable-name">heat_of_combustion</span>          : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> conv.Btu_lb_to_kJ_kg(fuel_model.h[0]) <span class="org-comment-delimiter"># </span><span class="org-comment">kJ/kg</span>
    <span class="org-variable-name">estimated_fine_fuel_moisture</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cell_inputs.fuel_moisture_dead_1hr    <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction of maximum spread</span>
    <span class="org-keyword">return</span> cf.calc_crown_fire_behavior_max(cell_inputs.canopy_height,
                                           cell_inputs.canopy_base_height,
                                           cell_inputs.canopy_bulk_density,
                                           heat_of_combustion,
                                           estimated_fine_fuel_moisture,
                                           cell_inputs.wind_speed_10m,
                                           cell_inputs.upwind_direction,
                                           cell_inputs.slope,
                                           cell_inputs.aspect,
                                           fb_opts.crown_max_lw_ratio)


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">resolve_crowning_spread_rate</span>(cell_inputs: CellInputs, surface_fire_max: FireBehaviorMax) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Computes the surface spread rate at which crown fire occurs.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> cf.van_wagner_crowning_spread_rate(surface_fire_max,
                                              cell_inputs.canopy_base_height,
                                              cell_inputs.foliar_moisture)


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">resolve_cell_elliptical_info</span>(fb_opts         : FireBehaviorSettings,
                                 cell_index      : coord_yx,
                                 cell_inputs     : CellInputs,
                                 fuel_model      : FuelModel,
                                 surface_fire_min: FireBehaviorMin) <span class="org-operator">-&gt;</span> EllipticalInfo:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the cell's elevation gradient</span>
    <span class="org-variable-name">elevation_gradient</span>: vec_xy <span class="org-operator">=</span> calc_elevation_gradient(cell_inputs.slope, cell_inputs.aspect)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the surface_wavelet, crown_wavelet, and crowning_spread_rate</span>
    surface_wavelet     : PartialedEllWavelet
    crown_wavelet       : PartialedEllWavelet
    crowning_spread_rate: cy.<span class="org-builtin">float</span>
    <span class="org-keyword">if</span> <span class="org-keyword">not</span> fuel_model.burnable:
        <span class="org-variable-name">surface_wavelet</span>      <span class="org-operator">=</span> zero_partialed_wavelet()
        <span class="org-variable-name">crown_wavelet</span>        <span class="org-operator">=</span> zero_partialed_wavelet()
        <span class="org-variable-name">crowning_spread_rate</span> <span class="org-operator">=</span> 1234.5 <span class="org-comment-delimiter"># </span><span class="org-comment">arbitrary positive value - this threshold will never be reached.</span>
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">surface_fire_max</span>: FireBehaviorMax <span class="org-operator">=</span> resolve_surface_max_behavior(fb_opts,
                                                                         cell_inputs,
                                                                         fuel_model,
                                                                         surface_fire_min)
        <span class="org-variable-name">crown_fire_max</span>  : FireBehaviorMax <span class="org-operator">=</span> resolve_crown_max_behavior(fb_opts, cell_inputs, fuel_model)
        <span class="org-variable-name">surface_wavelet</span>                   <span class="org-operator">=</span> wavelet_from_FireBehaviorMax(surface_fire_max)
        <span class="org-variable-name">crown_wavelet</span>                     <span class="org-operator">=</span> wavelet_from_FireBehaviorMax(crown_fire_max)
        <span class="org-variable-name">crowning_spread_rate</span>              <span class="org-operator">=</span> resolve_crowning_spread_rate(cell_inputs, surface_fire_max)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Build the EllipticalInfo struct</span>
    <span class="org-keyword">return</span> EllipticalInfo(
        cell_index           <span class="org-operator">=</span> cell_index,
        elevation_gradient   <span class="org-operator">=</span> elevation_gradient,
        surface_wavelet      <span class="org-operator">=</span> surface_wavelet,
        crown_wavelet        <span class="org-operator">=</span> crown_wavelet,
        crowning_spread_rate <span class="org-operator">=</span> crowning_spread_rate,
    )


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">refresh_caches_from_inputs_if_needed</span>(spread_inputs: SpreadInputs,
                                         fb_opts      : FireBehaviorSettings,
                                         tca          : TrackedCellsArrays,
                                         present_time : cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.void:
    <span class="org-doc">"""</span>
<span class="org-doc">    If required by the refresh rates, refresh inputs and recompute the necessary downstream calcs</span>
<span class="org-doc">    for each tracked cell, such as the elliptical info and the no-wind/no-slope surface fire behavior.</span>
<span class="org-doc">    Mutates `tca`.</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Update the cached cell inputs from the spread_inputs</span>
    <span class="org-variable-name">recompute_level</span>  : cy.uint         <span class="org-operator">=</span> refresh_inputs_if_needed(spread_inputs, fb_opts, tca, present_time)
    <span class="org-variable-name">cube_cache</span>       : cy.<span class="org-builtin">float</span>[:,::1] <span class="org-operator">=</span> tca.cube_cache
    cell_inputs      : CellInputs
    fuel_model_number: pyidx
    fuel_model       : FuelModel
    i                : pyidx
    <span class="org-keyword">if</span> recompute_level <span class="org-operator">&gt;=</span> 10:
        <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(tca.num_tracked_cells):
            <span class="org-comment-delimiter"># </span><span class="org-comment">Load the cached cell inputs from the spread_inputs</span>
            <span class="org-variable-name">cell_inputs</span> <span class="org-operator">=</span> load_saved_CellInputs(cube_cache, i)
            <span class="org-comment-delimiter"># </span><span class="org-comment">Load the fuel model</span>
            <span class="org-variable-name">fuel_model_number</span> <span class="org-operator">=</span> cy.cast(pyidx, cell_inputs.fuel_model_number)
            <span class="org-variable-name">fuel_model</span>        <span class="org-operator">=</span> spread_inputs.get_fm_struct(fuel_model_number)
            <span class="org-comment-delimiter"># </span><span class="org-comment">Recalculate the no-wind/no-slope surface fire behavior for all tracked cells if recompute_level &gt;= 100</span>
            <span class="org-keyword">if</span> recompute_level <span class="org-operator">&gt;=</span> 100:
                tca.<span class="org-variable-name">sfmin_cache</span>[i] <span class="org-operator">=</span> resolve_surface_no_wind_no_slope_behavior(cell_inputs, fuel_model)
            <span class="org-comment-delimiter"># </span><span class="org-comment">Recalculate the surface_wavelet, crown_wavelet, and crowning_spread_rate for all tracked cells</span>
            tca.<span class="org-variable-name">ellipse_cache</span>[i] <span class="org-operator">=</span> resolve_cell_elliptical_info(fb_opts,
                                                                tca.ellipse_cache[i].cell_index,
                                                                cell_inputs,
                                                                fuel_model,
                                                                tca.sfmin_cache[i])


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">resolve_combined_spread_behavior</span>(spread_inputs        : SpreadInputs,
                                     fb_opts              : FireBehaviorSettings,
                                     space_time_coordinate: coord_tyx,
                                     phi_gradient_xy      : vec_xy) <span class="org-operator">-&gt;</span> SpreadBehavior:
    <span class="org-doc">"""</span>
<span class="org-doc">    Similar to resolve_cell_elliptical_info, but does a more exhaustive computation</span>
<span class="org-doc">    and returns a SpreadBehavior struct.</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Load the cell inputs</span>
    <span class="org-variable-name">cell_inputs</span>: CellInputs <span class="org-operator">=</span> lookup_cell_inputs(spread_inputs, space_time_coordinate)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Load the fuel model</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Verify that this fuel_model_number exists</span>
    <span class="org-variable-name">fuel_model_number</span>: pyidx     <span class="org-operator">=</span> cy.cast(pyidx, cell_inputs.fuel_model_number)
    <span class="org-variable-name">fuel_model</span>       : FuelModel <span class="org-operator">=</span> spread_inputs.get_fm_struct(fuel_model_number)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Project phi_gradient_xy onto the slope-tangential plane as a 3D (x,y,z) vector</span>
    <span class="org-variable-name">elevation_gradient</span>: vec_xy   <span class="org-operator">=</span> calc_elevation_gradient(cell_inputs.slope, cell_inputs.aspect)
    <span class="org-variable-name">phi_gradient_xyz</span>  : vec_xyz  <span class="org-operator">=</span> calc_phi_gradient_on_slope(phi_gradient_xy, elevation_gradient)
    <span class="org-variable-name">phi_magnitude</span>     : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vu.vector_magnitude_3d(phi_gradient_xyz)
    <span class="org-keyword">if</span> <span class="org-keyword">not</span>(fuel_model.burnable):
        <span class="org-comment-delimiter"># </span><span class="org-comment">This location is not burnable</span>
        <span class="org-keyword">return</span> unburned_SpreadBehavior(elevation_gradient, phi_gradient_xyz)
    <span class="org-keyword">elif</span> phi_magnitude <span class="org-operator">==</span> 0.0:
        <span class="org-comment-delimiter"># </span><span class="org-comment">This location is not on the fire perimeter and represents a new ignition, so burn it as a head fire</span>
        <span class="org-variable-name">surface_fire_min</span>       : FireBehaviorMin <span class="org-operator">=</span> resolve_surface_no_wind_no_slope_behavior(cell_inputs, fuel_model)
        <span class="org-variable-name">surface_fire_max</span>       : FireBehaviorMax <span class="org-operator">=</span> resolve_surface_max_behavior(fb_opts,
                                                                                cell_inputs,
                                                                                fuel_model,
                                                                                surface_fire_min)
        <span class="org-variable-name">spread_direction</span>       : vec_xyz         <span class="org-operator">=</span> surface_fire_max.max_spread_direction
        <span class="org-variable-name">surface_fire_max_simple</span>: SpreadBehavior  <span class="org-operator">=</span> sf.calc_surface_fire_behavior_in_direction(surface_fire_max,
                                                                                              spread_direction)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Check whether a crown fire occurs</span>
        <span class="org-variable-name">crowning_spread_rate</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> resolve_crowning_spread_rate(cell_inputs, surface_fire_max)
        <span class="org-keyword">if</span> (surface_fire_max_simple.spread_rate <span class="org-operator">&lt;=</span> crowning_spread_rate):
            <span class="org-keyword">return</span> surface_fire_max_simple
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">crown_fire_max</span>       : FireBehaviorMax <span class="org-operator">=</span> resolve_crown_max_behavior(fb_opts, cell_inputs, fuel_model)
            <span class="org-variable-name">spread_direction</span>     : vec_xyz         <span class="org-operator">=</span> crown_fire_max.max_spread_direction
            <span class="org-variable-name">crown_fire_max_simple</span>: SpreadBehavior  <span class="org-operator">=</span> cf.calc_crown_fire_behavior_in_direction(crown_fire_max,
                                                                                              spread_direction)
            <span class="org-variable-name">combined_fire_max</span>    : SpreadBehavior  <span class="org-operator">=</span> cf.calc_combined_fire_behavior(surface_fire_max_simple,
                                                                                    crown_fire_max_simple)
            <span class="org-keyword">return</span> combined_fire_max
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">This location is on the fire perimeter and is burnable, so burn it normal to the fire front</span>
        <span class="org-variable-name">surface_fire_min</span>   : FireBehaviorMin <span class="org-operator">=</span> resolve_surface_no_wind_no_slope_behavior(cell_inputs, fuel_model)
        <span class="org-variable-name">surface_fire_max</span>   : FireBehaviorMax <span class="org-operator">=</span> resolve_surface_max_behavior(fb_opts,
                                                                            cell_inputs,
                                                                            fuel_model,
                                                                            surface_fire_min)
        <span class="org-variable-name">surface_fire_normal</span>: SpreadBehavior  <span class="org-operator">=</span> calc_fireline_normal_behavior(surface_fire_max, phi_gradient_xyz)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Check whether a crown fire occurs</span>
        <span class="org-variable-name">crowning_spread_rate</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> resolve_crowning_spread_rate(cell_inputs, surface_fire_max)
        <span class="org-keyword">if</span> (surface_fire_normal.spread_rate <span class="org-operator">&lt;=</span> crowning_spread_rate):
            <span class="org-keyword">return</span> surface_fire_normal
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">crown_fire_max</span>      : FireBehaviorMax <span class="org-operator">=</span> resolve_crown_max_behavior(fb_opts, cell_inputs, fuel_model)
            <span class="org-variable-name">crown_fire_normal</span>   : SpreadBehavior  <span class="org-operator">=</span> calc_fireline_normal_behavior(crown_fire_max, phi_gradient_xyz)
            <span class="org-variable-name">combined_fire_normal</span>: SpreadBehavior  <span class="org-operator">=</span> cf.calc_combined_fire_behavior(surface_fire_normal,
                                                                                   crown_fire_normal)
            <span class="org-keyword">return</span> combined_fire_normal


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">load_tracked_cell_data</span>(spread_inputs: SpreadInputs,
                           fb_opts      : FireBehaviorSettings,
                           cell_index   : coord_yx,
                           tca          : TrackedCellsArrays,
                           i            : pyidx) <span class="org-operator">-&gt;</span> cy.void:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Read data from spread_inputs and save it in tca.cube_cache</span>
    load_cube_cache_for_cell(spread_inputs, cell_index, tca, i)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Load the cached cell inputs from the spread_inputs</span>
    <span class="org-variable-name">cell_inputs</span>: CellInputs <span class="org-operator">=</span> load_saved_CellInputs(tca.cube_cache, i)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Load the fuel model</span>
    <span class="org-variable-name">fuel_model_number</span>: pyidx     <span class="org-operator">=</span> cy.cast(pyidx, cell_inputs.fuel_model_number)
    <span class="org-variable-name">fuel_model</span>       : FuelModel <span class="org-operator">=</span> spread_inputs.get_fm_struct(fuel_model_number)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Recalculate the no-wind/no-slope surface fire behavior</span>
    <span class="org-variable-name">surface_fire_min</span>: FireBehaviorMin <span class="org-operator">=</span> resolve_surface_no_wind_no_slope_behavior(cell_inputs, fuel_model)
    tca.<span class="org-variable-name">sfmin_cache</span>[i]                <span class="org-operator">=</span> surface_fire_min
    <span class="org-comment-delimiter"># </span><span class="org-comment">Recalculate the surface_wavelet, crown_wavelet, and crowning_spread_rate</span>
    tca.<span class="org-variable-name">ellipse_cache</span>[i] <span class="org-operator">=</span> resolve_cell_elliptical_info(fb_opts, cell_index, cell_inputs, fuel_model, surface_fire_min)


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">sync_tracked_cells_arrays</span>(spread_inputs: SpreadInputs,
                              fb_opts      : FireBehaviorSettings,
                              tracked_cells: nbt.NarrowBandTracker,
                              tca_old      : TrackedCellsArrays,
                              tca_new      : TrackedCellsArrays) <span class="org-operator">-&gt;</span> cy.void:
    <span class="org-doc">"""</span>
<span class="org-doc">    Mutates `tca_new` so that it covers the same set of cells as `tracked_cells`,</span>
<span class="org-doc">    copying data from `tca_old` where possible, and otherwise loading new data from `spread_inputs`.</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Copy time_refreshed and t_refreshed arrays from tca_old to tca_new</span>
    tca_new.reset_size(tracked_cells.num_tracked_cells)
    tca_new.<span class="org-variable-name">time_refreshed</span> <span class="org-operator">=</span> tca_old.time_refreshed
    tca_new.<span class="org-variable-name">t_refreshed</span>    <span class="org-operator">=</span> tca_old.t_refreshed
    <span class="org-comment-delimiter"># </span><span class="org-comment">Set up loop variables</span>
    <span class="org-variable-name">cell_old</span>     : coord_yx <span class="org-operator">=</span> (0, 0)
    cell_new     : coord_yx
    <span class="org-variable-name">i_old</span>        : pyidx    <span class="org-operator">=</span> 0
    <span class="org-variable-name">i_new</span>        : pyidx    <span class="org-operator">=</span> 0
    <span class="org-variable-name">exhausted_old</span>: cy.bint  <span class="org-operator">=</span> i_old <span class="org-operator">&gt;=</span> tca_old.num_tracked_cells
    <span class="org-keyword">if</span> <span class="org-keyword">not</span>(exhausted_old):
        <span class="org-variable-name">cell_old</span> <span class="org-operator">=</span> tca_old.ellipse_cache[i_old].cell_index
    <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: This loop uses the fact that tca_old is sorted consistently with compare_cell_indexes().</span>
    <span class="org-variable-name">ys_list</span>: <span class="org-builtin">list</span> <span class="org-operator">=</span> tracked_cells.ys_list
    <span class="org-keyword">if</span> ys_list <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
        s: SortedDict
        <span class="org-keyword">for</span> s <span class="org-keyword">in</span> ys_list:
            <span class="org-keyword">if</span> s <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
                segment: nbt.CellsCountSegment
                <span class="org-keyword">for</span> segment <span class="org-keyword">in</span> s.values():
                    k: pyidx
                    <span class="org-variable-name">y</span>: pyidx <span class="org-operator">=</span> segment.y
                    <span class="org-variable-name">segment_counts</span>: cy.ushort[16] <span class="org-operator">=</span> segment.counts
                    <span class="org-keyword">for</span> k <span class="org-keyword">in</span> <span class="org-builtin">range</span>(16):
                        <span class="org-keyword">if</span> (segment_counts[k] <span class="org-operator">&gt;</span> 0):
                            <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: The `for` and `if` code above is essentially just looping over the tracked cells.</span>
                            <span class="org-comment-delimiter">#       </span><span class="org-comment">This is ugly but faster than using an Iterator pattern.</span>
                            <span class="org-variable-name">x</span>: pyidx <span class="org-operator">=</span> segment.x0 <span class="org-operator">+</span> k
                            <span class="org-variable-name">cell_new</span> <span class="org-operator">=</span> (y, x)
                            <span class="org-keyword">while</span> <span class="org-keyword">not</span>(exhausted_old) <span class="org-keyword">and</span> compare_cell_indexes(cell_old, cell_new) <span class="org-operator">&lt;</span> 0:
                                <span class="org-comment-delimiter"># </span><span class="org-comment">cell_old is no longer tracked: just move forward.</span>
                                <span class="org-variable-name">i_old</span>        <span class="org-operator">+=</span> 1
                                <span class="org-variable-name">exhausted_old</span> <span class="org-operator">=</span> i_old <span class="org-operator">&gt;=</span> tca_old.num_tracked_cells
                                <span class="org-keyword">if</span> <span class="org-keyword">not</span>(exhausted_old):
                                    <span class="org-variable-name">cell_old</span> <span class="org-operator">=</span> tca_old.ellipse_cache[i_old].cell_index
                            <span class="org-keyword">if</span> <span class="org-keyword">not</span>(exhausted_old) <span class="org-keyword">and</span> (compare_cell_indexes(cell_old, cell_new) <span class="org-operator">==</span> 0):
                                <span class="org-comment-delimiter"># </span><span class="org-comment">cell_new was already tracked: copy the data.</span>
                                copy_tracked_cell_data(i_old, tca_old, i_new, tca_new)
                            <span class="org-keyword">else</span>:
                                <span class="org-comment-delimiter"># </span><span class="org-comment">cell_new was not in tca_old</span>
                                load_tracked_cell_data(spread_inputs, fb_opts, cell_new, tca_new, i_new)
                            <span class="org-variable-name">i_new</span> <span class="org-operator">+=</span> 1


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">runge_kutta_pass1</span>(max_cells_per_timestep: cy.<span class="org-builtin">float</span>,
                      dy                    : cy.<span class="org-builtin">float</span>,
                      dx                    : cy.<span class="org-builtin">float</span>,
                      max_timestep          : cy.<span class="org-builtin">float</span>,
                      tca                   : TrackedCellsArrays) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    1st Runge-Kutta loop over elliptical dimensions, which:</span>
<span class="org-doc">    1. Resolves dt from the CFL condition</span>
<span class="org-doc">    2. Saves a Pass1CellOutput struct for each cell</span>

<span class="org-doc">    Returns the resolved `dt` and mutates `tca.pass1_cache`.</span>
<span class="org-doc">    Reads only `tca.ellipse_cache`.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">ellipse_cache</span>: cy.pointer[EllipticalInfo]  <span class="org-operator">=</span> tca.ellipse_cache
    <span class="org-variable-name">pass1_cache</span>  : cy.pointer[Pass1CellOutput] <span class="org-operator">=</span> tca.pass1_cache
    <span class="org-comment-delimiter"># </span><span class="org-comment">The following will be useful to compute dt based on the CFL constraint.</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">It is more convenient to first compute dt_inv, the reciprocal of dt, and then</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">dt_inv = 0 represents an infinite dt. We will later enforce that dt &lt;= max_timestep.</span>
    <span class="org-variable-name">dt_inv</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 0.0
    <span class="org-variable-name">C_dx</span>  : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> max_cells_per_timestep <span class="org-operator">*</span> dx
    <span class="org-variable-name">C_dy</span>  : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> max_cells_per_timestep <span class="org-operator">*</span> dy
    <span class="org-comment-delimiter"># </span><span class="org-comment">Now looping over tracked cells:</span>
    <span class="org-variable-name">phi_cache</span>: cy.<span class="org-builtin">float</span>[:,::1] <span class="org-operator">=</span> tca.phi_cache
    <span class="org-variable-name">dx_inv</span>   : cy.<span class="org-builtin">float</span>        <span class="org-operator">=</span> 1.0 <span class="org-operator">/</span> dx
    <span class="org-variable-name">dy_inv</span>   : cy.<span class="org-builtin">float</span>        <span class="org-operator">=</span> 1.0 <span class="org-operator">/</span> dy
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(tca.num_tracked_cells):
        <span class="org-variable-name">ellipses</span>  : EllipticalInfo <span class="org-operator">=</span> ellipse_cache[i]
        <span class="org-variable-name">cell_index</span>: coord_yx       <span class="org-operator">=</span> ellipses.cell_index
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the non-flux-limited spatial phi gradient</span>
        <span class="org-variable-name">dphi_dx</span>           : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (phi_cache[i, 3] <span class="org-operator">-</span> phi_cache[i, 2]) <span class="org-operator">*</span> dx_inv <span class="org-operator">/</span> 2.0
        <span class="org-variable-name">dphi_dy</span>           : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (phi_cache[i, 7] <span class="org-operator">-</span> phi_cache[i, 6]) <span class="org-operator">*</span> dy_inv <span class="org-operator">/</span> 2.0
        <span class="org-variable-name">phi_gradient_xy</span>   : vec_xy   <span class="org-operator">=</span> (dphi_dx, dphi_dy)
        <span class="org-variable-name">dphi_norm2</span>        : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (dphi_dx <span class="org-operator">*</span> dphi_dx) <span class="org-operator">+</span> (dphi_dy <span class="org-operator">*</span> dphi_dy)
        dphi_dt_flim_pass1: cy.<span class="org-builtin">float</span>
        <span class="org-keyword">if</span> dphi_norm2 <span class="org-operator">&gt;</span> 0.0: <span class="org-comment-delimiter"># </span><span class="org-comment">Most common case</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the flux-limited spatial phi gradient</span>
            <span class="org-variable-name">dphi_dx_flim</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> dx_inv <span class="org-operator">*</span> calc_dphi_flim_x(phi_cache[i, 0],
                                                               phi_cache[i, 1],
                                                               phi_cache[i, 2],
                                                               phi_cache[i, 3],
                                                               phi_cache[i, 4])
            <span class="org-variable-name">dphi_dy_flim</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> dy_inv <span class="org-operator">*</span> calc_dphi_flim_y(phi_cache[i, 0],
                                                               phi_cache[i, 5],
                                                               phi_cache[i, 6],
                                                               phi_cache[i, 7],
                                                               phi_cache[i, 8])
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the flux-limited temporal phi gradient</span>
            <span class="org-variable-name">dphi_dt</span>           : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> dphi_dt_from_ellipses(ellipses, phi_gradient_xy)
            <span class="org-variable-name">dphi_dt_correction</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (dphi_dx <span class="org-operator">*</span> dphi_dx_flim <span class="org-operator">+</span> dphi_dy <span class="org-operator">*</span> dphi_dy_flim) <span class="org-operator">/</span> dphi_norm2
            <span class="org-variable-name">dphi_dt_flim_pass1</span>           <span class="org-operator">=</span> (dphi_dt <span class="org-operator">*</span> dphi_dt_correction)
            <span class="org-comment-delimiter"># </span><span class="org-comment">Checking the CFL condition and updating dt_inv if needed (which will be rare).</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">The code is written in this way to be fast, but it's not trivial that it's correct; proof below.</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">The CFL constraint is defined as the requirement that |Ux*dt| &lt;= C*dx and |Uy*dt| &lt;= C*dy,</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">in which U := (Ux, Uy) is the front-normal spread rate vector in the horizontal plane,</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">and C := max_cells_per_timestep.</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Recall that we could express U as follows: U: vec_xy = scale_2d(-dphi_dt/dphi_norm2, dphi),</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">which follows from the facts that dphi_dt = -dot2d(U, dphi) and that U is by definition</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">positively proportional to dphi.</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">In particular, Ux = -dphi_dx * dphi_dt / dphi_norm2.</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Our constraint (from Ux) thus becomes:</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">|dt * dphi_dx * dphi_dt / dphi_norm2| &lt;= C * dx</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Recalling that dt_inv := 1/dt and rearranging yields:</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">dt_inv * (C * dx) * dphi_norm2 &gt;= |dphi_dx * dphi_dt|</span>
            <span class="org-keyword">if</span> (dt_inv <span class="org-operator">*</span> (dphi_norm2 <span class="org-operator">*</span> C_dx) <span class="org-operator">&lt;</span> <span class="org-builtin">abs</span>(dphi_dt <span class="org-operator">*</span> dphi_dx)): <span class="org-comment-delimiter"># </span><span class="org-comment">dt is too large given Ux</span>
                <span class="org-variable-name">dt_inv</span> <span class="org-operator">=</span> <span class="org-builtin">abs</span>(dphi_dt <span class="org-operator">*</span> dphi_dx) <span class="org-operator">/</span> (dphi_norm2 <span class="org-operator">*</span> C_dx)
            <span class="org-comment-delimiter"># </span><span class="org-comment">And similarly for Uy:</span>
            <span class="org-keyword">if</span> (dt_inv <span class="org-operator">*</span> (dphi_norm2 <span class="org-operator">*</span> C_dy) <span class="org-operator">&lt;</span> <span class="org-builtin">abs</span>(dphi_dt <span class="org-operator">*</span> dphi_dy)): <span class="org-comment-delimiter"># </span><span class="org-comment">dt is too large given Uy</span>
                <span class="org-variable-name">dt_inv</span> <span class="org-operator">=</span> <span class="org-builtin">abs</span>(dphi_dt <span class="org-operator">*</span> dphi_dy) <span class="org-operator">/</span> (dphi_norm2 <span class="org-operator">*</span> C_dy)
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">dphi_dt_flim_pass1</span> <span class="org-operator">=</span> 0.0
        <span class="org-comment-delimiter"># </span><span class="org-comment">Store the old and new phi values for each cell in pass1_cache</span>
        <span class="org-variable-name">pass1_cache</span>[i] <span class="org-operator">=</span> Pass1CellOutput(
            cell_index      <span class="org-operator">=</span> cell_index,
            phi_gradient_xy <span class="org-operator">=</span> phi_gradient_xy,
            dphi_dt_flim    <span class="org-operator">=</span> dphi_dt_flim_pass1,
            phi_old         <span class="org-operator">=</span> phi_cache[i, 0],
        )
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the CFL-constrained timestep dt</span>
    <span class="org-variable-name">dt_inv</span>       <span class="org-operator">=</span> <span class="org-builtin">max</span>(dt_inv, 1.0 <span class="org-operator">/</span> max_timestep) <span class="org-comment-delimiter"># </span><span class="org-comment">(dt &lt;= max_timestep) iff (dt_inv &gt;= 1/max_timestep)</span>
    <span class="org-variable-name">dt</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 1.0 <span class="org-operator">/</span> dt_inv
    <span class="org-keyword">return</span> dt


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">update_phi_star</span>(tca            : TrackedCellsArrays,
                    dt             : cy.<span class="org-builtin">float</span>,
                    phi_star_matrix: cy.<span class="org-builtin">float</span>[:,::1]) <span class="org-operator">-&gt;</span> cy.void:
    <span class="org-doc">"""</span>
<span class="org-doc">    Mutates phi_star_matrix, by using the dt and dphi/dt computed in the 1st Runge-Kutta pass.</span>
<span class="org-doc">    To be called between Runge-Kutta passes.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">pass1_cache</span>: cy.pointer[Pass1CellOutput] <span class="org-operator">=</span> tca.pass1_cache
    i          : pyidx
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(tca.num_tracked_cells):
        <span class="org-variable-name">pass1output</span>: Pass1CellOutput <span class="org-operator">=</span> pass1_cache[i]
        <span class="org-variable-name">cell_index</span> : coord_yx        <span class="org-operator">=</span> pass1output.cell_index
        <span class="org-variable-name">y</span>          : pyidx           <span class="org-operator">=</span> cell_index[0]
        <span class="org-variable-name">x</span>          : pyidx           <span class="org-operator">=</span> cell_index[1]
        <span class="org-variable-name">phi_star_matrix</span>[2<span class="org-operator">+</span>y, 2<span class="org-operator">+</span>x]    <span class="org-operator">=</span> pass1output.phi_old <span class="org-operator">+</span> (dt <span class="org-operator">*</span> pass1output.dphi_dt_flim)


<span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: Using an Extension Type here instead of a struct because it's</span>
<span class="org-comment-delimiter">#       </span><span class="org-comment">convenient to store in Python data structures like lists and dicts.</span>
<span class="org-type">@cy.cclass</span>
<span class="org-keyword">class</span> <span class="org-type">BurnedCellInfo</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    This data structure simply records information about a burned cell.</span>
<span class="org-doc">    """</span>
    cell_index     : coord_yx
    time_of_arrival: cy.<span class="org-builtin">float</span>
    phi_gradient_xy: vec_xy


<span class="org-type">@cy.cfunc</span>
<span class="org-keyword">def</span> <span class="org-function-name">new_BurnedCellInfo</span>(cell_index     : coord_yx,
                       time_of_arrival: cy.<span class="org-builtin">float</span>,
                       phi_gradient_xy: vec_xy) <span class="org-operator">-&gt;</span> BurnedCellInfo:
    <span class="org-variable-name">ret</span>: BurnedCellInfo <span class="org-operator">=</span> BurnedCellInfo()
    ret.<span class="org-variable-name">cell_index</span>      <span class="org-operator">=</span> cell_index
    ret.<span class="org-variable-name">time_of_arrival</span> <span class="org-operator">=</span> time_of_arrival
    ret.<span class="org-variable-name">phi_gradient_xy</span> <span class="org-operator">=</span> phi_gradient_xy
    <span class="org-keyword">return</span> ret


<span class="org-type">@cy.cfunc</span>
<span class="org-keyword">def</span> <span class="org-function-name">runge_kutta_pass2</span>(dy                : cy.<span class="org-builtin">float</span>,
                      dx                : cy.<span class="org-builtin">float</span>,
                      start_time        : cy.<span class="org-builtin">float</span>,
                      dt                : cy.<span class="org-builtin">float</span>,
                      tca               : TrackedCellsArrays,
                      phi_matrix        : cy.<span class="org-builtin">float</span>[:,::1]) <span class="org-operator">-&gt;</span> <span class="org-builtin">list</span>[BurnedCellInfo]:
    <span class="org-doc">"""</span>
<span class="org-doc">    2nd Runge-Kutta loop, which:</span>
<span class="org-doc">    1. Updates phi_matrix</span>
<span class="org-doc">    2. Identifies cells that have just burned and returns them in a list</span>
<span class="org-doc">    Reads from `tca` and `phi_star_cache`, and mutates `phi_matrix`.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">dx_inv</span>        : cy.<span class="org-builtin">float</span>                    <span class="org-operator">=</span> 1.0 <span class="org-operator">/</span> dx
    <span class="org-variable-name">dy_inv</span>        : cy.<span class="org-builtin">float</span>                    <span class="org-operator">=</span> 1.0 <span class="org-operator">/</span> dy
    <span class="org-variable-name">ellipse_cache</span> : cy.pointer[EllipticalInfo]  <span class="org-operator">=</span> tca.ellipse_cache
    <span class="org-variable-name">pass1_cache</span>   : cy.pointer[Pass1CellOutput] <span class="org-operator">=</span> tca.pass1_cache
    <span class="org-variable-name">phi_star_cache</span>: cy.<span class="org-builtin">float</span>[:,::1]             <span class="org-operator">=</span> tca.phi_cache
    <span class="org-variable-name">burned_cells</span>  : <span class="org-builtin">list</span>[BurnedCellInfo]        <span class="org-operator">=</span> []
    i             : pyidx
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(tca.num_tracked_cells):
        <span class="org-variable-name">ellipses</span>  : EllipticalInfo <span class="org-operator">=</span> ellipse_cache[i]
        <span class="org-variable-name">cell_index</span>: coord_yx       <span class="org-operator">=</span> ellipses.cell_index
        <span class="org-variable-name">y</span>         : pyidx          <span class="org-operator">=</span> cell_index[0]
        <span class="org-variable-name">x</span>         : pyidx          <span class="org-operator">=</span> cell_index[1]
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the non-flux-limited spatial phi gradient</span>
        <span class="org-variable-name">dphi_dx</span>           : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (phi_star_cache[i, 3] <span class="org-operator">-</span> phi_star_cache[i, 2]) <span class="org-operator">*</span> dx_inv <span class="org-operator">/</span> 2.0
        <span class="org-variable-name">dphi_dy</span>           : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (phi_star_cache[i, 7] <span class="org-operator">-</span> phi_star_cache[i, 6]) <span class="org-operator">*</span> dy_inv <span class="org-operator">/</span> 2.0
        <span class="org-variable-name">phi_gradient_xy</span>   : vec_xy   <span class="org-operator">=</span> (dphi_dx, dphi_dy)
        <span class="org-variable-name">dphi_norm2</span>        : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (dphi_dx <span class="org-operator">*</span> dphi_dx) <span class="org-operator">+</span> (dphi_dy <span class="org-operator">*</span> dphi_dy)
        dphi_dt_flim_pass2: cy.<span class="org-builtin">float</span>
        <span class="org-keyword">if</span> dphi_norm2 <span class="org-operator">&gt;</span> 0.0: <span class="org-comment-delimiter"># </span><span class="org-comment">Most common case</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the flux-limited spatial phi gradient</span>
            <span class="org-variable-name">dphi_dx_flim</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> dx_inv <span class="org-operator">*</span> calc_dphi_flim_x(phi_star_cache[i, 0],
                                                               phi_star_cache[i, 1],
                                                               phi_star_cache[i, 2],
                                                               phi_star_cache[i, 3],
                                                               phi_star_cache[i, 4])
            <span class="org-variable-name">dphi_dy_flim</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> dy_inv <span class="org-operator">*</span> calc_dphi_flim_y(phi_star_cache[i, 0],
                                                               phi_star_cache[i, 5],
                                                               phi_star_cache[i, 6],
                                                               phi_star_cache[i, 7],
                                                               phi_star_cache[i, 8])
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the flux-limited temporal phi gradient</span>
            <span class="org-variable-name">dphi_dt</span>           : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> dphi_dt_from_ellipses(ellipses, phi_gradient_xy)
            <span class="org-variable-name">dphi_dt_correction</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (dphi_dx <span class="org-operator">*</span> dphi_dx_flim <span class="org-operator">+</span> dphi_dy <span class="org-operator">*</span> dphi_dy_flim) <span class="org-operator">/</span> dphi_norm2
            <span class="org-variable-name">dphi_dt_flim_pass2</span>           <span class="org-operator">=</span> (dphi_dt <span class="org-operator">*</span> dphi_dt_correction)
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">dphi_dt_flim_pass2</span> <span class="org-operator">=</span> 0.0
        <span class="org-comment-delimiter"># </span><span class="org-comment">Combine the flux-limited temporal phi gradients from both Runge-Kutta passes</span>
        <span class="org-variable-name">dphi_dt_flim_pass1</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> pass1_cache[i].dphi_dt_flim
        <span class="org-variable-name">phi_old</span>           : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> pass1_cache[i].phi_old
        <span class="org-variable-name">phi_new</span>           : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi_old <span class="org-operator">+</span> 0.5 <span class="org-operator">*</span> (dphi_dt_flim_pass1 <span class="org-operator">+</span> dphi_dt_flim_pass2) <span class="org-operator">*</span> dt
        <span class="org-variable-name">phi_matrix</span>[2<span class="org-operator">+</span>y, 2<span class="org-operator">+</span>x]         <span class="org-operator">=</span> phi_new
        <span class="org-comment-delimiter"># </span><span class="org-comment">Check whether this cell has just burned, and add it to the burned_cells list if so.</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: Phi can only ever decrease, and cells with negative phi are on fire.</span>
        <span class="org-comment-delimiter">#       </span><span class="org-comment">Therefore, if phi_old and phi_new are of opposite signs, the cell has just burned.</span>
        <span class="org-keyword">if</span> (phi_old <span class="org-operator">*</span> phi_new) <span class="org-operator">&lt;</span> 0.0:
            <span class="org-variable-name">preburn_weight</span>          : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi_old <span class="org-operator">/</span> (phi_old <span class="org-operator">-</span> phi_new)
            <span class="org-variable-name">postburn_weight</span>         : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 1.0 <span class="org-operator">-</span> preburn_weight
            <span class="org-variable-name">time_of_arrival</span>         : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> start_time <span class="org-operator">+</span> dt <span class="org-operator">*</span> preburn_weight
            <span class="org-variable-name">phi_gradient_xy_pass1</span>   : vec_xy   <span class="org-operator">=</span> pass1_cache[i].phi_gradient_xy
            <span class="org-variable-name">dphi_dx_pass1</span>           : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi_gradient_xy_pass1[0]
            <span class="org-variable-name">dphi_dy_pass1</span>           : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> phi_gradient_xy_pass1[1]
            <span class="org-variable-name">phi_gradient_xy_combined</span>: vec_xy   <span class="org-operator">=</span> (dphi_dx_pass1 <span class="org-operator">*</span> postburn_weight <span class="org-operator">+</span> dphi_dx <span class="org-operator">*</span> preburn_weight,
                                                  dphi_dy_pass1 <span class="org-operator">*</span> postburn_weight <span class="org-operator">+</span> dphi_dy <span class="org-operator">*</span> preburn_weight)
            burned_cells.append(
                new_BurnedCellInfo(cell_index      <span class="org-operator">=</span> cell_index,
                                   time_of_arrival <span class="org-operator">=</span> time_of_arrival,
                                   phi_gradient_xy <span class="org-operator">=</span> phi_gradient_xy_combined)
            )
    <span class="org-keyword">return</span> burned_cells


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">process_burned_cells</span>(spread_inputs   : SpreadInputs,
                         fb_opts         : FireBehaviorSettings,
                         spread_state    : SpreadState,
                         spot_ignitions  : SortedDict[<span class="org-builtin">float</span>, <span class="org-builtin">set</span>],
                         random_generator: BufferedRandGen,
                         burned_cells    : <span class="org-builtin">list</span>[BurnedCellInfo]) <span class="org-operator">-&gt;</span> cy.void:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack spread_state</span>
    <span class="org-variable-name">fire_type_matrix</span>         : cy.uchar[:,::1] <span class="org-operator">=</span> spread_state.fire_type
    <span class="org-variable-name">spread_rate_matrix</span>       : cy.<span class="org-builtin">float</span>[:,::1] <span class="org-operator">=</span> spread_state.spread_rate
    <span class="org-variable-name">spread_direction_matrix</span>  : cy.<span class="org-builtin">float</span>[:,::1] <span class="org-operator">=</span> spread_state.spread_direction
    <span class="org-variable-name">fireline_intensity_matrix</span>: cy.<span class="org-builtin">float</span>[:,::1] <span class="org-operator">=</span> spread_state.fireline_intensity
    <span class="org-variable-name">flame_length_matrix</span>      : cy.<span class="org-builtin">float</span>[:,::1] <span class="org-operator">=</span> spread_state.flame_length
    <span class="org-variable-name">time_of_arrival_matrix</span>   : cy.<span class="org-builtin">float</span>[:,::1] <span class="org-operator">=</span> spread_state.time_of_arrival

    <span class="org-comment-delimiter"># </span><span class="org-comment">Save the burned_cells fire behavior values in the spread_state matrices</span>
    burned_cell: BurnedCellInfo
    <span class="org-keyword">for</span> burned_cell <span class="org-keyword">in</span> burned_cells:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Determine the current space_time_coordinate</span>
        <span class="org-variable-name">time_of_arrival</span>      : cy.<span class="org-builtin">float</span>  <span class="org-operator">=</span> burned_cell.time_of_arrival
        <span class="org-variable-name">cell_index</span>           : coord_yx  <span class="org-operator">=</span> burned_cell.cell_index
        <span class="org-variable-name">t</span>                    : pyidx     <span class="org-operator">=</span> <span class="org-builtin">int</span>(time_of_arrival <span class="org-operator">//</span> spread_inputs.band_duration)
        (<span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>)                           <span class="org-operator">=</span> cell_index
        <span class="org-variable-name">space_time_coordinate</span>: coord_tyx <span class="org-operator">=</span> (t, y, x)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Re-compute the spread behavior. It's OK to re-compute it because a cell burning is a relatively rare event.</span>
        <span class="org-variable-name">fire_behavior</span>: SpreadBehavior <span class="org-operator">=</span> resolve_combined_spread_behavior(spread_inputs,
                                                                         fb_opts,
                                                                         space_time_coordinate,
                                                                         burned_cell.phi_gradient_xy)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Write to the spread_state matrices</span>
        <span class="org-variable-name">fire_type_matrix</span>[<span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>]          <span class="org-operator">=</span> fire_behavior.fire_type
        <span class="org-variable-name">spread_rate_matrix</span>[<span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>]        <span class="org-operator">=</span> fire_behavior.spread_rate
        <span class="org-variable-name">spread_direction_matrix</span>[<span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>]   <span class="org-operator">=</span> vu.spread_direction_vector_to_angle(fire_behavior.spread_direction)
        <span class="org-variable-name">fireline_intensity_matrix</span>[<span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>] <span class="org-operator">=</span> fire_behavior.fireline_intensity
        <span class="org-variable-name">flame_length_matrix</span>[<span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>]       <span class="org-operator">=</span> fire_behavior.flame_length
        <span class="org-variable-name">time_of_arrival_matrix</span>[<span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>]    <span class="org-operator">=</span> time_of_arrival

        <span class="org-comment-delimiter"># </span><span class="org-comment">Cast firebrands and update spot_ignitions</span>
        <span class="org-keyword">if</span> fb_opts.spot_config:
            spot_from_burned_cell(spread_inputs,
                                  fire_type_matrix,
                                  y,
                                  x,
                                  fire_behavior,
                                  time_of_arrival,
                                  random_generator,
                                  fb_opts.spot_config,
                                  spot_ignitions)


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">reset_phi_star</span>(tca               : TrackedCellsArrays,
                   spot_ignited_cells: <span class="org-builtin">list</span>[BurnedCellInfo],
                   phi_star_matrix   : cy.<span class="org-builtin">float</span>[:,::1],
                   phi_matrix        : cy.<span class="org-builtin">float</span>[:,::1]) <span class="org-operator">-&gt;</span> cy.void:
    <span class="org-doc">"""</span>
<span class="org-doc">    Efficiently updates `phi_star_matrix` to match `phi_matrix`,</span>
<span class="org-doc">    by copying only the values of cells where phi has changed.</span>
<span class="org-doc">    Mutates `phi_star_matrix`, reading from `tca.pass1_cache`, `spot_ignited_cells`, and `phi_matrix`.</span>
<span class="org-doc">    """</span>
    y: pyidx
    x: pyidx
    i: pyidx
    <span class="org-comment-delimiter"># </span><span class="org-comment">First copy phi values from the tracked cells</span>
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(tca.num_tracked_cells):
        (<span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>)                    <span class="org-operator">=</span> tca.pass1_cache[i].cell_index
        <span class="org-variable-name">phi_star_matrix</span>[2<span class="org-operator">+</span>y, 2<span class="org-operator">+</span>x] <span class="org-operator">=</span> phi_matrix[2<span class="org-operator">+</span>y, 2<span class="org-operator">+</span>x]
    <span class="org-comment-delimiter"># </span><span class="org-comment">Then copy phi values from any spot-ignited cells</span>
    burned_cell: BurnedCellInfo
    <span class="org-keyword">for</span> burned_cell <span class="org-keyword">in</span> spot_ignited_cells:
        (<span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>)                    <span class="org-operator">=</span> burned_cell.cell_index
        <span class="org-variable-name">phi_star_matrix</span>[2<span class="org-operator">+</span>y, 2<span class="org-operator">+</span>x] <span class="org-operator">=</span> phi_matrix[2<span class="org-operator">+</span>y, 2<span class="org-operator">+</span>x]


<span class="org-type">@cy.cfunc</span>
<span class="org-keyword">def</span> <span class="org-function-name">ignite_from_spotting</span>(spot_ignitions: SortedDict[<span class="org-builtin">float</span>, <span class="org-builtin">set</span>],
                         phi_matrix    : cy.<span class="org-builtin">float</span>[:,::1],
                         stop_time     : cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> <span class="org-builtin">list</span>[BurnedCellInfo]:
    <span class="org-doc">"""</span>
<span class="org-doc">    Resolves the cells to be ignited by spotting in the current time step,</span>
<span class="org-doc">    returning them as a list of (y, x) tuples, and mutates `phi_matrix` accordingly.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">ignited_cells</span>: <span class="org-builtin">list</span>[BurnedCellInfo] <span class="org-operator">=</span> []
    <span class="org-keyword">if</span> <span class="org-builtin">len</span>(spot_ignitions) <span class="org-operator">&gt;</span> 0:
        maybe_ignited_cells: <span class="org-builtin">set</span>
        cell_index         : coord_yx
        <span class="org-comment-delimiter"># </span><span class="org-comment">https://grantjenks.com/docs/sortedcontainers/sorteddict.html</span>
        <span class="org-variable-name">n</span> : pyidx <span class="org-operator">=</span> spot_ignitions.bisect_left(stop_time) <span class="org-comment-delimiter"># </span><span class="org-comment">number of ignition_time values smaller than stop_time</span>
        _i: pyidx
        <span class="org-keyword">for</span> _i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n):
            <span class="org-comment-delimiter"># </span><span class="org-comment">Remove and return the smallest ignition_time</span>
            <span class="org-variable-name">maybe_ignited_cells</span> <span class="org-operator">=</span> spot_ignitions.popitem(index<span class="org-operator">=</span>0)[1]
            <span class="org-keyword">for</span> cell_index <span class="org-keyword">in</span> maybe_ignited_cells:
                <span class="org-variable-name">y</span>: pyidx <span class="org-operator">=</span> cell_index[0]
                <span class="org-variable-name">x</span>: pyidx <span class="org-operator">=</span> cell_index[1]
                <span class="org-keyword">if</span> phi_matrix[2<span class="org-operator">+</span>y, 2<span class="org-operator">+</span>x] <span class="org-operator">&gt;</span> 0.0: <span class="org-comment-delimiter"># </span><span class="org-comment">Not burned by stop_time</span>
                    <span class="org-variable-name">phi_matrix</span>[2<span class="org-operator">+</span>y, 2<span class="org-operator">+</span>x] <span class="org-operator">=</span> <span class="org-operator">-</span>1.0 <span class="org-comment-delimiter"># </span><span class="org-comment">Ignite this cell at stop_time</span>
                    ignited_cells.append(
                        new_BurnedCellInfo(cell_index      <span class="org-operator">=</span> cell_index,
                                           time_of_arrival <span class="org-operator">=</span> stop_time, <span class="org-comment-delimiter"># </span><span class="org-comment">Start all spot_ignitions on the next timestep</span>
                                           phi_gradient_xy <span class="org-operator">=</span> (0.0, 0.0))
                    )
    <span class="org-keyword">return</span> ignited_cells


<span class="org-type">@cy.cfunc</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">route_cell_to_diff</span>(frontier_cells_old: <span class="org-builtin">set</span>,
                       frontier_additions: <span class="org-builtin">set</span>,
                       frontier_removals : <span class="org-builtin">set</span>,
                       phi_matrix        : cy.<span class="org-builtin">float</span>[:,::1],
                       fuel_model_cube   : ISpaceTimeCube,
                       t                 : pyidx,
                       y                 : pyidx,
                       x                 : pyidx) <span class="org-operator">-&gt;</span> cy.void:
    <span class="org-doc">"""</span>
<span class="org-doc">    Determines whether the cell `(y, x)` was just added or removed from the frontier cells,</span>
<span class="org-doc">    mutating the sets `frontier_additions` and `frontier_removals` accordingly.</span>
<span class="org-doc">    Idempotent.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">encoded_cell_index</span>: <span class="org-builtin">object</span> <span class="org-operator">=</span> encode_cell_index(y, x)
    <span class="org-keyword">if</span> is_frontier_cell(phi_matrix, fuel_model_cube, t, y, x):
        <span class="org-keyword">if</span> <span class="org-keyword">not</span> (encoded_cell_index <span class="org-keyword">in</span> frontier_cells_old):
            frontier_additions.add(encoded_cell_index)
    <span class="org-keyword">else</span>:
        <span class="org-keyword">if</span> (encoded_cell_index <span class="org-keyword">in</span> frontier_cells_old):
            frontier_removals.add(encoded_cell_index)


<span class="org-type">@cy.cfunc</span>
<span class="org-keyword">def</span> <span class="org-function-name">diff_frontier_cells</span>(frontier_cells_old  : <span class="org-builtin">set</span>,
                        spread_ignited_cells: <span class="org-builtin">list</span>[BurnedCellInfo],
                        spot_ignited_cells  : <span class="org-builtin">list</span>[BurnedCellInfo],
                        phi_matrix          : cy.<span class="org-builtin">float</span>[:,::1],
                        fuel_model_cube     : ISpaceTimeCube,
                        t                   : pyidx) <span class="org-operator">-&gt;</span> <span class="org-builtin">tuple</span>[<span class="org-builtin">set</span>, <span class="org-builtin">set</span>]:
    <span class="org-doc">"""</span>
<span class="org-doc">    Computes the bi-directional set difference between the old frontier cells and the new frontier cells,</span>
<span class="org-doc">    based on newly burned cells. Returns a `(cells_added, cells_dropped)` tuple of sets, containing cell indices</span>
<span class="org-doc">    encoded by `encode_cell_index`.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">frontier_additions</span>: <span class="org-builtin">set</span> <span class="org-operator">=</span> <span class="org-builtin">set</span>()
    <span class="org-variable-name">frontier_removals</span> : <span class="org-builtin">set</span> <span class="org-operator">=</span> <span class="org-builtin">set</span>()
    ignited_cells     : <span class="org-builtin">list</span>[BurnedCellInfo]
    <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: We accept two lists below instead of one to avoid paying the cost of concatenating them.</span>
    <span class="org-keyword">for</span> ignited_cells <span class="org-keyword">in</span> [spread_ignited_cells, spot_ignited_cells]:
        burned_cell: BurnedCellInfo
        y          : pyidx
        x          : pyidx
        <span class="org-keyword">for</span> burned_cell <span class="org-keyword">in</span> ignited_cells:
            (<span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>) <span class="org-operator">=</span> burned_cell.cell_index
            <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: Only in the neighborhood of a burned cell can there be changes to frontier cells membership.</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Should we be checking the diagonal directions as well?</span>
            route_cell_to_diff(frontier_cells_old,
                               frontier_additions,
                               frontier_removals,
                               phi_matrix,
                               fuel_model_cube,
                               t,
                               y,
                               x)
            route_cell_to_diff(frontier_cells_old,
                               frontier_additions,
                               frontier_removals,
                               phi_matrix,
                               fuel_model_cube,
                               t,
                               y<span class="org-operator">-</span>1,
                               x)
            route_cell_to_diff(frontier_cells_old,
                               frontier_additions,
                               frontier_removals,
                               phi_matrix,
                               fuel_model_cube,
                               t,
                               y<span class="org-operator">+</span>1,
                               x)
            route_cell_to_diff(frontier_cells_old,
                               frontier_additions,
                               frontier_removals,
                               phi_matrix,
                               fuel_model_cube,
                               t,
                               y,
                               x<span class="org-operator">-</span>1)
            route_cell_to_diff(frontier_cells_old,
                               frontier_additions,
                               frontier_removals,
                               phi_matrix,
                               fuel_model_cube,
                               t,
                               y,
                               x<span class="org-operator">+</span>1)
    <span class="org-keyword">return</span> (frontier_additions, frontier_removals)


<span class="org-type">@cy.cfunc</span>
<span class="org-keyword">def</span> <span class="org-function-name">apply_frontier_diff</span>(frontier_cells_old: <span class="org-builtin">set</span>, frontier_additions: <span class="org-builtin">set</span>, frontier_removals: <span class="org-builtin">set</span>) <span class="org-operator">-&gt;</span> <span class="org-builtin">set</span>:
    <span class="org-variable-name">frontier_cells_new</span>: <span class="org-builtin">set</span> <span class="org-operator">=</span> frontier_cells_old.copy()
    encoded_cell_index: <span class="org-builtin">object</span>
    <span class="org-keyword">for</span> encoded_cell_index <span class="org-keyword">in</span> frontier_additions:
        frontier_cells_new.add(encoded_cell_index)
    <span class="org-keyword">for</span> encoded_cell_index <span class="org-keyword">in</span> frontier_removals:
        frontier_cells_new.discard(encoded_cell_index)
    <span class="org-keyword">return</span> frontier_cells_new


<span class="org-type">@cy.cfunc</span>
<span class="org-keyword">def</span> <span class="org-function-name">update_tracked_cells_with_frontier_diff</span>(tracked_cells         : nbt.NarrowBandTracker,
                                            frontier_cells_added  : <span class="org-builtin">set</span>,
                                            frontier_cells_dropped: <span class="org-builtin">set</span>,
                                            buffer_width          : pyidx) <span class="org-operator">-&gt;</span> nbt.NarrowBandTracker:
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Increment reference counters for all cells within buffer_width of the added frontier cells</span>
    encoded_cell_index: <span class="org-builtin">object</span>
    y                 : pyidx
    x                 : pyidx
    <span class="org-keyword">for</span> encoded_cell_index <span class="org-keyword">in</span> frontier_cells_added:
        (<span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>) <span class="org-operator">=</span> decode_cell_index(encoded_cell_index)
        nbt.inc_square_around(tracked_cells, y, x, buffer_width)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Decrement reference counters for all cells within buffer_width of the dropped frontier cells</span>
    <span class="org-keyword">for</span> encoded_cell_index <span class="org-keyword">in</span> frontier_cells_dropped:
        (<span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>) <span class="org-operator">=</span> decode_cell_index(encoded_cell_index)
        nbt.dec_square_around(tracked_cells, y, x, buffer_width)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Return updated tracked cells</span>
    <span class="org-keyword">return</span> tracked_cells


<span class="org-type">@cy.cfunc</span>
<span class="org-keyword">def</span> <span class="org-function-name">spread_one_timestep</span>(sim_state    : <span class="org-builtin">dict</span>,
                        spread_inputs: SpreadInputs,
                        fb_opts      : FireBehaviorSettings,
                        max_timestep : cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> <span class="org-builtin">dict</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Spreads the fire for one iteration using the eulerian level-set method, returning an updated `sim_state`.</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack sim_state</span>
    <span class="org-variable-name">start_time</span>      : cy.<span class="org-builtin">float</span>               <span class="org-operator">=</span> sim_state[<span class="org-string">"simulation_time"</span>]
    <span class="org-variable-name">spread_state</span>    : SpreadState            <span class="org-operator">=</span> sim_state[<span class="org-string">"spread_state"</span>]
    <span class="org-variable-name">phi_matrix</span>      : cy.<span class="org-builtin">float</span>[:,::1]        <span class="org-operator">=</span> spread_state.phi
    <span class="org-variable-name">phi_star_matrix</span> : cy.<span class="org-builtin">float</span>[:,::1]        <span class="org-operator">=</span> spread_state.phi_star
    <span class="org-variable-name">frontier_cells</span>  : <span class="org-builtin">set</span>                    <span class="org-operator">=</span> sim_state[<span class="org-string">"frontier_cells"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">TODO: OPTIM Use a binary array instead?</span>
    <span class="org-variable-name">tracked_cells</span>   : nbt.NarrowBandTracker  <span class="org-operator">=</span> sim_state[<span class="org-string">"tracked_cells"</span>]
    <span class="org-variable-name">tca</span>             : TrackedCellsArrays     <span class="org-operator">=</span> sim_state[<span class="org-string">"_tracked_cells_arrays"</span>]
    <span class="org-variable-name">tca_old</span>         : TrackedCellsArrays     <span class="org-operator">=</span> sim_state[<span class="org-string">"_tracked_cells_arrays_old"</span>]
    <span class="org-variable-name">spot_ignitions</span>  : SortedDict[<span class="org-builtin">float</span>, <span class="org-builtin">set</span>] <span class="org-operator">=</span> sim_state[<span class="org-string">"spot_ignitions"</span>]
    <span class="org-variable-name">random_generator</span>: BufferedRandGen        <span class="org-operator">=</span> sim_state[<span class="org-string">"random_generator"</span>]

    <span class="org-comment-delimiter"># </span><span class="org-comment">Insert missing tracked cells</span>
    sync_tracked_cells_arrays(spread_inputs, fb_opts, tracked_cells, tca_old, tca)
    refresh_caches_from_inputs_if_needed(spread_inputs, fb_opts, tca, start_time)
    collect_phi_cache(phi_matrix, tca)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Perform the first Runge-Kutta pass and save the calculated timestep dt</span>
    <span class="org-variable-name">dt</span>       : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> runge_kutta_pass1(fb_opts.max_cells_per_timestep,
                                            spread_inputs.cell_height,
                                            spread_inputs.cell_width,
                                            max_timestep,
                                            tca)
    <span class="org-variable-name">stop_time</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> start_time <span class="org-operator">+</span> dt

    <span class="org-comment-delimiter"># </span><span class="org-comment">Now that dt is known, update phi_star_matrix</span>
    update_phi_star(tca, dt, phi_star_matrix)
    collect_phi_cache(phi_star_matrix, tca)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Perform the second Runge-Kutta pass and save the newly burned cells</span>
    <span class="org-variable-name">burned_cells</span>: <span class="org-builtin">list</span>[BurnedCellInfo] <span class="org-operator">=</span> runge_kutta_pass2(spread_inputs.cell_height,
                                                           spread_inputs.cell_width,
                                                           start_time,
                                                           dt,
                                                           tca,
                                                           phi_matrix)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Compute and save the fire behavior values for all burned cells and store any spot ignitions they create</span>
    process_burned_cells(spread_inputs, fb_opts, spread_state, spot_ignitions, random_generator, burned_cells)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Remove from spot_ignitions and return all cells which ignite before stop_time and set phi_matrix to -1.0 for each</span>
    <span class="org-variable-name">spot_ignited_cells</span>: <span class="org-builtin">list</span>[BurnedCellInfo] <span class="org-operator">=</span> ignite_from_spotting(spot_ignitions, phi_matrix, stop_time)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Compute and save the fire behavior values for all spot-ignited cells and store any spot ignitions they create</span>
    process_burned_cells(spread_inputs, fb_opts, spread_state, spot_ignitions, random_generator, spot_ignited_cells)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Save the new phi_matrix values in phi_star_matrix</span>
    reset_phi_star(tca, spot_ignited_cells, phi_star_matrix, phi_matrix)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Update the sets of frontier cells and tracked cells based on the updated phi matrix</span>
    <span class="org-variable-name">frontier_diff</span>     : <span class="org-builtin">tuple</span>[<span class="org-builtin">set</span>, <span class="org-builtin">set</span>]       <span class="org-operator">=</span> diff_frontier_cells(frontier_cells,
                                                                    burned_cells,
                                                                    spot_ignited_cells,
                                                                    phi_matrix,
                                                                    spread_inputs.fuel_model,
                                                                    <span class="org-builtin">int</span>(stop_time <span class="org-operator">//</span> spread_inputs.band_duration))
    <span class="org-variable-name">frontier_additions</span>: <span class="org-builtin">set</span>                   <span class="org-operator">=</span> frontier_diff[0]
    <span class="org-variable-name">frontier_removals</span> : <span class="org-builtin">set</span>                   <span class="org-operator">=</span> frontier_diff[1]
    <span class="org-variable-name">frontier_cells_new</span>: <span class="org-builtin">set</span>                   <span class="org-operator">=</span> apply_frontier_diff(frontier_cells,
                                                                    frontier_additions,
                                                                    frontier_removals)
    <span class="org-variable-name">tracked_cells_new</span> : nbt.NarrowBandTracker <span class="org-operator">=</span> update_tracked_cells_with_frontier_diff(tracked_cells,
                                                                                        frontier_additions,
                                                                                        frontier_removals,
                                                                                        fb_opts.buffer_width)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Return the updated world state</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: We are intentionally swapping the tracked_cells_arrays</span>
    <span class="org-keyword">return</span> {
        <span class="org-string">"simulation_time"</span>          : stop_time,
        <span class="org-string">"spread_state"</span>             : spread_state,
        <span class="org-string">"frontier_cells"</span>           : frontier_cells_new,
        <span class="org-string">"tracked_cells"</span>            : tracked_cells_new,
        <span class="org-string">"_tracked_cells_arrays"</span>    : tca_old,
        <span class="org-string">"_tracked_cells_arrays_old"</span>: tca,
        <span class="org-string">"spot_ignitions"</span>           : spot_ignitions,
        <span class="org-string">"random_generator"</span>         : random_generator,
    }


<span class="org-type">@cy.cfunc</span>
<span class="org-keyword">def</span> <span class="org-function-name">check_space_time_cubes</span>(space_time_cubes: <span class="org-builtin">dict</span>, spot_config: <span class="org-builtin">dict</span><span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> <span class="org-constant">None</span>) <span class="org-operator">-&gt;</span> cy.void:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Define the provided, required, and optional keys for space_time_cubes</span>
    <span class="org-variable-name">provided_cubes</span>: <span class="org-builtin">set</span> <span class="org-operator">=</span> <span class="org-builtin">set</span>(space_time_cubes.keys())
    <span class="org-variable-name">required_cubes</span>: <span class="org-builtin">set</span> <span class="org-operator">=</span> {
        <span class="org-string">"slope"</span>,
        <span class="org-string">"aspect"</span>,
        <span class="org-string">"fuel_model"</span>,
        <span class="org-string">"canopy_cover"</span>,
        <span class="org-string">"canopy_height"</span>,
        <span class="org-string">"canopy_base_height"</span>,
        <span class="org-string">"canopy_bulk_density"</span>,
        <span class="org-string">"wind_speed_10m"</span>,
        <span class="org-string">"upwind_direction"</span>,
        <span class="org-string">"fuel_moisture_dead_1hr"</span>,
        <span class="org-string">"fuel_moisture_dead_10hr"</span>,
        <span class="org-string">"fuel_moisture_dead_100hr"</span>,
        <span class="org-string">"fuel_moisture_live_herbaceous"</span>,
        <span class="org-string">"fuel_moisture_live_woody"</span>,
        <span class="org-string">"foliar_moisture"</span>,
    } <span class="org-operator">|</span> ({<span class="org-string">"temperature"</span>} <span class="org-keyword">if</span> spot_config <span class="org-keyword">else</span> <span class="org-builtin">set</span>())
    <span class="org-variable-name">optional_cubes</span>: <span class="org-builtin">set</span> <span class="org-operator">=</span> {
        <span class="org-string">"fuel_spread_adjustment"</span>,
        <span class="org-string">"weather_spread_adjustment"</span>,
    } <span class="org-operator">|</span> ({<span class="org-string">"temperature"</span>} <span class="org-keyword">if</span> spot_config <span class="org-keyword">is</span> <span class="org-constant">None</span> <span class="org-keyword">else</span> <span class="org-builtin">set</span>())

    <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that all required_cubes are present in provided_cubes</span>
    <span class="org-keyword">if</span> <span class="org-keyword">not</span> provided_cubes.issuperset(required_cubes):
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The space_time_cubes dictionary is missing these required keys: "</span>
                         <span class="org-operator">+</span> <span class="org-builtin">str</span>(required_cubes.difference(provided_cubes)))

    <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that only required_cubes and optional_cubes are present in provided_cubes</span>
    <span class="org-keyword">if</span> <span class="org-keyword">not</span> (required_cubes <span class="org-operator">|</span> optional_cubes).issuperset(provided_cubes):
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The space_time_cubes dictionary contains these unused keys: "</span>
                         <span class="org-operator">+</span> <span class="org-builtin">str</span>(provided_cubes.difference((required_cubes <span class="org-operator">|</span> optional_cubes))))

    <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that all space_time_cubes values are ISpaceTimeCube objects</span>
    cube: <span class="org-builtin">object</span>
    <span class="org-keyword">for</span> cube <span class="org-keyword">in</span> space_time_cubes.values():
        <span class="org-keyword">if</span> <span class="org-keyword">not</span>(<span class="org-builtin">isinstance</span>(cube, ISpaceTimeCube)):
            <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"All values in the space_time_cubes dictionary must be ISpaceTimeCube "</span>
                             <span class="org-operator">+</span> <span class="org-string">"objects. See pyretechnics.space_time_cube for more information."</span>)


<span class="org-type">@cy.cfunc</span>
<span class="org-keyword">def</span> <span class="org-function-name">check_dimensions_and_resolutions</span>(space_time_cubes: <span class="org-builtin">dict</span>,
                                     spread_state    : SpreadState,
                                     bands           : pyidx,
                                     rows            : pyidx,
                                     cols            : pyidx,
                                     band_duration   : cy.<span class="org-builtin">float</span>,
                                     cell_height     : cy.<span class="org-builtin">float</span>,
                                     cell_width      : cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.void:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that all space_time_cubes have the same cube shape</span>
    cube: ISpaceTimeCube
    <span class="org-keyword">for</span> cube <span class="org-keyword">in</span> space_time_cubes.values():
        <span class="org-keyword">if</span> cube.shape <span class="org-operator">!=</span> (bands, rows, cols):
            <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The space_time_cubes must all share the same cube shape."</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that the space_time_cubes and spread_state have the same cube shape</span>
    <span class="org-keyword">if</span> spread_state.cube_shape <span class="org-operator">!=</span> (bands, rows, cols):
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The space_time_cubes and spread_state must share the same cube shape."</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that all cube resolution values are positive</span>
    <span class="org-keyword">if</span> band_duration <span class="org-operator">&lt;=</span> 0.0 <span class="org-keyword">or</span> cell_height <span class="org-operator">&lt;=</span> 0.0 <span class="org-keyword">or</span> cell_width <span class="org-operator">&lt;=</span> 0.0:
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The cube_resolution tuple may only contain positive values."</span>)


<span class="org-type">@cy.cfunc</span>
<span class="org-keyword">def</span> <span class="org-function-name">check_start_and_stop_times</span>(start_time   : cy.<span class="org-builtin">float</span>,
                               max_stop_time: cy.<span class="org-builtin">float</span>,
                               cube_duration: cy.<span class="org-builtin">float</span>,
                               max_duration : <span class="org-builtin">float</span><span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> <span class="org-constant">None</span>) <span class="org-operator">-&gt;</span> cy.void:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that start_time exists within the temporal bounds of the space_time_cubes</span>
    <span class="org-keyword">if</span> <span class="org-keyword">not</span>(0.0 <span class="org-operator">&lt;=</span> start_time <span class="org-operator">&lt;</span> cube_duration):
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The start_time falls outside of the temporal bounds of the space_time_cubes."</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that max_duration is positive if provided</span>
    <span class="org-keyword">if</span> max_duration <span class="org-keyword">and</span> max_duration <span class="org-operator">&lt;=</span> 0.0:
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The max_duration must be a positive value if provided."</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that the max_stop_time does not exceed the cube_duration</span>
    <span class="org-keyword">if</span> max_stop_time <span class="org-operator">&gt;</span> cube_duration:
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The start_time + max_duration exceeds the temporal bounds of the space_time_cubes."</span>)


<span class="org-type">@cy.ccall</span>
<span class="org-keyword">def</span> <span class="org-function-name">spread_fire_with_phi_field</span>(space_time_cubes      : <span class="org-builtin">dict</span>[<span class="org-builtin">str</span>, ISpaceTimeCube],
                               spread_state          : SpreadState,
                               cube_resolution       : <span class="org-builtin">tuple</span>[cy.<span class="org-builtin">float</span>, cy.<span class="org-builtin">float</span>, cy.<span class="org-builtin">float</span>],
                               start_time            : cy.<span class="org-builtin">float</span>,
                               max_duration          : <span class="org-builtin">float</span><span class="org-operator">|</span><span class="org-constant">None</span>             <span class="org-operator">=</span> <span class="org-constant">None</span>,
                               max_cells_per_timestep: cy.<span class="org-builtin">float</span>               <span class="org-operator">=</span> 0.4,
                               buffer_width          : pyidx                  <span class="org-operator">=</span> 3,
                               use_wind_limit        : cy.bint                <span class="org-operator">=</span> <span class="org-constant">True</span>,
                               surface_lw_ratio_model: <span class="org-builtin">str</span>                    <span class="org-operator">=</span> <span class="org-string">"behave"</span>,
                               crown_max_lw_ratio    : cy.<span class="org-builtin">float</span>               <span class="org-operator">=</span> 1e10,
                               spot_ignitions        : <span class="org-builtin">dict</span>[<span class="org-builtin">float</span>, <span class="org-builtin">set</span>]       <span class="org-operator">=</span> {},
                               spot_config           : <span class="org-builtin">dict</span>[<span class="org-builtin">str</span>, <span class="org-builtin">object</span>]<span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> <span class="org-constant">None</span>,
                               cube_refresh_rates    : <span class="org-builtin">dict</span>[<span class="org-builtin">str</span>, <span class="org-builtin">float</span>]       <span class="org-operator">=</span> {}) <span class="org-operator">-&gt;</span> <span class="org-builtin">dict</span>[<span class="org-builtin">str</span>, <span class="org-builtin">object</span>]:
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - space_time_cubes             :: dictionary of ISpaceTimeCube objects with these cell types</span>
<span class="org-doc">      - slope                         :: rise/run</span>
<span class="org-doc">      - aspect                        :: degrees clockwise from North</span>
<span class="org-doc">      - fuel_model                    :: integer index in fm.fuel_model_table</span>
<span class="org-doc">      - canopy_cover                  :: 0-1</span>
<span class="org-doc">      - canopy_height                 :: m</span>
<span class="org-doc">      - canopy_base_height            :: m</span>
<span class="org-doc">      - canopy_bulk_density           :: kg/m^3</span>
<span class="org-doc">      - temperature                   :: degrees Celsius (Optional: needed for spotting)</span>
<span class="org-doc">      - wind_speed_10m                :: km/hr</span>
<span class="org-doc">      - upwind_direction              :: degrees clockwise from North</span>
<span class="org-doc">      - fuel_moisture_dead_1hr        :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_dead_10hr       :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_dead_100hr      :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_live_herbaceous :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_live_woody      :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - foliar_moisture               :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_spread_adjustment        :: float &gt;= 0.0 (Optional: defaults to 1.0)</span>
<span class="org-doc">      - weather_spread_adjustment     :: float &gt;= 0.0 (Optional: defaults to 1.0)</span>
<span class="org-doc">    - spread_state                 :: SpreadState object whose spatial dimensions match the space_time_cubes</span>
<span class="org-doc">    - cube_resolution              :: tuple with these fields</span>
<span class="org-doc">      - band_duration                 :: minutes</span>
<span class="org-doc">      - cell_height                   :: meters</span>
<span class="org-doc">      - cell_width                    :: meters</span>
<span class="org-doc">    - start_time                   :: minutes (from the start of the space_time_cube's temporal origin)</span>
<span class="org-doc">    - max_duration                 :: minutes (Optional)</span>
<span class="org-doc">    - max_cells_per_timestep       :: max number of cells the fire front can travel in one timestep (Optional)</span>
<span class="org-doc">    - buffer_width                 :: Chebyshev distance from frontier cells to include in tracked cells (Optional)</span>
<span class="org-doc">    - use_wind_limit               :: boolean (Optional)</span>
<span class="org-doc">    - surface_lw_ratio_model       :: "rothermel" or "behave" (Optional)</span>
<span class="org-doc">    - crown_max_lw_ratio           :: float &gt; 0.0 (Optional)</span>
<span class="org-doc">    - spot_ignitions               :: dictionary of (ignition_time -&gt; ignited_cells) (Optional: needed for spotting)</span>
<span class="org-doc">    - spot_config                  :: dictionary of spotting parameters (Optional: needed for spotting)</span>
<span class="org-doc">      - random_seed                   :: seed for a numpy.random.Generator object</span>
<span class="org-doc">      - firebrands_per_unit_heat      :: firebrands/kJ</span>
<span class="org-doc">      - downwind_distance_mean        :: meters</span>
<span class="org-doc">      - fireline_intensity_exponent   :: downwind_distance_mean multiplier [I^fireline_intensity_exponent]</span>
<span class="org-doc">      - wind_speed_exponent           :: downwind_distance_mean multiplier [U^wind_speed_exponent]</span>
<span class="org-doc">      - downwind_variance_mean_ratio  :: meters^2 / meter [downwind_variance_mean_ratio = Var(X) / E(X)]</span>
<span class="org-doc">      - crosswind_distance_stdev      :: meters</span>
<span class="org-doc">      - decay_distance                :: meters</span>
<span class="org-doc">    - cube_refresh_rates           :: dictionary from input name to refresh rate in 1/min (Optional).</span>
<span class="org-doc">                                      0 means never refresh. Weather inputs default to 1/band_duration,</span>
<span class="org-doc">                                      whereas non-weather inputs default to 0.</span>

<span class="org-doc">    return a dictionary with these keys:</span>
<span class="org-doc">    - stop_time         :: minutes</span>
<span class="org-doc">    - stop_condition    :: "max duration reached" or "no burnable cells"</span>
<span class="org-doc">    - spread_state      :: SpreadState object whose spatial dimensions match the space_time_cubes</span>
<span class="org-doc">    - num_tracked_cells :: number of cells in the narrow band at stop_time</span>
<span class="org-doc">    - spot_ignitions    :: dictionary of (ignition_time -&gt; ignited_cells) (only included when spotting is used)</span>
<span class="org-doc">    - random_generator  :: BufferedRandGen object (only included when spotting is used)</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Verify the contents of space_time_cubes</span>
    check_space_time_cubes(space_time_cubes, spot_config)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Extract simulation dimensions</span>
    <span class="org-variable-name">fuel_model_cube</span>: ISpaceTimeCube             <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_model"</span>]
    <span class="org-variable-name">cube_shape</span>     : <span class="org-builtin">tuple</span>[<span class="org-variable-name">pyidx</span>, <span class="org-variable-name">pyidx</span>, <span class="org-variable-name">pyidx</span>] <span class="org-operator">=</span> fuel_model_cube.shape
    <span class="org-variable-name">bands</span>          : pyidx                      <span class="org-operator">=</span> cube_shape[0]
    <span class="org-variable-name">rows</span>           : pyidx                      <span class="org-operator">=</span> cube_shape[1]
    <span class="org-variable-name">cols</span>           : pyidx                      <span class="org-operator">=</span> cube_shape[2]

    <span class="org-comment-delimiter"># </span><span class="org-comment">Extract simulation resolutions</span>
    <span class="org-variable-name">band_duration</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cube_resolution[0]
    <span class="org-variable-name">cell_height</span>  : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cube_resolution[1]
    <span class="org-variable-name">cell_width</span>   : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cube_resolution[2]

    <span class="org-comment-delimiter"># </span><span class="org-comment">Verify the simulation dimensions and resolutions</span>
    check_dimensions_and_resolutions(space_time_cubes,
                                     spread_state,
                                     bands,
                                     rows,
                                     cols,
                                     band_duration,
                                     cell_height,
                                     cell_width)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the cube duration and max stop time</span>
    <span class="org-variable-name">cube_duration</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> bands <span class="org-operator">*</span> band_duration
    <span class="org-variable-name">max_stop_time</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> start_time <span class="org-operator">+</span> max_duration <span class="org-keyword">if</span> max_duration <span class="org-keyword">else</span> cube_duration

    <span class="org-comment-delimiter"># </span><span class="org-comment">Verify simulation start and stop times</span>
    check_start_and_stop_times(start_time, max_stop_time, cube_duration, max_duration)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Identify the sets of frontier cells and tracked cells based on the phi matrix</span>
    <span class="org-variable-name">start_t</span>       : pyidx                 <span class="org-operator">=</span> <span class="org-builtin">int</span>(start_time <span class="org-operator">//</span> band_duration)
    <span class="org-variable-name">frontier_cells</span>: <span class="org-builtin">set</span>                   <span class="org-operator">=</span> identify_all_frontier_cells(spread_state.phi,
                                                                        fuel_model_cube,
                                                                        start_t,
                                                                        rows,
                                                                        cols)
    <span class="org-variable-name">tracked_cells</span> : nbt.NarrowBandTracker <span class="org-operator">=</span> identify_tracked_cells(frontier_cells, buffer_width, rows, cols)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Create a BufferedRandGen object to produce random samples if spot_config is provided</span>
    random_generator: BufferedRandGen<span class="org-operator">|</span><span class="org-constant">None</span> <span class="org-operator">=</span> <span class="org-constant">None</span>
    <span class="org-keyword">if</span> spot_config:
        <span class="org-variable-name">random_generator</span> <span class="org-operator">=</span> BufferedRandGen(np.random.default_rng(seed<span class="org-operator">=</span>spot_config.get(<span class="org-string">"random_seed"</span>)))

    <span class="org-comment-delimiter"># </span><span class="org-comment">Prepare the SpreadInputs struct</span>
    <span class="org-variable-name">spread_inputs</span>: SpreadInputs <span class="org-operator">=</span> make_SpreadInputs(cube_shape, cube_resolution, space_time_cubes)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Prepare the FireBehaviorSettings struct</span>
    <span class="org-variable-name">fb_opts</span>: FireBehaviorSettings <span class="org-operator">=</span> FireBehaviorSettings(
        max_cells_per_timestep <span class="org-operator">=</span> max_cells_per_timestep,
        buffer_width           <span class="org-operator">=</span> buffer_width,
        use_wind_limit         <span class="org-operator">=</span> use_wind_limit,
        surface_lw_ratio_model <span class="org-operator">=</span> surface_lw_ratio_model,
        crown_max_lw_ratio     <span class="org-operator">=</span> crown_max_lw_ratio,
        spot_config            <span class="org-operator">=</span> spot_config,
        cube_refresh_rates     <span class="org-operator">=</span> {<span class="org-operator">**</span>default_cube_refresh_rates(band_duration), <span class="org-operator">**</span>cube_refresh_rates},
    )

    <span class="org-comment-delimiter"># </span><span class="org-comment">Prepare the sim_state dictionary</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: We are intentionally swapping the tracked_cells_arrays.</span>
    <span class="org-comment-delimiter">#       </span><span class="org-comment">It's OK not to be in sync - spread_one_timestep will solve this.</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Turn sim_state into a struct</span>
    <span class="org-variable-name">sim_state</span>: <span class="org-builtin">dict</span> <span class="org-operator">=</span> {
        <span class="org-string">"simulation_time"</span>          : start_time,
        <span class="org-string">"spread_state"</span>             : spread_state,
        <span class="org-string">"frontier_cells"</span>           : frontier_cells,
        <span class="org-string">"tracked_cells"</span>            : tracked_cells,
        <span class="org-string">"_tracked_cells_arrays"</span>    : TrackedCellsArrays(start_time, start_t),
        <span class="org-string">"_tracked_cells_arrays_old"</span>: TrackedCellsArrays(start_time, start_t),
        <span class="org-string">"spot_ignitions"</span>           : SortedDict(spot_ignitions), <span class="org-comment-delimiter"># </span><span class="org-comment">Convert spot_ignitions into a SortedDict</span>
        <span class="org-string">"random_generator"</span>         : random_generator,
    }

    <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: I don't think the "no burnable cells" condition can ever be met currently.</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Spread the fire until an exit condition is reached</span>
    <span class="org-variable-name">remaining_time_in_simulation</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> max_stop_time <span class="org-operator">-</span> start_time
    <span class="org-variable-name">early_exit_threshold</span>        : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> 1.0 <span class="org-operator">/</span> 60.0 <span class="org-comment-delimiter"># </span><span class="org-comment">1 second</span>
    <span class="org-keyword">while</span>((remaining_time_in_simulation <span class="org-operator">&gt;</span> early_exit_threshold)       <span class="org-comment-delimiter"># </span><span class="org-comment">1. There is still time left in the simulation</span>
          <span class="org-keyword">and</span> (nbt.nonempty_tracked_cells(tracked_cells)              <span class="org-comment-delimiter"># </span><span class="org-comment">2. There are burning cells on the grid</span>
               <span class="org-keyword">or</span> <span class="org-builtin">len</span>(sim_state[<span class="org-string">"spot_ignitions"</span>]) <span class="org-operator">&gt;</span> 0)):             <span class="org-comment-delimiter"># </span><span class="org-comment">3. There are embers waiting to catch fire</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Spread fire one timestep</span>
        <span class="org-variable-name">sim_state</span>                    <span class="org-operator">=</span> spread_one_timestep(sim_state,
                                                           spread_inputs,
                                                           fb_opts,
                                                           remaining_time_in_simulation)
        <span class="org-variable-name">remaining_time_in_simulation</span> <span class="org-operator">=</span> max_stop_time <span class="org-operator">-</span> sim_state[<span class="org-string">"simulation_time"</span>]

    <span class="org-comment-delimiter"># </span><span class="org-comment">Determine the stop_condition</span>
    <span class="org-variable-name">stop_condition</span>: <span class="org-builtin">str</span> <span class="org-operator">=</span> (<span class="org-string">"max duration reached"</span>
                           <span class="org-keyword">if</span> remaining_time_in_simulation <span class="org-operator">&lt;=</span> early_exit_threshold
                           <span class="org-keyword">else</span> <span class="org-string">"no burnable cells"</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Return the final simulation results</span>
    <span class="org-keyword">return</span> {
        <span class="org-string">"stop_time"</span>        : sim_state[<span class="org-string">"simulation_time"</span>],
        <span class="org-string">"stop_condition"</span>   : stop_condition,
        <span class="org-string">"spread_state"</span>     : sim_state[<span class="org-string">"spread_state"</span>],
        <span class="org-string">"num_tracked_cells"</span>: tracked_cells.num_tracked_cells,
    } <span class="org-operator">|</span> ({
        <span class="org-string">"spot_ignitions"</span>  : sim_state[<span class="org-string">"spot_ignitions"</span>],
        <span class="org-string">"random_generator"</span>: sim_state[<span class="org-string">"random_generator"</span>],
    } <span class="org-keyword">if</span> spot_config <span class="org-keyword">else</span> {})
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-for-users-fire-spread" class="outline-3">
<h3 id="for-users-fire-spread"><span class="section-number-3">9.2.</span> For Users</h3>
<div class="outline-text-3" id="text-for-users-fire-spread">
</div>

<div id="outline-container-how-to-spread-a-fire-from-a-point-ignition" class="outline-4">
<h4 id="how-to-spread-a-fire-from-a-point-ignition"><span class="section-number-4">9.2.1.</span> How to Spread a Fire from a Point Ignition</h4>
<div class="outline-text-4" id="text-how-to-spread-a-fire-from-a-point-ignition">
</div>

<ol class="org-ol">
<li><a id="configure-and-run-the-fire-spread-simulation"></a>Configure and Run the Fire Spread Simulation<br>
<div class="outline-text-5" id="text-configure-and-run-the-fire-spread-simulation">
<div class="org-src-container">
<pre class="src src-python" id="run-spread-fire-with-phi-field"><span class="org-keyword">import</span> time
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube
<span class="org-keyword">import</span> pyretechnics.eulerian_level_set <span class="org-keyword">as</span> els

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (
    240, <span class="org-comment-delimiter"># </span><span class="org-comment">bands: 10 days @ 1 hour/band</span>
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">rows:  3 km @ 30 meters/row</span>
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">cols:  3 km @ 30 meters/col</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube resolution</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">cube_resolution</span> <span class="org-operator">=</span> (
    60, <span class="org-comment-delimiter"># </span><span class="org-comment">band_duration: minutes</span>
    30, <span class="org-comment-delimiter"># </span><span class="org-comment">cell_height:   meters</span>
    30, <span class="org-comment-delimiter"># </span><span class="org-comment">cell_width:    meters</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Create an input dictionary of SpaceTimeCubes (using constant data for this example)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">space_time_cubes</span> <span class="org-operator">=</span> {
    <span class="org-string">"slope"</span>                        : SpaceTimeCube(cube_shape, 0.8),   <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-string">"aspect"</span>                       : SpaceTimeCube(cube_shape, 225.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_model"</span>                   : SpaceTimeCube(cube_shape, 101),   <span class="org-comment-delimiter"># </span><span class="org-comment">integer index in fm.fuel_model_table</span>
    <span class="org-string">"canopy_cover"</span>                 : SpaceTimeCube(cube_shape, 0.6),   <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
    <span class="org-string">"canopy_height"</span>                : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_base_height"</span>           : SpaceTimeCube(cube_shape, 3.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_bulk_density"</span>          : SpaceTimeCube(cube_shape, 0.3),   <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>
    <span class="org-string">"wind_speed_10m"</span>               : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-string">"upwind_direction"</span>             : SpaceTimeCube(cube_shape, 180.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_moisture_dead_1hr"</span>       : SpaceTimeCube(cube_shape, 0.05),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_10hr"</span>      : SpaceTimeCube(cube_shape, 0.10),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_100hr"</span>     : SpaceTimeCube(cube_shape, 0.15),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_herbaceous"</span>: SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_woody"</span>     : SpaceTimeCube(cube_shape, 0.60),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"foliar_moisture"</span>              : SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_spread_adjustment"</span>       : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
    <span class="org-string">"weather_spread_adjustment"</span>    : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
}

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Create a SpreadState object and specify a point ignition location (y, x)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">spread_state</span> <span class="org-operator">=</span> els.SpreadState(cube_shape).ignite_cell((50,50))

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Set the start time and max duration of the simulation</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Day 2 @ 10:30am</span>
<span class="org-variable-name">start_time</span> <span class="org-operator">=</span> (24 <span class="org-operator">*</span> 60) <span class="org-operator">+</span> (10 <span class="org-operator">*</span> 60) <span class="org-operator">+</span> 30 <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">8 hours</span>
<span class="org-variable-name">max_duration</span> <span class="org-operator">=</span> 8 <span class="org-operator">*</span> 60 <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Spread fire from the start time for the max duration</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">runtime_start</span>       <span class="org-operator">=</span> time.perf_counter()
<span class="org-variable-name">fire_spread_results</span> <span class="org-operator">=</span> els.spread_fire_with_phi_field(space_time_cubes,
                                                     spread_state,
                                                     cube_resolution,
                                                     start_time,
                                                     max_duration,
                                                     surface_lw_ratio_model<span class="org-operator">=</span><span class="org-string">"rothermel"</span>)
<span class="org-variable-name">runtime_stop</span>        <span class="org-operator">=</span> time.perf_counter()
<span class="org-variable-name">stop_time</span>           <span class="org-operator">=</span> fire_spread_results[<span class="org-string">"stop_time"</span>]      <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>
<span class="org-variable-name">stop_condition</span>      <span class="org-operator">=</span> fire_spread_results[<span class="org-string">"stop_condition"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">"max duration reached" or "no burnable cells"</span>
<span class="org-variable-name">spread_state</span>        <span class="org-operator">=</span> fire_spread_results[<span class="org-string">"spread_state"</span>]   <span class="org-comment-delimiter"># </span><span class="org-comment">updated SpreadState object (mutated from inputs)</span>
<span class="org-variable-name">output_matrices</span>     <span class="org-operator">=</span> spread_state.get_full_matrices()

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Print out the acres burned, total runtime, and runtime per burned cell</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">num_burned_cells</span>        <span class="org-operator">=</span> np.count_nonzero(output_matrices[<span class="org-string">"fire_type"</span>]) <span class="org-comment-delimiter"># </span><span class="org-comment">cells</span>
<span class="org-variable-name">acres_burned</span>            <span class="org-operator">=</span> num_burned_cells <span class="org-operator">/</span> 4.5                         <span class="org-comment-delimiter"># </span><span class="org-comment">acres</span>
<span class="org-variable-name">simulation_runtime</span>      <span class="org-operator">=</span> runtime_stop <span class="org-operator">-</span> runtime_start                   <span class="org-comment-delimiter"># </span><span class="org-comment">seconds</span>
<span class="org-variable-name">runtime_per_burned_cell</span> <span class="org-operator">=</span> 1000.0 <span class="org-operator">*</span> simulation_runtime <span class="org-operator">/</span> num_burned_cells <span class="org-comment-delimiter"># </span><span class="org-comment">ms/cell</span>

<span class="org-builtin">print</span>(<span class="org-string">"Acres Burned: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(acres_burned))
<span class="org-builtin">print</span>(<span class="org-string">"Total Runtime: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(simulation_runtime) <span class="org-operator">+</span> <span class="org-string">" seconds"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Runtime Per Burned Cell: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(runtime_per_burned_cell) <span class="org-operator">+</span> <span class="org-string">" ms/cell"</span>)
</pre>
</div>
</div>
</li>

<li><a id="display-summary-statistics-of-the-output-matrices"></a>Display Summary Statistics of the Output Matrices<br>
<div class="outline-text-5" id="text-display-summary-statistics-of-the-output-matrices">
<div class="org-src-container">
<pre class="src src-python" id="run-spread-fire-with-phi-field-stats"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Display summary statistics of our fire spread results</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Used as a filter in get_array_stats below</span>
<span class="org-variable-name">burned_cells</span> <span class="org-operator">=</span> output_matrices[<span class="org-string">"fire_type"</span>] <span class="org-operator">&gt;</span> 0

<span class="org-keyword">def</span> <span class="org-function-name">get_array_stats</span>(array, use_burn_scar_mask<span class="org-operator">=</span><span class="org-constant">True</span>):
    <span class="org-variable-name">array_values_to_analyze</span> <span class="org-operator">=</span> array[burned_cells] <span class="org-keyword">if</span> use_burn_scar_mask <span class="org-keyword">else</span> array
    <span class="org-keyword">if</span> <span class="org-builtin">len</span>(array_values_to_analyze) <span class="org-operator">&gt;</span> 0:
        <span class="org-keyword">return</span> {
            <span class="org-string">"Min"</span>  : np.<span class="org-builtin">min</span>(array_values_to_analyze),
            <span class="org-string">"Max"</span>  : np.<span class="org-builtin">max</span>(array_values_to_analyze),
            <span class="org-string">"Mean"</span> : np.mean(array_values_to_analyze),
            <span class="org-string">"Stdev"</span>: np.std(array_values_to_analyze),
        }
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> {
            <span class="org-string">"Min"</span>  : <span class="org-string">"No Data"</span>,
            <span class="org-string">"Max"</span>  : <span class="org-string">"No Data"</span>,
            <span class="org-string">"Mean"</span> : <span class="org-string">"No Data"</span>,
            <span class="org-string">"Stdev"</span>: <span class="org-string">"No Data"</span>,
        }

<span class="org-builtin">print</span>(<span class="org-string">"Fire Behavior from Day 2 @ 10:30am - Day 2 @ 6:30pm Spreading from Coordinate (50,50)</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 100)

<span class="org-builtin">print</span>(<span class="org-string">"Stop Time: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(stop_time) <span class="org-operator">+</span> <span class="org-string">" (minutes)"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Stop Condition: "</span> <span class="org-operator">+</span> stop_condition)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Phi (phi &lt;= 0: burned, phi &gt; 0: unburned"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"phi"</span>], use_burn_scar_mask<span class="org-operator">=</span><span class="org-constant">False</span>), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Fire Type (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"fire_type"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Spread Rate (m/min)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"spread_rate"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Spread Direction (degrees clockwise from North)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"spread_direction"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Fireline Intensity (kW/m)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"fireline_intensity"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Flame Length (meters)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"flame_length"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Time of Arrival (minutes)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"time_of_arrival"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)
</pre>
</div>

<pre class="example" id="run-spread-fire-with-phi-field-stats-results">
Fire Behavior from Day 2 @ 10:30am - Day 2 @ 6:30pm Spreading from Coordinate (50,50)
====================================================================================================
Stop Time: 2550.0 (minutes)
Stop Condition: max duration reached

Phi (phi &lt;= 0: burned, phi &gt; 0: unburned
{'Min': -0.92554456, 'Max': 1.0, 'Mean': 0.9133916, 'Stdev': 0.3737736}

Fire Type (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)
{'Min': 1, 'Max': 1, 'Mean': 1.0, 'Stdev': 0.0}

Spread Rate (m/min)
{'Min': 0.16077128, 'Max': 2.2963135, 'Mean': 1.1945546, 'Stdev': 0.625517}

Spread Direction (degrees clockwise from North)
{'Min': 1.9940022, 'Max': 359.45844, 'Mean': 195.13614, 'Stdev': 116.97418}

Fireline Intensity (kW/m)
{'Min': 2.2772405, 'Max': 32.526073, 'Mean': 16.920237, 'Stdev': 8.86012}

Flame Length (meters)
{'Min': 0.113121204, 'Max': 0.3843815, 'Mean': 0.2734997, 'Stdev': 0.07289634}

Time of Arrival (minutes)
{'Min': 2081.852, 'Max': 2547.9133, 'Mean': 2385.5022, 'Stdev': 116.77271}
</pre>
</div>
</li>

<li><a id="create-images-of-the-output-matrices"></a>Create Images of the Output Matrices<br>
<div class="outline-text-5" id="text-create-images-of-the-output-matrices">
<div class="org-src-container">
<pre class="src src-python" id="run-spread-fire-with-phi-field-images"><span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np


<span class="org-keyword">def</span> <span class="org-function-name">save_matrix_as_heatmap</span>(matrix, colors, units, title, filename, vmin<span class="org-operator">=</span><span class="org-constant">None</span>, vmax<span class="org-operator">=</span><span class="org-constant">None</span>, ticks<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-variable-name">image</span>    <span class="org-operator">=</span> plt.imshow(matrix, origin<span class="org-operator">=</span><span class="org-string">"lower"</span>, cmap<span class="org-operator">=</span>colors, vmin<span class="org-operator">=</span>vmin, vmax<span class="org-operator">=</span>vmax)
    <span class="org-variable-name">colorbar</span> <span class="org-operator">=</span> plt.colorbar(image, orientation<span class="org-operator">=</span><span class="org-string">"vertical"</span>, ticks<span class="org-operator">=</span>ticks)
    colorbar.set_label(units)
    plt.title(title)
    plt.savefig(filename)
    plt.close(<span class="org-string">"all"</span>)


<span class="org-keyword">def</span> <span class="org-function-name">save_matrix_as_contours</span>(matrix, title, filename, levels<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-variable-name">fig</span>, <span class="org-variable-name">ax</span> <span class="org-operator">=</span> plt.subplots()
    <span class="org-variable-name">cs</span>      <span class="org-operator">=</span> ax.contour(matrix, levels<span class="org-operator">=</span>levels)
    ax.clabel(cs, inline<span class="org-operator">=</span><span class="org-constant">True</span>, fontsize<span class="org-operator">=</span>10)
    ax.set_aspect(<span class="org-string">'equal'</span>, <span class="org-string">'box'</span>)
    ax.set_title(title)
    plt.savefig(filename)
    plt.close(<span class="org-string">"all"</span>)


<span class="org-comment-delimiter"># </span><span class="org-comment">See https://matplotlib.org/stable/gallery/color/colormap_reference.html for the available options for "colors"</span>
<span class="org-variable-name">heatmap_configs</span> <span class="org-operator">=</span> [
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"phi"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"plasma"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"phi &lt;= 0: burned, phi &gt; 0: unburned"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Phi"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_phi.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"fire_type"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"viridis"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"0=unburned, 1=surface, 2=passive_crown, 3=active_crown"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Fire Type"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_fire_type.png"</span>,
        <span class="org-string">"vmin"</span>    : 0,
        <span class="org-string">"vmax"</span>    : 3,
        <span class="org-string">"ticks"</span>   : [0,1,2,3],
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"spread_rate"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"m/min"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Spread Rate"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_spread_rate.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"spread_direction"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"viridis"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"degrees clockwise from North"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Spread Direction"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_spread_direction.png"</span>,
        <span class="org-string">"vmin"</span>    : 0,
        <span class="org-string">"vmax"</span>    : 360,
        <span class="org-string">"ticks"</span>   : [0,45,90,135,180,225,270,315,360]
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"fireline_intensity"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"kW/m"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Fireline Intensity"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_fireline_intensity.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"flame_length"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"meters"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Flame Length"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_flame_length.png"</span>,
    },
]


<span class="org-variable-name">contour_configs</span> <span class="org-operator">=</span> [
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"time_of_arrival"</span>],
        <span class="org-string">"title"</span>   : <span class="org-string">"Time of Arrival"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_time_of_arrival.png"</span>,
        <span class="org-string">"levels"</span>  : <span class="org-builtin">int</span>(start_time) <span class="org-operator">+</span> np.asarray(<span class="org-builtin">range</span>(0, <span class="org-builtin">int</span>(max_duration) <span class="org-operator">+</span> 1, 60)),
    },
]


<span class="org-keyword">for</span> heatmap_config <span class="org-keyword">in</span> heatmap_configs:
    save_matrix_as_heatmap(<span class="org-operator">**</span>heatmap_config)


<span class="org-keyword">for</span> contour_config <span class="org-keyword">in</span> contour_configs:
    save_matrix_as_contours(<span class="org-operator">**</span>contour_config)
</pre>
</div>

<table id="fire-behavior-matplotlib-heatmaps">
<caption class="t-above"><span class="table-number">Table 6:</span> Fire behavior attributes after 8 hours of spread</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="pics/els_phi.png" alt="els_phi.png"></td>
<td class="org-left"><img src="pics/els_fire_type.png" alt="els_fire_type.png"></td>
</tr>

<tr>
<td class="org-left"><img src="pics/els_spread_rate.png" alt="els_spread_rate.png"></td>
<td class="org-left"><img src="pics/els_spread_direction.png" alt="els_spread_direction.png"></td>
</tr>

<tr>
<td class="org-left"><img src="pics/els_fireline_intensity.png" alt="els_fireline_intensity.png"></td>
<td class="org-left"><img src="pics/els_flame_length.png" alt="els_flame_length.png"></td>
</tr>
</tbody>
</table>


<div id="time-of-arrival-matplotlib-countours" class="figure">
<p><img src="pics/els_time_of_arrival.png" alt="els_time_of_arrival.png">
</p>
<p><span class="figure-number">Figure 4: </span>Time of arrival with hourly perimeters</p>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-how-to-spread-a-fire-from-a-point-ignition-with-spotting-enabled" class="outline-4">
<h4 id="how-to-spread-a-fire-from-a-point-ignition-with-spotting-enabled"><span class="section-number-4">9.2.2.</span> How to Spread a Fire from a Point Ignition with Spotting Enabled</h4>
<div class="outline-text-4" id="text-how-to-spread-a-fire-from-a-point-ignition-with-spotting-enabled">
</div>

<ol class="org-ol">
<li><a id="configure-and-run-the-fire-spread-simulation-with-spotting-enabled"></a>Configure and Run the Fire Spread Simulation with Spotting Enabled<br>
<div class="outline-text-5" id="text-configure-and-run-the-fire-spread-simulation-with-spotting-enabled">
<div class="org-src-container">
<pre class="src src-python" id="run-spread-fire-with-phi-field-with-spotting"><span class="org-keyword">import</span> time
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube
<span class="org-keyword">import</span> pyretechnics.eulerian_level_set <span class="org-keyword">as</span> els

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (
    240, <span class="org-comment-delimiter"># </span><span class="org-comment">bands: 10 days @ 1 hour/band</span>
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">rows:  3 km @ 30 meters/row</span>
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">cols:  3 km @ 30 meters/col</span>
)

<span class="org-variable-name">grid_shape</span> <span class="org-operator">=</span> cube_shape[1:]

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube resolution</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">cube_resolution</span> <span class="org-operator">=</span> (
    60, <span class="org-comment-delimiter"># </span><span class="org-comment">band_duration: minutes</span>
    30, <span class="org-comment-delimiter"># </span><span class="org-comment">cell_height:   meters</span>
    30, <span class="org-comment-delimiter"># </span><span class="org-comment">cell_width:    meters</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Create an input dictionary of SpaceTimeCubes (using constant data for this example)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">space_time_cubes</span> <span class="org-operator">=</span> {
    <span class="org-string">"slope"</span>                        : SpaceTimeCube(cube_shape, 0.8),   <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-string">"aspect"</span>                       : SpaceTimeCube(cube_shape, 225.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_model"</span>                   : SpaceTimeCube(cube_shape, 101),   <span class="org-comment-delimiter"># </span><span class="org-comment">integer index in fm.fuel_model_table</span>
    <span class="org-string">"canopy_cover"</span>                 : SpaceTimeCube(cube_shape, 0.6),   <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
    <span class="org-string">"canopy_height"</span>                : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_base_height"</span>           : SpaceTimeCube(cube_shape, 3.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_bulk_density"</span>          : SpaceTimeCube(cube_shape, 0.3),   <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>
    <span class="org-string">"temperature"</span>                  : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">degrees Celsius</span>
    <span class="org-string">"wind_speed_10m"</span>               : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-string">"upwind_direction"</span>             : SpaceTimeCube(cube_shape, 180.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_moisture_dead_1hr"</span>       : SpaceTimeCube(cube_shape, 0.05),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_10hr"</span>      : SpaceTimeCube(cube_shape, 0.10),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_100hr"</span>     : SpaceTimeCube(cube_shape, 0.15),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_herbaceous"</span>: SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_woody"</span>     : SpaceTimeCube(cube_shape, 0.60),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"foliar_moisture"</span>              : SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_spread_adjustment"</span>       : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
    <span class="org-string">"weather_spread_adjustment"</span>    : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
}

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Create a SpreadState object and specify a point ignition location (y, x)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">spread_state</span> <span class="org-operator">=</span> els.SpreadState(cube_shape).ignite_cell((50,50))

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Set the start time and max duration of the simulation</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Day 2 @ 10:30am</span>
<span class="org-variable-name">start_time</span> <span class="org-operator">=</span> (24 <span class="org-operator">*</span> 60) <span class="org-operator">+</span> (10 <span class="org-operator">*</span> 60) <span class="org-operator">+</span> 30 <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">8 hours</span>
<span class="org-variable-name">max_duration</span> <span class="org-operator">=</span> 8 <span class="org-operator">*</span> 60 <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the spotting parameters</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">spot_config</span> <span class="org-operator">=</span> {
    <span class="org-string">"random_seed"</span>                 : 1234567890,
    <span class="org-string">"firebrands_per_unit_heat"</span>    : 1e<span class="org-operator">-</span>6,       <span class="org-comment-delimiter"># </span><span class="org-comment">firebrands/kJ</span>
    <span class="org-string">"downwind_distance_mean"</span>      : 10.0,       <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
    <span class="org-string">"fireline_intensity_exponent"</span> : 0.3,        <span class="org-comment-delimiter"># </span><span class="org-comment">downwind_distance_mean multiplier [I^fireline_intensity_exponent]</span>
    <span class="org-string">"wind_speed_exponent"</span>         : 0.55,       <span class="org-comment-delimiter"># </span><span class="org-comment">downwind_distance_mean multiplier [U^wind_speed_exponent]</span>
    <span class="org-string">"downwind_variance_mean_ratio"</span>: 425.0,      <span class="org-comment-delimiter"># </span><span class="org-comment">meters^2 / meter [downwind_variance_mean_ratio = Var(X) / E(X)]</span>
    <span class="org-string">"crosswind_distance_stdev"</span>    : 100.0,      <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
    <span class="org-string">"decay_distance"</span>              : 200.0,      <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
}

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Spread fire from the start time for the max duration</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">runtime_start</span>       <span class="org-operator">=</span> time.perf_counter()
<span class="org-variable-name">fire_spread_results</span> <span class="org-operator">=</span> els.spread_fire_with_phi_field(space_time_cubes,
                                                     spread_state,
                                                     cube_resolution,
                                                     start_time,
                                                     max_duration,
                                                     surface_lw_ratio_model<span class="org-operator">=</span><span class="org-string">"rothermel"</span>,
                                                     spot_ignitions<span class="org-operator">=</span>{},
                                                     spot_config<span class="org-operator">=</span>spot_config)
<span class="org-variable-name">runtime_stop</span>        <span class="org-operator">=</span> time.perf_counter()
<span class="org-variable-name">stop_time</span>           <span class="org-operator">=</span> fire_spread_results[<span class="org-string">"stop_time"</span>]                  <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>
<span class="org-variable-name">stop_condition</span>      <span class="org-operator">=</span> fire_spread_results[<span class="org-string">"stop_condition"</span>]             <span class="org-comment-delimiter"># </span><span class="org-comment">"max duration reached" or "no burnable cells"</span>
<span class="org-variable-name">spread_state</span>        <span class="org-operator">=</span> fire_spread_results[<span class="org-string">"spread_state"</span>]               <span class="org-comment-delimiter"># </span><span class="org-comment">updated SpreadState object (mutated from inputs)</span>
<span class="org-variable-name">output_matrices</span>     <span class="org-operator">=</span> spread_state.get_full_matrices()
<span class="org-variable-name">spot_ignitions</span>      <span class="org-operator">=</span> fire_spread_results.get(<span class="org-string">"spot_ignitions"</span>, {})     <span class="org-comment-delimiter"># </span><span class="org-comment">remaining firebrands on the landscape</span>
<span class="org-variable-name">random_generator</span>    <span class="org-operator">=</span> fire_spread_results.get(<span class="org-string">"random_generator"</span>, <span class="org-constant">None</span>) <span class="org-comment-delimiter"># </span><span class="org-comment">numpy.random.Generator object</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Print out the acres burned, total runtime, and runtime per burned cell</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">num_burned_cells</span>        <span class="org-operator">=</span> np.count_nonzero(output_matrices[<span class="org-string">"fire_type"</span>]) <span class="org-comment-delimiter"># </span><span class="org-comment">cells</span>
<span class="org-variable-name">acres_burned</span>            <span class="org-operator">=</span> num_burned_cells <span class="org-operator">/</span> 4.5                         <span class="org-comment-delimiter"># </span><span class="org-comment">acres</span>
<span class="org-variable-name">simulation_runtime</span>      <span class="org-operator">=</span> runtime_stop <span class="org-operator">-</span> runtime_start                   <span class="org-comment-delimiter"># </span><span class="org-comment">seconds</span>
<span class="org-variable-name">runtime_per_burned_cell</span> <span class="org-operator">=</span> 1000.0 <span class="org-operator">*</span> simulation_runtime <span class="org-operator">/</span> num_burned_cells <span class="org-comment-delimiter"># </span><span class="org-comment">ms/cell</span>

<span class="org-builtin">print</span>(<span class="org-string">"Acres Burned: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(acres_burned))
<span class="org-builtin">print</span>(<span class="org-string">"Total Runtime: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(simulation_runtime) <span class="org-operator">+</span> <span class="org-string">" seconds"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Runtime per Burned Cell: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(runtime_per_burned_cell) <span class="org-operator">+</span> <span class="org-string">" ms/cell"</span>)
</pre>
</div>
</div>
</li>

<li><a id="display-summary-statistics-of-the-output-matrices-and-spot-ignitions"></a>Display Summary Statistics of the Output Matrices and Spot Ignitions<br>
<div class="outline-text-5" id="text-display-summary-statistics-of-the-output-matrices-and-spot-ignitions">
<div class="org-src-container">
<pre class="src src-python" id="run-spread-fire-with-phi-field-with-spotting-stats"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Display summary statistics of our fire spread results</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Used as a filter in get_array_stats below</span>
<span class="org-variable-name">burned_cells</span> <span class="org-operator">=</span> output_matrices[<span class="org-string">"fire_type"</span>] <span class="org-operator">&gt;</span> 0

<span class="org-keyword">def</span> <span class="org-function-name">get_array_stats</span>(array, use_burn_scar_mask<span class="org-operator">=</span><span class="org-constant">True</span>):
    <span class="org-variable-name">array_values_to_analyze</span> <span class="org-operator">=</span> array[burned_cells] <span class="org-keyword">if</span> use_burn_scar_mask <span class="org-keyword">else</span> array
    <span class="org-keyword">if</span> <span class="org-builtin">len</span>(array_values_to_analyze) <span class="org-operator">&gt;</span> 0:
        <span class="org-keyword">return</span> {
            <span class="org-string">"Min"</span>  : np.<span class="org-builtin">min</span>(array_values_to_analyze),
            <span class="org-string">"Max"</span>  : np.<span class="org-builtin">max</span>(array_values_to_analyze),
            <span class="org-string">"Mean"</span> : np.mean(array_values_to_analyze),
            <span class="org-string">"Stdev"</span>: np.std(array_values_to_analyze),
        }
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> {
            <span class="org-string">"Min"</span>  : <span class="org-string">"No Data"</span>,
            <span class="org-string">"Max"</span>  : <span class="org-string">"No Data"</span>,
            <span class="org-string">"Mean"</span> : <span class="org-string">"No Data"</span>,
            <span class="org-string">"Stdev"</span>: <span class="org-string">"No Data"</span>,
        }

<span class="org-builtin">print</span>(<span class="org-string">"Fire Behavior from Day 2 @ 10:30am - Day 2 @ 6:30pm Spreading from Coordinate (50,50)</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 100)

<span class="org-builtin">print</span>(<span class="org-string">"Stop Time: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(stop_time) <span class="org-operator">+</span> <span class="org-string">" (minutes)"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Stop Condition: "</span> <span class="org-operator">+</span> stop_condition)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Phi (phi &lt;= 0: burned, phi &gt; 0: unburned"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"phi"</span>], use_burn_scar_mask<span class="org-operator">=</span><span class="org-constant">False</span>), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Fire Type (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"fire_type"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Spread Rate (m/min)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"spread_rate"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Spread Direction (degrees clockwise from North)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"spread_direction"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Fireline Intensity (kW/m)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"fireline_intensity"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Flame Length (meters)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"flame_length"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Time of Arrival (minutes)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"time_of_arrival"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Future Spot Ignitions:"</span>)
pprint(<span class="org-builtin">dict</span>(spot_ignitions))
</pre>
</div>

<pre class="example" id="run-spread-fire-with-phi-field-with-spotting-stats-results">
Fire Behavior from Day 2 @ 10:30am - Day 2 @ 6:30pm Spreading from Coordinate (50,50)
====================================================================================================
Stop Time: 2550.0 (minutes)
Stop Condition: max duration reached

Phi (phi &lt;= 0: burned, phi &gt; 0: unburned
{'Min': -1.0, 'Max': 1.0, 'Mean': 0.73481274, 'Stdev': 0.6118095}

Fire Type (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)
{'Min': 1, 'Max': 1, 'Mean': 1.0, 'Stdev': 0.0}

Spread Rate (m/min)
{'Min': 0.16055909, 'Max': 2.2964687, 'Mean': 1.4940217, 'Stdev': 0.68819606}

Spread Direction (degrees clockwise from North)
{'Min': 0.6275849, 'Max': 359.89905, 'Mean': 164.18701, 'Stdev': 127.15898}

Fireline Intensity (kW/m)
{'Min': 2.274235, 'Max': 32.52827, 'Mean': 21.162033, 'Stdev': 9.747935}

Flame Length (meters)
{'Min': 0.1130525, 'Max': 0.38439345, 'Mean': 0.30407032, 'Stdev': 0.07810408}

Time of Arrival (minutes)
{'Min': 2081.852, 'Max': 2549.9265, 'Mean': 2407.1692, 'Stdev': 102.33414}

Future Spot Ignitions:
{2550.45703125: {(95, 47)},
 2550.852294921875: {(87, 37)},
 2550.93896484375: {(92, 41)},
 2551.01171875: {(65, 75)},
 2551.0771484375: {(68, 28)},
 2551.452880859375: {(66, 75)},
 2551.677001953125: {(81, 36)},
 2552.345947265625: {(81, 74)},
 2552.68212890625: {(81, 35)},
 2553.10205078125: {(94, 50)},
 2553.343994140625: {(97, 55)},
 2554.3759765625: {(87, 59)},
 2554.402099609375: {(87, 58)},
 2554.9951171875: {(80, 68)},
 2556.635498046875: {(78, 32)},
 2558.4677734375: {(92, 38)},
 2558.884521484375: {(83, 40)},
 2559.06396484375: {(47, 49)},
 2559.979736328125: {(60, 79)},
 2561.0: {(81, 65)},
 2561.268798828125: {(86, 58)},
 2563.274658203125: {(81, 74)},
 2565.331298828125: {(66, 79)},
 2565.522705078125: {(84, 71)},
 2566.02490234375: {(69, 78)},
 2566.51025390625: {(87, 52), (89, 52)},
 2567.084228515625: {(86, 65)},
 2567.610107421875: {(81, 75)},
 2567.80810546875: {(88, 38), (96, 44), (89, 34)},
 2568.060302734375: {(89, 44)},
 2569.0361328125: {(60, 72)},
 2569.083740234375: {(91, 44)},
 2570.712890625: {(91, 44)},
 2572.74169921875: {(51, 43)},
 2574.04443359375: {(94, 49)},
 2574.22802734375: {(85, 68)},
 2574.310302734375: {(94, 50)},
 2574.4716796875: {(65, 77), (68, 78)},
 2574.9755859375: {(73, 80)},
 2575.160888671875: {(85, 66), (69, 77)},
 2575.209228515625: {(95, 46)},
 2575.345703125: {(87, 50)},
 2575.988525390625: {(67, 25), (68, 22)},
 2577.4248046875: {(91, 49)},
 2577.693603515625: {(81, 36)},
 2578.118408203125: {(92, 60)},
 2578.92041015625: {(88, 46)},
 2580.1201171875: {(89, 70)},
 2580.56787109375: {(91, 55)},
 2580.878173828125: {(86, 68), (85, 70)},
 2580.94140625: {(85, 65)},
 2582.059326171875: {(86, 65)},
 2582.513916015625: {(58, 76)},
 2582.754150390625: {(86, 64)},
 2582.821044921875: {(64, 76)},
 2583.43505859375: {(97, 64), (98, 57)},
 2583.483642578125: {(82, 76)},
 2586.32666015625: {(69, 80)},
 2588.114013671875: {(88, 38)},
 2593.70849609375: {(65, 83), (64, 82)},
 2602.1689453125: {(70, 34)},
 2607.730224609375: {(76, 38)}}
</pre>
</div>
</li>

<li><a id="create-images-of-the-output-matrices-with-spotting-enabled"></a>Create Images of the Output Matrices with Spotting Enabled<br>
<div class="outline-text-5" id="text-create-images-of-the-output-matrices-with-spotting-enabled">
<div class="org-src-container">
<pre class="src src-python" id="run-spread-fire-with-phi-field-with-spotting-images"><span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np


<span class="org-keyword">def</span> <span class="org-function-name">save_matrix_as_heatmap</span>(matrix, colors, units, title, filename, vmin<span class="org-operator">=</span><span class="org-constant">None</span>, vmax<span class="org-operator">=</span><span class="org-constant">None</span>, ticks<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-variable-name">image</span>    <span class="org-operator">=</span> plt.imshow(matrix, origin<span class="org-operator">=</span><span class="org-string">"lower"</span>, cmap<span class="org-operator">=</span>colors, vmin<span class="org-operator">=</span>vmin, vmax<span class="org-operator">=</span>vmax)
    <span class="org-variable-name">colorbar</span> <span class="org-operator">=</span> plt.colorbar(image, orientation<span class="org-operator">=</span><span class="org-string">"vertical"</span>, ticks<span class="org-operator">=</span>ticks)
    colorbar.set_label(units)
    plt.title(title)
    plt.savefig(filename)
    plt.close(<span class="org-string">"all"</span>)


<span class="org-keyword">def</span> <span class="org-function-name">save_matrix_as_contours</span>(matrix, title, filename, levels<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-variable-name">fig</span>, <span class="org-variable-name">ax</span> <span class="org-operator">=</span> plt.subplots()
    <span class="org-variable-name">cs</span>      <span class="org-operator">=</span> ax.contour(matrix, levels<span class="org-operator">=</span>levels)
    ax.clabel(cs, inline<span class="org-operator">=</span><span class="org-constant">True</span>, fontsize<span class="org-operator">=</span>10)
    ax.set_aspect(<span class="org-string">'equal'</span>, <span class="org-string">'box'</span>)
    ax.set_title(title)
    plt.savefig(filename)
    plt.close(<span class="org-string">"all"</span>)


<span class="org-comment-delimiter"># </span><span class="org-comment">See https://matplotlib.org/stable/gallery/color/colormap_reference.html for the available options for "colors"</span>
<span class="org-variable-name">heatmap_configs</span> <span class="org-operator">=</span> [
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"phi"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"plasma"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"phi &lt;= 0: burned, phi &gt; 0: unburned"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Phi"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_spot_phi.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"fire_type"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"viridis"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"0=unburned, 1=surface, 2=passive_crown, 3=active_crown"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Fire Type"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_spot_fire_type.png"</span>,
        <span class="org-string">"vmin"</span>    : 0,
        <span class="org-string">"vmax"</span>    : 3,
        <span class="org-string">"ticks"</span>   : [0,1,2,3],
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"spread_rate"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"m/min"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Spread Rate"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_spot_spread_rate.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"spread_direction"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"viridis"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"degrees clockwise from North"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Spread Direction"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_spot_spread_direction.png"</span>,
        <span class="org-string">"vmin"</span>    : 0,
        <span class="org-string">"vmax"</span>    : 360,
        <span class="org-string">"ticks"</span>   : [0,45,90,135,180,225,270,315,360]
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"fireline_intensity"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"kW/m"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Fireline Intensity"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_spot_fireline_intensity.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"flame_length"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"meters"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Flame Length"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_spot_flame_length.png"</span>,
    },
]


<span class="org-variable-name">contour_configs</span> <span class="org-operator">=</span> [
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"time_of_arrival"</span>],
        <span class="org-string">"title"</span>   : <span class="org-string">"Time of Arrival"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_spot_time_of_arrival.png"</span>,
        <span class="org-string">"levels"</span>  : <span class="org-builtin">int</span>(start_time) <span class="org-operator">+</span> np.asarray(<span class="org-builtin">range</span>(0, <span class="org-builtin">int</span>(max_duration) <span class="org-operator">+</span> 1, 60)),
    },
]


<span class="org-keyword">for</span> heatmap_config <span class="org-keyword">in</span> heatmap_configs:
    save_matrix_as_heatmap(<span class="org-operator">**</span>heatmap_config)


<span class="org-keyword">for</span> contour_config <span class="org-keyword">in</span> contour_configs:
    save_matrix_as_contours(<span class="org-operator">**</span>contour_config)
</pre>
</div>

<table id="spot-fire-behavior-matplotlib-heatmaps">
<caption class="t-above"><span class="table-number">Table 7:</span> Fire behavior attributes after 8 hours of spread with spotting enabled</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="pics/els_spot_phi.png" alt="els_spot_phi.png"></td>
<td class="org-left"><img src="pics/els_spot_fire_type.png" alt="els_spot_fire_type.png"></td>
</tr>

<tr>
<td class="org-left"><img src="pics/els_spot_spread_rate.png" alt="els_spot_spread_rate.png"></td>
<td class="org-left"><img src="pics/els_spot_spread_direction.png" alt="els_spot_spread_direction.png"></td>
</tr>

<tr>
<td class="org-left"><img src="pics/els_spot_fireline_intensity.png" alt="els_spot_fireline_intensity.png"></td>
<td class="org-left"><img src="pics/els_spot_flame_length.png" alt="els_spot_flame_length.png"></td>
</tr>
</tbody>
</table>


<div id="spot-time-of-arrival-matplotlib-countours" class="figure">
<p><img src="pics/els_spot_time_of_arrival.png" alt="els_spot_time_of_arrival.png">
</p>
<p><span class="figure-number">Figure 5: </span>Time of arrival with hourly perimeters with spotting enabled</p>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-how-to-spread-a-fire,-pause,-fork,-and-continue" class="outline-4">
<h4 id="how-to-spread-a-fire,-pause,-fork,-and-continue"><span class="section-number-4">9.2.3.</span> How to Spread a Fire, Pause, Fork, and Continue</h4>
<div class="outline-text-4" id="text-how-to-spread-a-fire,-pause,-fork,-and-continue">
</div>

<ol class="org-ol">
<li><a id="configure-and-run-the-initial-fire-spread-simulation"></a>Configure and Run the Initial Fire Spread Simulation<br>
<div class="outline-text-5" id="text-configure-and-run-the-initial-fire-spread-simulation">
<div class="org-src-container">
<pre class="src src-python" id="run-spread-fire-with-phi-field-initial"><span class="org-keyword">import</span> time
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube
<span class="org-keyword">import</span> pyretechnics.eulerian_level_set <span class="org-keyword">as</span> els

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (
    240, <span class="org-comment-delimiter"># </span><span class="org-comment">bands: 10 days @ 1 hour/band</span>
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">rows:  3 km @ 30 meters/row</span>
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">cols:  3 km @ 30 meters/col</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube resolution</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">cube_resolution</span> <span class="org-operator">=</span> (
    60, <span class="org-comment-delimiter"># </span><span class="org-comment">band_duration: minutes</span>
    30, <span class="org-comment-delimiter"># </span><span class="org-comment">cell_height:   meters</span>
    30, <span class="org-comment-delimiter"># </span><span class="org-comment">cell_width:    meters</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Create an input dictionary of SpaceTimeCubes (using constant data for this example)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">space_time_cubes</span> <span class="org-operator">=</span> {
    <span class="org-string">"slope"</span>                        : SpaceTimeCube(cube_shape, 0.8),   <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-string">"aspect"</span>                       : SpaceTimeCube(cube_shape, 225.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_model"</span>                   : SpaceTimeCube(cube_shape, 101),   <span class="org-comment-delimiter"># </span><span class="org-comment">integer index in fm.fuel_model_table</span>
    <span class="org-string">"canopy_cover"</span>                 : SpaceTimeCube(cube_shape, 0.6),   <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
    <span class="org-string">"canopy_height"</span>                : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_base_height"</span>           : SpaceTimeCube(cube_shape, 3.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_bulk_density"</span>          : SpaceTimeCube(cube_shape, 0.3),   <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>
    <span class="org-string">"wind_speed_10m"</span>               : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-string">"upwind_direction"</span>             : SpaceTimeCube(cube_shape, 180.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_moisture_dead_1hr"</span>       : SpaceTimeCube(cube_shape, 0.05),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_10hr"</span>      : SpaceTimeCube(cube_shape, 0.10),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_100hr"</span>     : SpaceTimeCube(cube_shape, 0.15),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_herbaceous"</span>: SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_woody"</span>     : SpaceTimeCube(cube_shape, 0.60),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"foliar_moisture"</span>              : SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_spread_adjustment"</span>       : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
    <span class="org-string">"weather_spread_adjustment"</span>    : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
}

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Create a SpreadState object and specify a point ignition location (y, x)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">spread_state</span> <span class="org-operator">=</span> els.SpreadState(cube_shape).ignite_cell((50,50))

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Set the start time and max duration of the simulation</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Day 2 @ 10:30am</span>
<span class="org-variable-name">start_time</span> <span class="org-operator">=</span> (24 <span class="org-operator">*</span> 60) <span class="org-operator">+</span> (10 <span class="org-operator">*</span> 60) <span class="org-operator">+</span> 30 <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">8 hours</span>
<span class="org-variable-name">max_duration</span> <span class="org-operator">=</span> 8 <span class="org-operator">*</span> 60 <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Spread fire from the start time for the max duration</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">runtime_start</span>         <span class="org-operator">=</span> time.perf_counter()
<span class="org-variable-name">fire_spread_results_8</span> <span class="org-operator">=</span> els.spread_fire_with_phi_field(space_time_cubes,
                                                       spread_state,
                                                       cube_resolution,
                                                       start_time,
                                                       max_duration,
                                                       surface_lw_ratio_model<span class="org-operator">=</span><span class="org-string">"rothermel"</span>)
<span class="org-variable-name">runtime_stop</span>          <span class="org-operator">=</span> time.perf_counter()
<span class="org-variable-name">stop_time</span>             <span class="org-operator">=</span> fire_spread_results_8[<span class="org-string">"stop_time"</span>]      <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>
<span class="org-variable-name">stop_condition</span>        <span class="org-operator">=</span> fire_spread_results_8[<span class="org-string">"stop_condition"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">"max duration reached" or "no burnable cells"</span>
<span class="org-variable-name">spread_state</span>          <span class="org-operator">=</span> fire_spread_results_8[<span class="org-string">"spread_state"</span>]   <span class="org-comment-delimiter"># </span><span class="org-comment">updated SpreadState object (mutated from inputs)</span>
<span class="org-variable-name">output_matrices</span>       <span class="org-operator">=</span> spread_state.get_full_matrices()

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Print out the acres burned, total runtime, and runtime per burned cell</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">num_burned_cells</span>        <span class="org-operator">=</span> np.count_nonzero(output_matrices[<span class="org-string">"fire_type"</span>]) <span class="org-comment-delimiter"># </span><span class="org-comment">cells</span>
<span class="org-variable-name">acres_burned</span>            <span class="org-operator">=</span> num_burned_cells <span class="org-operator">/</span> 4.5                         <span class="org-comment-delimiter"># </span><span class="org-comment">acres</span>
<span class="org-variable-name">simulation_runtime</span>      <span class="org-operator">=</span> runtime_stop <span class="org-operator">-</span> runtime_start                   <span class="org-comment-delimiter"># </span><span class="org-comment">seconds</span>
<span class="org-variable-name">runtime_per_burned_cell</span> <span class="org-operator">=</span> 1000.0 <span class="org-operator">*</span> simulation_runtime <span class="org-operator">/</span> num_burned_cells <span class="org-comment-delimiter"># </span><span class="org-comment">ms/cell</span>

<span class="org-builtin">print</span>(<span class="org-string">"Acres Burned: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(acres_burned))
<span class="org-builtin">print</span>(<span class="org-string">"Total Runtime: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(simulation_runtime) <span class="org-operator">+</span> <span class="org-string">" seconds"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Runtime per Burned Cell: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(runtime_per_burned_cell) <span class="org-operator">+</span> <span class="org-string">" ms/cell"</span>)
</pre>
</div>
</div>
</li>

<li><a id="fork-and-run-two-fire-spread-scenarios"></a>Fork and Run Two Fire Spread Scenarios<br>
<div class="outline-text-5" id="text-fork-and-run-two-fire-spread-scenarios">
<div class="org-src-container">
<pre class="src src-python" id="run-spread-fire-with-phi-field-forked"><span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Fork the simulation by creating a copy of the space_time_cubes and spread_state</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">space_time_cubes_fork</span> <span class="org-operator">=</span> space_time_cubes.copy() <span class="org-comment-delimiter"># </span><span class="org-comment">shallow copy</span>
<span class="org-variable-name">spread_state_fork</span>     <span class="org-operator">=</span> spread_state.copy()     <span class="org-comment-delimiter"># </span><span class="org-comment">deep copy</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Add a non-burnable fire-break to the forked space_time_cubes fuel model</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Extract 2D array of fuel_model values at the cube's spatial dimensions (100 x 100)</span>
<span class="org-variable-name">fuel_model_grid_ro</span> <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_model"</span>].getSpatialPlane(0, <span class="org-constant">None</span>, <span class="org-constant">None</span>) <span class="org-comment-delimiter"># </span><span class="org-comment">read-only</span>
<span class="org-variable-name">fuel_model_grid</span>    <span class="org-operator">=</span> np.copy(fuel_model_grid_ro)                                   <span class="org-comment-delimiter"># </span><span class="org-comment">writable</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Add a non-burnable fire-break in the northeastern corner of the grid</span>
(<span class="org-variable-name">ys</span>, <span class="org-variable-name">xs</span>) <span class="org-operator">=</span> np.diag_indices(40)
fuel_model_grid[60:,60:][(<span class="org-builtin">list</span>(<span class="org-builtin">reversed</span>(ys)), xs)] <span class="org-operator">=</span> 91 <span class="org-comment-delimiter"># </span><span class="org-comment">NB1</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Replace the old fuel_model cube with a new fire-break-containing cube</span>
<span class="org-variable-name">space_time_cubes_fork</span>[<span class="org-string">"fuel_model"</span>] <span class="org-operator">=</span> SpaceTimeCube(cube_shape, fuel_model_grid)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Run both simulations for another 4 hours</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Day 2 @ 6:30pm</span>
<span class="org-variable-name">new_start_time</span> <span class="org-operator">=</span> stop_time <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">4 hours</span>
<span class="org-variable-name">new_max_duration</span> <span class="org-operator">=</span> 4 <span class="org-operator">*</span> 60 <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Spread the main simulation</span>
<span class="org-variable-name">runtime_start_main</span>     <span class="org-operator">=</span> time.perf_counter()
<span class="org-variable-name">fire_spread_results_12</span> <span class="org-operator">=</span> els.spread_fire_with_phi_field(space_time_cubes,
                                                        spread_state,
                                                        cube_resolution,
                                                        new_start_time,
                                                        new_max_duration,
                                                        surface_lw_ratio_model<span class="org-operator">=</span><span class="org-string">"rothermel"</span>)
<span class="org-variable-name">runtime_stop_main</span>      <span class="org-operator">=</span> time.perf_counter()
<span class="org-variable-name">stop_time</span>              <span class="org-operator">=</span> fire_spread_results_12[<span class="org-string">"stop_time"</span>]      <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>
<span class="org-variable-name">stop_condition</span>         <span class="org-operator">=</span> fire_spread_results_12[<span class="org-string">"stop_condition"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">"max duration reached" or "no burnable cells"</span>
<span class="org-variable-name">spread_state</span>           <span class="org-operator">=</span> fire_spread_results_12[<span class="org-string">"spread_state"</span>]   <span class="org-comment-delimiter"># </span><span class="org-comment">updated SpreadState object (mutated from inputs)</span>
<span class="org-variable-name">output_matrices</span>        <span class="org-operator">=</span> spread_state.get_full_matrices()

<span class="org-comment-delimiter"># </span><span class="org-comment">Spread the forked simulation</span>
<span class="org-variable-name">runtime_start_fork</span>          <span class="org-operator">=</span> time.perf_counter()
<span class="org-variable-name">fire_spread_results_12_fork</span> <span class="org-operator">=</span> els.spread_fire_with_phi_field(space_time_cubes_fork,
                                                             spread_state_fork,
                                                             cube_resolution,
                                                             new_start_time,
                                                             new_max_duration,
                                                             surface_lw_ratio_model<span class="org-operator">=</span><span class="org-string">"rothermel"</span>)
<span class="org-variable-name">runtime_stop_fork</span>           <span class="org-operator">=</span> time.perf_counter()
<span class="org-variable-name">stop_time_fork</span>              <span class="org-operator">=</span> fire_spread_results_12_fork[<span class="org-string">"stop_time"</span>]      <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>
<span class="org-variable-name">stop_condition_fork</span>         <span class="org-operator">=</span> fire_spread_results_12_fork[<span class="org-string">"stop_condition"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">"max duration reached" or "no burnable cells"</span>
<span class="org-variable-name">spread_state_fork</span>           <span class="org-operator">=</span> fire_spread_results_12_fork[<span class="org-string">"spread_state"</span>]   <span class="org-comment-delimiter"># </span><span class="org-comment">updated SpreadState object (mutated from inputs)</span>
<span class="org-variable-name">output_matrices_fork</span>        <span class="org-operator">=</span> spread_state_fork.get_full_matrices()

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Print out the acres burned, total runtime, and runtime per burned cell for the main run</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">num_burned_cells</span>         <span class="org-operator">=</span> np.count_nonzero(output_matrices[<span class="org-string">"fire_type"</span>])       <span class="org-comment-delimiter"># </span><span class="org-comment">cells</span>
<span class="org-variable-name">acres_burned</span>             <span class="org-operator">=</span> num_burned_cells <span class="org-operator">/</span> 4.5                               <span class="org-comment-delimiter"># </span><span class="org-comment">acres</span>
<span class="org-variable-name">simulation_runtime_main</span>  <span class="org-operator">=</span> runtime_stop_main <span class="org-operator">-</span> runtime_start_main               <span class="org-comment-delimiter"># </span><span class="org-comment">seconds</span>
<span class="org-variable-name">simulation_runtime_total</span> <span class="org-operator">=</span> simulation_runtime <span class="org-operator">+</span> simulation_runtime_main         <span class="org-comment-delimiter"># </span><span class="org-comment">seconds</span>
<span class="org-variable-name">runtime_per_burned_cell</span>  <span class="org-operator">=</span> 1000.0 <span class="org-operator">*</span> simulation_runtime_total <span class="org-operator">/</span> num_burned_cells <span class="org-comment-delimiter"># </span><span class="org-comment">ms/cell</span>

<span class="org-builtin">print</span>(<span class="org-string">"Main Fire</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)
<span class="org-builtin">print</span>(<span class="org-string">"Acres Burned: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(acres_burned))
<span class="org-builtin">print</span>(<span class="org-string">"Total Runtime: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(simulation_runtime_total) <span class="org-operator">+</span> <span class="org-string">" seconds"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Runtime per Burned Cell: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(runtime_per_burned_cell) <span class="org-operator">+</span> <span class="org-string">" ms/cell"</span>)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Print out the acres burned, total runtime, and runtime per burned cell for the forked run</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">num_burned_cells</span>         <span class="org-operator">=</span> np.count_nonzero(output_matrices_fork[<span class="org-string">"fire_type"</span>])  <span class="org-comment-delimiter"># </span><span class="org-comment">cells</span>
<span class="org-variable-name">acres_burned</span>             <span class="org-operator">=</span> num_burned_cells <span class="org-operator">/</span> 4.5                               <span class="org-comment-delimiter"># </span><span class="org-comment">acres</span>
<span class="org-variable-name">simulation_runtime_fork</span>  <span class="org-operator">=</span> runtime_stop_fork <span class="org-operator">-</span> runtime_start_fork               <span class="org-comment-delimiter"># </span><span class="org-comment">seconds</span>
<span class="org-variable-name">simulation_runtime_total</span> <span class="org-operator">=</span> simulation_runtime <span class="org-operator">+</span> simulation_runtime_fork         <span class="org-comment-delimiter"># </span><span class="org-comment">seconds</span>
<span class="org-variable-name">runtime_per_burned_cell</span>  <span class="org-operator">=</span> 1000.0 <span class="org-operator">*</span> simulation_runtime_total <span class="org-operator">/</span> num_burned_cells <span class="org-comment-delimiter"># </span><span class="org-comment">ms/cell</span>

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Forked Fire</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)
<span class="org-builtin">print</span>(<span class="org-string">"Acres Burned: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(acres_burned))
<span class="org-builtin">print</span>(<span class="org-string">"Total Runtime: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(simulation_runtime_total) <span class="org-operator">+</span> <span class="org-string">" seconds"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Runtime per Burned Cell: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(runtime_per_burned_cell) <span class="org-operator">+</span> <span class="org-string">" ms/cell"</span>)
</pre>
</div>
</div>
</li>

<li><a id="display-summary-statistics-of-the-two-scenarios'-outputs"></a>Display Summary Statistics of the Two Scenarios' Outputs<br>
<div class="outline-text-5" id="text-display-summary-statistics-of-the-two-scenarios'-outputs">
<div class="org-src-container">
<pre class="src src-python" id="run-spread-fire-with-phi-field-stats-forked"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Display summary statistics of our fire spread results</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Used as filters in get_array_stats and get_array_stats_fork below</span>
<span class="org-variable-name">burned_cells</span>      <span class="org-operator">=</span> output_matrices[<span class="org-string">"fire_type"</span>] <span class="org-operator">&gt;</span> 0
<span class="org-variable-name">burned_cells_fork</span> <span class="org-operator">=</span> output_matrices_fork[<span class="org-string">"fire_type"</span>] <span class="org-operator">&gt;</span> 0

<span class="org-keyword">def</span> <span class="org-function-name">get_array_stats</span>(array, use_burn_scar_mask<span class="org-operator">=</span><span class="org-constant">True</span>):
    <span class="org-variable-name">array_values_to_analyze</span> <span class="org-operator">=</span> array[burned_cells] <span class="org-keyword">if</span> use_burn_scar_mask <span class="org-keyword">else</span> array
    <span class="org-keyword">if</span> <span class="org-builtin">len</span>(array_values_to_analyze) <span class="org-operator">&gt;</span> 0:
        <span class="org-keyword">return</span> {
            <span class="org-string">"Min"</span>  : np.<span class="org-builtin">min</span>(array_values_to_analyze),
            <span class="org-string">"Max"</span>  : np.<span class="org-builtin">max</span>(array_values_to_analyze),
            <span class="org-string">"Mean"</span> : np.mean(array_values_to_analyze),
            <span class="org-string">"Stdev"</span>: np.std(array_values_to_analyze),
        }
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> {
            <span class="org-string">"Min"</span>  : <span class="org-string">"No Data"</span>,
            <span class="org-string">"Max"</span>  : <span class="org-string">"No Data"</span>,
            <span class="org-string">"Mean"</span> : <span class="org-string">"No Data"</span>,
            <span class="org-string">"Stdev"</span>: <span class="org-string">"No Data"</span>,
        }

<span class="org-keyword">def</span> <span class="org-function-name">get_array_stats_fork</span>(array, use_burn_scar_mask<span class="org-operator">=</span><span class="org-constant">True</span>):
    <span class="org-variable-name">array_values_to_analyze</span> <span class="org-operator">=</span> array[burned_cells_fork] <span class="org-keyword">if</span> use_burn_scar_mask <span class="org-keyword">else</span> array
    <span class="org-keyword">if</span> <span class="org-builtin">len</span>(array_values_to_analyze) <span class="org-operator">&gt;</span> 0:
        <span class="org-keyword">return</span> {
            <span class="org-string">"Min"</span>  : np.<span class="org-builtin">min</span>(array_values_to_analyze),
            <span class="org-string">"Max"</span>  : np.<span class="org-builtin">max</span>(array_values_to_analyze),
            <span class="org-string">"Mean"</span> : np.mean(array_values_to_analyze),
            <span class="org-string">"Stdev"</span>: np.std(array_values_to_analyze),
        }
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> {
            <span class="org-string">"Min"</span>  : <span class="org-string">"No Data"</span>,
            <span class="org-string">"Max"</span>  : <span class="org-string">"No Data"</span>,
            <span class="org-string">"Mean"</span> : <span class="org-string">"No Data"</span>,
            <span class="org-string">"Stdev"</span>: <span class="org-string">"No Data"</span>,
        }

<span class="org-builtin">print</span>(<span class="org-string">"Fire Behavior from Day 2 @ 10:30am - Day 2 @ 10:30pm Spreading from Coordinate (50,50)</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 100)

<span class="org-builtin">print</span>(<span class="org-string">"Stop Time (Main): "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(stop_time) <span class="org-operator">+</span> <span class="org-string">" (minutes)"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Stop Time (Fork): "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(stop_time_fork) <span class="org-operator">+</span> <span class="org-string">" (minutes)"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Stop Condition (Main): "</span> <span class="org-operator">+</span> stop_condition)
<span class="org-builtin">print</span>(<span class="org-string">"Stop Condition (Fork): "</span> <span class="org-operator">+</span> stop_condition_fork)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Phi (phi &lt;= 0: burned, phi &gt; 0: unburned"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Main: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"phi"</span>], use_burn_scar_mask<span class="org-operator">=</span><span class="org-constant">False</span>), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Fork: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats_fork(output_matrices_fork[<span class="org-string">"phi"</span>], use_burn_scar_mask<span class="org-operator">=</span><span class="org-constant">False</span>), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Fire Type (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Main: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"fire_type"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Fork: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats_fork(output_matrices_fork[<span class="org-string">"fire_type"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Spread Rate (m/min)"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Main: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"spread_rate"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Fork: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats_fork(output_matrices_fork[<span class="org-string">"spread_rate"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Spread Direction (degrees clockwise from North)"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Main: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"spread_direction"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Fork: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats_fork(output_matrices_fork[<span class="org-string">"spread_direction"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Fireline Intensity (kW/m)"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Main: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"fireline_intensity"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Fork: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats_fork(output_matrices_fork[<span class="org-string">"fireline_intensity"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Flame Length (meters)"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Main: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"flame_length"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Fork: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats_fork(output_matrices_fork[<span class="org-string">"flame_length"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Time of Arrival (minutes)"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Main: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"time_of_arrival"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Fork: "</span>, end<span class="org-operator">=</span><span class="org-string">""</span>)
pprint(get_array_stats_fork(output_matrices_fork[<span class="org-string">"time_of_arrival"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)
</pre>
</div>

<pre class="example" id="run-spread-fire-with-phi-field-stats-forked-results">
Fire Behavior from Day 2 @ 10:30am - Day 2 @ 10:30pm Spreading from Coordinate (50,50)
====================================================================================================
Stop Time (Main): 2790.0 (minutes)
Stop Time (Fork): 2790.0 (minutes)
Stop Condition (Main): max duration reached
Stop Condition (Fork): max duration reached

Phi (phi &lt;= 0: burned, phi &gt; 0: unburned
Main: {'Min': -0.92529535, 'Max': 1.0, 'Mean': 0.8109577, 'Stdev': 0.542039}
Fork: {'Min': -0.92529535, 'Max': 1.0, 'Mean': 0.8146855, 'Stdev': 0.538873}

Fire Type (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)
Main: {'Min': 1, 'Max': 1, 'Mean': 1.0, 'Stdev': 0.0}
Fork: {'Min': 1, 'Max': 1, 'Mean': 1.0, 'Stdev': 0.0}

Spread Rate (m/min)
Main: {'Min': 0.16077128, 'Max': 2.2964315, 'Mean': 1.191673, 'Stdev': 0.6304963}
Fork: {'Min': 0.16077128, 'Max': 2.2964315, 'Mean': 1.1753283, 'Stdev': 0.6232901}

Spread Direction (degrees clockwise from North)
Main: {'Min': 1.0845373, 'Max': 359.45844, 'Mean': 193.19345, 'Stdev': 116.74348}
Fork: {'Min': 1.1319, 'Max': 359.45844, 'Mean': 195.22275, 'Stdev': 116.035866}

Fireline Intensity (kW/m)
Main: {'Min': 2.2772405, 'Max': 32.527744, 'Mean': 16.879421, 'Stdev': 8.930649}
Fork: {'Min': 2.2772405, 'Max': 32.527744, 'Mean': 16.64791, 'Stdev': 8.828576}

Flame Length (meters)
Main: {'Min': 0.113121204, 'Max': 0.3843906, 'Mean': 0.27317166, 'Stdev': 0.07285855}
Fork: {'Min': 0.113121204, 'Max': 0.3843906, 'Mean': 0.27146405, 'Stdev': 0.072314404}

Time of Arrival (minutes)
Main: {'Min': 2081.852, 'Max': 2789.606, 'Mean': 2543.9004, 'Stdev': 173.16722}
Fork: {'Min': 2081.852, 'Max': 2789.6057, 'Mean': 2539.8635, 'Stdev': 171.96436}
</pre>
</div>
</li>

<li><a id="create-images-of-the-two-scenarios'-outputs"></a>Create Images of the Two Scenarios' Outputs<br>
<div class="outline-text-5" id="text-create-images-of-the-two-scenarios'-outputs">
<div class="org-src-container">
<pre class="src src-python" id="run-spread-fire-with-phi-field-images-forked"><span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np


<span class="org-keyword">def</span> <span class="org-function-name">save_matrix_as_heatmap</span>(matrix, colors, units, title, filename, vmin<span class="org-operator">=</span><span class="org-constant">None</span>, vmax<span class="org-operator">=</span><span class="org-constant">None</span>, ticks<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-variable-name">image</span>    <span class="org-operator">=</span> plt.imshow(matrix, origin<span class="org-operator">=</span><span class="org-string">"lower"</span>, cmap<span class="org-operator">=</span>colors, vmin<span class="org-operator">=</span>vmin, vmax<span class="org-operator">=</span>vmax)
    <span class="org-variable-name">colorbar</span> <span class="org-operator">=</span> plt.colorbar(image, orientation<span class="org-operator">=</span><span class="org-string">"vertical"</span>, ticks<span class="org-operator">=</span>ticks)
    colorbar.set_label(units)
    plt.title(title)
    plt.savefig(filename)
    plt.close(<span class="org-string">"all"</span>)


<span class="org-keyword">def</span> <span class="org-function-name">save_matrix_as_contours</span>(matrix, title, filename, levels<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-variable-name">fig</span>, <span class="org-variable-name">ax</span> <span class="org-operator">=</span> plt.subplots()
    <span class="org-variable-name">cs</span>      <span class="org-operator">=</span> ax.contour(matrix, levels<span class="org-operator">=</span>levels)
    ax.clabel(cs, inline<span class="org-operator">=</span><span class="org-constant">True</span>, fontsize<span class="org-operator">=</span>10)
    ax.set_aspect(<span class="org-string">'equal'</span>, <span class="org-string">'box'</span>)
    ax.set_title(title)
    plt.savefig(filename)
    plt.close(<span class="org-string">"all"</span>)


<span class="org-comment-delimiter"># </span><span class="org-comment">See https://matplotlib.org/stable/gallery/color/colormap_reference.html for the available options for "colors"</span>
<span class="org-variable-name">heatmap_configs</span> <span class="org-operator">=</span> [
    {
        <span class="org-string">"matrix"</span>  : space_time_cubes[<span class="org-string">"fuel_model"</span>].getSpatialPlane(0, <span class="org-constant">None</span>, <span class="org-constant">None</span>),
        <span class="org-string">"colors"</span>  : <span class="org-string">"viridis_r"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"fuel model number: 91-204"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Fuel Model"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_fuel_model_main.png"</span>,
        <span class="org-string">"vmin"</span>    : 91,
        <span class="org-string">"vmax"</span>    : 204,
    },
    {
        <span class="org-string">"matrix"</span>  : space_time_cubes_fork[<span class="org-string">"fuel_model"</span>].getSpatialPlane(0, <span class="org-constant">None</span>, <span class="org-constant">None</span>),
        <span class="org-string">"colors"</span>  : <span class="org-string">"viridis_r"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"fuel model number: 91-204"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Fuel Model"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_fuel_model_fork.png"</span>,
        <span class="org-string">"vmin"</span>    : 91,
        <span class="org-string">"vmax"</span>    : 204,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"phi"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"plasma"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"phi &lt;= 0: burned, phi &gt; 0: unburned"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Phi"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_phi_main.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices_fork[<span class="org-string">"phi"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"plasma"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"phi &lt;= 0: burned, phi &gt; 0: unburned"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Phi"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_phi_fork.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"fire_type"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"viridis"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"0=unburned, 1=surface, 2=passive_crown, 3=active_crown"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Fire Type"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_fire_type_main.png"</span>,
        <span class="org-string">"vmin"</span>    : 0,
        <span class="org-string">"vmax"</span>    : 3,
        <span class="org-string">"ticks"</span>   : [0,1,2,3],
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices_fork[<span class="org-string">"fire_type"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"viridis"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"0=unburned, 1=surface, 2=passive_crown, 3=active_crown"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Fire Type"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_fire_type_fork.png"</span>,
        <span class="org-string">"vmin"</span>    : 0,
        <span class="org-string">"vmax"</span>    : 3,
        <span class="org-string">"ticks"</span>   : [0,1,2,3],
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"spread_rate"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"m/min"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Spread Rate"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_spread_rate_main.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices_fork[<span class="org-string">"spread_rate"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"m/min"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Spread Rate"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_spread_rate_fork.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"spread_direction"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"viridis"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"degrees clockwise from North"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Spread Direction"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_spread_direction_main.png"</span>,
        <span class="org-string">"vmin"</span>    : 0,
        <span class="org-string">"vmax"</span>    : 360,
        <span class="org-string">"ticks"</span>   : [0,45,90,135,180,225,270,315,360]
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices_fork[<span class="org-string">"spread_direction"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"viridis"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"degrees clockwise from North"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Spread Direction"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_spread_direction_fork.png"</span>,
        <span class="org-string">"vmin"</span>    : 0,
        <span class="org-string">"vmax"</span>    : 360,
        <span class="org-string">"ticks"</span>   : [0,45,90,135,180,225,270,315,360]
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"fireline_intensity"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"kW/m"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Fireline Intensity"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_fireline_intensity_main.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices_fork[<span class="org-string">"fireline_intensity"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"kW/m"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Fireline Intensity"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_fireline_intensity_fork.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"flame_length"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"meters"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Flame Length"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_flame_length_main.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices_fork[<span class="org-string">"flame_length"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"meters"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Flame Length"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_flame_length_fork.png"</span>,
    },
]


<span class="org-variable-name">contour_configs</span> <span class="org-operator">=</span> [
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"time_of_arrival"</span>],
        <span class="org-string">"title"</span>   : <span class="org-string">"Time of Arrival"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_time_of_arrival_main.png"</span>,
        <span class="org-string">"levels"</span>  : <span class="org-builtin">int</span>(start_time) <span class="org-operator">+</span> np.asarray(<span class="org-builtin">range</span>(0, <span class="org-builtin">int</span>(max_duration) <span class="org-operator">+</span> 1, 60)),
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices_fork[<span class="org-string">"time_of_arrival"</span>],
        <span class="org-string">"title"</span>   : <span class="org-string">"Time of Arrival"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"org/pics/els_time_of_arrival_fork.png"</span>,
        <span class="org-string">"levels"</span>  : <span class="org-builtin">int</span>(start_time) <span class="org-operator">+</span> np.asarray(<span class="org-builtin">range</span>(0, <span class="org-builtin">int</span>(max_duration) <span class="org-operator">+</span> 1, 60)),
    },
]


<span class="org-keyword">for</span> heatmap_config <span class="org-keyword">in</span> heatmap_configs:
    save_matrix_as_heatmap(<span class="org-operator">**</span>heatmap_config)


<span class="org-keyword">for</span> contour_config <span class="org-keyword">in</span> contour_configs:
    save_matrix_as_contours(<span class="org-operator">**</span>contour_config)
</pre>
</div>

<table id="fuel-model-matplotlib-heatmaps-forked">
<caption class="t-above"><span class="table-number">Table 8:</span> Fuel model [Left: Main, Right: Fork]</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="pics/els_fuel_model_main.png" alt="els_fuel_model_main.png"></td>
<td class="org-left"><img src="pics/els_fuel_model_fork.png" alt="els_fuel_model_fork.png"></td>
</tr>
</tbody>
</table>

<table id="fire-behavior-matplotlib-heatmaps-forked">
<caption class="t-above"><span class="table-number">Table 9:</span> Fire behavior attributes after 12 hours of spread [Left: Main, Right: Fork]</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="pics/els_phi_main.png" alt="els_phi_main.png"></td>
<td class="org-left"><img src="pics/els_phi_fork.png" alt="els_phi_fork.png"></td>
</tr>

<tr>
<td class="org-left"><img src="pics/els_fire_type_main.png" alt="els_fire_type_main.png"></td>
<td class="org-left"><img src="pics/els_fire_type_fork.png" alt="els_fire_type_fork.png"></td>
</tr>

<tr>
<td class="org-left"><img src="pics/els_spread_rate_main.png" alt="els_spread_rate_main.png"></td>
<td class="org-left"><img src="pics/els_spread_rate_fork.png" alt="els_spread_rate_fork.png"></td>
</tr>

<tr>
<td class="org-left"><img src="pics/els_spread_direction_main.png" alt="els_spread_direction_main.png"></td>
<td class="org-left"><img src="pics/els_spread_direction_fork.png" alt="els_spread_direction_fork.png"></td>
</tr>

<tr>
<td class="org-left"><img src="pics/els_fireline_intensity_main.png" alt="els_fireline_intensity_main.png"></td>
<td class="org-left"><img src="pics/els_fireline_intensity_fork.png" alt="els_fireline_intensity_fork.png"></td>
</tr>

<tr>
<td class="org-left"><img src="pics/els_flame_length_main.png" alt="els_flame_length_main.png"></td>
<td class="org-left"><img src="pics/els_flame_length_fork.png" alt="els_flame_length_fork.png"></td>
</tr>
</tbody>
</table>

<table id="time-of-arrival-matplotlib-countours-forked">
<caption class="t-above"><span class="table-number">Table 10:</span> Time of arrival with hourly perimeters [Left: Main, Right: Fork]</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="pics/els_time_of_arrival_main.png" alt="els_time_of_arrival_main.png"></td>
<td class="org-left"><img src="pics/els_time_of_arrival_fork.png" alt="els_time_of_arrival_fork.png"></td>
</tr>
</tbody>
</table>
</div>
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-appendices" class="outline-2">
<h2 id="appendices"><span class="section-number-2">10.</span> Appendices</h2>
<div class="outline-text-2" id="text-appendices">
</div>
<div id="outline-container-custom-types-(pyretechnics.py_types)" class="outline-3">
<h3 id="custom-types-(pyretechnics.py_types)"><span class="section-number-3">10.1.</span> Custom Types (pyretechnics.py_types)</h3>
<div class="outline-text-3" id="text-custom-types-(pyretechnics.py_types)">
<div class="org-src-container">
<pre class="src src-python" id="py-types"><span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Runtime-defined type aliases</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

<span class="org-keyword">import</span> cython <span class="org-keyword">as</span> cy

<span class="org-variable-name">pyidx</span>            <span class="org-operator">=</span> cy.typedef(cy.Py_ssize_t)
<span class="org-variable-name">vec_xy</span>           <span class="org-operator">=</span> cy.typedef(<span class="org-builtin">tuple</span>) <span class="org-comment-delimiter"># </span><span class="org-comment">tuple[cy.float, cy.float]</span>
<span class="org-variable-name">vec_xyz</span>          <span class="org-operator">=</span> cy.typedef(<span class="org-builtin">tuple</span>) <span class="org-comment-delimiter"># </span><span class="org-comment">tuple[cy.float, cy.float, cy.float]</span>
<span class="org-variable-name">coord_yx</span>         <span class="org-operator">=</span> cy.typedef(<span class="org-builtin">tuple</span>) <span class="org-comment-delimiter"># </span><span class="org-comment">tuple[pyidx, pyidx]</span>
<span class="org-variable-name">coord_tyx</span>        <span class="org-operator">=</span> cy.typedef(<span class="org-builtin">tuple</span>) <span class="org-comment-delimiter"># </span><span class="org-comment">tuple[pyidx, pyidx, pyidx]</span>
<span class="org-variable-name">fcatarr</span>          <span class="org-operator">=</span> cy.typedef(<span class="org-builtin">tuple</span>) <span class="org-comment-delimiter"># </span><span class="org-comment">tuple[cy.float, cy.float]</span>
<span class="org-variable-name">fclaarr</span>          <span class="org-operator">=</span> cy.typedef(<span class="org-builtin">tuple</span>) <span class="org-comment-delimiter"># </span><span class="org-comment">tuple[cy.float, cy.float, cy.float, cy.float, cy.float, cy.float]</span>
<span class="org-variable-name">CompactFuelModel</span> <span class="org-operator">=</span> cy.typedef(<span class="org-builtin">tuple</span>) <span class="org-comment-delimiter"># </span><span class="org-comment">tuple[cy.float, cy.float, cy.float, cy.float, cy.float, cy.float,</span>
                                     <span class="org-comment-delimiter">#       </span><span class="org-comment">cy.float, cy.float, cy.float, cy.float, cy.float, cy.float, cy.float]</span>

<span class="org-variable-name">FuelModel</span> <span class="org-operator">=</span> cy.struct(
    number               <span class="org-operator">=</span> cy.<span class="org-builtin">int</span>,
    delta                <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    M_x                  <span class="org-operator">=</span> fclaarr,
    M_f                  <span class="org-operator">=</span> fclaarr,
    w_o                  <span class="org-operator">=</span> fclaarr,
    sigma                <span class="org-operator">=</span> fclaarr,
    h                    <span class="org-operator">=</span> fclaarr,
    rho_p                <span class="org-operator">=</span> fclaarr,
    S_T                  <span class="org-operator">=</span> fclaarr,
    S_e                  <span class="org-operator">=</span> fclaarr,
    dynamic              <span class="org-operator">=</span> cy.bint,
    burnable             <span class="org-operator">=</span> cy.bint,
    exp_A_sigma          <span class="org-operator">=</span> fclaarr,
    firemod_size_classes <span class="org-operator">=</span> fclaarr,
    f_ij                 <span class="org-operator">=</span> fclaarr,
    f_i                  <span class="org-operator">=</span> fcatarr,
    g_ij                 <span class="org-operator">=</span> fclaarr,
)

<span class="org-variable-name">ProjectedVectors</span> <span class="org-operator">=</span> cy.struct(
    wind_vector_3d  <span class="org-operator">=</span> vec_xyz,
    slope_vector_3d <span class="org-operator">=</span> vec_xyz,
)

<span class="org-variable-name">FireBehaviorMin</span> <span class="org-operator">=</span> cy.struct(
    base_spread_rate         <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    base_fireline_intensity  <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    max_effective_wind_speed <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    _phiS_G                  <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    _phiW_scalr              <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    _phiW_expnt              <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    _ws_scalr                <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    _ws_expnt                <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
)

<span class="org-variable-name">FireBehaviorMax</span> <span class="org-operator">=</span> cy.struct(
    max_fire_type          <span class="org-operator">=</span> cy.<span class="org-builtin">int</span>,
    max_spread_rate        <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    max_spread_direction   <span class="org-operator">=</span> vec_xyz,
    max_fireline_intensity <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    max_flame_length       <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    length_to_width_ratio  <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    eccentricity           <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    critical_spread_rate   <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
)

<span class="org-variable-name">SpreadBehavior</span> <span class="org-operator">=</span> cy.struct(
    dphi_dt            <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    fire_type          <span class="org-operator">=</span> cy.<span class="org-builtin">int</span>,
    spread_rate        <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    spread_direction   <span class="org-operator">=</span> vec_xyz,
    fireline_intensity <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    flame_length       <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
)

<span class="org-variable-name">CrownSpreadInfo</span> <span class="org-operator">=</span> cy.struct(
    fire_type            <span class="org-operator">=</span> cy.<span class="org-builtin">int</span>,
    spread_rate          <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    critical_spread_rate <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
)

<span class="org-variable-name">SpotConfig</span> <span class="org-operator">=</span> cy.struct(
    random_seed                  <span class="org-operator">=</span> cy.longlong,
    firebrands_per_unit_heat     <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    downwind_distance_mean       <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    fireline_intensity_exponent  <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    wind_speed_exponent          <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    downwind_variance_mean_ratio <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    crosswind_distance_stdev     <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    decay_distance               <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
)

<span class="org-variable-name">JumpDistribution</span> <span class="org-operator">=</span> cy.struct(
    <span class="org-comment-delimiter"># </span><span class="org-comment">Downwind LogNormal params</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Formally, we have ln(downwind_jump / 1m) ~ Normal(mu = mu_x, sigma = sigma_x)</span>
    mu_x    <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>, <span class="org-comment-delimiter"># </span><span class="org-comment">dimensionless (log-space)</span>
    sigma_x <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>, <span class="org-comment-delimiter"># </span><span class="org-comment">dimensionless (log-space)</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Crosswind normal params</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Formally, we have crosswind_jump ~ Normal(mu = 0, sigma = sigma_y)</span>
    sigma_y <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>, <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
)

<span class="org-comment-delimiter"># </span><span class="org-comment">Pre-computed coefficients to apply elliptical wavelet math as fast as possible</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">once the phi gradient information is available.</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">See `pyretechnics.eulerian_level_set.dphi_dt_from_partialed_wavelet`.</span>
<span class="org-variable-name">PartialedEllWavelet</span> <span class="org-operator">=</span> cy.struct(
    Vh_3d <span class="org-operator">=</span> vec_xyz,  <span class="org-comment-delimiter"># </span><span class="org-comment">Heading spread rate vector (m/min)</span>
    ewc_A <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>, <span class="org-comment-delimiter"># </span><span class="org-comment">Dimensionless elliptical wavelet coefficient (&lt;= 0)</span>
    ewc_B <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>, <span class="org-comment-delimiter"># </span><span class="org-comment">Dimensionless elliptical wavelet coefficient (&lt;= 0)</span>
    ewc_C <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>, <span class="org-comment-delimiter"># </span><span class="org-comment">Dimensionless elliptical wavelet coefficient (&gt;= 0)</span>
)

<span class="org-variable-name">CellInputs</span> <span class="org-operator">=</span> cy.struct(
    slope                         <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    aspect                        <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    fuel_model_number             <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    canopy_cover                  <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    canopy_height                 <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    canopy_base_height            <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    canopy_bulk_density           <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    wind_speed_10m                <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    upwind_direction              <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    fuel_moisture_dead_1hr        <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    fuel_moisture_dead_10hr       <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    fuel_moisture_dead_100hr      <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    fuel_moisture_live_herbaceous <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    fuel_moisture_live_woody      <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    foliar_moisture               <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    fuel_spread_adjustment        <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
    weather_spread_adjustment     <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
)

<span class="org-comment-delimiter"># </span><span class="org-comment">Pre-computed information required to compute dphi/dt once the phi</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">gradient is known. Derived from the surface and crown wavelets.</span>
<span class="org-comment-delimiter">#</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: The reason to make this a small struct stored in an array is</span>
<span class="org-comment-delimiter">#       </span><span class="org-comment">efficiency - we want the CPU to have a low cache miss rate.</span>
<span class="org-comment-delimiter">#</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: A significant benefit of this architecture is that it's</span>
<span class="org-comment-delimiter">#       </span><span class="org-comment">Rothermel-agnostic. EllipticalInfo could conceivably be</span>
<span class="org-comment-delimiter">#       </span><span class="org-comment">implemented using variants of the Rothermel model. This can be</span>
<span class="org-comment-delimiter">#       </span><span class="org-comment">valuable to give flexibility to users.</span>
<span class="org-variable-name">EllipticalInfo</span> <span class="org-operator">=</span> cy.struct(
    cell_index           <span class="org-operator">=</span> coord_yx,
    elevation_gradient   <span class="org-operator">=</span> vec_xy,
    surface_wavelet      <span class="org-operator">=</span> PartialedEllWavelet,
    crown_wavelet        <span class="org-operator">=</span> PartialedEllWavelet,
    crowning_spread_rate <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>, <span class="org-comment-delimiter"># </span><span class="org-comment">Surface spread rate at which crowning occurs</span>
)

<span class="org-comment-delimiter"># </span><span class="org-comment">Some data saved during the 1st Runge-Kutta pass.</span>
<span class="org-variable-name">Pass1CellOutput</span> <span class="org-operator">=</span> cy.struct(
    cell_index      <span class="org-operator">=</span> coord_yx,
    phi_gradient_xy <span class="org-operator">=</span> vec_xy,
    dphi_dt_flim    <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>, <span class="org-comment-delimiter"># </span><span class="org-comment">Flux-limited dphi/dt (phi/min, &lt;= 0).</span>
    phi_old         <span class="org-operator">=</span> cy.<span class="org-builtin">float</span>,
)
</pre>
</div>
</div>
</div>

<div id="outline-container-units-conversion-functions-(pyretechnics.conversion)" class="outline-3">
<h3 id="units-conversion-functions-(pyretechnics.conversion)"><span class="section-number-3">10.2.</span> Units Conversion Functions (pyretechnics.conversion)</h3>
<div class="outline-text-3" id="text-units-conversion-functions-(pyretechnics.conversion)">
<div class="org-src-container">
<pre class="src src-python" id="units-conversion"><span class="org-keyword">import</span> cython
<span class="org-keyword">import</span> cython <span class="org-keyword">as</span> cy
<span class="org-keyword">if</span> cython.compiled:
    <span class="org-keyword">from</span> cython.cimports.libc.math <span class="org-keyword">import</span> pi, sqrt, sin, cos, tan, atan, atan2
    <span class="org-keyword">from</span> cython.cimports.pyretechnics.cy_types <span class="org-keyword">import</span> vec_xy
<span class="org-keyword">else</span>:
    <span class="org-keyword">from</span> math <span class="org-keyword">import</span> pi, sqrt, sin, cos, tan, atan, atan2
    <span class="org-keyword">from</span> pyretechnics.py_types <span class="org-keyword">import</span> vec_xy


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">rad_to_deg</span>(radians: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert radians to degrees."""</span>
    <span class="org-keyword">return</span> radians <span class="org-operator">*</span> 180.0 <span class="org-operator">/</span> pi


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">deg_to_rad</span>(degrees: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert degrees to radians."""</span>
    <span class="org-keyword">return</span> degrees <span class="org-operator">*</span> pi <span class="org-operator">/</span> 180.0


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">deg_to_ratio</span>(degrees: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert degrees to ratio."""</span>
    <span class="org-keyword">return</span> tan(deg_to_rad(degrees))


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">ratio_to_deg</span>(ratio: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert ratio to degrees."""</span>
    <span class="org-keyword">return</span> rad_to_deg(atan(ratio))


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">F_to_K</span>(degrees: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert fahrenheit to kelvin."""</span>
    <span class="org-keyword">return</span> (degrees <span class="org-operator">+</span> 459.67) <span class="org-operator">*</span> 0.5555555555555556


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">K_to_F</span>(degrees: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert kelvin to fahrenheit."""</span>
    <span class="org-keyword">return</span> (degrees <span class="org-operator">*</span> 1.8) <span class="org-operator">-</span> 459.67


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">F_to_C</span>(degrees: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert fahrenheit to celsius."""</span>
    <span class="org-keyword">return</span> (degrees <span class="org-operator">-</span> 32.0) <span class="org-operator">*</span> 0.5555555555555556


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">C_to_F</span>(degrees: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert celsius to fahrenheit."""</span>
    <span class="org-keyword">return</span> (degrees <span class="org-operator">*</span> 1.8) <span class="org-operator">+</span> 32.0


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">ch_to_m</span>(ch: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert chains to meters."""</span>
    <span class="org-keyword">return</span> ch <span class="org-operator">*</span> 20.1168


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">m_to_ch</span>(m: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert meters to chains."""</span>
    <span class="org-keyword">return</span> m <span class="org-operator">*</span> 0.0497097


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">m_to_ft</span>(m: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert meters to feet."""</span>
    <span class="org-keyword">return</span> m <span class="org-operator">*</span> 3.281


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">ft_to_m</span>(ft: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert feet to meters."""</span>
    <span class="org-keyword">return</span> ft <span class="org-operator">*</span> 0.30478512648582745


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">mph_to_mps</span>(mph: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert miles per hour to meters per second."""</span>
    <span class="org-keyword">return</span> mph <span class="org-operator">*</span> 0.44701818551254696


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">mps_to_mph</span>(mps: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert meters per second to miles per hour."""</span>
    <span class="org-keyword">return</span> mps <span class="org-operator">*</span> 2.237045454545455


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">km_hr_to_mps</span>(km_hr: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert kilometers per hour to meters per second."""</span>
    <span class="org-keyword">return</span> km_hr <span class="org-operator">*</span> 0.277764222883701


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">mps_to_km_hr</span>(mps: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert meters per second to kilometers per hour."""</span>
    <span class="org-keyword">return</span> mps <span class="org-operator">*</span> 3.6001756800000004


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">mph_to_km_hr</span>(mph: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert miles per hour to kilometers per hour."""</span>
    <span class="org-keyword">return</span> mph <span class="org-operator">*</span> 1.609344


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">km_hr_to_mph</span>(km_hr: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert kilometers per hour to miles per hour."""</span>
    <span class="org-keyword">return</span> km_hr <span class="org-operator">*</span> 0.621371192237334


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">m_min_to_km_hr</span>(m_min: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert meters per minute to kilometers per hour."""</span>
    <span class="org-keyword">return</span> m_min <span class="org-operator">*</span> 0.06


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">km_hr_to_m_min</span>(km_hr: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert kilometers per hour to meters per minute."""</span>
    <span class="org-keyword">return</span> km_hr <span class="org-operator">/</span> 0.06


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">m_min_to_mph</span>(m_min: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert meters per minute to miles per hour."""</span>
    <span class="org-keyword">return</span> m_min <span class="org-operator">*</span> 0.0372840909091


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">mph_to_m_min</span>(mph: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert miles per hour to meters per minute."""</span>
    <span class="org-keyword">return</span> mph <span class="org-operator">*</span> 26.8210911307


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">mps_to_fpm</span>(mps: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert meters per second to feet per minute."""</span>
    <span class="org-keyword">return</span> mps <span class="org-operator">*</span> 196.86


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">fpm_to_mps</span>(fpm: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert feet per minute to meters per second."""</span>
    <span class="org-keyword">return</span> fpm <span class="org-operator">/</span> 196.86


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">mph_to_fpm</span>(mph: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert miles per hour to feet per minute."""</span>
    <span class="org-keyword">return</span> mph <span class="org-operator">*</span> 88.0


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">fpm_to_mph</span>(fpm: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert feet per minute to miles per hour."""</span>
    <span class="org-keyword">return</span> fpm <span class="org-operator">/</span> 88.0


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">Btu_ft_s_to_kW_m</span>(Btu_ft_s: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert BTU per feet per second to kilowatt per meter."""</span>
    <span class="org-keyword">return</span> Btu_ft_s <span class="org-operator">*</span> 3.46165186


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">kW_m_to_Btu_ft_s</span>(kW_m: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert kilowatt per meter to BTU per feet per second."""</span>
    <span class="org-keyword">return</span> kW_m <span class="org-operator">*</span> 0.28887942532730604


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">Btu_lb_to_kJ_kg</span>(Btu_lb: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert BTU per lb to kilojoule per kilogram."""</span>
    <span class="org-keyword">return</span> Btu_lb <span class="org-operator">*</span> 2.3259999996185


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">kJ_kg_to_Btu_lb</span>(kJ_kg: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert kilojoule per kilogram to BTU per lb."""</span>
    <span class="org-keyword">return</span> kJ_kg <span class="org-operator">/</span> 2.3259999996185


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">kg_m3_to_lb_ft3</span>(kg_m3: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert kilogram per cubic meter to pound per cubic foot."""</span>
    <span class="org-keyword">return</span> kg_m3 <span class="org-operator">*</span> 0.0624


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">lb_ft3_to_kg_m3</span>(lb_ft3: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert pound per cubic foot to kilogram per cubic meter."""</span>
    <span class="org-keyword">return</span> lb_ft3 <span class="org-operator">*</span> 16.025641025641026


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">percent_to_dec</span>(percent: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert percent to decimal."""</span>
    <span class="org-keyword">return</span> percent <span class="org-operator">*</span> 0.01


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">dec_to_percent</span>(decimal: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert decimal to percent."""</span>
    <span class="org-keyword">return</span> decimal <span class="org-operator">*</span> 100.0


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">sec_to_min</span>(seconds: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert seconds to minutes."""</span>
    <span class="org-keyword">return</span> seconds <span class="org-operator">*</span> 0.016666666666666666


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">min_to_sec</span>(minutes: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert minutes to seconds."""</span>
    <span class="org-keyword">return</span> minutes <span class="org-operator">*</span> 60.0


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">ms_to_min</span>(milliseconds: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert milliseconds to minutes."""</span>
    <span class="org-keyword">return</span> milliseconds <span class="org-operator">*</span> 0.000016667


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">min_to_ms</span>(minutes: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert minutes to milliseconds."""</span>
    <span class="org-keyword">return</span> minutes <span class="org-operator">*</span> 60000.0


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">hour_to_min</span>(hours: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Converts hours to minutes."""</span>
    <span class="org-keyword">return</span> hours <span class="org-operator">*</span> 60.0


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">min_to_hour</span>(minutes: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Converts minutes to hours."""</span>
    <span class="org-keyword">return</span> minutes <span class="org-operator">/</span> 60.0


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">day_to_min</span>(days: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert days to minutes."""</span>
    <span class="org-keyword">return</span> days <span class="org-operator">*</span> 1440.0


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">min_to_day</span>(minutes: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert minutes to days."""</span>
    <span class="org-keyword">return</span> minutes <span class="org-operator">/</span> 1440.0


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO Return vec_rt</span>
<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">cartesian_to_polar</span>(x: cy.<span class="org-builtin">float</span>, y: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> vec_xy:
    <span class="org-doc">"""Convert cartesian coordinates (x, y) to polar coordinates (r, theta)."""</span>
    <span class="org-variable-name">r</span>        : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> sqrt(x <span class="org-operator">*</span> x <span class="org-operator">+</span> y <span class="org-operator">*</span> y)
    <span class="org-variable-name">theta_rad</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> atan2(y, x)
    <span class="org-variable-name">theta</span>    : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (rad_to_deg(theta_rad) <span class="org-operator">+</span> 360.0) <span class="org-operator">%</span> 360.0
    <span class="org-keyword">return</span> (r, theta)


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">polar_to_cartesian</span>(r: cy.<span class="org-builtin">float</span>, theta: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> vec_xy:
    <span class="org-doc">"""Convert polar coordinates (r, theta) to cartesian coordinates (x, y)."""</span>
    <span class="org-variable-name">theta_rad</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> deg_to_rad(theta)
    <span class="org-variable-name">x</span>        : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> r <span class="org-operator">*</span> cos(theta_rad)
    <span class="org-variable-name">y</span>        : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> r <span class="org-operator">*</span> sin(theta_rad)
    <span class="org-keyword">return</span> (x, y)


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO Return vec_ra</span>
<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">cartesian_to_azimuthal</span>(x: cy.<span class="org-builtin">float</span>, y: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> vec_xy:
    <span class="org-doc">"""Convert cartesian coordinates (x, y) to azimuthal coordinates (r, azimuth)."""</span>
    <span class="org-variable-name">r</span>          : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> sqrt(x <span class="org-operator">*</span> x <span class="org-operator">+</span> y <span class="org-operator">*</span> y)
    <span class="org-variable-name">azimuth_rad</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> atan2(x, y)
    <span class="org-variable-name">azimuth</span>    : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> (rad_to_deg(azimuth_rad) <span class="org-operator">+</span> 360.0) <span class="org-operator">%</span> 360.0
    <span class="org-keyword">return</span> (r, azimuth)


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">azimuthal_to_cartesian</span>(r: cy.<span class="org-builtin">float</span>, azimuth: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> vec_xy:
    <span class="org-doc">"""Convert azimuthal coordinates (r, azimuth) to cartesian coordinates (x, y)."""</span>
    <span class="org-variable-name">azimuth_rad</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> deg_to_rad(azimuth)
    <span class="org-variable-name">x</span>          : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> r <span class="org-operator">*</span> sin(azimuth_rad)
    <span class="org-variable-name">y</span>          : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> r <span class="org-operator">*</span> cos(azimuth_rad)
    <span class="org-keyword">return</span> (x, y)


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">opposite_direction</span>(theta: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert theta to theta + 180 degrees."""</span>
    <span class="org-keyword">return</span> (theta <span class="org-operator">+</span> 180.0) <span class="org-operator">%</span> 360.0


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">wind_speed_10m_to_wind_speed_20ft</span>(wind_speed_10m: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert wind speed at 10m to wind speed at 20ft."""</span>
    <span class="org-keyword">return</span> wind_speed_10m <span class="org-operator">/</span> 1.15


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">wind_speed_20ft_to_wind_speed_10m</span>(wind_speed_20ft: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-doc">"""Convert wind speed at 20ft to wind speed at 10m."""</span>
    <span class="org-keyword">return</span> wind_speed_20ft <span class="org-operator">*</span> 1.15
</pre>
</div>
</div>
</div>

<div id="outline-container-vector-utility-functions-(pyretechnics.vector_utils)" class="outline-3">
<h3 id="vector-utility-functions-(pyretechnics.vector_utils)"><span class="section-number-3">10.3.</span> Vector Utility Functions (pyretechnics.vector_utils)</h3>
<div class="outline-text-3" id="text-vector-utility-functions-(pyretechnics.vector_utils)">
<div class="org-src-container">
<pre class="src src-python" id="vector-utilities"><span class="org-keyword">import</span> cython
<span class="org-keyword">import</span> cython <span class="org-keyword">as</span> cy
<span class="org-keyword">if</span> cython.compiled:
    <span class="org-keyword">from</span> cython.cimports.libc.math <span class="org-keyword">import</span> sqrt, sin, cos
    <span class="org-keyword">from</span> cython.cimports.pyretechnics.cy_types <span class="org-keyword">import</span> pyidx, vec_xy, vec_xyz
    <span class="org-keyword">import</span> cython.cimports.pyretechnics.conversion <span class="org-keyword">as</span> conv
<span class="org-keyword">else</span>:
    <span class="org-keyword">from</span> math <span class="org-keyword">import</span> sqrt, sin, cos
    <span class="org-keyword">from</span> pyretechnics.py_types <span class="org-keyword">import</span> pyidx, vec_xy, vec_xyz
    <span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">dot_2d</span>(vector1: vec_xy, vector2: vec_xy) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-keyword">return</span> vector1[0] <span class="org-operator">*</span> vector2[0] <span class="org-operator">+</span> vector1[1] <span class="org-operator">*</span> vector2[1]


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">dot_3d</span>(vector1: vec_xyz, vector2: vec_xyz) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-keyword">return</span> vector1[0] <span class="org-operator">*</span> vector2[0] <span class="org-operator">+</span> vector1[1] <span class="org-operator">*</span> vector2[1] <span class="org-operator">+</span> vector1[2] <span class="org-operator">*</span> vector2[2]


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">scale_2d</span>(scalar: cy.<span class="org-builtin">float</span>, vector: vec_xy) <span class="org-operator">-&gt;</span> vec_xy:
    <span class="org-keyword">return</span> (scalar <span class="org-operator">*</span> vector[0], scalar <span class="org-operator">*</span> vector[1])


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">scale_3d</span>(scalar: cy.<span class="org-builtin">float</span>, vector: vec_xyz) <span class="org-operator">-&gt;</span> vec_xyz:
    <span class="org-keyword">return</span> (scalar <span class="org-operator">*</span> vector[0], scalar <span class="org-operator">*</span> vector[1], scalar <span class="org-operator">*</span> vector[2])


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">add_2d</span>(vector1: vec_xy, vector2: vec_xy) <span class="org-operator">-&gt;</span> vec_xy:
    <span class="org-keyword">return</span> (vector1[0] <span class="org-operator">+</span> vector2[0], vector1[1] <span class="org-operator">+</span> vector2[1])


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">add_3d</span>(vector1: vec_xyz, vector2: vec_xyz) <span class="org-operator">-&gt;</span> vec_xyz:
    <span class="org-keyword">return</span> (vector1[0] <span class="org-operator">+</span> vector2[0], vector1[1] <span class="org-operator">+</span> vector2[1], vector1[2] <span class="org-operator">+</span> vector2[2])


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">vector_magnitude_2d</span>(vector: vec_xy) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-keyword">return</span> sqrt(dot_2d(vector, vector))


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">vector_magnitude_3d</span>(vector: vec_xyz) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-keyword">return</span> sqrt(dot_3d(vector, vector))


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">as_unit_vector_2d</span>(vector: vec_xy) <span class="org-operator">-&gt;</span> vec_xy:
    <span class="org-variable-name">magnitude</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vector_magnitude_2d(vector)
    <span class="org-keyword">if</span> magnitude <span class="org-operator">==</span> 0.0:
        <span class="org-keyword">return</span> vector
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">ux</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vector[0] <span class="org-operator">/</span> magnitude
        <span class="org-variable-name">uy</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vector[1] <span class="org-operator">/</span> magnitude
        <span class="org-keyword">return</span> (ux, uy)


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">as_unit_vector_3d</span>(vector: vec_xyz) <span class="org-operator">-&gt;</span> vec_xyz:
    <span class="org-variable-name">magnitude</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vector_magnitude_3d(vector)
    <span class="org-keyword">if</span> magnitude <span class="org-operator">==</span> 0.0:
        <span class="org-keyword">return</span> vector
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">ux</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vector[0] <span class="org-operator">/</span> magnitude
        <span class="org-variable-name">uy</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vector[1] <span class="org-operator">/</span> magnitude
        <span class="org-variable-name">uz</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vector[2] <span class="org-operator">/</span> magnitude
        <span class="org-keyword">return</span> (ux, uy, uz)


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">to_slope_plane</span>(vector_2d: vec_xy, elevation_gradient: vec_xy) <span class="org-operator">-&gt;</span> vec_xyz:
    <span class="org-keyword">return</span> (
        vector_2d[0],
        vector_2d[1],
        dot_2d(vector_2d, elevation_gradient)
    )


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.inline</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">to_horizontal_plane</span>(vector_3d: vec_xyz) <span class="org-operator">-&gt;</span> vec_xy:
    <span class="org-keyword">return</span> (vector_3d[0], vector_3d[1])


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">spread_direction_vector_to_angle</span>(vector_3d: vec_xyz) <span class="org-operator">-&gt;</span> cy.<span class="org-builtin">float</span>:
    <span class="org-variable-name">x</span>        : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vector_3d[0]
    <span class="org-variable-name">y</span>        : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> vector_3d[1]
    <span class="org-variable-name">az_coords</span>: vec_xy   <span class="org-operator">=</span> conv.cartesian_to_azimuthal(x, y)
    <span class="org-variable-name">azimuth</span>  : cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> az_coords[1]
    <span class="org-keyword">return</span> azimuth


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">get_slope_normal_vector</span>(elevation_gradient: vec_xy) <span class="org-operator">-&gt;</span> vec_xyz:
    (<span class="org-variable-name">dz_dx</span>, <span class="org-variable-name">dz_dy</span>)               <span class="org-operator">=</span> elevation_gradient
    <span class="org-variable-name">slope_normal_vector</span>: vec_xyz <span class="org-operator">=</span> (<span class="org-operator">-</span>dz_dx, <span class="org-operator">-</span>dz_dy, 1.0)
    <span class="org-keyword">return</span> as_unit_vector_3d(slope_normal_vector)


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">cross_3d</span>(vector1: vec_xyz, vector2: vec_xyz) <span class="org-operator">-&gt;</span> vec_xyz:
    (<span class="org-variable-name">a</span>, <span class="org-variable-name">b</span>, <span class="org-variable-name">c</span>) <span class="org-operator">=</span> vector1
    (<span class="org-variable-name">d</span>, <span class="org-variable-name">e</span>, <span class="org-variable-name">f</span>) <span class="org-operator">=</span> vector2
    <span class="org-keyword">return</span> (
        b <span class="org-operator">*</span> f <span class="org-operator">-</span> e <span class="org-operator">*</span> c,
        <span class="org-operator">-</span>a <span class="org-operator">*</span> f <span class="org-operator">+</span> d <span class="org-operator">*</span> c,
        a <span class="org-operator">*</span> e <span class="org-operator">-</span> d <span class="org-operator">*</span> b,
    )


<span class="org-type">@cy.ccall</span>
<span class="org-type">@cy.exceptval</span>(check<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-keyword">def</span> <span class="org-function-name">rotate_on_sloped_plane</span>(vector: vec_xyz, theta: cy.<span class="org-builtin">float</span>, slope: cy.<span class="org-builtin">float</span>, aspect: cy.<span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> vec_xyz:
    <span class="org-doc">"""</span>
<span class="org-doc">    Rotate a 3D vector &lt;x,y,z&gt; theta degrees clockwise on the plane defined by the slope and aspect.</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the slope normal vector from the slope and aspect</span>
    <span class="org-variable-name">elevation_gradient</span> : vec_xy  <span class="org-operator">=</span> conv.azimuthal_to_cartesian(slope, conv.opposite_direction(aspect))
    <span class="org-variable-name">slope_normal_vector</span>: vec_xyz <span class="org-operator">=</span> get_slope_normal_vector(elevation_gradient)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate sine and cosine of theta</span>
    <span class="org-variable-name">theta_rad</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> conv.deg_to_rad(theta)
    <span class="org-variable-name">cos_theta</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> cos(theta_rad)
    <span class="org-variable-name">sin_theta</span>: cy.<span class="org-builtin">float</span> <span class="org-operator">=</span> sin(theta_rad)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Rotate theta degrees clockwise around the slope_normal_vector</span>
    <span class="org-variable-name">vector_i</span>: vec_xyz <span class="org-operator">=</span> (
        cos_theta <span class="org-operator">*</span> vector[0],
        cos_theta <span class="org-operator">*</span> vector[1],
        cos_theta <span class="org-operator">*</span> vector[2],
    )
    <span class="org-variable-name">vector_j</span>: vec_xyz <span class="org-operator">=</span> (
        sin_theta <span class="org-operator">*</span> vector[0],
        sin_theta <span class="org-operator">*</span> vector[1],
        sin_theta <span class="org-operator">*</span> vector[2],
    )
    <span class="org-variable-name">vector_k</span>: vec_xyz <span class="org-operator">=</span> cross_3d(vector_j, slope_normal_vector)
    <span class="org-keyword">return</span> (
        vector_i[0] <span class="org-operator">+</span> vector_k[0],
        vector_i[1] <span class="org-operator">+</span> vector_k[1],
        vector_i[2] <span class="org-operator">+</span> vector_k[2],
    )
</pre>
</div>
</div>
</div>

<div id="outline-container-spacetimecube-and-lazyspacetimecube-tests-(pyretechnics_test.test_space_time_cube)" class="outline-3">
<h3 id="spacetimecube-and-lazyspacetimecube-tests-(pyretechnics_test.test_space_time_cube)"><span class="section-number-3">10.4.</span> SpaceTimeCube and LazySpaceTimeCube Tests (pyretechnics_test.test_space_time_cube)</h3>
<div class="outline-text-3" id="text-spacetimecube-and-lazyspacetimecube-tests-(pyretechnics_test.test_space_time_cube)">
<div class="org-src-container">
<pre class="src src-python" id="test-space-time-cube"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Raw Data - Managed by the Caller</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">2D Arrays (e.g. 30m x 30m resolution, 30km x 30km extent)</span>
<span class="org-variable-name">elevation_layer</span>                    <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">slope_layer</span>                        <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">aspect_layer</span>                       <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">fuel_model_layer</span>                   <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">canopy_cover_layer</span>                 <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">canopy_height_layer</span>                <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">canopy_base_height_layer</span>           <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">canopy_bulk_density_layer</span>          <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">fuel_spread_adjustment_layer</span>       <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000) <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>
<span class="org-variable-name">suppression_difficulty_index_layer</span> <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000) <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">3D Arrays (e.g. 1hr x 300m x 300m resolution, 1day x 30km x 30km extent)</span>
<span class="org-variable-name">temperature_layer</span>                   <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100) <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>
<span class="org-variable-name">relative_humidity_layer</span>             <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100) <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>
<span class="org-variable-name">wind_speed_10m_layer</span>                <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">upwind_direction_layer</span>              <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">fuel_moisture_dead_1hr_layer</span>        <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">fuel_moisture_dead_10hr_layer</span>       <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">fuel_moisture_dead_100hr_layer</span>      <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">fuel_moisture_live_herbaceous_layer</span> <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">fuel_moisture_live_woody_layer</span>      <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">foliar_moisture_layer</span>               <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">weather_spread_adjustment_layer</span>     <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100) <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube Dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (
    24,   <span class="org-comment-delimiter"># </span><span class="org-comment">bands: 1 day @ 1 hour/band</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">rows:  30 km @ 30 meters/row</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">cols:  30 km @ 30 meters/col</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Create the Dictionary of Layer Names to SpaceTimeCubes</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

<span class="org-keyword">def</span> <span class="org-function-name">make_layer_lookup</span>():
    <span class="org-keyword">return</span> {
        <span class="org-comment-delimiter"># </span><span class="org-comment">2D Arrays (e.g. 30m x 30m resolution, 30km x 30km extent)</span>
        <span class="org-string">"elevation"</span>                    : SpaceTimeCube(cube_shape, elevation_layer),
        <span class="org-string">"slope"</span>                        : SpaceTimeCube(cube_shape, slope_layer),
        <span class="org-string">"aspect"</span>                       : SpaceTimeCube(cube_shape, aspect_layer),
        <span class="org-string">"fuel_model"</span>                   : SpaceTimeCube(cube_shape, fuel_model_layer),
        <span class="org-string">"canopy_cover"</span>                 : SpaceTimeCube(cube_shape, canopy_cover_layer),
        <span class="org-string">"canopy_height"</span>                : SpaceTimeCube(cube_shape, canopy_height_layer),
        <span class="org-string">"canopy_base_height"</span>           : SpaceTimeCube(cube_shape, canopy_base_height_layer),
        <span class="org-string">"canopy_bulk_density"</span>          : SpaceTimeCube(cube_shape, canopy_bulk_density_layer),
        <span class="org-string">"fuel_spread_adjustment"</span>       : SpaceTimeCube(cube_shape, fuel_spread_adjustment_layer),       <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>
        <span class="org-string">"suppression_difficulty_index"</span> : SpaceTimeCube(cube_shape, suppression_difficulty_index_layer), <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">3D Arrays (e.g. 1hr x 300m x 300m resolution, 1day x 30km x 30km extent)</span>
        <span class="org-string">"temperature"</span>                  : SpaceTimeCube(cube_shape, temperature_layer),
        <span class="org-string">"relative_humidity"</span>            : SpaceTimeCube(cube_shape, relative_humidity_layer),
        <span class="org-string">"wind_speed_10m"</span>               : SpaceTimeCube(cube_shape, wind_speed_10m_layer),
        <span class="org-string">"upwind_direction"</span>             : SpaceTimeCube(cube_shape, upwind_direction_layer),
        <span class="org-string">"fuel_moisture_dead_1hr"</span>       : SpaceTimeCube(cube_shape, fuel_moisture_dead_1hr_layer),
        <span class="org-string">"fuel_moisture_dead_10hr"</span>      : SpaceTimeCube(cube_shape, fuel_moisture_dead_10hr_layer),
        <span class="org-string">"fuel_moisture_dead_100hr"</span>     : SpaceTimeCube(cube_shape, fuel_moisture_dead_100hr_layer),
        <span class="org-string">"fuel_moisture_live_herbaceous"</span>: SpaceTimeCube(cube_shape, fuel_moisture_live_herbaceous_layer),
        <span class="org-string">"fuel_moisture_live_woody"</span>     : SpaceTimeCube(cube_shape, fuel_moisture_live_woody_layer),
        <span class="org-string">"foliar_moisture"</span>              : SpaceTimeCube(cube_shape, foliar_moisture_layer),
        <span class="org-string">"weather_spread_adjustment"</span>    : SpaceTimeCube(cube_shape, weather_spread_adjustment_layer),    <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>
    }


<span class="org-keyword">def</span> <span class="org-function-name">test_make_layer_lookup</span>():
    <span class="org-variable-name">layer_lookup</span> <span class="org-operator">=</span> make_layer_lookup()
    <span class="org-keyword">assert</span> <span class="org-builtin">all</span>(<span class="org-builtin">map</span>(<span class="org-keyword">lambda</span> cube: <span class="org-builtin">isinstance</span>(cube, SpaceTimeCube), layer_lookup.values()))

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Looking Up Values in the Layers</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

<span class="org-keyword">def</span> <span class="org-function-name">test_use_layer_lookup_2d</span>():
    <span class="org-variable-name">layer_lookup</span> <span class="org-operator">=</span> make_layer_lookup()
    <span class="org-variable-name">dem_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"elevation"</span>].get(0, 100, 100)
    <span class="org-variable-name">slp_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"slope"</span>].get(0, 100, 100)
    <span class="org-variable-name">asp_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"aspect"</span>].get(0, 100, 100)
    <span class="org-variable-name">fbfm_100_100</span> <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_model"</span>].get(0, 100, 100)
    <span class="org-variable-name">cc_100_100</span>   <span class="org-operator">=</span> layer_lookup[<span class="org-string">"canopy_cover"</span>].get(0, 100, 100)
    <span class="org-variable-name">ch_100_100</span>   <span class="org-operator">=</span> layer_lookup[<span class="org-string">"canopy_height"</span>].get(0, 100, 100)
    <span class="org-variable-name">cbh_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"canopy_base_height"</span>].get(0, 100, 100)
    <span class="org-variable-name">cbd_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"canopy_bulk_density"</span>].get(0, 100, 100)
    <span class="org-variable-name">fsa_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_spread_adjustment"</span>].get(0, 100, 100)           <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>
    <span class="org-variable-name">sdi_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"suppression_difficulty_index"</span>].get(0, 100, 100)     <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>
    <span class="org-keyword">assert</span> dem_100_100  <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> slp_100_100  <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> asp_100_100  <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> fbfm_100_100 <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> cc_100_100   <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> ch_100_100   <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> cbh_100_100  <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> cbd_100_100  <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> fsa_100_100  <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> sdi_100_100  <span class="org-operator">==</span> 100100


<span class="org-keyword">def</span> <span class="org-function-name">test_use_layer_lookup_3d</span>():
    <span class="org-variable-name">layer_lookup</span>     <span class="org-operator">=</span> make_layer_lookup()
    <span class="org-variable-name">temp_12_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"temperature"</span>].get(12, 100, 100)
    <span class="org-variable-name">rh_12_100_100</span>    <span class="org-operator">=</span> layer_lookup[<span class="org-string">"relative_humidity"</span>].get(12, 100, 100)
    <span class="org-variable-name">wsp_12_100_100</span>   <span class="org-operator">=</span> layer_lookup[<span class="org-string">"wind_speed_10m"</span>].get(12, 100, 100)
    <span class="org-variable-name">wdir_12_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"upwind_direction"</span>].get(12, 100, 100)
    <span class="org-variable-name">md1_12_100_100</span>   <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_moisture_dead_1hr"</span>].get(12, 100, 100)
    <span class="org-variable-name">md10_12_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_moisture_dead_10hr"</span>].get(12, 100, 100)
    <span class="org-variable-name">md100_12_100_100</span> <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_moisture_dead_100hr"</span>].get(12, 100, 100)
    <span class="org-variable-name">mlh_12_100_100</span>   <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_moisture_live_herbaceous"</span>].get(12, 100, 100)
    <span class="org-variable-name">mlw_12_100_100</span>   <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_moisture_live_woody"</span>].get(12, 100, 100)
    <span class="org-variable-name">fm_12_100_100</span>    <span class="org-operator">=</span> layer_lookup[<span class="org-string">"foliar_moisture"</span>].get(12, 100, 100)
    <span class="org-variable-name">wsa_12_100_100</span>   <span class="org-operator">=</span> layer_lookup[<span class="org-string">"weather_spread_adjustment"</span>].get(12, 100, 100) <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>
    <span class="org-keyword">assert</span> temp_12_100_100  <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> rh_12_100_100    <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> wsp_12_100_100   <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> wdir_12_100_100  <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> md1_12_100_100   <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> md10_12_100_100  <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> md100_12_100_100 <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> mlh_12_100_100   <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> mlw_12_100_100   <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> fm_12_100_100    <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> wsa_12_100_100   <span class="org-operator">==</span> 121010
</pre>
</div>
</div>
</div>

<div id="outline-container-loading-landfire-inputs-(pyretechnics.load_landfire)" class="outline-3">
<h3 id="loading-landfire-inputs-(pyretechnics.load_landfire)"><span class="section-number-3">10.5.</span> Loading LANDFIRE Inputs (pyretechnics.load_landfire)</h3>
<div class="outline-text-3" id="text-loading-landfire-inputs-(pyretechnics.load_landfire)">
<p>
In order to use the functions from <code>pyretechnics.burn_cells</code> (see
section <a href="#burning-cells-on-a-grid-(pyretechnics.burn_cells)">8</a>), we must
first create a collection of <code>SpaceTimeCube</code> objects, representing all
of the input layers that are needed to describe the simulation
environment. A popular source of data for the space-varying
topography, fuels, and vegetation layers are the 30m raster layers
provided by the US LANDFIRE program<sup><a id="fnr.59" class="footref" href="#fn.59" role="doc-backlink">59</a></sup> (see
table <a href="#tab:landfire-layers">11</a> for details).
</p>

<table id="tab:landfire-layers">
<caption class="t-above"><span class="table-number">Table 11:</span> 2022 LANDFIRE Raster Layers</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Layer Name</th>
<th scope="col" class="org-left">Label</th>
<th scope="col" class="org-left">Units</th>
<th scope="col" class="org-right">Min</th>
<th scope="col" class="org-right">Max</th>
<th scope="col" class="org-right">NoData</th>
<th scope="col" class="org-left">Notes</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">SRID</th>
<th scope="col" class="org-left">Cell Size</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Elevation</td>
<td class="org-left">DEM</td>
<td class="org-left">meters above sea level</td>
<td class="org-right">0</td>
<td class="org-right">8850</td>
<td class="org-right">32767</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Slope</td>
<td class="org-left">SLP</td>
<td class="org-left">percent (100 * meters rise / meters run)</td>
<td class="org-right">0</td>
<td class="org-right">400</td>
<td class="org-right">32767</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Aspect</td>
<td class="org-left">ASP</td>
<td class="org-left">degrees CW from North</td>
<td class="org-right">0</td>
<td class="org-right">359</td>
<td class="org-right">32767</td>
<td class="org-left">-1 = no slope</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Fuel Model (S&amp;B 40)</td>
<td class="org-left">FBFM40</td>
<td class="org-left">integer classes</td>
<td class="org-right">91</td>
<td class="org-right">204</td>
<td class="org-right">32767</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Canopy Cover</td>
<td class="org-left">CC</td>
<td class="org-left">percent (100 * canopy area / total area)</td>
<td class="org-right">0</td>
<td class="org-right">95</td>
<td class="org-right">32767</td>
<td class="org-left">0 = no canopy</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Canopy Height</td>
<td class="org-left">CH</td>
<td class="org-left">meters * 10</td>
<td class="org-right">0</td>
<td class="org-right">510</td>
<td class="org-right">32767</td>
<td class="org-left">0 = no canopy</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Canopy Base Height</td>
<td class="org-left">CBH</td>
<td class="org-left">meters * 10</td>
<td class="org-right">0</td>
<td class="org-right">100</td>
<td class="org-right">32767</td>
<td class="org-left">0 = no canopy</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Canopy Bulk Density</td>
<td class="org-left">CBD</td>
<td class="org-left">kg/m^3 * 100</td>
<td class="org-right">0</td>
<td class="org-right">45</td>
<td class="org-right">32767</td>
<td class="org-left">0 = no canopy</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>
</tbody>
</table>

<p>
For convenience, this section introduces functionality to load these
raster layers from files on disk into a Python dictionary of
<code>SpaceTimeCube</code> objects.
</p>
</div>

<div id="outline-container-module-imports-load-landfire" class="outline-4">
<h4 id="module-imports-load-landfire"><span class="section-number-4">10.5.1.</span> Module Imports</h4>
<div class="outline-text-4" id="text-module-imports-load-landfire">
<div class="org-src-container">
<pre class="src src-python" id="load-landfire-imports"><span class="org-keyword">import</span> cython
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> rasterio
<span class="org-keyword">from</span> rasterio.enums <span class="org-keyword">import</span> Resampling
<span class="org-keyword">if</span> cython.compiled:
    <span class="org-keyword">from</span> cython.cimports.pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube
<span class="org-keyword">else</span>:
    <span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube
</pre>
</div>
</div>
</div>

<div id="outline-container-loading-raster-files-with-python-rasterio" class="outline-4">
<h4 id="loading-raster-files-with-python-rasterio"><span class="section-number-4">10.5.2.</span> Loading Raster Files with Python Rasterio</h4>
<div class="outline-text-4" id="text-loading-raster-files-with-python-rasterio">
<p>
We will begin by defining a <code>load_raster</code> function that takes a path
to a raster file (e.g., a GeoTIFF) and returns a dictionary containing
these keys:
</p>

<dl class="org-dl">
<dt>array</dt><dd>raster data as a 3D Numpy array <code>(bands, rows, cols)</code> of the specified <code>dtype</code> (default: <code>float32</code>)</dd>
<dt>metadata</dt><dd>dictionary of raster metadata values (e.g., number of bands/rows/cols, band dtypes, nodata value, georeferencing info)</dd>
</dl>

<div class="org-src-container">
<pre class="src src-python" id="load-raster"><span class="org-keyword">def</span> <span class="org-function-name">raster_metadata</span>(raster):
    <span class="org-keyword">return</span> {
        <span class="org-string">"name"</span>      : raster.name,
        <span class="org-string">"bands"</span>     : raster.count,
        <span class="org-string">"rows"</span>      : raster.height,
        <span class="org-string">"cols"</span>      : raster.width,
        <span class="org-string">"band_types"</span>: {i: dtype <span class="org-keyword">for</span> i, dtype <span class="org-keyword">in</span> <span class="org-builtin">zip</span>(raster.indexes, raster.dtypes)},
        <span class="org-string">"nodata"</span>    : raster.nodata,
        <span class="org-string">"crs"</span>       : raster.crs,
        <span class="org-string">"bounds"</span>    : raster.bounds,
        <span class="org-string">"transform"</span> : raster.transform,
    }


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: rasterio.open can also load chunks of a raster file: https://pypi.org/project/rasterio/</span>
<span class="org-keyword">def</span> <span class="org-function-name">maybe_resample_resolution</span>(resolution, divisor, resampling_policy):
    <span class="org-keyword">if</span> (resolution <span class="org-operator">%</span> divisor <span class="org-operator">==</span> 0):
        <span class="org-keyword">return</span> resolution
    <span class="org-keyword">elif</span> resampling_policy <span class="org-operator">==</span> <span class="org-string">"always_upsample"</span>:
        <span class="org-keyword">return</span> divisor <span class="org-operator">*</span> (resolution <span class="org-operator">//</span> divisor <span class="org-operator">+</span> 1)
    <span class="org-keyword">elif</span> resampling_policy <span class="org-operator">==</span> <span class="org-string">"nearest_match"</span>:
        <span class="org-keyword">return</span> divisor <span class="org-operator">*</span> <span class="org-builtin">max</span>(1, <span class="org-builtin">round</span>(resolution <span class="org-operator">/</span> divisor))
    <span class="org-keyword">else</span>:
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The resampling_policy must be either 'always_upsample' or 'nearest_match'."</span>)


<span class="org-keyword">def</span> <span class="org-function-name">load_raster</span>(file_path, dtype<span class="org-operator">=</span><span class="org-constant">None</span>, cube_shape_divisors<span class="org-operator">=</span>(1,1,1),
                resampling_policy<span class="org-operator">=</span><span class="org-string">"nearest_match"</span>,
                resampling_method<span class="org-operator">=</span>Resampling.nearest):
    <span class="org-doc">"""</span>
<span class="org-doc">    resampling_policy: "always_upsample" or "nearest_match"</span>
<span class="org-doc">    resampling_method: any rasterio.enums.Resampling method</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">with</span> rasterio.<span class="org-builtin">open</span>(file_path, <span class="org-string">"r"</span>) <span class="org-keyword">as</span> input_raster:
        <span class="org-variable-name">metadata</span>  <span class="org-operator">=</span> raster_metadata(input_raster)
        <span class="org-variable-name">bands</span>     <span class="org-operator">=</span> metadata[<span class="org-string">"bands"</span>]
        <span class="org-variable-name">rows</span>      <span class="org-operator">=</span> metadata[<span class="org-string">"rows"</span>]
        <span class="org-variable-name">cols</span>      <span class="org-operator">=</span> metadata[<span class="org-string">"cols"</span>]
        (<span class="org-variable-name">b</span>, <span class="org-variable-name">r</span>, <span class="org-variable-name">c</span>) <span class="org-operator">=</span> cube_shape_divisors
        <span class="org-variable-name">new_bands</span> <span class="org-operator">=</span> maybe_resample_resolution(bands, b, resampling_policy)
        <span class="org-variable-name">new_rows</span>  <span class="org-operator">=</span> maybe_resample_resolution(rows, r, resampling_policy)
        <span class="org-variable-name">new_cols</span>  <span class="org-operator">=</span> maybe_resample_resolution(cols, c, resampling_policy)
        <span class="org-keyword">if</span> new_bands <span class="org-operator">==</span> bands <span class="org-keyword">and</span> new_rows <span class="org-operator">==</span> rows <span class="org-keyword">and</span> new_cols <span class="org-operator">==</span> cols:
            <span class="org-keyword">return</span> {
                <span class="org-string">"array"</span>   : input_raster.read(out_dtype<span class="org-operator">=</span>dtype),
                <span class="org-string">"metadata"</span>: metadata,
            }
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">metadata</span>[<span class="org-string">"bands"</span>]     <span class="org-operator">=</span> new_bands
            <span class="org-variable-name">metadata</span>[<span class="org-string">"rows"</span>]      <span class="org-operator">=</span> new_rows
            <span class="org-variable-name">metadata</span>[<span class="org-string">"cols"</span>]      <span class="org-operator">=</span> new_cols
            <span class="org-variable-name">metadata</span>[<span class="org-string">"transform"</span>] <span class="org-operator">=</span> (input_raster.transform
                                     <span class="org-operator">*</span> input_raster.transform.scale(
                                         cols <span class="org-operator">/</span> new_cols,
                                         rows <span class="org-operator">/</span> new_rows,
                                     ))
            <span class="org-variable-name">array</span> <span class="org-operator">=</span> input_raster.read(
                out_dtype<span class="org-operator">=</span>dtype,
                out_shape<span class="org-operator">=</span>(new_bands, new_rows, new_cols),
                resampling<span class="org-operator">=</span>resampling_method,
            )
            <span class="org-keyword">return</span> {
                <span class="org-string">"array"</span>   : array,
                <span class="org-string">"metadata"</span>: metadata,
            }
</pre>
</div>
</div>
</div>

<div id="outline-container-converting-landfire-units-and-datatypes" class="outline-4">
<h4 id="converting-landfire-units-and-datatypes"><span class="section-number-4">10.5.3.</span> Converting LANDFIRE Units and Datatypes</h4>
<div class="outline-text-4" id="text-converting-landfire-units-and-datatypes">
<p>
The units and datatypes of our LANDFIRE GeoTIFFs are documented in
Table <a href="#tab:landfire-layers">11</a>. In order to make them match those required
by the Pyretechnics Fire Spread API, we need to apply some conversions
during the layer loading process.
</p>

<div class="org-src-container">
<pre class="src src-python" id="load-and-convert-landfire-rasters"><span class="org-variable-name">landfire_array_conversions</span> <span class="org-operator">=</span> {
    <span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Layer Name         : (New dtype, Mult), # New Units                [Min-Max]</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================================</span>
    <span class="org-string">"elevation"</span>          : (<span class="org-string">"float32"</span>, 1.00), <span class="org-comment-delimiter"># </span><span class="org-comment">meters above sea level   [0-8850]</span>
    <span class="org-string">"slope"</span>              : (<span class="org-string">"float32"</span>, 0.01), <span class="org-comment-delimiter"># </span><span class="org-comment">meters rise / meters run [0-4]</span>
    <span class="org-string">"aspect"</span>             : (<span class="org-string">"int16"</span>  , 1   ), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees CW from North    [0-359]</span>
    <span class="org-string">"fuel_model"</span>         : (<span class="org-string">"int16"</span>  , 1   ), <span class="org-comment-delimiter"># </span><span class="org-comment">integer classes          [1-204]</span>
    <span class="org-string">"canopy_cover"</span>       : (<span class="org-string">"float32"</span>, 0.01), <span class="org-comment-delimiter"># </span><span class="org-comment">canopy area / total area [0-0.95]</span>
    <span class="org-string">"canopy_height"</span>      : (<span class="org-string">"float32"</span>, 0.10), <span class="org-comment-delimiter"># </span><span class="org-comment">meters                   [0-51]</span>
    <span class="org-string">"canopy_base_height"</span> : (<span class="org-string">"float32"</span>, 0.10), <span class="org-comment-delimiter"># </span><span class="org-comment">meters                   [0-10]</span>
    <span class="org-string">"canopy_bulk_density"</span>: (<span class="org-string">"float32"</span>, 0.01), <span class="org-comment-delimiter"># </span><span class="org-comment">kilograms/meters^3       [0-0.45]</span>
}


<span class="org-keyword">def</span> <span class="org-function-name">load_and_convert_landfire_rasters</span>(landfire_file_paths):
    <span class="org-variable-name">landfire_rasters</span> <span class="org-operator">=</span> {}

    <span class="org-keyword">for</span> name, path <span class="org-keyword">in</span> landfire_file_paths.items():
        (<span class="org-variable-name">dtype</span>, <span class="org-variable-name">multiplier</span>) <span class="org-operator">=</span> landfire_array_conversions[name]
        <span class="org-variable-name">landfire_rasters</span>[name] <span class="org-operator">=</span> load_raster(path, dtype)
        <span class="org-keyword">if</span> multiplier <span class="org-operator">!=</span> 1:
            <span class="org-variable-name">array</span>  <span class="org-operator">=</span> landfire_rasters[name][<span class="org-string">"array"</span>]
            <span class="org-variable-name">nodata</span> <span class="org-operator">=</span> landfire_rasters[name][<span class="org-string">"metadata"</span>][<span class="org-string">"nodata"</span>]
            <span class="org-variable-name">array</span>[array <span class="org-operator">!=</span> nodata] <span class="org-operator">*=</span> multiplier

    <span class="org-keyword">return</span> landfire_rasters
</pre>
</div>
</div>
</div>

<div id="outline-container-verifying-raster-constraints" class="outline-4">
<h4 id="verifying-raster-constraints"><span class="section-number-4">10.5.4.</span> Verifying Raster Constraints</h4>
<div class="outline-text-4" id="text-verifying-raster-constraints">
<p>
In order to work with the Pyretechnics Fire Spread API, all rasters
must meet certain requirements:
</p>

<ol class="org-ol">
<li>All rasters must have array shapes <code>(bands, rows, cols)</code> that are
less than or equal to a user-specified space-time cube shape
<code>(t,y,x)</code>.</li>
<li>All rasters must share the same spatial extent and projection.</li>
</ol>

<p>
Below we implement functions to check these constraints:
</p>

<div class="org-src-container">
<pre class="src src-python" id="verify-raster-constraints"><span class="org-keyword">def</span> <span class="org-function-name">verify_cube_compatible_dimensions</span>(cube_shape, rasters):
    <span class="org-variable-name">cube_shape_</span> <span class="org-operator">=</span> np.asarray(cube_shape)
    <span class="org-keyword">for</span> r <span class="org-keyword">in</span> rasters:
        <span class="org-variable-name">raster_shape</span> <span class="org-operator">=</span> np.asarray((r[<span class="org-string">"metadata"</span>][<span class="org-string">"bands"</span>],
                                   r[<span class="org-string">"metadata"</span>][<span class="org-string">"rows"</span>],
                                   r[<span class="org-string">"metadata"</span>][<span class="org-string">"cols"</span>]))
        <span class="org-keyword">if</span> np.<span class="org-builtin">any</span>(raster_shape <span class="org-operator">&gt;</span> cube_shape_):
            <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"Some raster dimensions exceed the space-time cube dimensions."</span>)

    <span class="org-keyword">return</span> <span class="org-constant">True</span>


<span class="org-keyword">def</span> <span class="org-function-name">verify_same_georeferences</span>(rasters):
    <span class="org-variable-name">georeferences</span> <span class="org-operator">=</span> [
        (r[<span class="org-string">"metadata"</span>][<span class="org-string">"crs"</span>],
         r[<span class="org-string">"metadata"</span>][<span class="org-string">"bounds"</span>],
         r[<span class="org-string">"metadata"</span>][<span class="org-string">"transform"</span>])
        <span class="org-keyword">for</span> r <span class="org-keyword">in</span> rasters
    ]
    <span class="org-keyword">if</span> <span class="org-builtin">len</span>(<span class="org-builtin">set</span>(georeferences)) <span class="org-operator">==</span> 1:
        <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">else</span>:
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"All rasters do not share the same georeferences."</span>)


<span class="org-keyword">def</span> <span class="org-function-name">verify_raster_constraints</span>(cube_shape, rasters):
    <span class="org-keyword">return</span> verify_cube_compatible_dimensions(cube_shape, rasters) <span class="org-keyword">and</span> verify_same_georeferences(rasters)
</pre>
</div>
</div>
</div>

<div id="outline-container-converting-rasters-to-spacetimecubes" class="outline-4">
<h4 id="converting-rasters-to-spacetimecubes"><span class="section-number-4">10.5.5.</span> Converting Rasters to SpaceTimeCubes</h4>
<div class="outline-text-4" id="text-converting-rasters-to-spacetimecubes">
<p>
Another requirement of the Pyretechnics Fire Spread API is that each
input layer must be specified as a <code>SpaceTimeCube</code> or
<code>LazySpaceTimeCube</code> object (see section <a href="#loading-data-into-the-3d-space-time-cube-(pyretechnics.space_time_cube)">3</a>). This abstracts away
the underlying data representation (e.g., an ND array, a single
constant value, a random sampling function), allowing many different
sources of information to interoperate through a simple unified
interface.
</p>

<p>
For our LANDFIRE use case, the following function converts a
dictionary of single-band rasters <code>(1, rows, cols)</code> into a dictionary
of <code>SpaceTimeCube</code> objects, that always return the same value for each
<code>(t,y,x)</code> coordinate regardless of the time value <code>t</code> specified in
lookup calls.
</p>

<div class="org-src-container">
<pre class="src src-python" id="convert-rasters-to-space-time-cubes"><span class="org-keyword">def</span> <span class="org-function-name">convert_rasters_to_space_time_cubes</span>(cube_shape, raster_dict):
    <span class="org-variable-name">fn_dict</span> <span class="org-operator">=</span> {}

    <span class="org-keyword">for</span> name, raster <span class="org-keyword">in</span> raster_dict.items():
        <span class="org-variable-name">fn_dict</span>[name] <span class="org-operator">=</span> SpaceTimeCube(cube_shape, raster[<span class="org-string">"array"</span>])

    <span class="org-keyword">return</span> fn_dict
</pre>
</div>
</div>
</div>

<div id="outline-container-putting-it-all-together" class="outline-4">
<h4 id="putting-it-all-together"><span class="section-number-4">10.5.6.</span> Putting It All Together</h4>
<div class="outline-text-4" id="text-putting-it-all-together">
<p>
By combining the functions defined in the previous sections, we can
now read in a dictionary of layer names to file paths, load the
associated rasters and apply the correct dtype and unit conversions,
verify all of our raster constraints, and wrap each raster's array
with a <code>SpaceTimeCube</code> object.
</p>

<div class="org-src-container">
<pre class="src src-python" id="read-landfire-rasters-as-space-time-cubes"><span class="org-keyword">def</span> <span class="org-function-name">read_landfire_rasters_as_space_time_cubes</span>(cube_shape, landfire_file_paths):
    <span class="org-variable-name">landfire_rasters</span> <span class="org-operator">=</span> load_and_convert_landfire_rasters(landfire_file_paths)
    <span class="org-keyword">if</span> verify_raster_constraints(cube_shape, landfire_rasters.values()):
        <span class="org-keyword">return</span> convert_rasters_to_space_time_cubes(cube_shape, landfire_rasters)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-cython-pxd-files" class="outline-3">
<h3 id="cython-pxd-files"><span class="section-number-3">10.6.</span> Cython PXD Files</h3>
<div class="outline-text-3" id="text-cython-pxd-files">
<p>
The following sections contain the PXD (Cython description) files used
by the Cython compiler to enable fast C-level linking between modules.
</p>
</div>

<div id="outline-container-pyretechnics-cy-types-pxd" class="outline-4">
<h4 id="pyretechnics-cy-types-pxd"><span class="section-number-4">10.6.1.</span> pyretechnics.cy_types</h4>
<div class="outline-text-4" id="text-pyretechnics-cy-types-pxd">
<div class="org-src-container">
<pre class="src src-python" id="cy-types-pxd"><span class="org-comment-delimiter">#</span><span class="org-comment">==================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Compile-time-defined type aliases</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==================================================</span>

ctypedef Py_ssize_t pyidx
ctypedef (<span class="org-builtin">float</span>, <span class="org-builtin">float</span>) vec_xy
ctypedef (<span class="org-builtin">float</span>, <span class="org-builtin">float</span>, <span class="org-builtin">float</span>) vec_xyz
ctypedef (pyidx, pyidx) coord_yx
ctypedef (pyidx, pyidx, pyidx) coord_tyx
ctypedef (<span class="org-builtin">float</span>, <span class="org-builtin">float</span>) fcatarr
ctypedef (<span class="org-builtin">float</span>, <span class="org-builtin">float</span>, <span class="org-builtin">float</span>, <span class="org-builtin">float</span>, <span class="org-builtin">float</span>, <span class="org-builtin">float</span>) fclaarr
ctypedef (<span class="org-builtin">float</span>, <span class="org-builtin">float</span>, <span class="org-builtin">float</span>, <span class="org-builtin">float</span>, <span class="org-builtin">float</span>, <span class="org-builtin">float</span>, <span class="org-builtin">float</span>, <span class="org-builtin">float</span>, <span class="org-builtin">float</span>, <span class="org-builtin">float</span>, <span class="org-builtin">float</span>, <span class="org-builtin">float</span>, <span class="org-builtin">float</span>) CompactFuelModel

cdef struct FuelModel:
    <span class="org-builtin">int</span> number
    <span class="org-builtin">float</span> delta
    fclaarr M_x
    fclaarr M_f
    fclaarr w_o
    fclaarr sigma
    fclaarr h
    fclaarr rho_p
    fclaarr S_T
    fclaarr S_e
    bint dynamic
    bint burnable
    fclaarr exp_A_sigma
    fclaarr firemod_size_classes
    fclaarr f_ij
    fcatarr f_i
    fclaarr g_ij

cdef struct ProjectedVectors:
    vec_xyz wind_vector_3d
    vec_xyz slope_vector_3d

cdef struct FireBehaviorMin:
    <span class="org-builtin">float</span> base_spread_rate
    <span class="org-builtin">float</span> base_fireline_intensity
    <span class="org-builtin">float</span> max_effective_wind_speed
    <span class="org-builtin">float</span> _phiS_G
    <span class="org-builtin">float</span> _phiW_scalr
    <span class="org-builtin">float</span> _phiW_expnt
    <span class="org-builtin">float</span> _ws_scalr
    <span class="org-builtin">float</span> _ws_expnt

cdef struct FireBehaviorMax:
    <span class="org-builtin">int</span> max_fire_type
    <span class="org-builtin">float</span> max_spread_rate
    vec_xyz max_spread_direction
    <span class="org-builtin">float</span> max_fireline_intensity
    <span class="org-builtin">float</span> max_flame_length
    <span class="org-builtin">float</span> length_to_width_ratio
    <span class="org-builtin">float</span> eccentricity
    <span class="org-builtin">float</span> critical_spread_rate

cdef struct SpreadBehavior:
    <span class="org-builtin">float</span> dphi_dt
    <span class="org-builtin">int</span> fire_type
    <span class="org-builtin">float</span> spread_rate
    vec_xyz spread_direction
    <span class="org-builtin">float</span> fireline_intensity
    <span class="org-builtin">float</span> flame_length

cdef struct CrownSpreadInfo:
    <span class="org-builtin">int</span> fire_type
    <span class="org-builtin">float</span> spread_rate
    <span class="org-builtin">float</span> critical_spread_rate

cdef struct SpotConfig:
    <span class="org-builtin">long</span> <span class="org-builtin">long</span> random_seed
    <span class="org-builtin">float</span> firebrands_per_unit_heat
    <span class="org-builtin">float</span> downwind_distance_mean
    <span class="org-builtin">float</span> fireline_intensity_exponent
    <span class="org-builtin">float</span> wind_speed_exponent
    <span class="org-builtin">float</span> downwind_variance_mean_ratio
    <span class="org-builtin">float</span> crosswind_distance_stdev
    <span class="org-builtin">float</span> decay_distance

cdef struct JumpDistribution:
    <span class="org-builtin">float</span> mu_x
    <span class="org-builtin">float</span> sigma_x
    <span class="org-builtin">float</span> sigma_y

cdef struct PartialedEllWavelet:
    vec_xyz Vh_3d
    <span class="org-builtin">float</span> ewc_A
    <span class="org-builtin">float</span> ewc_B
    <span class="org-builtin">float</span> ewc_C

cdef struct CellInputs:
    <span class="org-builtin">float</span> slope
    <span class="org-builtin">float</span> aspect
    <span class="org-builtin">float</span> fuel_model_number
    <span class="org-builtin">float</span> canopy_cover
    <span class="org-builtin">float</span> canopy_height
    <span class="org-builtin">float</span> canopy_base_height
    <span class="org-builtin">float</span> canopy_bulk_density
    <span class="org-builtin">float</span> wind_speed_10m
    <span class="org-builtin">float</span> upwind_direction
    <span class="org-builtin">float</span> fuel_moisture_dead_1hr
    <span class="org-builtin">float</span> fuel_moisture_dead_10hr
    <span class="org-builtin">float</span> fuel_moisture_dead_100hr
    <span class="org-builtin">float</span> fuel_moisture_live_herbaceous
    <span class="org-builtin">float</span> fuel_moisture_live_woody
    <span class="org-builtin">float</span> foliar_moisture
    <span class="org-builtin">float</span> fuel_spread_adjustment
    <span class="org-builtin">float</span> weather_spread_adjustment

cdef struct EllipticalInfo:
    coord_yx cell_index
    vec_xy elevation_gradient
    PartialedEllWavelet surface_wavelet
    PartialedEllWavelet crown_wavelet
    <span class="org-builtin">float</span> crowning_spread_rate

cdef struct Pass1CellOutput:
    coord_yx cell_index
    vec_xy phi_gradient_xy
    <span class="org-builtin">float</span> dphi_dt_flim
    <span class="org-builtin">float</span> phi_old
</pre>
</div>
</div>
</div>

<div id="outline-container-pyretechnics-conversion-pxd" class="outline-4">
<h4 id="pyretechnics-conversion-pxd"><span class="section-number-4">10.6.2.</span> pyretechnics.conversion</h4>
<div class="outline-text-4" id="text-pyretechnics-conversion-pxd">
<div class="org-src-container">
<pre class="src src-python" id="conversion-pxd"><span class="org-keyword">from</span> pyretechnics.cy_types cimport vec_xy

cpdef <span class="org-builtin">float</span> rad_to_deg(<span class="org-builtin">float</span> radians) noexcept
cpdef <span class="org-builtin">float</span> deg_to_rad(<span class="org-builtin">float</span> degrees) noexcept
cpdef <span class="org-builtin">float</span> deg_to_ratio(<span class="org-builtin">float</span> degrees) noexcept
cpdef <span class="org-builtin">float</span> ratio_to_deg(<span class="org-builtin">float</span> ratio) noexcept
cpdef <span class="org-builtin">float</span> F_to_K(<span class="org-builtin">float</span> degrees) noexcept
cpdef <span class="org-builtin">float</span> K_to_F(<span class="org-builtin">float</span> degrees) noexcept
cpdef <span class="org-builtin">float</span> F_to_C(<span class="org-builtin">float</span> degrees) noexcept
cpdef <span class="org-builtin">float</span> C_to_F(<span class="org-builtin">float</span> degrees) noexcept
cpdef <span class="org-builtin">float</span> ch_to_m(<span class="org-builtin">float</span> ch) noexcept
cpdef <span class="org-builtin">float</span> m_to_ch(<span class="org-builtin">float</span> m) noexcept
cpdef <span class="org-builtin">float</span> m_to_ft(<span class="org-builtin">float</span> m) noexcept
cpdef <span class="org-builtin">float</span> ft_to_m(<span class="org-builtin">float</span> ft) noexcept
cpdef <span class="org-builtin">float</span> mph_to_mps(<span class="org-builtin">float</span> mph) noexcept
cpdef <span class="org-builtin">float</span> mps_to_mph(<span class="org-builtin">float</span> mps) noexcept
cpdef <span class="org-builtin">float</span> km_hr_to_mps(<span class="org-builtin">float</span> km_hr) noexcept
cpdef <span class="org-builtin">float</span> mps_to_km_hr(<span class="org-builtin">float</span> mps) noexcept
cpdef <span class="org-builtin">float</span> mph_to_km_hr(<span class="org-builtin">float</span> mph) noexcept
cpdef <span class="org-builtin">float</span> km_hr_to_mph(<span class="org-builtin">float</span> km_hr) noexcept
cpdef <span class="org-builtin">float</span> m_min_to_km_hr(<span class="org-builtin">float</span> m_min) noexcept
cpdef <span class="org-builtin">float</span> km_hr_to_m_min(<span class="org-builtin">float</span> km_hr) noexcept
cpdef <span class="org-builtin">float</span> m_min_to_mph(<span class="org-builtin">float</span> m_min) noexcept
cpdef <span class="org-builtin">float</span> mph_to_m_min(<span class="org-builtin">float</span> mph) noexcept
cpdef <span class="org-builtin">float</span> mps_to_fpm(<span class="org-builtin">float</span> mps) noexcept
cpdef <span class="org-builtin">float</span> fpm_to_mps(<span class="org-builtin">float</span> fpm) noexcept
cpdef <span class="org-builtin">float</span> mph_to_fpm(<span class="org-builtin">float</span> mph) noexcept
cpdef <span class="org-builtin">float</span> fpm_to_mph(<span class="org-builtin">float</span> fpm) noexcept
cpdef <span class="org-builtin">float</span> Btu_ft_s_to_kW_m(<span class="org-builtin">float</span> Btu_ft_s) noexcept
cpdef <span class="org-builtin">float</span> kW_m_to_Btu_ft_s(<span class="org-builtin">float</span> kW_m) noexcept
cpdef <span class="org-builtin">float</span> Btu_lb_to_kJ_kg(<span class="org-builtin">float</span> Btu_lb) noexcept
cpdef <span class="org-builtin">float</span> kJ_kg_to_Btu_lb(<span class="org-builtin">float</span> kJ_kg) noexcept
cpdef <span class="org-builtin">float</span> kg_m3_to_lb_ft3(<span class="org-builtin">float</span> kg_m3) noexcept
cpdef <span class="org-builtin">float</span> lb_ft3_to_kg_m3(<span class="org-builtin">float</span> lb_ft3) noexcept
cpdef <span class="org-builtin">float</span> percent_to_dec(<span class="org-builtin">float</span> percent) noexcept
cpdef <span class="org-builtin">float</span> dec_to_percent(<span class="org-builtin">float</span> decimal) noexcept
cpdef <span class="org-builtin">float</span> sec_to_min(<span class="org-builtin">float</span> seconds) noexcept
cpdef <span class="org-builtin">float</span> min_to_sec(<span class="org-builtin">float</span> minutes) noexcept
cpdef <span class="org-builtin">float</span> ms_to_min(<span class="org-builtin">float</span> milliseconds) noexcept
cpdef <span class="org-builtin">float</span> min_to_ms(<span class="org-builtin">float</span> minutes) noexcept
cpdef <span class="org-builtin">float</span> hour_to_min(<span class="org-builtin">float</span> hours) noexcept
cpdef <span class="org-builtin">float</span> min_to_hour(<span class="org-builtin">float</span> minutes) noexcept
cpdef <span class="org-builtin">float</span> day_to_min(<span class="org-builtin">float</span> days) noexcept
cpdef <span class="org-builtin">float</span> min_to_day(<span class="org-builtin">float</span> minutes) noexcept
cpdef vec_xy cartesian_to_polar(<span class="org-builtin">float</span> x, <span class="org-builtin">float</span> y) noexcept
cpdef vec_xy polar_to_cartesian(<span class="org-builtin">float</span> r, <span class="org-builtin">float</span> theta) noexcept
cpdef vec_xy cartesian_to_azimuthal(<span class="org-builtin">float</span> x, <span class="org-builtin">float</span> y) noexcept
cpdef vec_xy azimuthal_to_cartesian(<span class="org-builtin">float</span> r, <span class="org-builtin">float</span> azimuth) noexcept
cpdef <span class="org-builtin">float</span> opposite_direction(<span class="org-builtin">float</span> theta) noexcept
cpdef <span class="org-builtin">float</span> wind_speed_10m_to_wind_speed_20ft(<span class="org-builtin">float</span> wind_speed_10m) noexcept
cpdef <span class="org-builtin">float</span> wind_speed_20ft_to_wind_speed_10m(<span class="org-builtin">float</span> wind_speed_20ft) noexcept
</pre>
</div>
</div>
</div>

<div id="outline-container-pyretechnics-vector-utils-pxd" class="outline-4">
<h4 id="pyretechnics-vector-utils-pxd"><span class="section-number-4">10.6.3.</span> pyretechnics.vector_utils</h4>
<div class="outline-text-4" id="text-pyretechnics-vector-utils-pxd">
<div class="org-src-container">
<pre class="src src-python" id="vector-utils-pxd"><span class="org-keyword">from</span> pyretechnics.cy_types cimport vec_xy, vec_xyz

cpdef <span class="org-builtin">float</span> dot_2d(vec_xy vector1, vec_xy vector2) noexcept
cpdef <span class="org-builtin">float</span> dot_3d(vec_xyz vector1, vec_xyz vector2) noexcept
cpdef vec_xy scale_2d(<span class="org-builtin">float</span> scalar, vec_xy vector) noexcept
cpdef vec_xyz scale_3d(<span class="org-builtin">float</span> scalar, vec_xyz vector) noexcept
cpdef vec_xy add_2d(vec_xy vector1, vec_xy vector2) noexcept
cpdef vec_xyz add_3d(vec_xyz vector1, vec_xyz vector2) noexcept
cpdef <span class="org-builtin">float</span> vector_magnitude_2d(vec_xy vector) noexcept
cpdef <span class="org-builtin">float</span> vector_magnitude_3d(vec_xyz vector) noexcept
cpdef vec_xy as_unit_vector_2d(vec_xy vector) noexcept
cpdef vec_xyz as_unit_vector_3d(vec_xyz vector) noexcept
cpdef vec_xyz to_slope_plane(vec_xy vector_2d, vec_xy elevation_gradient) noexcept
cpdef vec_xy to_horizontal_plane(vec_xyz vector_3d) noexcept
cpdef <span class="org-builtin">float</span> spread_direction_vector_to_angle(vec_xyz vector_3d) noexcept
cpdef vec_xyz get_slope_normal_vector(vec_xy elevation_gradient) noexcept
cpdef vec_xyz cross_3d(vec_xyz vector1, vec_xyz vector2) noexcept
cpdef vec_xyz rotate_on_sloped_plane(vec_xyz vector, <span class="org-builtin">float</span> theta, <span class="org-builtin">float</span> slope, <span class="org-builtin">float</span> aspect) noexcept
</pre>
</div>
</div>
</div>

<div id="outline-container-pyretechnics-random-pxd" class="outline-4">
<h4 id="pyretechnics-random-pxd"><span class="section-number-4">10.6.4.</span> pyretechnics.random</h4>
<div class="outline-text-4" id="text-pyretechnics-random-pxd">
<div class="org-src-container">
<pre class="src src-python" id="random-pxd"><span class="org-keyword">from</span> pyretechnics.cy_types cimport pyidx

cdef <span class="org-keyword">class</span> <span class="org-type">BufferedRandGen</span>:
    cdef <span class="org-builtin">object</span> numpy_rand     <span class="org-comment-delimiter"># </span><span class="org-comment">TODO: object -&gt; Generator</span>
    cdef <span class="org-builtin">float</span>[::1] uniform_buf
    cdef pyidx uniform_pos
    cdef <span class="org-builtin">float</span>[::1] normal_buf
    cdef pyidx normal_pos
    cdef <span class="org-builtin">long</span> <span class="org-builtin">long</span>[::1] poisson16_buf
    cdef pyidx poisson16_pos
    cdef <span class="org-builtin">long</span> <span class="org-builtin">long</span>[::1] poisson1_buf
    cdef pyidx poisson1_pos
    cdef double[::1] poisson_exp_buf
    cdef pyidx poisson_exp_pos
    cdef <span class="org-builtin">long</span> <span class="org-builtin">long</span> next_poisson(BufferedRandGen <span class="org-keyword">self</span>, double M) noexcept
    cdef <span class="org-builtin">float</span> next_uniform(BufferedRandGen <span class="org-keyword">self</span>) noexcept
    cdef <span class="org-builtin">float</span> next_normal(BufferedRandGen <span class="org-keyword">self</span>) noexcept
</pre>
</div>
</div>
</div>

<div id="outline-container-pyretechnics-space-time-cube-pxd" class="outline-4">
<h4 id="pyretechnics-space-time-cube-pxd"><span class="section-number-4">10.6.5.</span> pyretechnics.space_time_cube</h4>
<div class="outline-text-4" id="text-pyretechnics-space-time-cube-pxd">
<div class="org-src-container">
<pre class="src src-python" id="space-time-cube-pxd">cimport numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pyretechnics.cy_types cimport pyidx

cdef bint is_pos_int(<span class="org-builtin">object</span> x) noexcept
cdef <span class="org-builtin">int</span> divide_evenly(<span class="org-builtin">int</span> dividend, <span class="org-builtin">int</span> divisor)
cpdef (pyidx, pyidx) to_positive_index_range(<span class="org-builtin">object</span> index_range, pyidx axis_length) noexcept
cdef np.ndarray stretch_array(np.ndarray old_array, <span class="org-builtin">int</span> new_length, <span class="org-builtin">float</span> repetitions)
cdef np.ndarray maybe_repeat_array(np.ndarray maybe_array, (pyidx, <span class="org-builtin">float</span>) axis_repetitions)

cdef <span class="org-keyword">class</span> <span class="org-type">ISpaceTimeCube</span>:
    cdef <span class="org-builtin">float</span> get(ISpaceTimeCube <span class="org-keyword">self</span>, pyidx t, pyidx y, pyidx x) noexcept

cdef <span class="org-keyword">class</span> <span class="org-type">SpaceTimeCube</span>(ISpaceTimeCube):
    cdef public <span class="org-builtin">int</span> ndim
    cdef public unsigned <span class="org-builtin">long</span> <span class="org-builtin">long</span> size
    cdef public (<span class="org-builtin">int</span>, <span class="org-builtin">int</span>, <span class="org-builtin">int</span>) shape
    cdef public <span class="org-builtin">object</span> base
    cdef public <span class="org-builtin">float</span> t_repetitions
    cdef public <span class="org-builtin">float</span> y_repetitions
    cdef public <span class="org-builtin">float</span> x_repetitions
    <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: We use const (read-only MemoryView) so that Cython will accept read-only arrays, which is required for shared-memory parallelism.</span>
    cdef public const <span class="org-builtin">float</span>[:,:,::1] data
    cpdef <span class="org-builtin">float</span> get(SpaceTimeCube <span class="org-keyword">self</span>, pyidx t, pyidx y, pyidx x) noexcept
    cpdef np.ndarray getTimeSeries(SpaceTimeCube <span class="org-keyword">self</span>, <span class="org-builtin">object</span> t_range, pyidx y, pyidx x)
    cpdef np.ndarray getSpatialPlane(SpaceTimeCube <span class="org-keyword">self</span>, pyidx t, <span class="org-builtin">object</span> y_range, <span class="org-builtin">object</span> x_range)
    cpdef np.ndarray getSubcube(SpaceTimeCube <span class="org-keyword">self</span>, <span class="org-builtin">object</span> t_range, <span class="org-builtin">object</span> y_range, <span class="org-builtin">object</span> x_range)
    <span class="org-comment-delimiter"># </span><span class="org-comment">def getFullyRealizedCube(self, cache=False)</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">def releaseFullyRealizedCube(self)</span>

cdef <span class="org-keyword">class</span> <span class="org-type">LazySpaceTimeCube</span>(ISpaceTimeCube):
    cdef public <span class="org-builtin">int</span> ndim
    cdef public unsigned <span class="org-builtin">long</span> <span class="org-builtin">long</span> size
    cdef public (<span class="org-builtin">int</span>, <span class="org-builtin">int</span>, <span class="org-builtin">int</span>) shape
    cdef public (<span class="org-builtin">int</span>, <span class="org-builtin">int</span>, <span class="org-builtin">int</span>) subcube_shape
    cdef public (<span class="org-builtin">int</span>, <span class="org-builtin">int</span>, <span class="org-builtin">int</span>) cache_shape
    cdef public np.ndarray cache
    cdef public <span class="org-builtin">object</span> load_subcube
    cdef SpaceTimeCube __getOrLoadSubcube(
        LazySpaceTimeCube <span class="org-keyword">self</span>,
        pyidx cache_t,
        pyidx cache_y,
        pyidx cache_x,
        )
    cpdef <span class="org-builtin">float</span> get(LazySpaceTimeCube <span class="org-keyword">self</span>, pyidx t, pyidx y, pyidx x) noexcept
    <span class="org-comment-delimiter"># </span><span class="org-comment">def getTimeSeries(self, t_range, y, x)</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">def getSpatialPlane(self, t, y_range, x_range)</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">def getSubcube(self, t_range, y_range, x_range)</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">def getFullyRealizedCube(self, cache=False)</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">def releaseFullyRealizedCube(self)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-pyretechnics-fuel-models-pxd" class="outline-4">
<h4 id="pyretechnics-fuel-models-pxd"><span class="section-number-4">10.6.6.</span> pyretechnics.fuel_models</h4>
<div class="outline-text-4" id="text-pyretechnics-fuel-models-pxd">
<div class="org-src-container">
<pre class="src src-python" id="fuel-models-pxd"><span class="org-keyword">from</span> pyretechnics.cy_types cimport fclaarr, CompactFuelModel, FuelModel

cdef <span class="org-builtin">dict</span>[<span class="org-builtin">int</span>, CompactFuelModel] compact_fuel_model_table

cdef <span class="org-builtin">float</span> <span class="org-variable-name">almost_zero</span> <span class="org-operator">=</span> 1e<span class="org-operator">-</span>6

cdef bint is_burnable_fuel_model_number(<span class="org-builtin">int</span> fuel_model_number) noexcept

cdef <span class="org-builtin">float</span> compute_exp_A_sigma(<span class="org-builtin">float</span> A, <span class="org-builtin">float</span> sigma_ij) noexcept

cdef <span class="org-builtin">float</span> compute_firemod_size_class(<span class="org-builtin">float</span> sigma_i) noexcept

cdef FuelModel expand_compact_fuel_model(<span class="org-builtin">int</span> fuel_model_number) noexcept

cdef <span class="org-builtin">dict</span>[<span class="org-builtin">int</span>, FuelModel] fuel_model_table

cpdef <span class="org-builtin">list</span>[<span class="org-builtin">int</span>] list_fuel_model_numbers()

cpdef <span class="org-builtin">list</span>[FuelModel] list_fuel_models()

cpdef bint fuel_model_exists(<span class="org-builtin">int</span> fuel_model_number) noexcept

cpdef FuelModel get_fuel_model(<span class="org-builtin">int</span> fuel_model_number) noexcept

cdef FuelModel add_dynamic_fuel_loading(FuelModel fuel_model, fclaarr M_f) noexcept

cdef <span class="org-builtin">float</span> compute_gij(fclaarr firemod_size_classes, fclaarr f_ij, <span class="org-builtin">float</span> firemod_size_class_ij, bint is_dead) noexcept

cdef FuelModel add_weighting_factors(FuelModel fuel_model) noexcept

cdef FuelModel add_live_moisture_of_extinction(FuelModel fuel_model) noexcept

cpdef FuelModel moisturize(FuelModel fuel_model, fclaarr fuel_moisture) noexcept
</pre>
</div>
</div>
</div>

<div id="outline-container-pyretechnics-surface-fire-pxd" class="outline-4">
<h4 id="pyretechnics-surface-fire-pxd"><span class="section-number-4">10.6.7.</span> pyretechnics.surface_fire</h4>
<div class="outline-text-4" id="text-pyretechnics-surface-fire-pxd">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-pxd"><span class="org-keyword">from</span> pyretechnics.cy_types cimport vec_xyz, fcatarr, fclaarr, FuelModel, ProjectedVectors, \
     FireBehaviorMin, FireBehaviorMax, SpreadBehavior

cdef <span class="org-builtin">float</span> calc_surface_area_to_volume_ratio(fcatarr f_i, fclaarr f_ij, fclaarr sigma) noexcept

cdef <span class="org-builtin">float</span> calc_packing_ratio(fclaarr w_o, fclaarr rho_p, <span class="org-builtin">float</span> delta) noexcept

cdef <span class="org-builtin">float</span> calc_optimum_packing_ratio(<span class="org-builtin">float</span> sigma_prime) noexcept

cdef fcatarr calc_mineral_damping_coefficients(fclaarr f_ij, fclaarr S_e) noexcept

cdef fcatarr calc_moisture_damping_coefficients(fclaarr f_ij, fclaarr M_f, fclaarr M_x) noexcept

cdef fcatarr calc_low_heat_content(fclaarr f_ij, fclaarr h) noexcept

cdef fcatarr calc_net_fuel_loading(fclaarr g_ij, fclaarr w_o, fclaarr S_T) noexcept

cdef <span class="org-builtin">float</span> calc_heat_per_unit_area(fcatarr eta_S_i, fcatarr eta_M_i, fcatarr h_i, fcatarr W_n_i) noexcept

cdef <span class="org-builtin">float</span> calc_optimum_reaction_velocity(<span class="org-builtin">float</span> sigma_prime, <span class="org-builtin">float</span> beta, <span class="org-builtin">float</span> beta_op) noexcept

cdef <span class="org-builtin">float</span> calc_reaction_intensity(
    FuelModel moisturized_fuel_model,
    <span class="org-builtin">float</span> sigma_prime,
    <span class="org-builtin">float</span> beta,
    <span class="org-builtin">float</span> beta_op,
    ) noexcept

cdef <span class="org-builtin">float</span> calc_propagating_flux_ratio(<span class="org-builtin">float</span> sigma_prime, <span class="org-builtin">float</span> beta) noexcept

cdef <span class="org-builtin">float</span> calc_heat_source(<span class="org-builtin">float</span> I_R, <span class="org-builtin">float</span> xi) noexcept

cdef <span class="org-builtin">float</span> calc_ovendry_bulk_density(fclaarr w_o, <span class="org-builtin">float</span> delta) noexcept

cdef fclaarr calc_effective_heating_number_distribution(fclaarr sigma) noexcept

cdef fclaarr calc_heat_of_preignition_distribution(fclaarr M_f) noexcept

cdef <span class="org-builtin">float</span> calc_heat_sink(fcatarr f_i, fclaarr f_ij, <span class="org-builtin">float</span> rho_b, fclaarr epsilon_ij, fclaarr Q_ig_ij) noexcept

cdef <span class="org-builtin">float</span> calc_spread_rate(<span class="org-builtin">float</span> heat_source, <span class="org-builtin">float</span> heat_sink) noexcept

cdef <span class="org-builtin">float</span> calc_residence_time(<span class="org-builtin">float</span> sigma_prime) noexcept

cdef <span class="org-builtin">float</span> calc_flame_depth(<span class="org-builtin">float</span> spread_rate, <span class="org-builtin">float</span> residence_time) noexcept

cdef <span class="org-builtin">float</span> calc_fireline_intensity(<span class="org-builtin">float</span> reaction_intensity, <span class="org-builtin">float</span> flame_depth) noexcept

cdef <span class="org-builtin">float</span> calc_flame_length(<span class="org-builtin">float</span> fireline_intensity) noexcept

cpdef <span class="org-builtin">float</span> calc_areal_heat_output(<span class="org-builtin">float</span> spread_rate, <span class="org-builtin">float</span> fireline_intensity) noexcept

cdef <span class="org-builtin">float</span> calc_max_effective_wind_speed(<span class="org-builtin">float</span> reaction_intensity) noexcept

cdef <span class="org-builtin">float</span> get_phi_S(FireBehaviorMin sfmin, <span class="org-builtin">float</span> slope) noexcept

cdef <span class="org-builtin">float</span> get_phi_W(FireBehaviorMin sfmin, <span class="org-builtin">float</span> midflame_wind_speed) noexcept

cdef <span class="org-builtin">float</span> get_wind_speed(FireBehaviorMin sfmin, <span class="org-builtin">float</span> phi_W) noexcept

cdef FireBehaviorMin make_surface_fire_min(
    <span class="org-builtin">float</span> base_spread_rate,
    <span class="org-builtin">float</span> base_fireline_intensity,
    <span class="org-builtin">float</span> max_effective_wind_speed,
    <span class="org-builtin">float</span> B,
    <span class="org-builtin">float</span> C,
    <span class="org-builtin">float</span> F,
    <span class="org-builtin">float</span> beta,
    ) noexcept

cpdef FireBehaviorMin calc_surface_fire_behavior_no_wind_no_slope(
    FuelModel moisturized_fuel_model,
    <span class="org-builtin">float</span> spread_rate_adjustment<span class="org-operator">=</span>?,
    ) noexcept

cdef <span class="org-builtin">float</span> calc_wind_adjustment_factor(<span class="org-builtin">float</span> fuel_bed_depth, <span class="org-builtin">float</span> canopy_height, <span class="org-builtin">float</span> canopy_cover) noexcept

cpdef <span class="org-builtin">float</span> calc_midflame_wind_speed(
    <span class="org-builtin">float</span> wind_speed_20ft,
    <span class="org-builtin">float</span> fuel_bed_depth,
    <span class="org-builtin">float</span> canopy_height,
    <span class="org-builtin">float</span> canopy_cover,
    ) noexcept

cdef ProjectedVectors project_wind_and_slope_vectors_3d(
    <span class="org-builtin">float</span> wind_speed,
    <span class="org-builtin">float</span> downwind_direction,
    <span class="org-builtin">float</span> slope,
    <span class="org-builtin">float</span> upslope_direction,
    ) noexcept

cdef vec_xyz get_phi_E(vec_xyz wind_vector_3d, vec_xyz slope_vector_3d, <span class="org-builtin">float</span> phi_W, <span class="org-builtin">float</span> phi_S) noexcept

cdef <span class="org-builtin">float</span> surface_length_to_width_ratio(<span class="org-builtin">float</span> effective_wind_speed, <span class="org-builtin">str</span> model<span class="org-operator">=</span>?)

cdef <span class="org-builtin">float</span> surface_fire_eccentricity(<span class="org-builtin">float</span> length_to_width_ratio) noexcept

cdef (<span class="org-builtin">float</span>, <span class="org-builtin">float</span>) maybe_limit_wind_speed(
    bint use_wind_limit,
    <span class="org-builtin">float</span> max_wind_speed,
    FireBehaviorMin sfmin,
    <span class="org-builtin">float</span> phi_E_magnitude,
    ) noexcept

cpdef FireBehaviorMax calc_surface_fire_behavior_max(
    FireBehaviorMin sfmin,
    <span class="org-builtin">float</span> midflame_wind_speed,
    <span class="org-builtin">float</span> upwind_direction,
    <span class="org-builtin">float</span> slope,
    <span class="org-builtin">float</span> aspect,
    bint use_wind_limit<span class="org-operator">=</span>?,
    <span class="org-builtin">str</span> surface_lw_ratio_model<span class="org-operator">=</span>?,
    ) noexcept

cpdef SpreadBehavior calc_surface_fire_behavior_in_direction(
    FireBehaviorMax surface_fire_max,
    vec_xyz spread_direction,
    ) noexcept
</pre>
</div>
</div>
</div>

<div id="outline-container-pyretechnics-crown-fire-pxd" class="outline-4">
<h4 id="pyretechnics-crown-fire-pxd"><span class="section-number-4">10.6.8.</span> pyretechnics.crown_fire</h4>
<div class="outline-text-4" id="text-pyretechnics-crown-fire-pxd">
<div class="org-src-container">
<pre class="src src-python" id="crown-fire-pxd"><span class="org-keyword">from</span> pyretechnics.cy_types cimport vec_xyz, FireBehaviorMax, SpreadBehavior, CrownSpreadInfo

cdef <span class="org-builtin">float</span> van_wagner_critical_fireline_intensity(
    <span class="org-builtin">float</span> canopy_base_height,
    <span class="org-builtin">float</span> foliar_moisture,
    ) noexcept

cdef <span class="org-builtin">float</span> van_wagner_crowning_spread_rate(
    FireBehaviorMax surface_fire_max,
    <span class="org-builtin">float</span> canopy_base_height,
    <span class="org-builtin">float</span> foliar_moisture,
    ) noexcept

cpdef bint van_wagner_crown_fire_initiation(
    <span class="org-builtin">float</span> surface_fireline_intensity,
    <span class="org-builtin">float</span> canopy_cover,
    <span class="org-builtin">float</span> canopy_base_height,
    <span class="org-builtin">float</span> foliar_moisture,
    ) noexcept

cdef <span class="org-builtin">float</span> cruz_active_crown_fire_spread_rate(
    <span class="org-builtin">float</span> wind_speed_10m,
    <span class="org-builtin">float</span> canopy_bulk_density,
    <span class="org-builtin">float</span> estimated_fine_fuel_moisture,
    ) noexcept

cdef <span class="org-builtin">float</span> van_wagner_critical_spread_rate(<span class="org-builtin">float</span> canopy_bulk_density) noexcept

cdef <span class="org-builtin">float</span> cruz_passive_crown_fire_spread_rate(
    <span class="org-builtin">float</span> active_spread_rate,
    <span class="org-builtin">float</span> critical_spread_rate,
    ) noexcept

cdef CrownSpreadInfo cruz_crown_fire_spread_info(
    <span class="org-builtin">float</span> wind_speed_10m,
    <span class="org-builtin">float</span> canopy_bulk_density,
    <span class="org-builtin">float</span> estimated_fine_fuel_moisture,
    ) noexcept

cdef <span class="org-builtin">float</span> calc_crown_fireline_intensity(
    <span class="org-builtin">float</span> crown_spread_rate,
    <span class="org-builtin">float</span> canopy_bulk_density,
    <span class="org-builtin">float</span> canopy_height,
    <span class="org-builtin">float</span> canopy_base_height,
    <span class="org-builtin">float</span> heat_of_combustion,
    ) noexcept

cdef <span class="org-builtin">float</span> crown_length_to_width_ratio(
    <span class="org-builtin">float</span> wind_speed_10m,
    <span class="org-builtin">float</span> max_length_to_width_ratio<span class="org-operator">=</span>?,
    ) noexcept

cdef <span class="org-builtin">float</span> crown_fire_eccentricity(<span class="org-builtin">float</span> length_to_width_ratio) noexcept

cpdef FireBehaviorMax calc_crown_fire_behavior_max(
    <span class="org-builtin">float</span> canopy_height,
    <span class="org-builtin">float</span> canopy_base_height,
    <span class="org-builtin">float</span> canopy_bulk_density,
    <span class="org-builtin">float</span> heat_of_combustion,
    <span class="org-builtin">float</span> estimated_fine_fuel_moisture,
    <span class="org-builtin">float</span> wind_speed_10m,
    <span class="org-builtin">float</span> upwind_direction,
    <span class="org-builtin">float</span> slope,
    <span class="org-builtin">float</span> aspect,
    <span class="org-builtin">float</span> crown_max_lw_ratio<span class="org-operator">=</span>?,
    ) noexcept

cpdef SpreadBehavior calc_crown_fire_behavior_in_direction(
    FireBehaviorMax crown_fire_max,
    vec_xyz spread_direction,
    ) noexcept

cpdef SpreadBehavior calc_combined_fire_behavior(
    SpreadBehavior surface_fire_behavior,
    SpreadBehavior crown_fire_behavior,
    ) noexcept
</pre>
</div>
</div>
</div>

<div id="outline-container-pyretechnics-spot-fire-pxd" class="outline-4">
<h4 id="pyretechnics-spot-fire-pxd"><span class="section-number-4">10.6.9.</span> pyretechnics.spot_fire</h4>
<div class="outline-text-4" id="text-pyretechnics-spot-fire-pxd">
<div class="org-src-container">
<pre class="src src-python" id="spot-fire-pxd"><span class="org-keyword">from</span> pyretechnics.cy_types cimport pyidx, vec_xy, coord_yx, coord_tyx, SpreadBehavior, SpotConfig, JumpDistribution
<span class="org-keyword">from</span> pyretechnics.random cimport BufferedRandGen
<span class="org-keyword">from</span> pyretechnics.space_time_cube cimport ISpaceTimeCube

cdef <span class="org-builtin">float</span> expected_firebrand_production(
    SpreadBehavior fire_behavior,
    vec_xy elevation_gradient,
    <span class="org-builtin">float</span> cell_horizontal_area,
    <span class="org-builtin">float</span> firebrands_per_unit_heat<span class="org-operator">=</span>?,
    ) noexcept

cdef <span class="org-builtin">float</span> delta_to_grid_dx(<span class="org-builtin">float</span> cos_wdir, <span class="org-builtin">float</span> sin_wdir, <span class="org-builtin">float</span> delta_x, <span class="org-builtin">float</span> delta_y) noexcept
cdef <span class="org-builtin">float</span> delta_to_grid_dy(<span class="org-builtin">float</span> cos_wdir, <span class="org-builtin">float</span> sin_wdir, <span class="org-builtin">float</span> delta_x, <span class="org-builtin">float</span> delta_y) noexcept

cdef <span class="org-builtin">int</span> distance_to_n_cells(<span class="org-builtin">float</span> distance, <span class="org-builtin">float</span> cell_size) noexcept

cdef <span class="org-builtin">float</span> resolve_exp_delta_x(SpotConfig spot_config, <span class="org-builtin">float</span> fireline_intensity, <span class="org-builtin">float</span> wind_speed_20ft) noexcept
cdef <span class="org-builtin">float</span> resolve_var_delta_x(SpotConfig spot_config, <span class="org-builtin">float</span> exp_delta_x) noexcept

cdef <span class="org-builtin">float</span> lognormal_mu_from_moments(<span class="org-builtin">float</span> mean, <span class="org-builtin">float</span> variance) noexcept
cdef <span class="org-builtin">float</span> lognormal_sigma_from_moments(<span class="org-builtin">float</span> mean, <span class="org-builtin">float</span> variance) noexcept

cdef (<span class="org-builtin">float</span>, <span class="org-builtin">float</span>) resolve_lognormal_params(
    SpotConfig spot_config,
    <span class="org-builtin">float</span> fireline_intensity,
    <span class="org-builtin">float</span> wind_speed_20ft
    ) noexcept

cdef double <span class="org-variable-name">sigma_y_scalar_m</span> <span class="org-operator">=</span> 0.92 <span class="org-operator">*</span> 0.47 <span class="org-operator">/</span> (0.88 <span class="org-operator">*</span> 0.88)

cdef <span class="org-builtin">float</span> himoto_resolve_default_sigma_y_from_lognormal_params(<span class="org-builtin">float</span> mu_x, <span class="org-builtin">float</span> sigma_x) noexcept
cdef <span class="org-builtin">float</span> himoto_resolve_default_sigma_y(
    SpotConfig spot_config,
    <span class="org-builtin">float</span> fireline_intensity,
    <span class="org-builtin">float</span> wind_speed_20ft
    ) noexcept

cdef <span class="org-builtin">float</span> resolve_crosswind_distance_stdev(
    SpotConfig spot_config,
    <span class="org-builtin">float</span> fireline_intensity,
    <span class="org-builtin">float</span> wind_speed_20ft
    ) noexcept

cdef <span class="org-builtin">float</span> sample_normal(BufferedRandGen rng, <span class="org-builtin">float</span> mu, <span class="org-builtin">float</span> sd) noexcept
cdef <span class="org-builtin">float</span> sample_lognormal(BufferedRandGen rng, <span class="org-builtin">float</span> mu, <span class="org-builtin">float</span> sd) noexcept

cdef JumpDistribution resolve_JumpDistribution(SpotConfig spot_config, <span class="org-builtin">float</span> fireline_intensity, <span class="org-builtin">float</span> wind_speed_20ft)

cdef <span class="org-builtin">float</span> sample_downwind_jump(JumpDistribution jd, BufferedRandGen random_generator) noexcept
cdef <span class="org-builtin">float</span> sample_crosswind_jump(JumpDistribution jd, BufferedRandGen random_generator) noexcept

cdef <span class="org-builtin">float</span> heat_of_preignition(<span class="org-builtin">float</span> temperature, <span class="org-builtin">float</span> fine_fuel_moisture) noexcept
cpdef <span class="org-builtin">float</span> schroeder_ignition_probability(<span class="org-builtin">float</span> temperature, <span class="org-builtin">float</span> fine_fuel_moisture) noexcept
cpdef <span class="org-builtin">float</span> firebrand_flight_survival_probability(<span class="org-builtin">float</span> spotting_distance, <span class="org-builtin">float</span> decay_distance) noexcept

cdef <span class="org-builtin">float</span> albini_firebrand_maximum_height(<span class="org-builtin">float</span> firebrand_diameter) noexcept
cdef <span class="org-builtin">float</span> albini_t_max(<span class="org-builtin">float</span> flame_length) noexcept
cdef <span class="org-builtin">float</span> spot_ignition_time(<span class="org-builtin">float</span> time_of_arrival, <span class="org-builtin">float</span> flame_length) noexcept

cdef bint is_in_bounds(pyidx y, pyidx x, pyidx rows, pyidx cols) noexcept
cdef bint is_burnable_cell(ISpaceTimeCube fuel_model_cube, pyidx t, pyidx y, pyidx x) noexcept

cdef coord_yx cast_firebrand(
    BufferedRandGen rng,
    ISpaceTimeCube fuel_model_cube,
    ISpaceTimeCube temperature_cube,
    ISpaceTimeCube fuel_moisture_dead_1hr_cube,
    unsigned char[:,::1] fire_type_matrix,
    pyidx rows,
    pyidx cols,
    <span class="org-builtin">float</span> cell_height,
    <span class="org-builtin">float</span> cell_width,
    pyidx source_t,
    pyidx source_y,
    pyidx source_x,
    <span class="org-builtin">float</span> decay_distance,
    <span class="org-builtin">float</span> cos_wdir,
    <span class="org-builtin">float</span> sin_wdir,
    JumpDistribution jd,
    ) noexcept

cdef <span class="org-builtin">tuple</span> spread_firebrands(
    ISpaceTimeCube fuel_model_cube,
    ISpaceTimeCube temperature_cube,
    ISpaceTimeCube fuel_moisture_dead_1hr_cube,
    unsigned char[:,::1] fire_type_matrix,
    coord_yx sim_area_bounds,
    <span class="org-builtin">float</span> cell_height,
    <span class="org-builtin">float</span> cell_width,
    coord_tyx space_time_coordinate,
    <span class="org-builtin">float</span> wind_speed_10m,
    <span class="org-builtin">float</span> upwind_direction,
    <span class="org-builtin">float</span> fireline_intensity,
    <span class="org-builtin">float</span> flame_length,
    <span class="org-builtin">float</span> time_of_arrival,
    BufferedRandGen random_generator,
    <span class="org-builtin">long</span> <span class="org-builtin">long</span> num_firebrands,
    SpotConfig spot_config,
    )
</pre>
</div>
</div>
</div>

<div id="outline-container-pyretechnics-burn-cells-pxd" class="outline-4">
<h4 id="pyretechnics-burn-cells-pxd"><span class="section-number-4">10.6.10.</span> pyretechnics.burn_cells</h4>
<div class="outline-text-4" id="text-pyretechnics-burn-cells-pxd">
<div class="org-src-container">
<pre class="src src-python" id="burn-cells-pxd"><span class="org-keyword">from</span> pyretechnics.cy_types cimport pyidx, coord_tyx

cpdef <span class="org-builtin">dict</span> burn_cell_as_head_fire(
    <span class="org-builtin">dict</span> space_time_cubes,
    coord_tyx space_time_coordinate,
    bint use_wind_limit<span class="org-operator">=</span>?,
    <span class="org-builtin">str</span> surface_lw_ratio_model<span class="org-operator">=</span>?,
    <span class="org-builtin">float</span> crown_max_lw_ratio<span class="org-operator">=</span>?,
    )

cpdef <span class="org-builtin">dict</span> burn_all_cells_as_head_fire(
    <span class="org-builtin">dict</span> space_time_cubes,
    pyidx t,
    <span class="org-builtin">object</span> y_range<span class="org-operator">=</span>?,
    <span class="org-builtin">object</span> x_range<span class="org-operator">=</span>?,
    bint use_wind_limit<span class="org-operator">=</span>?,
    <span class="org-builtin">str</span> surface_lw_ratio_model<span class="org-operator">=</span>?,
    <span class="org-builtin">float</span> crown_max_lw_ratio<span class="org-operator">=</span>?,
    )

cpdef <span class="org-builtin">dict</span> burn_cell_toward_azimuth(
    <span class="org-builtin">dict</span> space_time_cubes,
    coord_tyx space_time_coordinate,
    <span class="org-builtin">float</span> azimuth,
    bint use_wind_limit<span class="org-operator">=</span>?,
    <span class="org-builtin">str</span> surface_lw_ratio_model<span class="org-operator">=</span>?,
    <span class="org-builtin">float</span> crown_max_lw_ratio<span class="org-operator">=</span>?,
    )

cpdef <span class="org-builtin">dict</span> burn_all_cells_toward_azimuth(
    <span class="org-builtin">dict</span> space_time_cubes,
    <span class="org-builtin">float</span> azimuth,
    pyidx t,
    <span class="org-builtin">object</span> y_range<span class="org-operator">=</span>?,
    <span class="org-builtin">object</span> x_range<span class="org-operator">=</span>?,
    bint use_wind_limit<span class="org-operator">=</span>?,
    <span class="org-builtin">str</span> surface_lw_ratio_model<span class="org-operator">=</span>?,
    <span class="org-builtin">float</span> crown_max_lw_ratio<span class="org-operator">=</span>?,
    )
</pre>
</div>
</div>
</div>

<div id="outline-container-pyretechnics-narrow-band-tracking-pxd" class="outline-4">
<h4 id="pyretechnics-narrow-band-tracking-pxd"><span class="section-number-4">10.6.11.</span> pyretechnics.narrow_band_tracking</h4>
<div class="outline-text-4" id="text-pyretechnics-narrow-band-tracking-pxd">
<div class="org-src-container">
<pre class="src src-python" id="narrow-band-tracking-pxd"><span class="org-keyword">from</span> pyretechnics.cy_types cimport pyidx, coord_yx

cdef <span class="org-keyword">class</span> <span class="org-type">CellsCountSegment</span>:
    cdef <span class="org-builtin">int</span> y
    cdef <span class="org-builtin">int</span> x0
    cdef unsigned short[16] counts

cdef bint segment_is_empty(CellsCountSegment segment) noexcept
cdef bint segment_is_pos_at(CellsCountSegment segment, pyidx k) noexcept
cdef CellsCountSegment make_CellsCountSegment(pyidx y, pyidx x0)

cdef <span class="org-keyword">class</span> <span class="org-type">NarrowBandTracker</span>:
    cdef public <span class="org-builtin">int</span> num_tracked_cells
    cdef pyidx y_high
    cdef pyidx x_high
    cdef pyidx ys_offset
    cdef <span class="org-builtin">list</span> ys_list
    cdef <span class="org-builtin">int</span> _rows_count

cdef NarrowBandTracker new_NarrowBandTracker(pyidx y_high, pyidx x_high)
cdef void inc_y_segment(NarrowBandTracker tracked_cells, pyidx y, pyidx x_start, <span class="org-builtin">int</span> segment_length) noexcept
cdef void dec_y_segment(NarrowBandTracker tracked_cells, pyidx y, pyidx x_start, <span class="org-builtin">int</span> segment_length)
cdef (pyidx, pyidx) resolve_truncated_x_segment(NarrowBandTracker tracked_cells, pyidx x, pyidx buffer_width) noexcept
cdef void inc_square_around(NarrowBandTracker tracked_cells, pyidx y, pyidx x, pyidx buffer_width) noexcept
cdef void dec_square_around(NarrowBandTracker tracked_cells, pyidx y, pyidx x, pyidx buffer_width) noexcept
cdef bint nonempty_tracked_cells(NarrowBandTracker tracked_cells) noexcept

cdef <span class="org-keyword">class</span> <span class="org-type">TrackedCellsIterator</span>:
    cdef <span class="org-builtin">object</span> segment_iter
    cdef CellsCountSegment current_segment
    cdef pyidx current_k
    cdef bint has_next(TrackedCellsIterator <span class="org-keyword">self</span>) noexcept
    cdef coord_yx next_cell(TrackedCellsIterator <span class="org-keyword">self</span>) noexcept

cdef TrackedCellsIterator tracked_cells_iterator(NarrowBandTracker tracked_cells)
</pre>
</div>
</div>
</div>

<div id="outline-container-pyretechnics-eulerian-level-set-pxd" class="outline-4">
<h4 id="pyretechnics-eulerian-level-set-pxd"><span class="section-number-4">10.6.12.</span> pyretechnics.eulerian_level_set</h4>
<div class="outline-text-4" id="text-pyretechnics-eulerian-level-set-pxd">
<div class="org-src-container">
<pre class="src src-python" id="eulerian-level-set-pxd"><span class="org-comment-delimiter"># </span><span class="org-comment">from pyretechnics.cy_types cimport pyidx, vec_xy, vec_xyz, coord_yx, coord_tyx, \</span>
<span class="org-comment-delimiter">#      </span><span class="org-comment">FuelModel, FireBehaviorMin, FireBehaviorMax, SpreadBehavior, SpotConfig, \</span>
<span class="org-comment-delimiter">#      </span><span class="org-comment">PartialedEllWavelet, CellInputs, EllipticalInfo, Pass1CellOutput</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">from pyretechnics.space_time_cube cimport ISpaceTimeCube</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">from pyretechnics.narrow_band_tracking cimport NarrowBandTracker</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">from pyretechnics.random cimport BufferedRandGen</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cimport numpy as np</span>
<span class="org-comment-delimiter">#</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef float calc_dphi_dx_approx(float[:,::1] phi_matrix, float dx, pyidx x, pyidx y) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef float calc_dphi_dy_approx(float[:,::1] phi_matrix, float dy, pyidx x, pyidx y) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef vec_xy calc_phi_gradient_approx(float[:,::1] phi_matrix, float dx, float dy, pyidx x, pyidx y) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef vec_xy calc_phi_normal_vector(float[:,::1] phi_matrix, float dx, float dy, pyidx x, pyidx y) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef float calc_phi_normal_azimuth(vec_xy phi_normal_vector) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef float half_superbee_dphi_up(float dphi_up, float dphi_loc) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef float calc_dphi_flim_x(float p00, float pw2, float pw1, float pe1, float pe2) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef float calc_dphi_flim_y(float p00, float ps2, float ps1, float pn1, float pn2) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef int fire_type_unburned      = 0</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef int fire_type_surface       = 1</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef int fire_type_crown_passive = 2</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef int fire_type_crown_active  = 3</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef vec_xy calc_elevation_gradient(float slope, float aspect) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef vec_xyz calc_phi_gradient_on_slope(vec_xy phi_gradient_xy, vec_xy elevation_gradient) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef SpreadBehavior calc_fireline_normal_behavior(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">FireBehaviorMax fire_behavior_max,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">vec_xyz phi_gradient_xyz,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef class SpreadInputs:</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef pyidx rows</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef pyidx cols</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef float band_duration</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef float cell_height</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef float cell_width</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef ISpaceTimeCube slope</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef ISpaceTimeCube aspect</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef ISpaceTimeCube fuel_model</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef ISpaceTimeCube canopy_cover</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef ISpaceTimeCube canopy_height</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef ISpaceTimeCube canopy_base_height</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef ISpaceTimeCube canopy_bulk_density</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef ISpaceTimeCube wind_speed_10m</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef ISpaceTimeCube upwind_direction</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef ISpaceTimeCube fuel_moisture_dead_1hr</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef ISpaceTimeCube fuel_moisture_dead_10hr</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef ISpaceTimeCube fuel_moisture_dead_100hr</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef ISpaceTimeCube fuel_moisture_live_herbaceous</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef ISpaceTimeCube fuel_moisture_live_woody</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef ISpaceTimeCube foliar_moisture</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef ISpaceTimeCube temperature</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef ISpaceTimeCube fuel_spread_adjustment</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef ISpaceTimeCube weather_spread_adjustment</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef FuelModel* fuel_model_cache</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef void __init_fuel_models(SpreadInputs self)</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef FuelModel get_fm_struct(SpreadInputs self, pyidx fm_number) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef SpreadInputs make_SpreadInputs(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">(pyidx, pyidx, pyidx) cube_shape,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">(float, float, float) cube_resolution,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">dict space_time_cubes,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef CellInputs lookup_cell_inputs(SpreadInputs spread_inputs, coord_tyx space_time_coordinate) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef SpreadBehavior unburned_SpreadBehavior(vec_xy elevation_gradient, vec_xyz phi_gradient_xyz) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef class SpreadState:</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef (pyidx, pyidx, pyidx) cube_shape</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef float[:,::1] phi</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef float[:,::1] phi_star</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef unsigned char[:,::1] fire_type</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef float[:,::1] spread_rate</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef float[:,::1] spread_direction</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef float[:,::1] fireline_intensity</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef float[:,::1] flame_length</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef float[:,::1] time_of_arrival</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cpdef SpreadState ignite_cell(SpreadState self, coord_yx ignited_cell)</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cpdef SpreadState ignite_cells(</span>
<span class="org-comment-delimiter">#         </span><span class="org-comment">SpreadState self,</span>
<span class="org-comment-delimiter">#         </span><span class="org-comment">coord_yx lower_left_corner,</span>
<span class="org-comment-delimiter">#         </span><span class="org-comment">float[:,::1] ignition_matrix,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">)</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cpdef dict get_burned_matrices(SpreadState self, list layers=?)</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cpdef dict get_full_matrices(SpreadState self, list layers=?)</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cpdef SpreadState copy(SpreadState self)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef object encode_cell_index(pyidx y, pyidx x)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef coord_yx decode_cell_index(object encoded_cell_index) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef bint opposite_phi_signs(float[:,::1] phi_matrix, pyidx y1, pyidx x1, pyidx y2, pyidx x2) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef bint is_frontier_cell(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float[:,::1] phi_matrix,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">ISpaceTimeCube fuel_model_cube,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">pyidx t,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">pyidx y,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">pyidx x,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef set identify_all_frontier_cells(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float[:,::1] phi_matrix,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">ISpaceTimeCube fuel_model_cube,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">pyidx t,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">pyidx rows,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">pyidx cols,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef NarrowBandTracker identify_tracked_cells(set frontier_cells, pyidx buffer_width, pyidx rows, pyidx cols)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef void spot_from_burned_cell(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">SpreadInputs spread_inputs,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">unsigned char[:,::1] fire_type_matrix,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">pyidx y,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">pyidx x,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">SpreadBehavior fire_behavior,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float time_of_arrival,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">BufferedRandGen random_generator,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">SpotConfig spot_config,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">object spot_ignitions,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef float calc_phi_magnitude_xyz_2(vec_xy phi_gradient_xy, vec_xy elevation_gradient) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef PartialedEllWavelet zero_partialed_wavelet() noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef PartialedEllWavelet prepare_partialed_wavelet(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">vec_xyz heading_spread_vector,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float flanking_spread_rate,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float backing_spread_rate,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef PartialedEllWavelet wavelet_from_FireBehaviorMax(FireBehaviorMax fire_behavior_max) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef float dphi_dt_from_partialed_wavelet(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">PartialedEllWavelet wavelet,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">vec_xy phi_gradient_xy,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float phi_magnitude_xyz_2,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef bint phi_aware_crowning_check(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float phi_magnitude_xyz_2,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float surface_dphi_dt,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float crowning_spread_rate,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef float dphi_dt_from_ellipses(EllipticalInfo ellipses, vec_xy phi_gradient_xy) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef pyidx p_CellInputs = 17</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef class TrackedCellsArrays:</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef pyidx _array_length</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef pyidx num_tracked_cells</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef float[:,::1] cube_cache</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef float[:,::1] phi_cache</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef FireBehaviorMin* sfmin_cache</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef EllipticalInfo* ellipse_cache</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef Pass1CellOutput* pass1_cache</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef float[17] time_refreshed</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef pyidx[17] t_refreshed</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef void reset_size(TrackedCellsArrays self, pyidx num_tracked_cells)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef void collect_phi_cache(float[:,::1] phi_matrix, TrackedCellsArrays tca) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef int compare_cell_indexes(coord_yx c0, coord_yx c1) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef void copy_tracked_cell_data(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">pyidx i_old,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">TrackedCellsArrays tca_old,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">pyidx i_new,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">TrackedCellsArrays tca_new,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef list[str] inputs_name_list()</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef class FireBehaviorSettings:</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef float max_cells_per_timestep</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef pyidx buffer_width</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef bint use_wind_limit</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef str surface_lw_ratio_model</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef float crown_max_lw_ratio</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef dict spot_config</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef float[17] cube_refresh_rates</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef void load_cube_cache_for_cell(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">SpreadInputs spread_inputs,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">coord_yx cell_index,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">TrackedCellsArrays tca,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">pyidx i,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef list[ISpaceTimeCube] list_float_input_cubes(SpreadInputs spread_inputs)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef dict default_cube_refresh_rates(float band_duration)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef unsigned int recompute_level_for_input(pyidx input_k) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef unsigned int refresh_inputs_if_needed(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">SpreadInputs spread_inputs,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">FireBehaviorSettings fb_opts,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">TrackedCellsArrays tca,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float present_time,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef CellInputs load_saved_CellInputs(float[:,::1] cube_cache, pyidx i) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef FireBehaviorMin resolve_surface_no_wind_no_slope_behavior(CellInputs cell_inputs, FuelModel fuel_model) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef FireBehaviorMax resolve_surface_max_behavior(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">FireBehaviorSettings fb_opts,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">CellInputs cell_inputs,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">FuelModel fuel_model,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">FireBehaviorMin surface_fire_min,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef FireBehaviorMax resolve_crown_max_behavior(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">FireBehaviorSettings fb_opts,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">CellInputs cell_inputs,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">FuelModel fuel_model,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef float resolve_crowning_spread_rate(CellInputs cell_inputs, FireBehaviorMax surface_fire_max) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef EllipticalInfo resolve_cell_elliptical_info(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">FireBehaviorSettings fb_opts,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">coord_yx cell_index,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">CellInputs cell_inputs,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">FuelModel fuel_model,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">FireBehaviorMin surface_fire_min,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef void refresh_caches_from_inputs_if_needed(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">SpreadInputs spread_inputs,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">FireBehaviorSettings fb_opts,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">TrackedCellsArrays tca,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float present_time,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef SpreadBehavior resolve_combined_spread_behavior(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">SpreadInputs spread_inputs,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">FireBehaviorSettings fb_opts,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">coord_tyx space_time_coordinate,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">vec_xy phi_gradient_xy,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef void load_tracked_cell_data(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">SpreadInputs spread_inputs,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">FireBehaviorSettings fb_opts,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">coord_yx cell_index,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">TrackedCellsArrays tca,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">pyidx i,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef void sync_tracked_cells_arrays(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">SpreadInputs spread_inputs,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">FireBehaviorSettings fb_opts,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">NarrowBandTracker tracked_cells,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">TrackedCellsArrays tca_old,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">TrackedCellsArrays tca_new,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef float runge_kutta_pass1(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float max_cells_per_timestep,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float dy,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float dx,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float max_timestep,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">TrackedCellsArrays tca,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef void update_phi_star(TrackedCellsArrays tca, float dt, float[:,::1] phi_star_matrix) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef class BurnedCellInfo:</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef coord_yx cell_index</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef float time_of_arrival</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">cdef vec_xy phi_gradient_xy</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef BurnedCellInfo new_BurnedCellInfo(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">coord_yx cell_index,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float time_of_arrival,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">vec_xy phi_gradient_xy,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef list[BurnedCellInfo] runge_kutta_pass2(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float dy,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float dx,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float start_time,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float dt,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">TrackedCellsArrays tca,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float[:,::1] phi_matrix,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef void process_burned_cells(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">SpreadInputs spread_inputs,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">FireBehaviorSettings fb_opts,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">SpreadState spread_state,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">object spot_ignitions,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">BufferedRandGen random_generator,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">list[BurnedCellInfo] burned_cells,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef void reset_phi_star(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">TrackedCellsArrays tca,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">list[BurnedCellInfo] spot_ignited_cells,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float[:,::1] phi_star_matrix,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float[:,::1] phi_matrix,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef list[BurnedCellInfo] ignite_from_spotting(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">object spot_ignitions,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float[:,::1] phi_matrix,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float stop_time,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef void route_cell_to_diff(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">set frontier_cells_old,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">set frontier_additions,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">set frontier_removals,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float[:,::1] phi_matrix,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">ISpaceTimeCube fuel_model_cube,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">pyidx t,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">pyidx y,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">pyidx x,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">) noexcept</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef tuple[set, set] diff_frontier_cells(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">set frontier_cells_old,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">list[BurnedCellInfo] spread_ignited_cells,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">list[BurnedCellInfo] spot_ignited_cells,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float[:,::1] phi_matrix,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">ISpaceTimeCube fuel_model_cube,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">pyidx t,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef set apply_frontier_diff(set frontier_cells_old, set frontier_additions, set frontier_removals)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef NarrowBandTracker update_tracked_cells_with_frontier_diff(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">NarrowBandTracker tracked_cells,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">set frontier_cells_added,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">set frontier_cells_dropped,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">pyidx buffer_width,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef dict spread_one_timestep(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">dict sim_state,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">SpreadInputs spread_inputs,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">FireBehaviorSettings fb_opts,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float max_timestep,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef void check_space_time_cubes(dict space_time_cubes, dict spot_config=?)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef void check_dimensions_and_resolutions(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">dict space_time_cubes,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">SpreadState spread_state,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">pyidx bands,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">pyidx rows,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">pyidx cols,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float band_duration,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float cell_height,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float cell_width,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cdef void check_start_and_stop_times(float start_time, float max_stop_time, float cube_duration, object max_duration=?)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">cpdef dict[str, object] spread_fire_with_phi_field(</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">dict[str, ISpaceTimeCube] space_time_cubes,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">SpreadState spread_state,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">(float, float, float) cube_resolution,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float start_time,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">object max_duration=?,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float max_cells_per_timestep=?,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">pyidx buffer_width=?,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">bint use_wind_limit=?,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">str surface_lw_ratio_model=?,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">float crown_max_lw_ratio=?,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">dict[float, set] spot_ignitions=?,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">object spot_config=?,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">dict[str, float] cube_refresh_rates=?,</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">)</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://en.wikipedia.org/wiki/Literate_programming">https://en.wikipedia.org/wiki/Literate_programming</a></p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://guix.gnu.org">https://guix.gnu.org</a></p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://landfire.gov">https://landfire.gov</a></p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://www.nco.ncep.noaa.gov/pmb/products/rtma/">https://www.nco.ncep.noaa.gov/pmb/products/rtma/</a></p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5" role="doc-backlink">5</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Anderson1982</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6" role="doc-backlink">6</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Scott2005</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7" role="doc-backlink">7</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Burgan1979</p></div></div>

<div class="footdef"><sup><a id="fn.8" class="footnum" href="#fnr.8" role="doc-backlink">8</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Rothermel1972</p></div></div>

<div class="footdef"><sup><a id="fn.9" class="footnum" href="#fnr.9" role="doc-backlink">9</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Rothermel1972</p></div></div>

<div class="footdef"><sup><a id="fn.10" class="footnum" href="#fnr.10" role="doc-backlink">10</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1976</p></div></div>

<div class="footdef"><sup><a id="fn.11" class="footnum" href="#fnr.11" role="doc-backlink">11</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Rothermel1972</p></div></div>

<div class="footdef"><sup><a id="fn.12" class="footnum" href="#fnr.12" role="doc-backlink">12</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1976</p></div></div>

<div class="footdef"><sup><a id="fn.13" class="footnum" href="#fnr.13" role="doc-backlink">13</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Andrews2018</p></div></div>

<div class="footdef"><sup><a id="fn.14" class="footnum" href="#fnr.14" role="doc-backlink">14</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Anderson1969</p></div></div>

<div class="footdef"><sup><a id="fn.15" class="footnum" href="#fnr.15" role="doc-backlink">15</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Byram1959</p></div></div>

<div class="footdef"><sup><a id="fn.16" class="footnum" href="#fnr.16" role="doc-backlink">16</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">AndrewsRothermel1982</p></div></div>

<div class="footdef"><sup><a id="fn.17" class="footnum" href="#fnr.17" role="doc-backlink">17</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1976</p></div></div>

<div class="footdef"><sup><a id="fn.18" class="footnum" href="#fnr.18" role="doc-backlink">18</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1979</p></div></div>

<div class="footdef"><sup><a id="fn.19" class="footnum" href="#fnr.19" role="doc-backlink">19</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Andrews2012</p></div></div>

<div class="footdef"><sup><a id="fn.20" class="footnum" href="#fnr.20" role="doc-backlink">20</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Rothermel1983</p></div></div>

<div class="footdef"><sup><a id="fn.21" class="footnum" href="#fnr.21" role="doc-backlink">21</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Waeselynck2024</p></div></div>

<div class="footdef"><sup><a id="fn.22" class="footnum" href="#fnr.22" role="doc-backlink">22</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1980</p></div></div>

<div class="footdef"><sup><a id="fn.23" class="footnum" href="#fnr.23" role="doc-backlink">23</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Rothermel1991</p></div></div>

<div class="footdef"><sup><a id="fn.24" class="footnum" href="#fnr.24" role="doc-backlink">24</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://github.com/firelab/behave/blob/00b90853182031c9e22e33f22bb0ac497bad9415/src/behave/fireSize.cpp#L93">https://github.com/firelab/behave/blob/00b90853182031c9e22e33f22bb0ac497bad9415/src/behave/fireSize.cpp#L93</a></p></div></div>

<div class="footdef"><sup><a id="fn.25" class="footnum" href="#fnr.25" role="doc-backlink">25</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Rothermel1972</p></div></div>

<div class="footdef"><sup><a id="fn.26" class="footnum" href="#fnr.26" role="doc-backlink">26</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Andrews2013</p></div></div>

<div class="footdef"><sup><a id="fn.27" class="footnum" href="#fnr.27" role="doc-backlink">27</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">VanWagner1977</p></div></div>

<div class="footdef"><sup><a id="fn.28" class="footnum" href="#fnr.28" role="doc-backlink">28</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Cruz2005</p></div></div>

<div class="footdef"><sup><a id="fn.29" class="footnum" href="#fnr.29" role="doc-backlink">29</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">VanWagner1977</p></div></div>

<div class="footdef"><sup><a id="fn.30" class="footnum" href="#fnr.30" role="doc-backlink">30</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Cruz2005</p></div></div>

<div class="footdef"><sup><a id="fn.31" class="footnum" href="#fnr.31" role="doc-backlink">31</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Rothermel1991</p></div></div>

<div class="footdef"><sup><a id="fn.32" class="footnum" href="#fnr.32" role="doc-backlink">32</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1980</p></div></div>

<div class="footdef"><sup><a id="fn.33" class="footnum" href="#fnr.33" role="doc-backlink">33</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Waeselynck2024</p></div></div>

<div class="footdef"><sup><a id="fn.34" class="footnum" href="#fnr.34" role="doc-backlink">34</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Perryman2012</p></div></div>

<div class="footdef"><sup><a id="fn.35" class="footnum" href="#fnr.35" role="doc-backlink">35</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Sardoy2008</p></div></div>

<div class="footdef"><sup><a id="fn.36" class="footnum" href="#fnr.36" role="doc-backlink">36</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Himoto2005</p></div></div>

<div class="footdef"><sup><a id="fn.37" class="footnum" href="#fnr.37" role="doc-backlink">37</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Sardoy2008</p></div></div>

<div class="footdef"><sup><a id="fn.38" class="footnum" href="#fnr.38" role="doc-backlink">38</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://elmfire.io">https://elmfire.io</a></p></div></div>

<div class="footdef"><sup><a id="fn.39" class="footnum" href="#fnr.39" role="doc-backlink">39</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Perryman2012</p></div></div>

<div class="footdef"><sup><a id="fn.40" class="footnum" href="#fnr.40" role="doc-backlink">40</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Himoto2005</p></div></div>

<div class="footdef"><sup><a id="fn.41" class="footnum" href="#fnr.41" role="doc-backlink">41</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Sardoy2008</p></div></div>

<div class="footdef"><sup><a id="fn.42" class="footnum" href="#fnr.42" role="doc-backlink">42</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Sardoy2008</p></div></div>

<div class="footdef"><sup><a id="fn.43" class="footnum" href="#fnr.43" role="doc-backlink">43</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Himoto2005</p></div></div>

<div class="footdef"><sup><a id="fn.44" class="footnum" href="#fnr.44" role="doc-backlink">44</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Sardoy2008</p></div></div>

<div class="footdef"><sup><a id="fn.45" class="footnum" href="#fnr.45" role="doc-backlink">45</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Himoto2005</p></div></div>

<div class="footdef"><sup><a id="fn.46" class="footnum" href="#fnr.46" role="doc-backlink">46</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Sardoy2008</p></div></div>

<div class="footdef"><sup><a id="fn.47" class="footnum" href="#fnr.47" role="doc-backlink">47</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Himoto2005</p></div></div>

<div class="footdef"><sup><a id="fn.48" class="footnum" href="#fnr.48" role="doc-backlink">48</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Schroeder1969</p></div></div>

<div class="footdef"><sup><a id="fn.49" class="footnum" href="#fnr.49" role="doc-backlink">49</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Perryman2012</p></div></div>

<div class="footdef"><sup><a id="fn.50" class="footnum" href="#fnr.50" role="doc-backlink">50</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1979</p></div></div>

<div class="footdef"><sup><a id="fn.51" class="footnum" href="#fnr.51" role="doc-backlink">51</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Stauffer2008</p></div></div>

<div class="footdef"><sup><a id="fn.52" class="footnum" href="#fnr.52" role="doc-backlink">52</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Perryman2012</p></div></div>

<div class="footdef"><sup><a id="fn.53" class="footnum" href="#fnr.53" role="doc-backlink">53</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1979spot</p></div></div>

<div class="footdef"><sup><a id="fn.54" class="footnum" href="#fnr.54" role="doc-backlink">54</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">McAlpine1991</p></div></div>

<div class="footdef"><sup><a id="fn.55" class="footnum" href="#fnr.55" role="doc-backlink">55</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1979spot</p></div></div>

<div class="footdef"><sup><a id="fn.56" class="footnum" href="#fnr.56" role="doc-backlink">56</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1979spot</p></div></div>

<div class="footdef"><sup><a id="fn.57" class="footnum" href="#fnr.57" role="doc-backlink">57</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1979spot</p></div></div>

<div class="footdef"><sup><a id="fn.58" class="footnum" href="#fnr.58" role="doc-backlink">58</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://elmfire.io">https://elmfire.io</a></p></div></div>

<div class="footdef"><sup><a id="fn.59" class="footnum" href="#fnr.59" role="doc-backlink">59</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://landfire.gov">https://landfire.gov</a></p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Gary W. Johnson, Valentin Waeselynck, Chris Lautenberger, David Saah</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
