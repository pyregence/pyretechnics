<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Pyretechnics Fire Behavior Library</title>
<meta name="author" content="Gary W. Johnson, Valentin Waeselynck, Chris Lautenberger" />
<meta name="description" content="A Python library for simulating fire behavior in a variety of ways." />
<meta name="keywords" content="pyretechnics fire behavior model python library pyregence pyrecast" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="pyretechnics-base.css" />
<link rel="stylesheet" type="text/css" href="pyretechnics-custom.css" />
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">The Pyretechnics Fire Behavior Library
<br>
<span class="subtitle">Copyright Â© 2023-2024 Spatial Informatics Group, LLC</span>
</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org572f5b5">1. Preface</a></li>
<li><a href="#orgae234cc">2. Data Model</a>
<ul>
<li><a href="#org7d5ef86">2.1. Working in a 3D Space-Time Cube</a></li>
<li><a href="#orgb5d8e29">2.2. Fires as Conical Shapes in Space-Time</a></li>
<li><a href="#org5dba100">2.3. Support for Input Datasets of Varying Dimensionality and Resolution</a></li>
<li><a href="#org4186c5f">2.4. Input Loading Functions for Arrays</a></li>
<li><a href="#org1e30146">2.5. Lazy Loading of Space-Time Chunks</a></li>
<li><a href="#org7b0757c">2.6. Lazy-Loading Multi-Resolution Array Lookup Functions</a></li>
<li><a href="#org6f3c9ad">2.7. Lazy Array Usage Examples</a></li>
</ul>
</li>
<li><a href="#org7d8e155">3. Fire Spread API</a>
<ul>
<li><a href="#org1d1a6d2">3.1. grow_fire</a>
<ul>
<li><a href="#org2637ec1">3.1.1. Inputs</a></li>
<li><a href="#orgcce3edc">3.1.2. Outputs</a></li>
<li><a href="#orgcd1c2bf">3.1.3. Play/Pause/Continue Workflow</a></li>
</ul>
</li>
<li><a href="#org26754ca">3.2. burn_cells</a></li>
</ul>
</li>
<li><a href="#org1877336">4. Fire Spread Functions</a>
<ul>
<li><a href="#orgddac956">4.1. ELMFIRE Inputs</a></li>
</ul>
</li>
<li><a href="#org37f9154">5. Fire Behavior Model</a>
<ul>
<li><a href="#org546b33b">5.1. Fuel Model Definitions</a>
<ul>
<li><a href="#org7548906">5.1.1. Dynamic Fuel Loading</a></li>
<li><a href="#orgab5cd46">5.1.2. Live Moisture of Extinction</a></li>
</ul>
</li>
<li><a href="#org256a745">5.2. Surface Fire Formulas</a></li>
<li><a href="#orgc78373c">5.3. Crown Fire Formulas</a></li>
</ul>
</li>
<li><a href="#org16dd555">6. Burning All Cells as a Head-Fire (similar to FLAMMAP)</a></li>
<li><a href="#orged45365">7. Loading LANDFIRE Inputs</a>
<ul>
<li><a href="#orgec2db32">7.1. Loading Raster Files with Python Rasterio</a></li>
<li><a href="#org0760711">7.2. Convert LANDFIRE Units and Datatypes</a></li>
<li><a href="#org75eeefb">7.3. Verifying Raster Constraints</a></li>
<li><a href="#org35d4cde">7.4. Converting Rasters to 3D Lookup Functions</a></li>
<li><a href="#org3f1c4b1">7.5. Putting It All Together</a></li>
</ul>
</li>
<li><a href="#orgb08adfd">8. Testing burn_cells on Worcester, VT</a>
<ul>
<li><a href="#org95c374b">8.1. Loading Topography, Fuel Model, and Vegetation Inputs from LANDFIRE GeoTIFFs</a></li>
<li><a href="#org09f9a48">8.2. Adding Constant Wind and Moisture Values</a></li>
<li><a href="#org8efba36">8.3. Burning a Single Cell in the Dataset</a></li>
<li><a href="#org3c6d089">8.4. Running Burn Cells on the Test Dataset</a></li>
<li><a href="#org5ece7b6">8.5. Visualizing the Burned Layers</a></li>
<li><a href="#org29db06b">8.6. Comparing Pyretechnics Outputs with FLAMMAP Outputs</a></li>
</ul>
</li>
<li><a href="#org598edc7">9. Fire Spread on a Raster Grid</a>
<ul>
<li>
<ul>
<li><a href="#orge878469">9.0.1. Eulerian Level Set Method</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd1d16dc">10. Appendix: Units Conversion Functions</a></li>
</ul>
</div>
</div>
<div id="list-of-tables">
<h2>List of Tables</h2>
<div id="text-list-of-tables">
<ul>
<li><a href="#orgfea42ac"><span class="table-number">Table 1:</span> Software necessary to evaluate the code in this document</a></li>
<li><a href="#org5a7ceb9"><span class="table-number">Table 2:</span> Physical properties assigned to each fuel model</a></li>
<li><a href="#org930aa18"><span class="table-number">Table 3:</span> Inputs to Rothermel's surface fire rate of spread equation</a></li>
<li><a href="#orgf8a51df"><span class="table-number">Table 4:</span> 2022 LANDFIRE Raster Layers</a></li>
</ul>
</div>
</div>

<div id="outline-container-org572f5b5" class="outline-2">
<h2 id="org572f5b5"><span class="section-number-2">1.</span> Preface</h2>
<div class="outline-text-2" id="text-1">
<p>
This document is a Literate
Program<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>,
containing both the source code of the software it describes as well
as the rationale used in each step of its design and implementation.
The purpose of this approach is to enable anyone sufficiently
experienced in programming to easily retrace the author's footsteps as
they read through the text and code. By the time they have reached the
end of this document, the reader should have just as strong a grasp of
the system as the original programmer.
</p>

<p>
To execute the code illustrated within this document, you will need to
install several pieces of software, all of which are open source
and/or freely available for all major operating systems. These
programs are listed in Table <a href="#orgfea42ac">1</a> along with their
minimum required versions and URLs from which they may be downloaded.
</p>

<table id="orgfea42ac">
<caption class="t-above"><span class="table-number">Table 1:</span> Software necessary to evaluate the code in this document</caption>

<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-right">Version</th>
<th scope="col" class="org-left">URL</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Python</td>
<td class="org-right">3.10.7</td>
<td class="org-left"><a href="https://www.python.org/">https://www.python.org/</a></td>
</tr>

<tr>
<td class="org-left">Numpy</td>
<td class="org-right">1.23.2</td>
<td class="org-left"><a href="https://numpy.org/">https://numpy.org/</a></td>
</tr>

<tr>
<td class="org-left">Rasterio</td>
<td class="org-right">1.3.7</td>
<td class="org-left"><a href="https://github.com/rasterio/rasterio/">https://github.com/rasterio/rasterio/</a></td>
</tr>

<tr>
<td class="org-left">GDAL</td>
<td class="org-right">3.6.1</td>
<td class="org-left"><a href="https://gdal.org/">https://gdal.org/</a></td>
</tr>

<tr>
<td class="org-left">Emacs</td>
<td class="org-right">29.3</td>
<td class="org-left"><a href="https://www.gnu.org/software/emacs/">https://www.gnu.org/software/emacs/</a></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgae234cc" class="outline-2">
<h2 id="orgae234cc"><span class="section-number-2">2.</span> Data Model</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org7d5ef86" class="outline-3">
<h3 id="org7d5ef86"><span class="section-number-3">2.1.</span> Working in a 3D Space-Time Cube</h3>
<div class="outline-text-3" id="text-2-1">
<p>
In Pyretechnics, a fire is viewed as a three-dimensional event
occurring within a bounded region of space-time <code>(T, Y, X)</code>. In this
mental model, the environment in which a fire develops can be
visualized as a cube in which space is described in 2D by the <code>X</code> and
<code>Y</code> dimensions and time projects this 2D world into 3D along the <code>T</code>
dimension.
</p>

<p>
Note, in particular, that this is not the same thing as a
three-dimensional model of fire behavior that incorporates surface
elevation as the third dimension. Although terrain data (such as
elevation, slope, and aspect) and tree cover characteristics (such as
canopy height and canopy base height) are incorporated into the
implemented spread equations in order to determine the rate,
direction, and mode of fire spread, the outputs of the fire behavior
algorithms in Pyretechnics currently only use two dimensions to
describe spatial heterogeneity within the simulation environment. The
third dimension is instead reserved for temporal variations in the
model outputs.
</p>
</div>
</div>

<div id="outline-container-orgb5d8e29" class="outline-3">
<h3 id="orgb5d8e29"><span class="section-number-3">2.2.</span> Fires as Conical Shapes in Space-Time</h3>
<div class="outline-text-3" id="text-2-2">
<p>
All fire events begin from an ignition somewhere in space-time. As
combustion and propagation occur in burnable fuels, the burned area
(a.k.a "burn scar") of a fire spreads monotonically outward in space.
Viewed from the lens of our 3D space-time cube, these monotonically
expanding burn scars form conical solids within the simulation
environment, with the bottom point of the cone representing the
initial ignition point and the upper edge of the cone representing the
actively burning fire perimeter. Of course, we only expect idealized
fire cones to appear in environments with homogeneous topography,
weather, fuels, and fuel moisture. As these inputs become more
heterogenous throughout the burned region of space-time, these
idealized cones will become distorted in the directions of faster or
slower spread and their perimeters will become more finely dissected.
However, we use this conical shape description of fire events within
the simulated space-time cube to convey both their monotonically
increasing spatial area over time as well as to provide the foundation
for a more visually intuitive understanding of the effect of
temporally varying environmental conditions on the behavior (and thus
shape) of fires.
</p>
</div>
</div>

<div id="outline-container-org5dba100" class="outline-3">
<h3 id="org5dba100"><span class="section-number-3">2.3.</span> Support for Input Datasets of Varying Dimensionality and Resolution</h3>
<div class="outline-text-3" id="text-2-3">
<p>
At the beginning of a fire behavior simulation, our 3D space-time cube
is populated with all of the information that describes the
environment and will remain effectively static as the fire event
unfolds. This includes (but is not limited to) topography, weather,
fuels, and fuel moisture. In many common simulation scenarios, we
expect that topography and fuels will probably vary in space but not
in time, and weather and fuel moisture may vary in both space and
time. However, we use "may" in these statements because the data model
within Pyretechnics is flexibly designed to allow any of these
environmental input variables to take on any of these forms:
</p>

<ul class="org-ul">
<li>constant in space and time</li>
<li>constant in space but variable in time</li>
<li>variable in space but constant in time</li>
<li>variable in space and time</li>
</ul>

<p>
This is accomplished by representing each such input value as an
abstract datatype with a 3D space-time look-up function. From within
our fire behavior algorithms, we should always be able to call the
look-up function for any environmental input variable with a 3D
space-time coordinate <code>(t, y, x)</code> and get back the correct value for
that location. Moreover, such look-ups must be referentially
transparent, so as to ensure that subsequent look-ups with the same
coordinate will always yield the same values.
</p>

<p>
Note, that for performance reasons, input values that are constant in
either space or time will not be broadcast into these constant
dimensions when stored in memory. Instead, their native
representations will be preserved, and the 3D look-up function
assigned to that input will correctly map the 3D space-time coordinate
into the corresponding index within the native dataset.
</p>

<p>
Similarly, input datasets may be provided at different resolutions
from one another, provided that the following conditions are met:
</p>

<ol class="org-ol">
<li>All spatially varying datasets must share the same projection.</li>
<li>All spatial and temporal extents must match.</li>
<li>All spatial and temporal resolutions must be exact multiples of one another.</li>
</ol>

<p>
The simulated space-time cube will share the same projection and
extent as the input datasets, but its resolution may be specified by
the user, provided that it meets condition 3 above.
</p>

<p>
The 3D look-up function for each input will then be responsible for
translating the space-time coordinate it receives at the simulation
resolution into the correct coordinate for the underlying dataset's
native resolution.
</p>
</div>
</div>

<div id="outline-container-org4186c5f" class="outline-3">
<h3 id="org4186c5f"><span class="section-number-3">2.4.</span> Input Loading Functions for Arrays</h3>
<div class="outline-text-3" id="text-2-4">
<p>
The following sections provide some pre-built methods for transforming
arrays into abstract 3D datatypes with index translating lookup
functions.
</p>

<div class="org-src-container">
<pre class="src src-python" id="org2de1047"><span style="color: #00ffff;">from</span> functools <span style="color: #00ffff;">import</span> <span style="color: #b0c4de;">reduce</span>
<span style="color: #00ffff;">import</span> numpy <span style="color: #00ffff;">as</span> np

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">ArrayGrid3D</span>:
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    TODO: Add docstring.</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #00ffff;">def</span> <span style="color: #87cefa;">__init__</span>(<span style="color: #00ffff;">self</span>, base, t, y, x):
        <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Ensure that t, y, x are positive integers or throw an error</span>
        <span style="color: #00ffff;">if</span> <span style="color: #00ffff;">not</span>(<span style="color: #b0c4de;">all</span>(<span style="color: #b0c4de;">map</span>(ArrayGrid3D.is_pos_int, (t, y, x)))):
            <span style="color: #00ffff;">raise</span> <span style="color: #98fb98;">ValueError</span>(<span style="color: #ffa07a;">"The target dimensions (t, y, x) must all be positive integers."</span>)

        <span style="color: #00ffff;">self</span>.<span style="color: #eedd82;">ndim</span> = 3
        <span style="color: #00ffff;">self</span>.<span style="color: #eedd82;">size</span> = t * y * x
        <span style="color: #00ffff;">self</span>.<span style="color: #eedd82;">shape</span> = (t, y, x)
        <span style="color: #00ffff;">self</span>.<span style="color: #eedd82;">base</span> = base

        <span style="color: #00ffff;">match</span> np.ndim(base):
            <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">0D: Constant Input</span>
            <span style="color: #00ffff;">case</span> 0:
                <span style="color: #00ffff;">self</span>.<span style="color: #eedd82;">data</span> = np.broadcast_to([[[base]]], <span style="color: #00ffff;">self</span>.shape)

            <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">1D: Time-Series Input</span>
            <span style="color: #00ffff;">case</span> 1:
                <span style="color: #eedd82;">t0</span> = <span style="color: #b0c4de;">len</span>(base)
                <span style="color: #eedd82;">t_repetitions</span> = ArrayGrid3D.divide_evenly(t, t0)
                <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Repeat (t0) -&gt; (t)              [FIXME: Inefficient memory usage]</span>
                <span style="color: #eedd82;">repeated_array</span> = ArrayGrid3D.maybe_repeat_array(base, (0, t_repetitions))
                <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Expand (t) -&gt; (t,1,1)</span>
                <span style="color: #eedd82;">expanded_array</span> = np.expand_dims(repeated_array, axis=(1,2))
                <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Broadcast (t,1,1) -&gt; (t,y,x)</span>
                <span style="color: #00ffff;">self</span>.<span style="color: #eedd82;">data</span> = np.broadcast_to(expanded_array, <span style="color: #00ffff;">self</span>.shape)

            <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">2D: Spatial Input</span>
            <span style="color: #00ffff;">case</span> 2:
                (<span style="color: #eedd82;">y0</span>, <span style="color: #eedd82;">x0</span>) = np.shape(base)
                <span style="color: #eedd82;">y_repetitions</span> = ArrayGrid3D.divide_evenly(y, y0)
                <span style="color: #eedd82;">x_repetitions</span> = ArrayGrid3D.divide_evenly(x, x0)
                <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Repeat (y0,x0) -&gt; (y,x)         [FIXME: Inefficient memory usage]</span>
                <span style="color: #eedd82;">repeated_array</span> = <span style="color: #b0c4de;">reduce</span>(ArrayGrid3D.maybe_repeat_array,
                                        ((0, y_repetitions),
                                         (1, x_repetitions)),
                                        base)
                <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Expand (y,x) -&gt; (1,y,x)</span>
                <span style="color: #eedd82;">expanded_array</span> = np.expand_dims(repeated_array, axis=0)
                <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Broadcast (1,y,x) -&gt; (t,y,x)</span>
                <span style="color: #00ffff;">self</span>.<span style="color: #eedd82;">data</span> = np.broadcast_to(expanded_array, <span style="color: #00ffff;">self</span>.shape)

            <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">3D: Spatio-Temporal Input</span>
            <span style="color: #00ffff;">case</span> 3:
                (<span style="color: #eedd82;">t0</span>, <span style="color: #eedd82;">y0</span>, <span style="color: #eedd82;">x0</span>) = np.shape(base)
                <span style="color: #eedd82;">t_repetitions</span> = ArrayGrid3D.divide_evenly(t, t0)
                <span style="color: #eedd82;">y_repetitions</span> = ArrayGrid3D.divide_evenly(y, y0)
                <span style="color: #eedd82;">x_repetitions</span> = ArrayGrid3D.divide_evenly(x, x0)
                <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Repeat (t0,y0,x0) -&gt; (t,y,x)    [FIXME: Inefficient memory usage]</span>
                <span style="color: #eedd82;">repeated_array</span> = <span style="color: #b0c4de;">reduce</span>(ArrayGrid3D.maybe_repeat_array,
                                        ((0, t_repetitions),
                                         (1, y_repetitions),
                                         (2, x_repetitions)),
                                        base)
                <span style="color: #00ffff;">self</span>.<span style="color: #eedd82;">data</span> = repeated_array

            <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">4D+: Invalid Input</span>
            <span style="color: #00ffff;">case</span> _:
                <span style="color: #00ffff;">raise</span> <span style="color: #98fb98;">ValueError</span>(<span style="color: #ffa07a;">"Invalid input: base must have 0-3 dimensions."</span>)

    @<span style="color: #b0c4de;">staticmethod</span>
    <span style="color: #00ffff;">def</span> <span style="color: #87cefa;">is_pos_int</span>(x):
        <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">isinstance</span>(x, <span style="color: #b0c4de;">int</span>) <span style="color: #00ffff;">and</span> x &gt; 0

    @<span style="color: #b0c4de;">staticmethod</span>
    <span style="color: #00ffff;">def</span> <span style="color: #87cefa;">divide_evenly</span>(dividend, divisor):
        (<span style="color: #eedd82;">quotient</span>, <span style="color: #eedd82;">remainder</span>) = <span style="color: #b0c4de;">divmod</span>(dividend, divisor)
        <span style="color: #00ffff;">if</span> remainder == 0:
            <span style="color: #00ffff;">return</span> quotient
        <span style="color: #00ffff;">else</span>:
            <span style="color: #00ffff;">raise</span> <span style="color: #98fb98;">ValueError</span>(<span style="color: #b0c4de;">str</span>(dividend) + <span style="color: #ffa07a;">" must be an exact multiple of "</span> + <span style="color: #b0c4de;">str</span>(divisor) + <span style="color: #ffa07a;">"."</span>)

    @<span style="color: #b0c4de;">staticmethod</span>
    <span style="color: #00ffff;">def</span> <span style="color: #87cefa;">maybe_repeat_array</span>(array, axis_repetitions):
        <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">        TODO: Add docstring.</span>
<span style="color: #ffa07a;">        """</span>
        (<span style="color: #eedd82;">axis</span>, <span style="color: #eedd82;">repetitions</span>) = axis_repetitions
        <span style="color: #00ffff;">return</span> np.repeat(array, repetitions, axis) <span style="color: #00ffff;">if</span> (repetitions &gt; 1) <span style="color: #00ffff;">else</span> array

    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">FIXME: Inefficient invocation with match/case</span>
    <span style="color: #00ffff;">def</span> <span style="color: #87cefa;">get</span>(<span style="color: #00ffff;">self</span>, *args):
        <span style="color: #00ffff;">match</span> <span style="color: #b0c4de;">len</span>(args):
            <span style="color: #00ffff;">case</span> 1:
                (<span style="color: #eedd82;">t</span>) = args
                <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">self</span>.data[t]
            <span style="color: #00ffff;">case</span> 2:
                (<span style="color: #eedd82;">y</span>,<span style="color: #eedd82;">x</span>) = args
                <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">self</span>.data[:,y,x]
            <span style="color: #00ffff;">case</span> 3:
                (<span style="color: #eedd82;">t</span>,<span style="color: #eedd82;">y</span>,<span style="color: #eedd82;">x</span>) = args
                <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">self</span>.data[t,y,x]
            <span style="color: #00ffff;">case</span> _:
                <span style="color: #00ffff;">raise</span> <span style="color: #98fb98;">ValueError</span>(<span style="color: #ffa07a;">"ArrayGrid3D.get() takes 1-3 arguments."</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-org1e30146" class="outline-3">
<h3 id="org1e30146"><span class="section-number-3">2.5.</span> Lazy Loading of Space-Time Chunks</h3>
<div class="outline-text-3" id="text-2-5">
<p>
In order to avoid the need to fully load all of the 3D space-time
cube's environmental datasets into memory at the beginning of a fire
behavior simulation, Pyretechnics implements a lazy-loading mechanism
that works as follows:
</p>

<ol class="org-ol">
<li>The 3D space-time cube is assigned a <b>simulation shape</b> \((T_s, Y_s,
   X_s)\), which describes the number of timesteps, rows, and columns
it contains. This must be an exact multiple (in every dimension) of
the <b>layer shapes</b> described below.</li>

<li>Each input dataset is assigned a <b>layer shape</b> \((T_l, Y_l, X_l)\),
which describes the number of timesteps, rows, and columns it
contains.</li>

<li>Each input dataset is assigned a <b>chunk shape</b> \((T_c, Y_c,
   X_c)\), which describes the number of timesteps, rows, and columns
to be loaded from the corresponding layer when requesting a new
chunk of data within its spatio-temporal extent. All chunk
dimensions must exactly divide their corresponding layer
dimensions.</li>

<li>Each input dataset is assigned a <b>chunk cache</b> with shape
\((T_l/T_c, Y_l/Y_c, X_l/X_c)\). This is represented in memory as a
3D array of pointers, initialized to nulls.</li>

<li>Each input dataset is assigned a 3D look-up function to be used in
fire behavior calculations.

<ol class="org-ol">
<li>Whenever this function is called on a space-time coordinate
which has no value in the <b>chunk cache</b>, a call is first made
automatically to load the array chunk containing this coordinate
from the underlying input dataset into the <b>chunk cache</b>, and
then the coordinate value is looked up and returned.</li>

<li>Whenever this function is called on a space-time coordinate
which has a value in the <b>chunk cache</b>, it is looked up and
returned.</li>
</ol></li>
</ol>

<p>
The net effect of this chunked data model approach is that
Pyretechnics only needs to load into memory those space-time chunks
which are intersected by the expanding conical burn scar. In
simulations of fires that are small relative to the extent of the full
3D space-time environment, these memory savings may be substantial and
may make it possible to run simulations over larger extents and/or
finer resolutions than have been used previously.
</p>
</div>
</div>

<div id="outline-container-org7b0757c" class="outline-3">
<h3 id="org7b0757c"><span class="section-number-3">2.6.</span> Lazy-Loading Multi-Resolution Array Lookup Functions</h3>
<div class="outline-text-3" id="text-2-6">
<div class="org-src-container">
<pre class="src src-python" id="org2770632"><span style="color: #00ffff;">import</span> numpy <span style="color: #00ffff;">as</span> np

<span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">==============================================================</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Lazy-Loading Multi-Resolution Array Lookup Functions</span>
<span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">==============================================================</span>

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">translate_coords_2d</span>(coords_2d, simulation_shape_2d, layer_shape_2d, chunk_shape_2d):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Given row y and column x on the simulation grid, return chunk</span>
<span style="color: #ffa07a;">    row cy, chunk column cx, subchunk row c_y, and subchunk column c_x on</span>
<span style="color: #ffa07a;">    the chunk grid.</span>
<span style="color: #ffa07a;">    NOTE: (y,x) = (0,0) is the upper-left corner of the array.</span>
<span style="color: #ffa07a;">    NOTE: simulation_shape_2d &gt;= layer_shape_2d &gt;= chunk_shape_2d</span>
<span style="color: #ffa07a;">    """</span>
    (<span style="color: #eedd82;">y</span>, <span style="color: #eedd82;">x</span>) = coords_2d
    (<span style="color: #eedd82;">simulation_rows</span>, <span style="color: #eedd82;">simulation_cols</span>) = simulation_shape_2d
    (<span style="color: #eedd82;">layer_rows</span>, <span style="color: #eedd82;">layer_cols</span>) = layer_shape_2d
    (<span style="color: #eedd82;">chunk_rows</span>, <span style="color: #eedd82;">chunk_cols</span>) = chunk_shape_2d
    <span style="color: #eedd82;">ly</span> = y // (simulation_rows // layer_rows)
    <span style="color: #eedd82;">lx</span> = x // (simulation_cols // layer_cols)
    <span style="color: #eedd82;">cy</span>  = ly // chunk_rows
    <span style="color: #eedd82;">cx</span>  = lx // chunk_cols
    <span style="color: #eedd82;">c_y</span> = ly % chunk_rows
    <span style="color: #eedd82;">c_x</span> = lx % chunk_cols
    <span style="color: #00ffff;">return</span> (cy, cx, c_y, c_x)

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">translate_coords_3d</span>(coords_3d, simulation_shape_3d, layer_shape_3d, chunk_shape_3d):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Given band z, row y, and column x on the simulation grid,</span>
<span style="color: #ffa07a;">    return chunk band cz, chunk row cy, chunk column cx, subchunk band</span>
<span style="color: #ffa07a;">    c_z, subchunk row c_y, and subchunk column c_x on the chunk grid.</span>
<span style="color: #ffa07a;">    NOTE: (z,y,x) = (0,0,0) is the upper-left corner of the array in the first timestep.</span>
<span style="color: #ffa07a;">    NOTE: simulation_shape_3d &gt;= layer_shape_3d &gt;= chunk_shape_3d</span>
<span style="color: #ffa07a;">    """</span>
    (<span style="color: #eedd82;">z</span>, <span style="color: #eedd82;">y</span>, <span style="color: #eedd82;">x</span>) = coords_3d
    (<span style="color: #eedd82;">simulation_bands</span>, <span style="color: #eedd82;">simulation_rows</span>, <span style="color: #eedd82;">simulation_cols</span>) = simulation_shape_3d
    (<span style="color: #eedd82;">layer_bands</span>, <span style="color: #eedd82;">layer_rows</span>, <span style="color: #eedd82;">layer_cols</span>) = layer_shape_3d
    (<span style="color: #eedd82;">chunk_bands</span>, <span style="color: #eedd82;">chunk_rows</span>, <span style="color: #eedd82;">chunk_cols</span>) = chunk_shape_3d
    <span style="color: #eedd82;">lz</span> = z // (simulation_bands // layer_bands)
    <span style="color: #eedd82;">ly</span> = y // (simulation_rows // layer_rows)
    <span style="color: #eedd82;">lx</span> = x // (simulation_cols // layer_cols)
    <span style="color: #eedd82;">cz</span>  = lz // chunk_bands
    <span style="color: #eedd82;">cy</span>  = ly // chunk_rows
    <span style="color: #eedd82;">cx</span>  = lx // chunk_cols
    <span style="color: #eedd82;">c_z</span> = lz % chunk_bands
    <span style="color: #eedd82;">c_y</span> = ly % chunk_rows
    <span style="color: #eedd82;">c_x</span> = lx % chunk_cols
    <span style="color: #00ffff;">return</span> (cz, cy, cx, c_z, c_y, c_x)

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">get_or_load_chunk_2d</span>(chunk_cache_2d, cy, cx, load_chunk_2d):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Checks whether chunk_cache_2d contains chunk (cy, cx). If so,</span>
<span style="color: #ffa07a;">    return it. Otherwise, call load_chunk_2d(cy, cx) to retrieve it,</span>
<span style="color: #ffa07a;">    store it in chunk_cache_2d, and return it.</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #eedd82;">chunk_2d</span> = chunk_cache_2d[cy, cx]
    <span style="color: #00ffff;">if</span> (<span style="color: #b0c4de;">type</span>(chunk_2d) == np.ndarray):
        <span style="color: #00ffff;">return</span> chunk_2d
    <span style="color: #00ffff;">else</span>:
        <span style="color: #eedd82;">chunk_2d</span> = load_chunk_2d(cy, cx)
        <span style="color: #eedd82;">chunk_cache_2d</span>[<span style="color: #eedd82;">cy</span>, <span style="color: #eedd82;">cx</span>] = chunk_2d
        <span style="color: #00ffff;">return</span> chunk_2d

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">get_or_load_chunk_3d</span>(chunk_cache_3d, cz, cy, cx, load_chunk_3d):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Checks whether chunk_cache_3d contains chunk (cz, cy, cx). If so,</span>
<span style="color: #ffa07a;">    return it. Otherwise, call load_chunk_3d(cz, cy, cx) to retrieve it,</span>
<span style="color: #ffa07a;">    store it in chunk_cache_3d, and return it.</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #eedd82;">chunk_3d</span> = chunk_cache_3d[cz, cy, cx]
    <span style="color: #00ffff;">if</span> (<span style="color: #b0c4de;">type</span>(chunk_3d) == np.ndarray):
        <span style="color: #00ffff;">return</span> chunk_3d
    <span style="color: #00ffff;">else</span>:
        <span style="color: #eedd82;">chunk_3d</span> = load_chunk_3d(cz, cy, cx)
        <span style="color: #eedd82;">chunk_cache_3d</span>[<span style="color: #eedd82;">cz</span>, <span style="color: #eedd82;">cy</span>, <span style="color: #eedd82;">cx</span>] = chunk_3d
        <span style="color: #00ffff;">return</span> chunk_3d

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">at_coords_2d</span>(coords_2d, simulation_shape_2d, layer_shape_2d, chunk_shape_2d, chunk_cache_2d, load_chunk_2d):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Given row y and column x on the simulation grid, return the</span>
<span style="color: #ffa07a;">    value at that index in the underlying chunk cache.</span>
<span style="color: #ffa07a;">    NOTE: (y,x) = (0,0) is the upper-left corner of the array.</span>
<span style="color: #ffa07a;">    """</span>
    (<span style="color: #eedd82;">cy</span>, <span style="color: #eedd82;">cx</span>, <span style="color: #eedd82;">c_y</span>, <span style="color: #eedd82;">c_x</span>) = translate_coords_2d(coords_2d, simulation_shape_2d, layer_shape_2d, chunk_shape_2d)
    <span style="color: #eedd82;">chunk_2d</span> = get_or_load_chunk_2d(chunk_cache_2d, cy, cx, load_chunk_2d)
    <span style="color: #00ffff;">return</span> chunk_2d[c_y, c_x]

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">at_coords_3d</span>(coords_3d, simulation_shape_3d, layer_shape_3d, chunk_shape_3d, chunk_cache_3d, load_chunk_3d):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Given band z, row y, and column x on the simulation grid,</span>
<span style="color: #ffa07a;">    return the value at that index in the underlying chunk cache.</span>
<span style="color: #ffa07a;">    NOTE: (z,y,x) = (0,0,0) is the upper-left corner of the array in the first timestep.</span>
<span style="color: #ffa07a;">    """</span>
    (<span style="color: #eedd82;">cz</span>, <span style="color: #eedd82;">cy</span>, <span style="color: #eedd82;">cx</span>, <span style="color: #eedd82;">c_z</span>, <span style="color: #eedd82;">c_y</span>, <span style="color: #eedd82;">c_x</span>) = translate_coords_3d(coords_3d, simulation_shape_3d, layer_shape_3d, chunk_shape_3d)
    <span style="color: #eedd82;">chunk_3d</span> = get_or_load_chunk_3d(chunk_cache_3d, cz, cy, cx, load_chunk_3d)
    <span style="color: #00ffff;">return</span> chunk_3d[c_z, c_y, c_x]

<span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">==============================================================</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Constructor: Returns a 2D/3D Lookup Function for One Array</span>
<span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">==============================================================</span>

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">make_lookup_fn_2d</span>(simulation_shape_2d, layer_shape_2d, chunk_shape_2d, load_chunk_2d):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Given the array shapes of the simulation space (|Y|,|X|), the</span>
<span style="color: #ffa07a;">    underlying data layer (|LY|,|LX|), and a single chunk within the</span>
<span style="color: #ffa07a;">    chunk cache (|CY|,|CX|) as well as a function to load one chunk</span>
<span style="color: #ffa07a;">    on demand, return a closure that will retrieve the value from the</span>
<span style="color: #ffa07a;">    underlying data layer corresponding to coordinate (y,x) in the</span>
<span style="color: #ffa07a;">    simulation space. Chunks will be loaded on demand using load_chunk_2d.</span>
<span style="color: #ffa07a;">    NOTE: (y,x) = (0,0) is the upper-left corner of the array.</span>
<span style="color: #ffa07a;">    NOTE: simulation_shape_2d &gt;= layer_shape_2d &gt;= chunk_shape_2d</span>
<span style="color: #ffa07a;">    """</span>
    (<span style="color: #eedd82;">layer_rows</span>, <span style="color: #eedd82;">layer_cols</span>) = layer_shape_2d
    (<span style="color: #eedd82;">chunk_rows</span>, <span style="color: #eedd82;">chunk_cols</span>) = chunk_shape_2d
    <span style="color: #eedd82;">chunk_cache_2d</span> = np.empty((layer_rows // chunk_rows,
                               layer_cols // chunk_cols),
                              dtype=<span style="color: #b0c4de;">object</span>)
    <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">lambda</span> y, x: at_coords_2d((y, x),
                                     simulation_shape_2d,
                                     layer_shape_2d,
                                     chunk_shape_2d,
                                     chunk_cache_2d,
                                     load_chunk_2d)

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">make_lookup_fn_3d</span>(simulation_shape_3d, layer_shape_3d, chunk_shape_3d, load_chunk_3d):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Given the array shapes of the simulation space (|Z|,|Y|,|X|), the</span>
<span style="color: #ffa07a;">    underlying data layer (|LZ|,|LY|,|LX|), and a single chunk within the</span>
<span style="color: #ffa07a;">    chunk cache (|CZ|,|CY|,|CX|) as well as a function to load one chunk</span>
<span style="color: #ffa07a;">    on demand, return a closure that will retrieve the value from the</span>
<span style="color: #ffa07a;">    underlying data layer corresponding to coordinate (z,y,x) in the</span>
<span style="color: #ffa07a;">    simulation space. Chunks will be loaded on demand using load_chunk_3d.</span>
<span style="color: #ffa07a;">    NOTE: (z,y,x) = (0,0,0) is the upper-left corner of the array in the first timestep.</span>
<span style="color: #ffa07a;">    NOTE: simulation_shape_3d &gt;= layer_shape_3d &gt;= chunk_shape_3d</span>
<span style="color: #ffa07a;">    """</span>
    (<span style="color: #eedd82;">layer_bands</span>, <span style="color: #eedd82;">layer_rows</span>, <span style="color: #eedd82;">layer_cols</span>) = layer_shape_3d
    (<span style="color: #eedd82;">chunk_bands</span>, <span style="color: #eedd82;">chunk_rows</span>, <span style="color: #eedd82;">chunk_cols</span>) = chunk_shape_3d
    <span style="color: #eedd82;">chunk_cache_3d</span> = np.empty((layer_bands // chunk_bands,
                               layer_rows // chunk_rows,
                               layer_cols // chunk_cols),
                              dtype=<span style="color: #b0c4de;">object</span>)
    <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">lambda</span> z, y, x: at_coords_3d((z, y, x),
                                        simulation_shape_3d,
                                        layer_shape_3d,
                                        chunk_shape_3d,
                                        chunk_cache_3d,
                                        load_chunk_3d)
</pre>
</div>
</div>
</div>

<div id="outline-container-org6f3c9ad" class="outline-3">
<h3 id="org6f3c9ad"><span class="section-number-3">2.7.</span> Lazy Array Usage Examples</h3>
<div class="outline-text-3" id="text-2-7">
<div class="org-src-container">
<pre class="src src-python" id="orgd37b0cd"><span style="color: #00ffff;">import</span> numpy <span style="color: #00ffff;">as</span> np
<span style="color: #00ffff;">from</span> pyretechnics.lazy_array <span style="color: #00ffff;">import</span> make_lookup_fn_2d, make_lookup_fn_3d

<span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">==============================================================</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Example Chunk Loading Functions</span>
<span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">==============================================================</span>

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">make_load_chunk_2d</span>(layer_2d, chunk_shape_2d):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Example 2D chunk loading function. Since we are calling the</span>
<span style="color: #ffa07a;">    lazy array functions from Python and they will be used as</span>
<span style="color: #ffa07a;">    read-only data by the caller, we can just provide a sliced view of</span>
<span style="color: #ffa07a;">    the underlying array rather than generating a copy.</span>
<span style="color: #ffa07a;">    """</span>
    (<span style="color: #eedd82;">chunk_rows</span>, <span style="color: #eedd82;">chunk_cols</span>) = chunk_shape_2d
    <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">lambda</span> cy, cx: layer_2d[cy * chunk_rows : (cy + 1) * chunk_rows,
                                   cx * chunk_cols : (cx + 1) * chunk_cols]


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">make_load_chunk_3d</span>(layer_3d, chunk_shape_3d):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Example 3D chunk loading function. Since we are calling the</span>
<span style="color: #ffa07a;">    lazy array functions from Python and they will be used as</span>
<span style="color: #ffa07a;">    read-only data by the caller, we can just provide a sliced view of</span>
<span style="color: #ffa07a;">    the underlying array rather than generating a copy.</span>
<span style="color: #ffa07a;">    """</span>
    (<span style="color: #eedd82;">chunk_bands</span>, <span style="color: #eedd82;">chunk_rows</span>, <span style="color: #eedd82;">chunk_cols</span>) = chunk_shape_3d
    <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">lambda</span> cz, cy, cx: layer_3d[cz * chunk_bands : (cz + 1) * chunk_bands,
                                       cy * chunk_rows  : (cy + 1) * chunk_rows,
                                       cx * chunk_cols  : (cx + 1) * chunk_cols]

<span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">==============================================================</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Example Lookup Functions for 1000x1000 and 24x100x100 Layers</span>
<span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">==============================================================</span>

<span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">--------------------  bands, rows, cols</span>
<span style="color: #eedd82;">simulation_shape_2d</span> = (       1000, 1000)
<span style="color: #eedd82;">layer_shape_2d</span>      = (       1000, 1000)
<span style="color: #eedd82;">chunk_shape_2d</span>      = (        100,  100)

<span style="color: #eedd82;">simulation_shape_3d</span> = (   24, 1000, 1000)
<span style="color: #eedd82;">layer_shape_3d</span>      = (   24,  100,  100)
<span style="color: #eedd82;">chunk_shape_3d</span>      = (    1,   10,   10)

<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Partial Application Functions</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">make_lookup_fn_2d_for_layer</span>(layer_2d):
    <span style="color: #00ffff;">return</span> make_lookup_fn_2d(simulation_shape_2d,
                             layer_shape_2d,
                             chunk_shape_2d,
                             make_load_chunk_2d(layer_2d, chunk_shape_2d))


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">make_lookup_fn_3d_for_layer</span>(layer_3d):
    <span style="color: #00ffff;">return</span> make_lookup_fn_3d(simulation_shape_3d,
                             layer_shape_3d,
                             chunk_shape_3d,
                             make_load_chunk_3d(layer_3d, chunk_shape_3d))

<span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">==============================================================</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Raw Data - Managed by the Caller</span>
<span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">==============================================================</span>

<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">2D Arrays (e.g. 30m x 30m resolution, 30km x 30km extent)</span>
<span style="color: #eedd82;">elevation_layer</span>                    = np.arange(0,1000000).reshape(1000,1000)
<span style="color: #eedd82;">slope_layer</span>                        = np.arange(0,1000000).reshape(1000,1000)
<span style="color: #eedd82;">aspect_layer</span>                       = np.arange(0,1000000).reshape(1000,1000)
<span style="color: #eedd82;">fuel_model_layer</span>                   = np.arange(0,1000000).reshape(1000,1000)
<span style="color: #eedd82;">canopy_cover_layer</span>                 = np.arange(0,1000000).reshape(1000,1000)
<span style="color: #eedd82;">canopy_height_layer</span>                = np.arange(0,1000000).reshape(1000,1000)
<span style="color: #eedd82;">canopy_base_height_layer</span>           = np.arange(0,1000000).reshape(1000,1000)
<span style="color: #eedd82;">canopy_bulk_density_layer</span>          = np.arange(0,1000000).reshape(1000,1000)
<span style="color: #eedd82;">fuel_spread_adjustment_layer</span>       = np.arange(0,1000000).reshape(1000,1000) <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Optional</span>
<span style="color: #eedd82;">suppression_difficulty_index_layer</span> = np.arange(0,1000000).reshape(1000,1000) <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Optional</span>

<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">3D Arrays (e.g. 1hr x 300m x 300m resolution, 1day x 30km x 30km extent)</span>
<span style="color: #eedd82;">temperature_layer</span>                   = np.arange(240000).reshape(24,100,100)
<span style="color: #eedd82;">relative_humidity_layer</span>             = np.arange(240000).reshape(24,100,100)
<span style="color: #eedd82;">wind_speed_10m_x_layer</span>              = np.arange(240000).reshape(24,100,100)
<span style="color: #eedd82;">wind_speed_10m_y_layer</span>              = np.arange(240000).reshape(24,100,100)
<span style="color: #eedd82;">fuel_moisture_dead_1hr_layer</span>        = np.arange(240000).reshape(24,100,100)
<span style="color: #eedd82;">fuel_moisture_dead_10hr_layer</span>       = np.arange(240000).reshape(24,100,100)
<span style="color: #eedd82;">fuel_moisture_dead_100hr_layer</span>      = np.arange(240000).reshape(24,100,100)
<span style="color: #eedd82;">fuel_moisture_live_herbaceous_layer</span> = np.arange(240000).reshape(24,100,100)
<span style="color: #eedd82;">fuel_moisture_live_woody_layer</span>      = np.arange(240000).reshape(24,100,100)
<span style="color: #eedd82;">foliar_moisture_layer</span>               = np.arange(240000).reshape(24,100,100)
<span style="color: #eedd82;">weather_spread_adjustment_layer</span>     = np.arange(240000).reshape(24,100,100) <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Optional</span>

<span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">==============================================================</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Creating the Dictionary of Layer Names to Lookup Functions</span>
<span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">==============================================================</span>

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">test_make_layer_lookup</span>():
    <span style="color: #eedd82;">layer_lookup</span> = {
        <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">2D Arrays (e.g. 30m x 30m resolution, 30km x 30km extent)</span>
        <span style="color: #ffa07a;">"elevation"</span>                    : make_lookup_fn_2d_for_layer(elevation_layer),
        <span style="color: #ffa07a;">"slope"</span>                        : make_lookup_fn_2d_for_layer(slope_layer),
        <span style="color: #ffa07a;">"aspect"</span>                       : make_lookup_fn_2d_for_layer(aspect_layer),
        <span style="color: #ffa07a;">"fuel_model"</span>                   : make_lookup_fn_2d_for_layer(fuel_model_layer),
        <span style="color: #ffa07a;">"canopy_cover"</span>                 : make_lookup_fn_2d_for_layer(canopy_cover_layer),
        <span style="color: #ffa07a;">"canopy_height"</span>                : make_lookup_fn_2d_for_layer(canopy_height_layer),
        <span style="color: #ffa07a;">"canopy_base_height"</span>           : make_lookup_fn_2d_for_layer(canopy_base_height_layer),
        <span style="color: #ffa07a;">"canopy_bulk_density"</span>          : make_lookup_fn_2d_for_layer(canopy_bulk_density_layer),
        <span style="color: #ffa07a;">"fuel_spread_adjustment"</span>       : make_lookup_fn_2d_for_layer(fuel_spread_adjustment_layer),       <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Optional</span>
        <span style="color: #ffa07a;">"suppression_difficulty_index"</span> : make_lookup_fn_2d_for_layer(suppression_difficulty_index_layer), <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Optional</span>

        <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">3D Arrays (e.g. 1hr x 300m x 300m resolution, 1day x 30km x 30km extent)</span>
        <span style="color: #ffa07a;">"temperature"</span>                  : make_lookup_fn_3d_for_layer(temperature_layer),
        <span style="color: #ffa07a;">"relative_humidity"</span>            : make_lookup_fn_3d_for_layer(relative_humidity_layer),
        <span style="color: #ffa07a;">"wind_speed_10m_x"</span>             : make_lookup_fn_3d_for_layer(wind_speed_10m_x_layer),
        <span style="color: #ffa07a;">"wind_speed_10m_y"</span>             : make_lookup_fn_3d_for_layer(wind_speed_10m_y_layer),
        <span style="color: #ffa07a;">"fuel_moisture_dead_1hr"</span>       : make_lookup_fn_3d_for_layer(fuel_moisture_dead_1hr_layer),
        <span style="color: #ffa07a;">"fuel_moisture_dead_10hr"</span>      : make_lookup_fn_3d_for_layer(fuel_moisture_dead_10hr_layer),
        <span style="color: #ffa07a;">"fuel_moisture_dead_100hr"</span>     : make_lookup_fn_3d_for_layer(fuel_moisture_dead_100hr_layer),
        <span style="color: #ffa07a;">"fuel_moisture_live_herbaceous"</span>: make_lookup_fn_3d_for_layer(fuel_moisture_live_herbaceous_layer),
        <span style="color: #ffa07a;">"fuel_moisture_live_woody"</span>     : make_lookup_fn_3d_for_layer(fuel_moisture_live_woody_layer),
        <span style="color: #ffa07a;">"foliar_moisture"</span>              : make_lookup_fn_3d_for_layer(foliar_moisture_layer),
        <span style="color: #ffa07a;">"weather_spread_adjustment"</span>    : make_lookup_fn_3d_for_layer(weather_spread_adjustment_layer),    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Optional</span>
    }
    <span style="color: #00ffff;">assert</span> <span style="color: #b0c4de;">all</span>(<span style="color: #b0c4de;">map</span>(<span style="color: #00ffff;">lambda</span> v: <span style="color: #b0c4de;">callable</span>(v), layer_lookup.values()))
    <span style="color: #00ffff;">return</span> layer_lookup

<span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">==============================================================</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Looking Up Values in the Layers</span>
<span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">==============================================================</span>

<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">NOTE: 2D coords should be provided as (y,x) in simulation space.</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">test_use_layer_lookup_2d</span>():
    <span style="color: #eedd82;">layer_lookup</span> = test_make_layer_lookup()
    <span style="color: #eedd82;">dem_100_100</span>  = layer_lookup[<span style="color: #ffa07a;">"elevation"</span>](100,100)
    <span style="color: #eedd82;">slp_100_100</span>  = layer_lookup[<span style="color: #ffa07a;">"slope"</span>](100,100)
    <span style="color: #eedd82;">asp_100_100</span>  = layer_lookup[<span style="color: #ffa07a;">"aspect"</span>](100,100)
    <span style="color: #eedd82;">fbfm_100_100</span> = layer_lookup[<span style="color: #ffa07a;">"fuel_model"</span>](100,100)
    <span style="color: #eedd82;">cc_100_100</span>   = layer_lookup[<span style="color: #ffa07a;">"canopy_cover"</span>](100,100)
    <span style="color: #eedd82;">ch_100_100</span>   = layer_lookup[<span style="color: #ffa07a;">"canopy_height"</span>](100,100)
    <span style="color: #eedd82;">cbh_100_100</span>  = layer_lookup[<span style="color: #ffa07a;">"canopy_base_height"</span>](100,100)
    <span style="color: #eedd82;">cbd_100_100</span>  = layer_lookup[<span style="color: #ffa07a;">"canopy_bulk_density"</span>](100,100)
    <span style="color: #eedd82;">fsa_100_100</span>  = layer_lookup[<span style="color: #ffa07a;">"fuel_spread_adjustment"</span>](100,100)           <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Optional</span>
    <span style="color: #eedd82;">sdi_100_100</span>  = layer_lookup[<span style="color: #ffa07a;">"suppression_difficulty_index"</span>](100,100)     <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Optional</span>
    <span style="color: #00ffff;">assert</span> dem_100_100  == 100100
    <span style="color: #00ffff;">assert</span> slp_100_100  == 100100
    <span style="color: #00ffff;">assert</span> asp_100_100  == 100100
    <span style="color: #00ffff;">assert</span> fbfm_100_100 == 100100
    <span style="color: #00ffff;">assert</span> cc_100_100   == 100100
    <span style="color: #00ffff;">assert</span> ch_100_100   == 100100
    <span style="color: #00ffff;">assert</span> cbh_100_100  == 100100
    <span style="color: #00ffff;">assert</span> cbd_100_100  == 100100
    <span style="color: #00ffff;">assert</span> fsa_100_100  == 100100
    <span style="color: #00ffff;">assert</span> sdi_100_100  == 100100


<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">NOTE: 3D coords should be provided as (t,y,x) in simulation space.</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">test_use_layer_lookup_3d</span>():
    <span style="color: #eedd82;">layer_lookup</span> = test_make_layer_lookup()
    <span style="color: #eedd82;">temp_12_100_100</span>  = layer_lookup[<span style="color: #ffa07a;">"temperature"</span>](12,100,100)
    <span style="color: #eedd82;">rh_12_100_100</span>    = layer_lookup[<span style="color: #ffa07a;">"relative_humidity"</span>](12,100,100)
    <span style="color: #eedd82;">wspx_12_100_100</span>  = layer_lookup[<span style="color: #ffa07a;">"wind_speed_10m_x"</span>](12,100,100)
    <span style="color: #eedd82;">wspy_12_100_100</span>  = layer_lookup[<span style="color: #ffa07a;">"wind_speed_10m_y"</span>](12,100,100)
    <span style="color: #eedd82;">md1_12_100_100</span>   = layer_lookup[<span style="color: #ffa07a;">"fuel_moisture_dead_1hr"</span>](12,100,100)
    <span style="color: #eedd82;">md10_12_100_100</span>  = layer_lookup[<span style="color: #ffa07a;">"fuel_moisture_dead_10hr"</span>](12,100,100)
    <span style="color: #eedd82;">md100_12_100_100</span> = layer_lookup[<span style="color: #ffa07a;">"fuel_moisture_dead_100hr"</span>](12,100,100)
    <span style="color: #eedd82;">mlh_12_100_100</span>   = layer_lookup[<span style="color: #ffa07a;">"fuel_moisture_live_herbaceous"</span>](12,100,100)
    <span style="color: #eedd82;">mlw_12_100_100</span>   = layer_lookup[<span style="color: #ffa07a;">"fuel_moisture_live_woody"</span>](12,100,100)
    <span style="color: #eedd82;">fm_12_100_100</span>    = layer_lookup[<span style="color: #ffa07a;">"foliar_moisture"</span>](12,100,100)
    <span style="color: #eedd82;">wsa_12_100_100</span>   = layer_lookup[<span style="color: #ffa07a;">"weather_spread_adjustment"</span>](12,100,100) <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Optional</span>
    <span style="color: #00ffff;">assert</span> temp_12_100_100  == 121010
    <span style="color: #00ffff;">assert</span> rh_12_100_100    == 121010
    <span style="color: #00ffff;">assert</span> wspx_12_100_100  == 121010
    <span style="color: #00ffff;">assert</span> wspy_12_100_100  == 121010
    <span style="color: #00ffff;">assert</span> md1_12_100_100   == 121010
    <span style="color: #00ffff;">assert</span> md10_12_100_100  == 121010
    <span style="color: #00ffff;">assert</span> md100_12_100_100 == 121010
    <span style="color: #00ffff;">assert</span> mlh_12_100_100   == 121010
    <span style="color: #00ffff;">assert</span> mlw_12_100_100   == 121010
    <span style="color: #00ffff;">assert</span> fm_12_100_100    == 121010
    <span style="color: #00ffff;">assert</span> wsa_12_100_100   == 121010
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org7d8e155" class="outline-2">
<h2 id="org7d8e155"><span class="section-number-2">3.</span> Fire Spread API</h2>
<div class="outline-text-2" id="text-3">
<p>
Pyretechnics provides two main functions for simulating fire behavior over a region of space-time:
</p>
</div>

<div id="outline-container-org1d1a6d2" class="outline-3">
<h3 id="org1d1a6d2"><span class="section-number-3">3.1.</span> grow_fire</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Simulates the growth of a fire over space and time starting from one
or more actively burning cells. Suppression effects may be optionally
applied, and several different stop conditions may be specified. A
random seed may be optionally provided to ensure deterministically
reproducible runs, despite the presence of stochastic calculations
within the fire spread algorithm.
</p>
</div>

<div id="outline-container-org2637ec1" class="outline-4">
<h4 id="org2637ec1"><span class="section-number-4">3.1.1.</span> Inputs</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
The <code>grow_fire</code> function takes a single <code>world_state</code> dictionary as input with these fields:
</p>

<dl class="org-dl">
<dt>simulation_clock</dt><dd>a float specifying the number of minutes from the start time of the simulated space-time cube to begin the simulation</dd>

<dt>config_dict</dt><dd><p>
a dictionary of parameter names to their values with the following types:
</p>

<p>
<b>TODO</b>: Determine whether rectangular cells will work for the GridFire and ELMFIRE spread algorithms. If not, eliminate this degree of freedom from the API.
<b>TODO</b>: Add interpolation options to the gridded data source class
<b>TODO</b>: simulation_north_angle may be dropped if we require inputs to use North-up projections for both fuels and weather
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Parameter Name</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Units</th>
<th scope="col" class="org-left">Optional?</th>
<th scope="col" class="org-left">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">simulation_shape</td>
<td class="org-left">Tuple (int, int, int)</td>
<td class="org-left">(num timesteps, num rows, num cols)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">simulation_resolution</td>
<td class="org-left">Tuple (float, float, float)</td>
<td class="org-left">(minutes per timestep, meters per row, meters per column)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">simulation_north_angle</td>
<td class="org-left">float</td>
<td class="org-left">degrees clockwise from the top of the circle [0,360)</td>
<td class="org-left">Yes</td>
<td class="org-left">0.0</td>
</tr>

<tr>
<td class="org-left">simulation_stop_condition</td>
<td class="org-left">Dictionary {string: float}</td>
<td class="org-left">either {'max_burn_duration': minutes} or {'max_burned_area': square_meters}</td>
<td class="org-left">Yes</td>
<td class="org-left">None</td>
</tr>

<tr>
<td class="org-left">random_seed</td>
<td class="org-left">number or string</td>
<td class="org-left">the seed value to initialize the random number generator</td>
<td class="org-left">Yes</td>
<td class="org-left">None</td>
</tr>

<tr>
<td class="org-left">overwrite_outputs</td>
<td class="org-left">boolean</td>
<td class="org-left">True or False, whether to mutate or copy the Numpy arrays provided in <b>output_layer_dict</b></td>
<td class="org-left">Yes</td>
<td class="org-left">False</td>
</tr>

<tr>
<td class="org-left">alpha_suppression</td>
<td class="org-left">Dictionary {string: float}</td>
<td class="org-left">parameters for the <b>alpha</b> suppression algorithm (see table below)</td>
<td class="org-left">Yes</td>
<td class="org-left">None</td>
</tr>

<tr>
<td class="org-left">sdi_suppression</td>
<td class="org-left">Dictionary {string: float}</td>
<td class="org-left">parameters for the <b>sdi</b> suppression algorithm (see table below)</td>
<td class="org-left">Yes</td>
<td class="org-left">None</td>
</tr>

<tr>
<td class="org-left">spotting</td>
<td class="org-left">Dictionary {string: float}</td>
<td class="org-left">parameters for the spotting algorithm (see table below)</td>
<td class="org-left">Yes</td>
<td class="org-left">None</td>
</tr>
</tbody>
</table>

<dl class="org-dl">
<dt>alpha_suppression</dt><dd>a dictionary of parameter names to their values for the <b>alpha</b> suppression algorithm:</dd>
</dl>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Parameter Name</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Units</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">suppression_timestep</td>
<td class="org-left">float</td>
<td class="org-left">minutes between suppression events</td>
</tr>

<tr>
<td class="org-left">suppression_coefficient</td>
<td class="org-left">float</td>
<td class="org-left">unitless</td>
</tr>
</tbody>
</table>

<dl class="org-dl">
<dt>sdi_suppression</dt><dd>a dictionary of parameter names to their values for the <b>sdi</b> suppression algorithm:</dd>
</dl>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Parameter Name</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Units</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">suppression_timestep</td>
<td class="org-left">float</td>
<td class="org-left">minutes between suppression events</td>
</tr>

<tr>
<td class="org-left">sdi_sensitivity_to_difficulty</td>
<td class="org-left">float</td>
<td class="org-left">unitless</td>
</tr>

<tr>
<td class="org-left">sdi_containment_overwhelming_area_growth_rate</td>
<td class="org-left">float</td>
<td class="org-left">hectares/day</td>
</tr>

<tr>
<td class="org-left">sdi_reference_suppression_speed</td>
<td class="org-left">float</td>
<td class="org-left">percent/day</td>
</tr>
</tbody>
</table>

<dl class="org-dl">
<dt>spotting</dt><dd>a dictionary of parameter names to their values for the spotting algorithm:</dd>
</dl>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Parameter Name</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Units</th>
<th scope="col" class="org-left">Fire Model</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">firebrands_per_cell</td>
<td class="org-left">int</td>
<td class="org-left">number of embers to cast from each spotting cell</td>
<td class="org-left">GridFire</td>
</tr>

<tr>
<td class="org-left">decay_constant</td>
<td class="org-left">float</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">GridFire</td>
</tr>

<tr>
<td class="org-left">mean_distance</td>
<td class="org-left">float</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">GridFire</td>
</tr>

<tr>
<td class="org-left">flin_exp</td>
<td class="org-left">float</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">GridFire</td>
</tr>

<tr>
<td class="org-left">ws_exp</td>
<td class="org-left">float</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">GridFire</td>
</tr>

<tr>
<td class="org-left">normalized_distance_variance</td>
<td class="org-left">float</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">GridFire</td>
</tr>

<tr>
<td class="org-left">delta_y_sigma</td>
<td class="org-left">float</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">GridFire</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">ember_gr</td>
<td class="org-left">int</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">pign</td>
<td class="org-left">float</td>
<td class="org-left">percent [0-100]</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">pign_max</td>
<td class="org-left">float</td>
<td class="org-left">percent [0-100]</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">pign_min</td>
<td class="org-left">float</td>
<td class="org-left">percent [0-100]</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">tau_embergen</td>
<td class="org-left">float</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">use_umd_spotting_model</td>
<td class="org-left">boolean</td>
<td class="org-left">True or False</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">p_eps</td>
<td class="org-left">float</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">use_physical_spotting_duration</td>
<td class="org-left">boolean</td>
<td class="org-left">True or False</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">use_physical_ember_number</td>
<td class="org-left">boolean</td>
<td class="org-left">True or False</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">ember_sampling_factor</td>
<td class="org-left">float</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">use_superseded_spotting</td>
<td class="org-left">boolean</td>
<td class="org-left">True or False</td>
<td class="org-left">ELMFIRE</td>
</tr>
</tbody>
</table></dd>

<dt>input_layer_dict</dt><dd><p>
a dictionary of layer names to either 2-arity (2D) or 3-arity (3D) functions for accessing the numeric values at each <code>(y,x)</code> or <code>(z,y,x)</code> coordinate in the simulated space-time cube:
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Layer Name</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Units</th>
<th scope="col" class="org-left">Optional?</th>
<th scope="col" class="org-right">Arity</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">elevation</td>
<td class="org-left">float32</td>
<td class="org-left">meters above sea level [0-8850]</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">slope</td>
<td class="org-left">float32</td>
<td class="org-left">meters rise / meters run [0-4]</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">aspect</td>
<td class="org-left">int16</td>
<td class="org-left">degrees clockwise from North [0-359)</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">fuel_model</td>
<td class="org-left">int16</td>
<td class="org-left">integer classes [1-204]</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">canopy_cover</td>
<td class="org-left">float32</td>
<td class="org-left">canopy area / total area [0-0.95]</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">canopy_height</td>
<td class="org-left">float32</td>
<td class="org-left">meters  [0-51]</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">canopy_base_height</td>
<td class="org-left">float32</td>
<td class="org-left">meters  [0-10]</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">canopy_bulk_density</td>
<td class="org-left">float32</td>
<td class="org-left">kilograms/meters^3 [0-0.45]</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">fuel_spread_adjustment</td>
<td class="org-left">float</td>
<td class="org-left">real number &gt;= 0.0 (1.0 means no adjustment)</td>
<td class="org-left">Yes</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">suppression_difficulty_index</td>
<td class="org-left">float</td>
<td class="org-left">integer &gt;= 0  (TODO: What is the correct value range?)</td>
<td class="org-left">Yes</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">surface_spotting_fire_line_intensity</td>
<td class="org-left">float</td>
<td class="org-left">kilowatts/meter</td>
<td class="org-left">Yes</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">surface_spotting_percent (TODO: min, max?)</td>
<td class="org-left">float</td>
<td class="org-left">percent [0-1]</td>
<td class="org-left">Yes</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">crown_spotting_percent   (TODO: min, max?)</td>
<td class="org-left">float</td>
<td class="org-left">percent [0-1]</td>
<td class="org-left">Yes</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">temperature</td>
<td class="org-left">float</td>
<td class="org-left">degrees Celsius</td>
<td class="org-left">Yes</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">relative_humidity</td>
<td class="org-left">float</td>
<td class="org-left">percent [0-1+]</td>
<td class="org-left">Yes</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">wind_speed_10m_x</td>
<td class="org-left">float</td>
<td class="org-left">meters/minute</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">wind_speed_10m_y</td>
<td class="org-left">float</td>
<td class="org-left">meters/minute</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">fuel_moisture_dead_1hr</td>
<td class="org-left">float</td>
<td class="org-left">ratio [0-1+] grams moisture/grams ovendry wood</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">fuel_moisture_dead_10hr</td>
<td class="org-left">float</td>
<td class="org-left">ratio [0-1+] grams moisture/grams ovendry wood</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">fuel_moisture_dead_100hr</td>
<td class="org-left">float</td>
<td class="org-left">ratio [0-1+] grams moisture/grams ovendry wood</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">fuel_moisture_live_herbaceous</td>
<td class="org-left">float</td>
<td class="org-left">ratio [0-1+] grams moisture/grams ovendry wood</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">fuel_moisture_live_woody</td>
<td class="org-left">float</td>
<td class="org-left">ratio [0-1+] grams moisture/grams ovendry wood</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">foliar_moisture</td>
<td class="org-left">float</td>
<td class="org-left">ratio [0-1+] grams moisture/grams ovendry foliage</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">weather_spread_adjustment</td>
<td class="org-left">float</td>
<td class="org-left">real number &gt;= 0.0 (1.0 means no adjustment)</td>
<td class="org-left">Yes</td>
<td class="org-right">3</td>
</tr>
</tbody>
</table></dd>

<dt>output_layer_dict</dt><dd><p>
an <b>optional</b> dictionary of layer names to 2D Numpy arrays with the following units to pre-populate the simulation output arrays:
<b>TODO</b> Consider whether some of these layers should be kept as internal state and not returned to the user.
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Parameter Name</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Units</th>
<th scope="col" class="org-left">Optional?</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">eulerian_level_set_phi_field</td>
<td class="org-left">float16</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">time_of_arrival</td>
<td class="org-left">float32</td>
<td class="org-left">minutes from the start time of the simulated space-time cube</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">max_surface_spread_direction</td>
<td class="org-left">float16</td>
<td class="org-left">degrees clockwise from North</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">max_crown_spread_direction</td>
<td class="org-left">float16</td>
<td class="org-left">degrees clockwise from North</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">perimeter_spread_direction</td>
<td class="org-left">float16</td>
<td class="org-left">degrees clockwise from North</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">max_surface_spread_rate</td>
<td class="org-left">float16</td>
<td class="org-left">meters/second</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">max_crown_spread_rate</td>
<td class="org-left">float16</td>
<td class="org-left">meters/second</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">perimeter_spread_rate</td>
<td class="org-left">float16</td>
<td class="org-left">meters/second</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">surface_eccentricity</td>
<td class="org-left">float16</td>
<td class="org-left">dimensionless (0: circular fire, &gt;0: elliptical fire)</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">crown_eccentricity</td>
<td class="org-left">float16</td>
<td class="org-left">dimensionless (0: circular fire, &gt;0: elliptical fire)</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">max_surface_fire_line_intensity</td>
<td class="org-left">float32</td>
<td class="org-left">kilowatts/meter</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">max_crown_fire_line_intensity</td>
<td class="org-left">float32</td>
<td class="org-left">kilowatts/meter</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">perimeter_fire_line_intensity</td>
<td class="org-left">float32</td>
<td class="org-left">kilowatts/meter</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">max_surface_flame_length</td>
<td class="org-left">float16</td>
<td class="org-left">meters</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">max_crown_flame_length</td>
<td class="org-left">float16</td>
<td class="org-left">meters</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">perimeter_flame_length</td>
<td class="org-left">float16</td>
<td class="org-left">meters</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">fire_type</td>
<td class="org-left">uint8</td>
<td class="org-left">0 = no_fire, 1 = surface_fire, 2 = passive_crown_fire, 3 = active_crown_fire</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">ember_count</td>
<td class="org-left">uint32</td>
<td class="org-left">number of embers landing in each cell</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">ember_ignition</td>
<td class="org-left">bool8</td>
<td class="org-left">True for cells ignited by embers, False otherwise</td>
<td class="org-left">Yes</td>
</tr>
</tbody>
</table></dd>

<dt>ignited_cells_set</dt><dd>set of cells that are actively burning at the simulation start time, specified as 3D coordinates <code>(z,y,x)</code> in the simulated space-time cube</dd>
</dl>
</div>
</div>

<div id="outline-container-orgcce3edc" class="outline-4">
<h4 id="orgcce3edc"><span class="section-number-4">3.1.2.</span> Outputs</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
The <code>grow_fire</code> function will return a dictionary with these fields:
</p>

<dl class="org-dl">
<dt>simulation_clock</dt><dd>a float specifying the number of minutes from the start time of the simulated space-time cube at which the simulation stopped</dd>

<dt>simulation_stop_condition_encountered</dt><dd>max_burn_duration | max_burned_area | no_burnable_fuel | end_of_temporal_data | fully_suppressed</dd>

<dt>config_dict</dt><dd>a dictionary of parameter names to their values as defined in section <a href="#org2637ec1">3.1.1</a> above</dd>

<dt>input_layer_dict</dt><dd>a dictionary of layer names to either 2-arity (2D) or 3-arity (3D) functions as defined in section <a href="#org2637ec1">3.1.1</a> above</dd>

<dt>output_layer_dict</dt><dd>a dictionary of layer names to 2D Numpy arrays as defined in section <a href="#org2637ec1">3.1.1</a> above</dd>

<dt>ignited_cells_set</dt><dd>set of cells that are actively burning at the simulation stop time, specified as 3D coordinates <code>(z,y,x)</code> in the simulated space-time cube</dd>
</dl>

<p>
Note that <code>config_dict</code> and <code>input_layer_dict</code> will be unchanged from
the input dictionary that was provided to <code>grow_fire</code>. All other
fields will contain values updated by the fire spread simulation.
</p>
</div>
</div>

<div id="outline-container-orgcd1c2bf" class="outline-4">
<h4 id="orgcd1c2bf"><span class="section-number-4">3.1.3.</span> Play/Pause/Continue Workflow</h4>
<div class="outline-text-4" id="text-3-1-3">
<p>
The inputs and outputs of <code>grow_fire</code> are structured so as to enable
you to simulate fire spread from <code>simulation_clock</code> until a stop
condition is encountered and then to easily resume the fire spread
simulation from the output <code>simulation_clock</code> until the next stop
condition is met. Here is an example of how to do this.
</p>

<div class="org-src-container">
<pre class="src src-python" id="orgc8e0697"><span style="color: #00ffff;">import</span> numpy <span style="color: #00ffff;">as</span> np

<span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">=======================================================</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Phase 1: Initial fire simulation - first 12 hours</span>
<span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">=======================================================</span>

<span style="color: #eedd82;">world_state</span> = {
    simulation_clock: 0.0,

    config_dict: {
        <span style="color: #ffa07a;">"simulation_shape"</span>         : (24, 1000, 1000),
        <span style="color: #ffa07a;">"simulation_resolution"</span>    : (60, 30, 30),
        <span style="color: #ffa07a;">"simulation_stop_condition"</span>: {<span style="color: #ffa07a;">"max_burn_duration"</span>: 720.0},
    },

    input_layer_dict: {
        <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">2D Arrays (e.g. 30m x 30m resolution, 30km x 30km extent)</span>
        <span style="color: #ffa07a;">"elevation"</span>                    : <span style="color: #00ffff;">lambda</span> y,x: 0.0,
        <span style="color: #ffa07a;">"slope"</span>                        : <span style="color: #00ffff;">lambda</span> y,x: 0.0,
        <span style="color: #ffa07a;">"aspect"</span>                       : <span style="color: #00ffff;">lambda</span> y,x: 0.0,
        <span style="color: #ffa07a;">"fuel_model"</span>                   : <span style="color: #00ffff;">lambda</span> y,x: 100,
        <span style="color: #ffa07a;">"canopy_cover"</span>                 : <span style="color: #00ffff;">lambda</span> y,x: 0.0,
        <span style="color: #ffa07a;">"canopy_height"</span>                : <span style="color: #00ffff;">lambda</span> y,x: 0.0,
        <span style="color: #ffa07a;">"canopy_base_height"</span>           : <span style="color: #00ffff;">lambda</span> y,x: 0.0,
        <span style="color: #ffa07a;">"canopy_bulk_density"</span>          : <span style="color: #00ffff;">lambda</span> y,x: 0.0,
        <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">3D Arrays (e.g. 1hr x 300m x 300m resolution, 1day x 30km x 30km extent)</span>
        <span style="color: #ffa07a;">"temperature"</span>                  : <span style="color: #00ffff;">lambda</span> z,y,x: 10.0,
        <span style="color: #ffa07a;">"relative_humidity"</span>            : <span style="color: #00ffff;">lambda</span> z,y,x: 10.0,
        <span style="color: #ffa07a;">"wind_speed_10m_x"</span>             : <span style="color: #00ffff;">lambda</span> z,y,x: 0.0,
        <span style="color: #ffa07a;">"wind_speed_10m_y"</span>             : <span style="color: #00ffff;">lambda</span> z,y,x: 0.0,
        <span style="color: #ffa07a;">"fuel_moisture_dead_1hr"</span>       : <span style="color: #00ffff;">lambda</span> z,y,x: 10.0,
        <span style="color: #ffa07a;">"fuel_moisture_dead_10hr"</span>      : <span style="color: #00ffff;">lambda</span> z,y,x: 10.0,
        <span style="color: #ffa07a;">"fuel_moisture_dead_100hr"</span>     : <span style="color: #00ffff;">lambda</span> z,y,x: 10.0,
        <span style="color: #ffa07a;">"fuel_moisture_live_herbaceous"</span>: <span style="color: #00ffff;">lambda</span> z,y,x: 10.0,
        <span style="color: #ffa07a;">"fuel_moisture_live_woody"</span>     : <span style="color: #00ffff;">lambda</span> z,y,x: 10.0,
        <span style="color: #ffa07a;">"foliar_moisture"</span>              : <span style="color: #00ffff;">lambda</span> z,y,x: 10.0,
    },

    output_layer_dict: {
        <span style="color: #ffa07a;">"eulerian_level_set_phi_field"</span> : np.full((1000, 1000), 0.0, dtype=<span style="color: #ffa07a;">"float16"</span>),
    },

    ignited_cells_set: <span style="color: #b0c4de;">set</span>([(0, 100, 100)]),
}

<span style="color: #eedd82;">world_state2</span> = grow_fire(world_state)

<span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">=======================================================</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Phase 2: Continued fire simulation - second 12 hours</span>
<span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">=======================================================</span>

<span style="color: #eedd82;">world_state3</span> = grow_fire(world_state2)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org26754ca" class="outline-3">
<h3 id="org26754ca"><span class="section-number-3">3.2.</span> burn_cells</h3>
<div class="outline-text-3" id="text-3-2">
<p>
TODO: stub
</p>
</div>
</div>
</div>

<div id="outline-container-org1877336" class="outline-2">
<h2 id="org1877336"><span class="section-number-2">4.</span> Fire Spread Functions</h2>
<div class="outline-text-2" id="text-4">
<div class="org-src-container">
<pre class="src src-python" id="org4d8738f"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">TODO: Compare this with numpy.random (is there a generator object that I can use here?)</span>
<span style="color: #00ffff;">import</span> random
<span style="color: #00ffff;">import</span> numpy <span style="color: #00ffff;">as</span> np

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">supply_layer</span>(layer_dict, layer_name, layer_shape, layer_type, initial_value, overwrite_layers):
    <span style="color: #eedd82;">layer</span> = layer_dict.get(layer_name)
    <span style="color: #00ffff;">if</span> layer:
        <span style="color: #00ffff;">if</span> overwrite_layers:
            <span style="color: #00ffff;">return</span> layer
        <span style="color: #00ffff;">else</span>:
            <span style="color: #00ffff;">return</span> layer.copy()
    <span style="color: #00ffff;">else</span>:
        <span style="color: #00ffff;">return</span> np.full(layer_shape, initial_value, dtype=layer_type)


<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">FIXME: stub</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">burn_cells</span>(world_state):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    1. Validate inputs</span>
<span style="color: #ffa07a;">       - Make sure that all required parameters are present in config_dict</span>
<span style="color: #ffa07a;">       - Make sure that all required entries are present in layer_dict</span>
<span style="color: #ffa07a;">       - Check for entries in output_layer_dict; if present, copy/use as new output layers</span>
<span style="color: #ffa07a;">         - Use time of arrival raster to identify the burn scar(s); if missing, we are simulating point ignitions</span>
<span style="color: #ffa07a;">       - Make sure that ignited_cells_set is a set of integer 3-tuples</span>
<span style="color: #ffa07a;">    2. Iterate through all cells in (rows, cols), compute the maximum spread rate and severity values, and store them in output arrays</span>
<span style="color: #ffa07a;">       - Run surface and crown equations per cell</span>
<span style="color: #ffa07a;">    3. Return a dictionary of the outputs</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #eedd82;">simulation_clock</span>  = world_state[<span style="color: #ffa07a;">"simulation_clock"</span>]
    <span style="color: #eedd82;">config_dict</span>       = world_state[<span style="color: #ffa07a;">"config_dict"</span>]
    <span style="color: #eedd82;">input_layer_dict</span>  = world_state[<span style="color: #ffa07a;">"input_layer_dict"</span>]
    <span style="color: #eedd82;">output_layer_dict</span> = world_state.get(<span style="color: #ffa07a;">"output_layer_dict"</span>, {})
    <span style="color: #eedd82;">ignited_cells_set</span> = world_state[<span style="color: #ffa07a;">"ignited_cells_set"</span>]

    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">The random seed affects input layer perturbations.</span>
    <span style="color: #00ffff;">if</span> config_dict.get(<span style="color: #ffa07a;">"random_seed"</span>):
        random.seed(config_dict.get(<span style="color: #ffa07a;">"random_seed"</span>))

    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">None</span>


<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">FIXME: stub</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">grow_fire</span>(world_state):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    1. Validate inputs</span>
<span style="color: #ffa07a;">       - Make sure that all required parameters are present in config_dict</span>
<span style="color: #ffa07a;">       - Make sure that all required entries are present in layer_dict</span>
<span style="color: #ffa07a;">       - Check for entries in output_layer_dict; if present, copy/use as new output layers</span>
<span style="color: #ffa07a;">         - Use time of arrival raster to identify the burn scar(s); if missing, we are simulating point ignitions</span>
<span style="color: #ffa07a;">       - Make sure that ignited_cells_set is a set of integer 3-tuples</span>
<span style="color: #ffa07a;">    2. Iterate through all cells in ignited_cells_set, compute the perimeter-oriented spread rate and severity values, and store them in output arrays</span>
<span style="color: #ffa07a;">    3. Perform constant spread out over the landscape in all directions</span>
<span style="color: #ffa07a;">       - Run surface, crown, and spot equations per ignited cell</span>
<span style="color: #ffa07a;">    4. Record the time_of_arrival in each cell as it spreads</span>
<span style="color: #ffa07a;">    5. Continue until a stop condition is met (e.g., max_burn_duration or max_burned_area)</span>
<span style="color: #ffa07a;">    6. Return a dictionary of the outputs</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #eedd82;">simulation_clock</span>  = world_state[<span style="color: #ffa07a;">"simulation_clock"</span>]
    <span style="color: #eedd82;">config_dict</span>       = world_state[<span style="color: #ffa07a;">"config_dict"</span>]
    <span style="color: #eedd82;">input_layer_dict</span>  = world_state[<span style="color: #ffa07a;">"input_layer_dict"</span>]
    <span style="color: #eedd82;">output_layer_dict</span> = world_state.get(<span style="color: #ffa07a;">"output_layer_dict"</span>, {})
    <span style="color: #eedd82;">ignited_cells_set</span> = world_state[<span style="color: #ffa07a;">"ignited_cells_set"</span>]

    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">The random seed affects input layer perturbations and spotting calculations.</span>
    <span style="color: #00ffff;">if</span> config_dict.get(<span style="color: #ffa07a;">"random_seed"</span>):
        random.seed(config_dict.get(<span style="color: #ffa07a;">"random_seed"</span>))

    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">GridFire initializes the following 2D arrays for its spread algorithm:</span>
    <span style="color: #ff7f24;">#</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">:burn-time-matrix                [float32] time_of_arrival (with -1 for values in the interior of the burn scar)</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">:eccentricity-matrix             [float32] -1 in burn scar, 0 otherwise</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">:fire-line-intensity-matrix      [float32] -1 in burn scar, 0 otherwise</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">:fire-spread-matrix              [float32] +1 in burn scar, 0 otherwise</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">:fire-type-matrix                [float32] -1 in burn scar, 0 otherwise</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">:firebrand-count-matrix          [ int32 ]  0 everywhere (when spotting params are passed)</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">:flame-length-matrix             [float32] -1 in burn scar, 0 otherwise</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">:directional-flame-length-matrix [float32] -1 in burn scar, 0 otherwise (when compute-directional-values? = true)</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">:max-spread-direction-matrix     [float32] -1 in burn scar, 0 otherwise</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">:max-spread-rate-matrix          [float32] -1 in burn scar, 0 otherwise</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">:modified-time-matrix            [ int32 ]  0 everywhere</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">:residence-time-matrix           [float32] -1 in burn scar, 0 otherwise (when compute-directional-values? = true)</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">:reaction-intensity-matrix       [float32] -1 in burn scar, 0 otherwise (when compute-directional-values? = true)</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">:spot-matrix                     [float32]  0 everywhere (when spotting params are passed)</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">:spread-rate-matrix              [float32] -1 in burn scar, 0 otherwise</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">:spread-rate-sum-matrix          [float32]  0 everywhere (when compute-directional-values? = true)</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">:travel-lines-matrix             [ int16 ]  0 everywhere</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">:x-magnitude-sum-matrix          [float32]  0 everywhere (when compute-directional-values? = true)</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">:y-magnitude-sum-matrix          [float32]  0 everywhere (when compute-directional-values? = true)</span>
    <span style="color: #ff7f24;">#</span>
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Equivalent Pyretechnics 2D arrays in output_layer_dict:</span>
    <span style="color: #ff7f24;">#</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">========================= Output 2D Arrays =========================</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">time_of_arrival                  :burn-time-matrix</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">max_surface_spread_direction     :max-spread-direction-matrix</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">max_crown_spread_direction       :max-spread-direction-matrix</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">perimeter_spread_direction       N/A</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">max_surface_spread_rate          :max-spread-rate-matrix</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">max_crown_spread_rate            :max-spread-rate-matrix</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">perimeter_spread_rate            :spread-rate-matrix</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">max_surface_fire_line_intensity  :fire-line-intensity-matrix</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">max_crown_fire_line_intensity    :fire-line-intensity-matrix</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">perimeter_fire_line_intensity    :fire-line-intensity-matrix</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">max_surface_flame_length         :flame-length-matrix</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">max_crown_flame_length           :flame-length-matrix</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">perimeter_flame_length           :directional-flame-length-matrix</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">fire_type                        :fire-type-matrix</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">ember_count                      :firebrand-count-matrix</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">ember_ignition                   :spot-matrix</span>
    <span style="color: #ff7f24;">#</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">======================== Internal 2D Arrays ========================</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">surface_eccentricity             :eccentricity-matrix</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">crown_eccentricity               :eccentricity-matrix</span>
    <span style="color: #ff7f24;">#</span>
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">GridFire 2D arrays that are not needed by Pyretechnics:</span>
    <span style="color: #ff7f24;">#</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">======================== Replaced 2D Arrays ========================</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">:fire-spread-matrix              time_of_arrival</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">:residence-time-matrix           max_surface_fire_line_intensity, max_crown_fire_line_intensity, surface_eccentricity, crown_eccentricity</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">:reaction-intensity-matrix       max_surface_fire_line_intensity, max_crown_fire_line_intensity, surface_eccentricity, crown_eccentricity</span>
    <span style="color: #ff7f24;">#</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">======================== Internal 2D Arrays ========================</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">:modified-time-matrix            \</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">:travel-lines-matrix              |</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">:spread-rate-sum-matrix           |-- for its 2D spread algorithm</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">:x-magnitude-sum-matrix           |</span>
    <span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">:y-magnitude-sum-matrix          /</span>

    (<span style="color: #eedd82;">num_timesteps</span>, <span style="color: #eedd82;">num_rows</span>, <span style="color: #eedd82;">num_cols</span>) = config_dict[<span style="color: #ffa07a;">"simulation_shape"</span>]
    <span style="color: #eedd82;">layer_shape</span> = (num_rows, num_cols)
    <span style="color: #eedd82;">overwrite_outputs</span> = config_dict[<span style="color: #ffa07a;">"overwrite_outputs"</span>]

    <span style="color: #eedd82;">output_layer_dict</span> = {
        <span style="color: #ffa07a;">"eulerian_level_set_phi_field"</span>   : supply_layer(output_layer_dict, <span style="color: #ffa07a;">"eulerian_level_set_phi_field"</span>   , layer_shape, <span style="color: #ffa07a;">"float16"</span>, np.nan, overwrite_outputs),
        <span style="color: #ffa07a;">"time_of_arrival"</span>                : supply_layer(output_layer_dict, <span style="color: #ffa07a;">"time_of_arrival"</span>                , layer_shape, <span style="color: #ffa07a;">"float32"</span>, np.nan, overwrite_outputs),
        <span style="color: #ffa07a;">"max_surface_spread_direction"</span>   : supply_layer(output_layer_dict, <span style="color: #ffa07a;">"max_surface_spread_direction"</span>   , layer_shape, <span style="color: #ffa07a;">"float16"</span>, np.nan, overwrite_outputs),
        <span style="color: #ffa07a;">"max_crown_spread_direction"</span>     : supply_layer(output_layer_dict, <span style="color: #ffa07a;">"max_crown_spread_direction"</span>     , layer_shape, <span style="color: #ffa07a;">"float16"</span>, np.nan, overwrite_outputs),
        <span style="color: #ffa07a;">"perimeter_spread_direction"</span>     : supply_layer(output_layer_dict, <span style="color: #ffa07a;">"perimeter_spread_direction"</span>     , layer_shape, <span style="color: #ffa07a;">"float16"</span>, np.nan, overwrite_outputs),
        <span style="color: #ffa07a;">"max_surface_spread_rate"</span>        : supply_layer(output_layer_dict, <span style="color: #ffa07a;">"max_surface_spread_rate"</span>        , layer_shape, <span style="color: #ffa07a;">"float16"</span>, np.nan, overwrite_outputs),
        <span style="color: #ffa07a;">"max_crown_spread_rate"</span>          : supply_layer(output_layer_dict, <span style="color: #ffa07a;">"max_crown_spread_rate"</span>          , layer_shape, <span style="color: #ffa07a;">"float16"</span>, np.nan, overwrite_outputs),
        <span style="color: #ffa07a;">"perimeter_spread_rate"</span>          : supply_layer(output_layer_dict, <span style="color: #ffa07a;">"perimeter_spread_rate"</span>          , layer_shape, <span style="color: #ffa07a;">"float16"</span>, np.nan, overwrite_outputs),
        <span style="color: #ffa07a;">"surface_eccentricity"</span>           : supply_layer(output_layer_dict, <span style="color: #ffa07a;">"surface_eccentricity"</span>           , layer_shape, <span style="color: #ffa07a;">"float16"</span>, np.nan, overwrite_outputs),
        <span style="color: #ffa07a;">"crown_eccentricity"</span>             : supply_layer(output_layer_dict, <span style="color: #ffa07a;">"crown_eccentricity"</span>             , layer_shape, <span style="color: #ffa07a;">"float16"</span>, np.nan, overwrite_outputs),
        <span style="color: #ffa07a;">"max_surface_fire_line_intensity"</span>: supply_layer(output_layer_dict, <span style="color: #ffa07a;">"max_surface_fire_line_intensity"</span>, layer_shape, <span style="color: #ffa07a;">"float32"</span>, np.nan, overwrite_outputs),
        <span style="color: #ffa07a;">"max_crown_fire_line_intensity"</span>  : supply_layer(output_layer_dict, <span style="color: #ffa07a;">"max_crown_fire_line_intensity"</span>  , layer_shape, <span style="color: #ffa07a;">"float32"</span>, np.nan, overwrite_outputs),
        <span style="color: #ffa07a;">"perimeter_fire_line_intensity"</span>  : supply_layer(output_layer_dict, <span style="color: #ffa07a;">"perimeter_fire_line_intensity"</span>  , layer_shape, <span style="color: #ffa07a;">"float32"</span>, np.nan, overwrite_outputs),
        <span style="color: #ffa07a;">"max_surface_flame_length"</span>       : supply_layer(output_layer_dict, <span style="color: #ffa07a;">"max_surface_flame_length"</span>       , layer_shape, <span style="color: #ffa07a;">"float16"</span>, np.nan, overwrite_outputs),
        <span style="color: #ffa07a;">"max_crown_flame_length"</span>         : supply_layer(output_layer_dict, <span style="color: #ffa07a;">"max_crown_flame_length"</span>         , layer_shape, <span style="color: #ffa07a;">"float16"</span>, np.nan, overwrite_outputs),
        <span style="color: #ffa07a;">"perimeter_flame_length"</span>         : supply_layer(output_layer_dict, <span style="color: #ffa07a;">"perimeter_flame_length"</span>         , layer_shape, <span style="color: #ffa07a;">"float16"</span>, np.nan, overwrite_outputs),
        <span style="color: #ffa07a;">"fire_type"</span>                      : supply_layer(output_layer_dict, <span style="color: #ffa07a;">"fire_type"</span>                      , layer_shape, <span style="color: #ffa07a;">"uint8"</span>  ,      0, overwrite_outputs),
        <span style="color: #ffa07a;">"ember_count"</span>                    : supply_layer(output_layer_dict, <span style="color: #ffa07a;">"ember_count"</span>                    , layer_shape, <span style="color: #ffa07a;">"uint32"</span> ,      0, overwrite_outputs),
        <span style="color: #ffa07a;">"ember_ignition"</span>                 : supply_layer(output_layer_dict, <span style="color: #ffa07a;">"ember_ignition"</span>                 , layer_shape, <span style="color: #ffa07a;">"bool8"</span>  ,  <span style="color: #7fffd4;">False</span>, overwrite_outputs),
    }

    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">RESUME at [[file:~/code/sig-gis/gridfire/src/gridfire/fire_spread.clj::(defn- run-loop]]</span>
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">TODO: Investigate ELMFIRE's inputs to determine if we are missing anything needed by its API.</span>

    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">None</span>
</pre>
</div>
</div>

<div id="outline-container-orgddac956" class="outline-3">
<h3 id="orgddac956"><span class="section-number-3">4.1.</span> ELMFIRE Inputs</h3>
<div class="outline-text-3" id="text-4-1">
<p>
This section lists the full set of inputs used in any <code>elmfire.data</code> or <code>elmfire.data.in</code> file in:
</p>

<ul class="org-ul">
<li>the current <code>main</code> branch of the <code>elmfire</code> repository located here: <a href="https://github.com/lautenberger/elmfire">https://github.com/lautenberger/elmfire</a></li>
<li>the current <code>main</code> branch of the <code>runway-scripts</code> repository located here: <a href="https://gitlab.sig-gis.com/sig-gis/runway-scripts">https://gitlab.sig-gis.com/sig-gis/runway-scripts</a></li>
</ul>

<p>
The following table contains the current mapping from ELMFIRE parameters to Pyretechnics parameters:
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">ELMFIRE</th>
<th scope="col" class="org-left">Pyretechnics Group</th>
<th scope="col" class="org-left">Pyretechnics Parameter</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">DT_METEOROLOGY</td>
<td class="org-left">config_dict</td>
<td class="org-left">simulation_resolution[0]</td>
</tr>

<tr>
<td class="org-left">COMPUTATIONAL_DOMAIN_CELLSIZE</td>
<td class="org-left">config_dict</td>
<td class="org-left">simulation_resolution[1:]</td>
</tr>

<tr>
<td class="org-left">SIMULATION_TSTART</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">SIMULATION_TSTOP</td>
<td class="org-left">config_dict.simulation_stop_condition</td>
<td class="org-left">max_burn_duration</td>
</tr>

<tr>
<td class="org-left">EMBER_GR</td>
<td class="org-left">config_dict.spotting</td>
<td class="org-left">ember_gr</td>
</tr>

<tr>
<td class="org-left">EMBER_SAMPLING_FACTOR</td>
<td class="org-left">config_dict.spotting</td>
<td class="org-left">ember_sampling_factor</td>
</tr>

<tr>
<td class="org-left">ENABLE_SPOTTING</td>
<td class="org-left">config_dict.spotting</td>
<td class="org-left">Enabled if dictionary is present</td>
</tr>

<tr>
<td class="org-left">P_EPS</td>
<td class="org-left">config_dict.spotting</td>
<td class="org-left">p_eps</td>
</tr>

<tr>
<td class="org-left">PIGN</td>
<td class="org-left">config_dict.spotting</td>
<td class="org-left">pign</td>
</tr>

<tr>
<td class="org-left">PIGN_MAX</td>
<td class="org-left">config_dict.spotting</td>
<td class="org-left">pign_max</td>
</tr>

<tr>
<td class="org-left">PIGN_MIN</td>
<td class="org-left">config_dict.spotting</td>
<td class="org-left">pign_min</td>
</tr>

<tr>
<td class="org-left">TAU_EMBERGEN</td>
<td class="org-left">config_dict.spotting</td>
<td class="org-left">tau_embergen</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">DEM_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">elevation</td>
</tr>

<tr>
<td class="org-left">SLP_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">slope</td>
</tr>

<tr>
<td class="org-left">ASP_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">aspect</td>
</tr>

<tr>
<td class="org-left">FBFM_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">fuel_model</td>
</tr>

<tr>
<td class="org-left">CC_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">canopy_cover</td>
</tr>

<tr>
<td class="org-left">CH_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">canopy_height</td>
</tr>

<tr>
<td class="org-left">CBH_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">canopy_base_height</td>
</tr>

<tr>
<td class="org-left">CBD_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">canopy_bulk_density</td>
</tr>

<tr>
<td class="org-left">ADJ_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">fuel_spread_adjustment</td>
</tr>

<tr>
<td class="org-left">CRITICAL_SPOTTING_FIRELINE_INTENSITY(:)</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">surface_spotting_fire_line_intensity</td>
</tr>

<tr>
<td class="org-left">GLOBAL_SURFACE_FIRE_SPOTTING_PERCENT_MAX</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">surface_spotting_percent</td>
</tr>

<tr>
<td class="org-left">GLOBAL_SURFACE_FIRE_SPOTTING_PERCENT_MIN</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">surface_spotting_percent</td>
</tr>

<tr>
<td class="org-left">WS_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">wind_speed_10m_x, wind_speed_10m_y</td>
</tr>

<tr>
<td class="org-left">WD_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">wind_speed_10m_x, wind_speed_10m_y</td>
</tr>

<tr>
<td class="org-left">M1_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">fuel_moisture_dead_1hr</td>
</tr>

<tr>
<td class="org-left">M10_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">fuel_moisture_dead_10hr</td>
</tr>

<tr>
<td class="org-left">M100_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">fuel_moisture_dead_100hr</td>
</tr>

<tr>
<td class="org-left">MLH_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">fuel_moisture_live_herbaceous</td>
</tr>

<tr>
<td class="org-left">MLW_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">fuel_moisture_live_woody</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">PHI_FILENAME</td>
<td class="org-left">output_layer_dict</td>
<td class="org-left">eulerian_level_set_phi_field</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">T_IGN(1)</td>
<td class="org-left">ignited_cells_set</td>
<td class="org-left">(t, _, _)</td>
</tr>

<tr>
<td class="org-left">Y_IGN(1)</td>
<td class="org-left">ignited_cells_set</td>
<td class="org-left">(_, y, _)</td>
</tr>

<tr>
<td class="org-left">X_IGN(1)</td>
<td class="org-left">ignited_cells_set</td>
<td class="org-left">(_, _, x)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">BANDTHICKNESS</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">METEOROLOGY_BAND_SKIP_INTERVAL</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">METEOROLOGY_BAND_START</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">METEOROLOGY_BAND_STOP</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">NUM_METEOROLOGY_TIMES</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">CROWN_FIRE_MODEL</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">MODE</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">SIMULATION_DT</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">SIMULATION_DTMAX</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">TARGET_CFL</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">USE_BLDG_SPREAD_MODEL</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">USE_EULERIAN_FRAMEWORK</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">USE_PHYSICAL_EMBER_NUMBER</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">USE_PHYSICAL_SPOTTING_DURATION</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">USE_SUPERSEDED_SPOTTING</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">USE_UMD_SPOTTING_MODEL</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">WX_BILINEAR_INTERPOLATION</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">ALLOW_MULTIPLE_IGNITIONS_AT_A_PIXEL</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">FUELS_AND_TOPOGRAPHY_DIRECTORY</td>
<td class="org-left">N/A</td>
<td class="org-left">Input reading managed externally</td>
</tr>

<tr>
<td class="org-left">A_SRS</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">LATITUDE</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">LONGITUDE</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">COMPUTATIONAL_DOMAIN_XLLCORNER</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">COMPUTATIONAL_DOMAIN_YLLCORNER</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">FORECAST_START_HOUR</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">UTC_OFFSET_HOURS</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">CURRENT_YEAR</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">HOUR_OF_YEAR</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">PATH_TO_GDAL</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">NUM_ENSEMBLE_MEMBERS</td>
<td class="org-left">N/A</td>
<td class="org-left">Random sampling managed externally</td>
</tr>

<tr>
<td class="org-left">NUM_IGNITIONS</td>
<td class="org-left">N/A</td>
<td class="org-left">Random sampling managed externally</td>
</tr>

<tr>
<td class="org-left">RANDOM_IGNITIONS</td>
<td class="org-left">N/A</td>
<td class="org-left">Random sampling managed externally</td>
</tr>

<tr>
<td class="org-left">USE_IGNITION_MASK</td>
<td class="org-left">N/A</td>
<td class="org-left">Random sampling managed externally</td>
</tr>

<tr>
<td class="org-left">USE_CONSTANT_LH</td>
<td class="org-left">N/A</td>
<td class="org-left">Replaced by abstract gridded datasource</td>
</tr>

<tr>
<td class="org-left">USE_CONSTANT_LW</td>
<td class="org-left">N/A</td>
<td class="org-left">Replaced by abstract gridded datasource</td>
</tr>

<tr>
<td class="org-left">LH_MOISTURE_CONTENT</td>
<td class="org-left">N/A</td>
<td class="org-left">Replaced by abstract gridded datasource</td>
</tr>

<tr>
<td class="org-left">LW_MOISTURE_CONTENT</td>
<td class="org-left">N/A</td>
<td class="org-left">Replaced by abstract gridded datasource</td>
</tr>

<tr>
<td class="org-left">OUTPUTS_DIRECTORY</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">SCRATCH</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">CONVERT_TO_GEOTIFF</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">DTDUMP</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">DT_DUMP_EMBER_FLUX</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">DUMP_EMBER_FLUX_UMD</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">DUMP_FLAME_LENGTH</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">DUMP_FLIN</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">DUMP_SPOTTING_OUTPUTS</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">DUMP_SPREAD_RATE</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">DUMP_TIME_OF_ARRIVAL</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org37f9154" class="outline-2">
<h2 id="org37f9154"><span class="section-number-2">5.</span> Fire Behavior Model</h2>
<div class="outline-text-2" id="text-5">
<p>
Pyretechnics implements the following fire behavior formulas from the
fire science literature:
</p>

<ul class="org-ul">
<li>Surface Fire Spread: Rothermel 1972 with FIREMODS adjustments from Albini 1976</li>
<li>Crown Fire Initiation: Van Wagner 1977</li>
<li>Passive/Active Crown Fire Spread: Cruz 2005</li>
<li>Flame Length and Fire Line Intensity: Byram 1959</li>
<li>Midflame Wind Adjustment Factor: Albini &amp; Baughman 1979 parameterized as in BehavePlus, FARSITE, FlamMap, FSPro, and FPA according to Andrews 2012\nocite{Albini1979,Andrews2012}</li>
<li>Fire Spread on a Raster Grid: Morais 2001 (method of adaptive timesteps and fractional distances)</li>
<li>Spot Fire: Perryman 2013</li>
</ul>

<p>
The following fuel models are supported:
</p>

<ul class="org-ul">
<li>Anderson 13: no dynamic loading</li>
<li>Scott &amp; Burgan 40: dynamic loading implemented according to Scott &amp; Burgan 2005</li>
</ul>

<p>
In the following sections, we describe the operation of this system in
detail.
</p>
</div>

<div id="outline-container-org546b33b" class="outline-3">
<h3 id="org546b33b"><span class="section-number-3">5.1.</span> Fuel Model Definitions</h3>
<div class="outline-text-3" id="text-5-1">
<p>
All fires ignite and travel through some form of burnable fuel.
Although the effects of wind and slope on the rate of fire spread can
be quite pronounced, its fundamental thermodynamic characteristics are
largely determined by the fuel type in which it is sustained. For
wildfires, these fuels are predominantly herbaceous and woody
vegetation (both alive and dead) as well as decomposing elements of
dead vegetation, such as duff or leaf litter. To estimate the heat
output and rate of spread of a fire burning through any of these
fuels, we must determine those physical properties that affect heat
absorption and release.
</p>

<p>
Of course, measuring these fuel properties for every kind of
vegetation that may be burned in a wildfire is an intractable task. To
cope with this, fuels are classified into categories called ``fuel
models'' which share similar burning characteristics. Each fuel model
is then assigned a set of representative values for each of the
thermally relevant physical properties shown in Table
<a href="#org5a7ceb9">2</a>.
</p>

<table id="org5a7ceb9">
<caption class="t-above"><span class="table-number">Table 2:</span> Physical properties assigned to each fuel model</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Property</th>
<th scope="col" class="org-left">Description</th>
<th scope="col" class="org-left">Units</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&delta;</td>
<td class="org-left">fuel depth</td>
<td class="org-left">ft</td>
</tr>

<tr>
<td class="org-left">w<sub>o</sub></td>
<td class="org-left">ovendry fuel loading</td>
<td class="org-left">lb/ft<sup>2</sup></td>
</tr>

<tr>
<td class="org-left">&sigma;</td>
<td class="org-left">fuel particle surface-area-to-volume ratio</td>
<td class="org-left">ft<sup>2</sup>/ft<sup>3</sup></td>
</tr>

<tr>
<td class="org-left">M<sub>x</sub></td>
<td class="org-left">moisture content of extinction</td>
<td class="org-left">lb moisture/lb ovendry wood</td>
</tr>

<tr>
<td class="org-left">h</td>
<td class="org-left">fuel particle low heat content</td>
<td class="org-left">Btu/lb</td>
</tr>

<tr>
<td class="org-left">&rho;<sub>p</sub></td>
<td class="org-left">ovendry particle density</td>
<td class="org-left">lb/ft<sup>3</sup></td>
</tr>

<tr>
<td class="org-left">S<sub>T</sub></td>
<td class="org-left">fuel particle total mineral content</td>
<td class="org-left">lb minerals/lb ovendry wood</td>
</tr>

<tr>
<td class="org-left">S<sub>e</sub></td>
<td class="org-left">fuel particle effective mineral content</td>
<td class="org-left">lb silica-free minerals/lb ovendry wood</td>
</tr>

<tr>
<td class="org-left">M<sub>f</sub></td>
<td class="org-left">fuel particle moisture content</td>
<td class="org-left">lb moisture/lb ovendry wood</td>
</tr>
</tbody>
</table>

<p>
TODO: Change units to metric in the table above.
</p>

<p>
<b>Note:</b> While M<sub>f</sub> is not, in fact, directly assigned to any of these
fuel models, their definitions remain incomplete for the purposes of
fire spread modelling (particularly those reliant on the curing
formulas of dynamic fuel loading) until it is provided as a
characteristic of local weather conditions.
</p>

<p>
The fuel models supported by Pyretechnics include the standard 13 fuel
models of Rothermel, Albini, and Anderson\citep{Anderson1982} and the
additional 40 fuel models defined by Scott and
Burgan\citep{Scott2005}. These are all concisely encoded in an
internal data structure, which may be updated to include additional
custom fuel models desired by the user.
</p>

<div class="org-src-container">
<pre class="src src-python" id="org18e3d65"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Lookup table including one entry for each of the Anderson 13 and</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Scott &amp; Burgan 40 fuel models. The fields have the following</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">meanings:</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">{fuel-model-number</span>
<span style="color: #ff7f24;">#  </span><span style="color: #ff7f24;">[name delta M_x-dead h</span>
<span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">[w_o-dead-1hr w_o-dead-10hr w_o-dead-100hr w_o-live-herbaceous w_o-live-woody]</span>
<span style="color: #ff7f24;">#   </span><span style="color: #ff7f24;">[sigma-dead-1hr sigma-dead-10hr sigma-dead-100hr sigma-live-herbaceous sigma-live-woody]]</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">}</span>
<span style="color: #eedd82;">fuel_models</span> = {
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Anderson 13:</span>
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Grass and Grass-dominated (short-grass,timber-grass-and-understory,tall-grass)</span>
    1   : [<span style="color: #ffa07a;">"R01"</span>, 1.0, 12, 8, [0.0340, 0.0000, 0.0000, 0.0000, 0.0000], [3500.0,   0.0,  0.0,    0.0,    0.0]],
    2   : [<span style="color: #ffa07a;">"R02"</span>, 1.0, 15, 8, [0.0920, 0.0460, 0.0230, 0.0230, 0.0000], [3000.0, 109.0, 30.0, 1500.0,    0.0]],
    3   : [<span style="color: #ffa07a;">"R03"</span>, 2.5, 25, 8, [0.1380, 0.0000, 0.0000, 0.0000, 0.0000], [1500.0,   0.0,  0.0,    0.0,    0.0]],
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Chaparral and Shrubfields (chaparral,brush,dormant-brush-hardwood-slash,southern-rough)</span>
    4   : [<span style="color: #ffa07a;">"R04"</span>, 6.0, 20, 8, [0.2300, 0.1840, 0.0920, 0.2300, 0.0000], [2000.0, 109.0, 30.0, 1500.0,    0.0]],
    5   : [<span style="color: #ffa07a;">"R05"</span>, 2.0, 20, 8, [0.0460, 0.0230, 0.0000, 0.0920, 0.0000], [2000.0, 109.0,  0.0, 1500.0,    0.0]],
    6   : [<span style="color: #ffa07a;">"R06"</span>, 2.5, 25, 8, [0.0690, 0.1150, 0.0920, 0.0000, 0.0000], [1750.0, 109.0, 30.0,    0.0,    0.0]],
    7   : [<span style="color: #ffa07a;">"R07"</span>, 2.5, 40, 8, [0.0520, 0.0860, 0.0690, 0.0170, 0.0000], [1750.0, 109.0, 30.0, 1550.0,    0.0]],
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Timber Litter (closed-timber-litter,hardwood-litter,timber-litter-and-understory)</span>
    8   : [<span style="color: #ffa07a;">"R08"</span>, 0.2, 30, 8, [0.0690, 0.0460, 0.1150, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    9   : [<span style="color: #ffa07a;">"R09"</span>, 0.2, 25, 8, [0.1340, 0.0190, 0.0070, 0.0000, 0.0000], [2500.0, 109.0, 30.0,    0.0,    0.0]],
    10  : [<span style="color: #ffa07a;">"R10"</span>, 1.0, 25, 8, [0.1380, 0.0920, 0.2300, 0.0920, 0.0000], [2000.0, 109.0, 30.0, 1500.0,    0.0]],
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Logging Slash (light-logging-slash,medium-logging-slash,heavy-logging-slash)</span>
    11  : [<span style="color: #ffa07a;">"R11"</span>, 1.0, 15, 8, [0.0690, 0.2070, 0.2530, 0.0000, 0.0000], [1500.0, 109.0, 30.0,    0.0,    0.0]],
    12  : [<span style="color: #ffa07a;">"R12"</span>, 2.3, 20, 8, [0.1840, 0.6440, 0.7590, 0.0000, 0.0000], [1500.0, 109.0, 30.0,    0.0,    0.0]],
    13  : [<span style="color: #ffa07a;">"R13"</span>, 3.0, 25, 8, [0.3220, 1.0580, 1.2880, 0.0000, 0.0000], [1500.0, 109.0, 30.0,    0.0,    0.0]],
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Nonburnable (NB)</span>
    91  : [<span style="color: #ffa07a;">"NB1"</span>, 0.0,  0, 0, [0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [   0.0,   0.0,  0.0,    0.0,    0.0]],
    92  : [<span style="color: #ffa07a;">"NB2"</span>, 0.0,  0, 0, [0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [   0.0,   0.0,  0.0,    0.0,    0.0]],
    93  : [<span style="color: #ffa07a;">"NB3"</span>, 0.0,  0, 0, [0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [   0.0,   0.0,  0.0,    0.0,    0.0]],
    98  : [<span style="color: #ffa07a;">"NB4"</span>, 0.0,  0, 0, [0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [   0.0,   0.0,  0.0,    0.0,    0.0]],
    99  : [<span style="color: #ffa07a;">"NB5"</span>, 0.0,  0, 0, [0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [   0.0,   0.0,  0.0,    0.0,    0.0]],
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Scott &amp; Burgan 40:</span>
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Grass (GR)</span>
    101 : [<span style="color: #ffa07a;">"GR1"</span>, 0.4, 15, 8, [0.0046, 0.0000, 0.0000, 0.0138, 0.0000], [2200.0, 109.0, 30.0, 2000.0,    0.0]],
    102 : [<span style="color: #ffa07a;">"GR2"</span>, 1.0, 15, 8, [0.0046, 0.0000, 0.0000, 0.0459, 0.0000], [2000.0, 109.0, 30.0, 1800.0,    0.0]],
    103 : [<span style="color: #ffa07a;">"GR3"</span>, 2.0, 30, 8, [0.0046, 0.0184, 0.0000, 0.0689, 0.0000], [1500.0, 109.0, 30.0, 1300.0,    0.0]],
    104 : [<span style="color: #ffa07a;">"GR4"</span>, 2.0, 15, 8, [0.0115, 0.0000, 0.0000, 0.0872, 0.0000], [2000.0, 109.0, 30.0, 1800.0,    0.0]],
    105 : [<span style="color: #ffa07a;">"GR5"</span>, 1.5, 40, 8, [0.0184, 0.0000, 0.0000, 0.1148, 0.0000], [1800.0, 109.0, 30.0, 1600.0,    0.0]],
    106 : [<span style="color: #ffa07a;">"GR6"</span>, 1.5, 40, 9, [0.0046, 0.0000, 0.0000, 0.1561, 0.0000], [2200.0, 109.0, 30.0, 2000.0,    0.0]],
    107 : [<span style="color: #ffa07a;">"GR7"</span>, 3.0, 15, 8, [0.0459, 0.0000, 0.0000, 0.2479, 0.0000], [2000.0, 109.0, 30.0, 1800.0,    0.0]],
    108 : [<span style="color: #ffa07a;">"GR8"</span>, 4.0, 30, 8, [0.0230, 0.0459, 0.0000, 0.3352, 0.0000], [1500.0, 109.0, 30.0, 1300.0,    0.0]],
    109 : [<span style="color: #ffa07a;">"GR9"</span>, 5.0, 40, 8, [0.0459, 0.0459, 0.0000, 0.4132, 0.0000], [1800.0, 109.0, 30.0, 1600.0,    0.0]],
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Grass-Shrub (GS)</span>
    121 : [<span style="color: #ffa07a;">"GS1"</span>, 0.9, 15, 8, [0.0092, 0.0000, 0.0000, 0.0230, 0.0298], [2000.0, 109.0, 30.0, 1800.0, 1800.0]],
    122 : [<span style="color: #ffa07a;">"GS2"</span>, 1.5, 15, 8, [0.0230, 0.0230, 0.0000, 0.0275, 0.0459], [2000.0, 109.0, 30.0, 1800.0, 1800.0]],
    123 : [<span style="color: #ffa07a;">"GS3"</span>, 1.8, 40, 8, [0.0138, 0.0115, 0.0000, 0.0666, 0.0574], [1800.0, 109.0, 30.0, 1600.0, 1600.0]],
    124 : [<span style="color: #ffa07a;">"GS4"</span>, 2.1, 40, 8, [0.0872, 0.0138, 0.0046, 0.1561, 0.3260], [1800.0, 109.0, 30.0, 1600.0, 1600.0]],
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Shrub (SH)</span>
    141 : [<span style="color: #ffa07a;">"SH1"</span>, 1.0, 15, 8, [0.0115, 0.0115, 0.0000, 0.0069, 0.0597], [2000.0, 109.0, 30.0, 1800.0, 1600.0]],
    142 : [<span style="color: #ffa07a;">"SH2"</span>, 1.0, 15, 8, [0.0620, 0.1102, 0.0344, 0.0000, 0.1768], [2000.0, 109.0, 30.0,    0.0, 1600.0]],
    143 : [<span style="color: #ffa07a;">"SH3"</span>, 2.4, 40, 8, [0.0207, 0.1377, 0.0000, 0.0000, 0.2847], [1600.0, 109.0, 30.0,    0.0, 1400.0]],
    144 : [<span style="color: #ffa07a;">"SH4"</span>, 3.0, 30, 8, [0.0390, 0.0528, 0.0092, 0.0000, 0.1171], [2000.0, 109.0, 30.0, 1800.0, 1600.0]],
    145 : [<span style="color: #ffa07a;">"SH5"</span>, 6.0, 15, 8, [0.1653, 0.0964, 0.0000, 0.0000, 0.1331], [ 750.0, 109.0, 30.0,    0.0, 1600.0]],
    146 : [<span style="color: #ffa07a;">"SH6"</span>, 2.0, 30, 8, [0.1331, 0.0666, 0.0000, 0.0000, 0.0643], [ 750.0, 109.0, 30.0,    0.0, 1600.0]],
    147 : [<span style="color: #ffa07a;">"SH7"</span>, 6.0, 15, 8, [0.1607, 0.2433, 0.1010, 0.0000, 0.1561], [ 750.0, 109.0, 30.0,    0.0, 1600.0]],
    148 : [<span style="color: #ffa07a;">"SH8"</span>, 3.0, 40, 8, [0.0941, 0.1561, 0.0390, 0.0000, 0.1997], [ 750.0, 109.0, 30.0,    0.0, 1600.0]],
    149 : [<span style="color: #ffa07a;">"SH9"</span>, 4.4, 40, 8, [0.2066, 0.1125, 0.0000, 0.0712, 0.3214], [ 750.0, 109.0, 30.0, 1800.0, 1500.0]],
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Timber-Understory (TU)</span>
    161 : [<span style="color: #ffa07a;">"TU1"</span>, 0.6, 20, 8, [0.0092, 0.0413, 0.0689, 0.0092, 0.0413], [2000.0, 109.0, 30.0, 1800.0, 1600.0]],
    162 : [<span style="color: #ffa07a;">"TU2"</span>, 1.0, 30, 8, [0.0436, 0.0826, 0.0574, 0.0000, 0.0092], [2000.0, 109.0, 30.0,    0.0, 1600.0]],
    163 : [<span style="color: #ffa07a;">"TU3"</span>, 1.3, 30, 8, [0.0505, 0.0069, 0.0115, 0.0298, 0.0505], [1800.0, 109.0, 30.0, 1600.0, 1400.0]],
    164 : [<span style="color: #ffa07a;">"TU4"</span>, 0.5, 12, 8, [0.2066, 0.0000, 0.0000, 0.0000, 0.0918], [2300.0, 109.0, 30.0,    0.0, 2000.0]],
    165 : [<span style="color: #ffa07a;">"TU5"</span>, 1.0, 25, 8, [0.1837, 0.1837, 0.1377, 0.0000, 0.1377], [1500.0, 109.0, 30.0,    0.0,  750.0]],
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Timber Litter (TL)</span>
    181 : [<span style="color: #ffa07a;">"TL1"</span>, 0.2, 30, 8, [0.0459, 0.1010, 0.1653, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    182 : [<span style="color: #ffa07a;">"TL2"</span>, 0.2, 25, 8, [0.0643, 0.1056, 0.1010, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    183 : [<span style="color: #ffa07a;">"TL3"</span>, 0.3, 20, 8, [0.0230, 0.1010, 0.1286, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    184 : [<span style="color: #ffa07a;">"TL4"</span>, 0.4, 25, 8, [0.0230, 0.0689, 0.1928, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    185 : [<span style="color: #ffa07a;">"TL5"</span>, 0.6, 25, 8, [0.0528, 0.1148, 0.2020, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0, 1600.0]],
    186 : [<span style="color: #ffa07a;">"TL6"</span>, 0.3, 25, 8, [0.1102, 0.0551, 0.0551, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    187 : [<span style="color: #ffa07a;">"TL7"</span>, 0.4, 25, 8, [0.0138, 0.0643, 0.3719, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    188 : [<span style="color: #ffa07a;">"TL8"</span>, 0.3, 35, 8, [0.2663, 0.0643, 0.0505, 0.0000, 0.0000], [1800.0, 109.0, 30.0,    0.0,    0.0]],
    189 : [<span style="color: #ffa07a;">"TL9"</span>, 0.6, 35, 8, [0.3053, 0.1515, 0.1905, 0.0000, 0.0000], [1800.0, 109.0, 30.0,    0.0, 1600.0]],
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Slash-Blowdown (SB)</span>
    201 : [<span style="color: #ffa07a;">"SB1"</span>, 1.0, 25, 8, [0.0689, 0.1377, 0.5051, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    202 : [<span style="color: #ffa07a;">"SB2"</span>, 1.0, 25, 8, [0.2066, 0.1951, 0.1837, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    203 : [<span style="color: #ffa07a;">"SB3"</span>, 1.2, 25, 8, [0.2525, 0.1263, 0.1377, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    204 : [<span style="color: #ffa07a;">"SB4"</span>, 2.7, 25, 8, [0.2410, 0.1607, 0.2410, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
}


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">is_dynamic_fuel_model_number</span>(fuel_model_number):
    <span style="color: #00ffff;">return</span> fuel_model_number &gt; 100


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">compute_fuel_model</span>(fuel_model_number):
    [<span style="color: #eedd82;">name</span>, <span style="color: #eedd82;">delta</span>, <span style="color: #eedd82;">M_x_dead</span>, <span style="color: #eedd82;">h</span>, <span style="color: #eedd82;">w_o</span>, <span style="color: #eedd82;">sigma</span>] = fuel_models[fuel_model_number]
    [<span style="color: #eedd82;">w_o_dead_1hr</span>, <span style="color: #eedd82;">w_o_dead_10hr</span>, <span style="color: #eedd82;">w_o_dead_100hr</span>, <span style="color: #eedd82;">w_o_live_herbaceous</span>, <span style="color: #eedd82;">w_o_live_woody</span>] = w_o
    [<span style="color: #eedd82;">sigma_dead_1hr</span>, <span style="color: #eedd82;">sigma_dead_10hr</span>, <span style="color: #eedd82;">sigma_dead_100hr</span>, <span style="color: #eedd82;">sigma_live_herbaceous</span>, <span style="color: #eedd82;">sigma_live_woody</span>] = sigma
    <span style="color: #eedd82;">M_x_dead</span> = M_x_dead * 0.01
    <span style="color: #eedd82;">h</span>        = h * 1000.0
    <span style="color: #eedd82;">fuel_model</span> = {
        <span style="color: #ffa07a;">"name"</span>  : name,
        <span style="color: #ffa07a;">"number"</span>: fuel_model_number,
        <span style="color: #ffa07a;">"delta"</span> : delta,
        <span style="color: #ffa07a;">"M_x"</span>   : [M_x_dead, M_x_dead, M_x_dead, 0.0, 0.0, 0.0],
        <span style="color: #ffa07a;">"w_o"</span>   : [w_o_dead_1hr, w_o_dead_10hr, w_o_dead_100hr, 0.0, w_o_live_herbaceous, w_o_live_woody],
        <span style="color: #ffa07a;">"sigma"</span> : [sigma_dead_1hr, sigma_dead_10hr, sigma_dead_100hr, 0.0, sigma_live_herbaceous, sigma_live_woody],
        <span style="color: #ffa07a;">"h"</span>     : [h, h, h, h, h, h],
        <span style="color: #ffa07a;">"rho_p"</span> : [32.0, 32.0, 32.0, 32.0, 32.0, 32.0],
        <span style="color: #ffa07a;">"S_T"</span>   : [0.0555, 0.0555, 0.0555, 0.0555, 0.0555, 0.0555],
        <span style="color: #ffa07a;">"S_e"</span>   : [0.01, 0.01, 0.01, 0.01, 0.01, 0.01],
    }
    <span style="color: #00ffff;">if</span> is_dynamic_fuel_model_number(fuel_model_number) <span style="color: #00ffff;">and</span> (w_o_live_herbaceous &gt; 0.0):
        <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Set dead_herbaceous values</span>
        fuel_model[<span style="color: #ffa07a;">"M_x"</span>][3] = M_x_dead
        fuel_model[<span style="color: #ffa07a;">"sigma"</span>][3] = sigma_live_herbaceous
        <span style="color: #00ffff;">return</span> fuel_model
    <span style="color: #00ffff;">else</span>:
        <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">No dead_herbaceous values</span>
        <span style="color: #00ffff;">return</span> fuel_model


<span style="color: #eedd82;">fuel_models_precomputed</span> = {k: compute_fuel_model(k) <span style="color: #00ffff;">for</span> k <span style="color: #00ffff;">in</span> fuel_models.keys()}


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">is_burnable_fuel_model_number</span>(fuel_model_number):
    <span style="color: #00ffff;">return</span> fuel_models_precomputed.get(fuel_model_number) <span style="color: #00ffff;">and</span> <span style="color: #00ffff;">not</span> (91 &lt;= fuel_model_number &lt;= 99)
</pre>
</div>

<p>
Once fuel moisture is added to the base fuel model definitions, they
will each contain values for the following six fuel size classes:
</p>

<ol class="org-ol">
<li>Dead 1 hour (\(<\) 1/4" diameter)</li>
<li>Dead 10 hour (1/4"&#x2013;1" diameter)</li>
<li>Dead 100 hour (1"&#x2013;3" diameter)</li>
<li>Dead herbaceous (dynamic fuel models only)</li>
<li>Live herbaceous</li>
<li>Live woody</li>
</ol>

<p>
In order to more easily encode mathematical operations over these size
classes, we define a collection of utility functions that will later
be used in both the fuel moisture and fire spread algorithms.
</p>

<div class="org-src-container">
<pre class="src src-python" id="org163aec9"><span style="color: #00ffff;">def</span> <span style="color: #87cefa;">map_category</span>(f):
    <span style="color: #00ffff;">return</span> [f(0), f(1)]

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">map_size_class</span>(f):
    <span style="color: #00ffff;">return</span> [f(0), f(1), f(2), f(3), f(4), f(5)]

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">category_sum</span>(f):
    <span style="color: #00ffff;">return</span> f(0) + f(1)

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">size_class_sum</span>(f):
    <span style="color: #00ffff;">return</span> [f(0) + f(1) + f(2) + f(3), f(4) + f(5)]
</pre>
</div>

<p>
Although most fuel model properties are static with respect to
environmental conditions, the fuel moisture content can have two
significant impacts on a fuel model's burning potential:
</p>

<ol class="org-ol">
<li>Dynamic fuel loading</li>
<li>Live moisture of extinction</li>
</ol>

<p>
These two topics are discussed in the remainder of this section.
</p>
</div>

<div id="outline-container-org7548906" class="outline-4">
<h4 id="org7548906"><span class="section-number-4">5.1.1.</span> Dynamic Fuel Loading</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
All of the Scott &amp; Burgan 40 fuel models with a live herbaceous
component are considered dynamic. In these models, a fraction of the
live herbaceous load is transferred to a new dead herbaceous category
as a function of live herbaceous moisture content (see equation
below).\citep{Burgan1979} The dead herbaceous category uses the dead 1
hour moisture content, dead moisture of extinction, and live
herbaceous surface-area-to-volume-ratio. In the following formula,
\(M_{f}^{lh}\) is the live herbaceous moisture content.
</p>

\begin{align}
  \text{FractionGreen} &= \left\{
    \begin{array}{lr}
      0 & M_{f}^{lh} \le 0.3 \\
      1 & M_{f}^{lh} \ge 1.2 \\
      \frac{M_{f}^{lh}}{0.9} - \frac{1}{3} & \text{else}
    \end{array}
  \right. \\
  \text{FractionCured} &= 1 - \text{FractionGreen}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="org0cd2ce6"><span style="color: #00ffff;">def</span> <span style="color: #87cefa;">add_dynamic_fuel_loading</span>(fuel_model, M_f):
    <span style="color: #eedd82;">number</span>               = fuel_model[<span style="color: #ffa07a;">"number"</span>]
    <span style="color: #eedd82;">w_o</span>                  = fuel_model[<span style="color: #ffa07a;">"w_o"</span>]
    <span style="color: #eedd82;">live_herbaceous_load</span> = w_o[4] <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">4 = live_herbaceous</span>
    <span style="color: #00ffff;">if</span> is_dynamic_fuel_model_number(number) <span style="color: #00ffff;">and</span> live_herbaceous_load &gt; 0:
        <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">dynamic fuel model</span>
        <span style="color: #eedd82;">fraction_green</span>            = <span style="color: #b0c4de;">max</span>(0.0, <span style="color: #b0c4de;">min</span>(1.0, (M_f[4] / 0.9) - 0.3333333333333333)) <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">4 = live_herbaceous</span>
        <span style="color: #eedd82;">fraction_cured</span>            = 1.0 - fraction_green
        <span style="color: #eedd82;">dynamic_M_f</span>               = M_f.copy() <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">shallow copy</span>
        <span style="color: #eedd82;">dynamic_M_f</span>[3]            = M_f[0]     <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">0 = dead_1hr, 3 = dead_herbaceous</span>
        <span style="color: #eedd82;">dynamic_fuel_model</span>        = fuel_model.copy() <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">shallow copy</span>
        <span style="color: #eedd82;">dynamic_fuel_model</span>[<span style="color: #ffa07a;">"M_f"</span>] = dynamic_M_f
        <span style="color: #eedd82;">dynamic_fuel_model</span>[<span style="color: #ffa07a;">"w_o"</span>] = [
            w_o[0],
            w_o[1],
            w_o[2],
            live_herbaceous_load * fraction_cured,
            live_herbaceous_load * fraction_green,
            w_o[5]
        ]
        <span style="color: #00ffff;">return</span> dynamic_fuel_model
    <span style="color: #00ffff;">else</span>:
        <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">static fuel model</span>
        <span style="color: #eedd82;">static_fuel_model</span> = fuel_model.copy()
        <span style="color: #eedd82;">static_fuel_model</span>[<span style="color: #ffa07a;">"M_f"</span>] = M_f
        <span style="color: #00ffff;">return</span> static_fuel_model
</pre>
</div>

<p>
Once the dynamic fuel loading is applied, we can compute the size
class weighting factors expressed in equations 53-57 in Rothermel
1972\citep{Rothermel1972}. For brevity, these formulas are elided from
this text.
</p>

<p>
TODO: Test whether <code>g_ij</code> below creates different values for any fuel models if we simply compare <code>i</code> to [0,1,2,3].
</p>

<div class="org-src-container">
<pre class="src src-python" id="org69a41c8"><span style="color: #00ffff;">def</span> <span style="color: #87cefa;">add_weighting_factors</span>(fuel_model):
    <span style="color: #eedd82;">w_o</span>                  = fuel_model[<span style="color: #ffa07a;">"w_o"</span>]
    <span style="color: #eedd82;">sigma</span>                = fuel_model[<span style="color: #ffa07a;">"sigma"</span>]
    <span style="color: #eedd82;">rho_p</span>                = fuel_model[<span style="color: #ffa07a;">"rho_p"</span>]
    <span style="color: #eedd82;">A_ij</span>                 = map_size_class(<span style="color: #00ffff;">lambda</span> i: (sigma[i] * w_o[i]) / rho_p[i])
    <span style="color: #eedd82;">A_i</span>                  = size_class_sum(<span style="color: #00ffff;">lambda</span> i: A_ij[i])
    <span style="color: #eedd82;">A_T</span>                  = category_sum(<span style="color: #00ffff;">lambda</span> i: A_i[i])
    <span style="color: #eedd82;">f_ij</span>                 = map_size_class(<span style="color: #00ffff;">lambda</span> i: (<span style="color: #00ffff;">lambda</span> A: (A_ij[i] / A) <span style="color: #00ffff;">if</span> A &gt; 0.0 <span style="color: #00ffff;">else</span> 0.0)(A_i[i//4]))
    <span style="color: #eedd82;">f_i</span>                  = map_category(<span style="color: #00ffff;">lambda</span> i: (A_i[i] / A_T) <span style="color: #00ffff;">if</span> A_T &gt; 0.0 <span style="color: #00ffff;">else</span> 0.0)
    <span style="color: #eedd82;">firemod_size_classes</span> = map_size_class(<span style="color: #00ffff;">lambda</span> i: (<span style="color: #00ffff;">lambda</span> s:
                                                     1 <span style="color: #00ffff;">if</span> (s &gt;= 1200.0)
                                                     <span style="color: #00ffff;">else</span> 2 <span style="color: #00ffff;">if</span> (s &gt;= 192.0)
                                                     <span style="color: #00ffff;">else</span> 3 <span style="color: #00ffff;">if</span> (s &gt;= 96.0)
                                                     <span style="color: #00ffff;">else</span> 4 <span style="color: #00ffff;">if</span> (s &gt;= 48.0)
                                                     <span style="color: #00ffff;">else</span> 5 <span style="color: #00ffff;">if</span> (s &gt;= 16.0)
                                                     <span style="color: #00ffff;">else</span> 6
                                                     )(sigma[i]))
    <span style="color: #eedd82;">g_ij</span>                 = map_size_class(<span style="color: #00ffff;">lambda</span> i: (<span style="color: #00ffff;">lambda</span> c:
                                                     ((f_ij[0] <span style="color: #00ffff;">if</span> (c == firemod_size_classes[0]) <span style="color: #00ffff;">else</span> 0.0)
                                                      + (f_ij[1] <span style="color: #00ffff;">if</span> (c == firemod_size_classes[1]) <span style="color: #00ffff;">else</span> 0.0)
                                                      + (f_ij[2] <span style="color: #00ffff;">if</span> (c == firemod_size_classes[2]) <span style="color: #00ffff;">else</span> 0.0)
                                                      + (f_ij[3] <span style="color: #00ffff;">if</span> (c == firemod_size_classes[3]) <span style="color: #00ffff;">else</span> 0.0))
                                                     <span style="color: #00ffff;">if</span> (i &lt; 4) <span style="color: #00ffff;">else</span>
                                                     ((f_ij[4] <span style="color: #00ffff;">if</span> (c == firemod_size_classes[4]) <span style="color: #00ffff;">else</span> 0.0)
                                                      + (f_ij[5] <span style="color: #00ffff;">if</span> (c == firemod_size_classes[5]) <span style="color: #00ffff;">else</span> 0.0))
                                                     )(firemod_size_classes[i]))
    <span style="color: #eedd82;">weighted_fuel_model</span> = fuel_model.copy() <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">shallow copy</span>
    <span style="color: #eedd82;">weighted_fuel_model</span>[<span style="color: #ffa07a;">"f_ij"</span>] = f_ij
    <span style="color: #eedd82;">weighted_fuel_model</span>[<span style="color: #ffa07a;">"f_i"</span>] = f_i
    <span style="color: #eedd82;">weighted_fuel_model</span>[<span style="color: #ffa07a;">"g_ij"</span>] = g_ij
    <span style="color: #00ffff;">return</span> weighted_fuel_model
</pre>
</div>
</div>
</div>

<div id="outline-container-orgab5cd46" class="outline-4">
<h4 id="orgab5cd46"><span class="section-number-4">5.1.2.</span> Live Moisture of Extinction</h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
The live moisture of extinction for each fuel model is determined from
the dead fuel moisture content, the dead moisture of extinction, and
the ratio of dead fuel loading to live fuel loading using Equation 88
from Rothermel 1972, adjusted according to Albini 1976 Appendix III to
match the behavior of Albini's original FIREMODS
library.\citep{Rothermel1972,Albini1976} Whenever the fuel moisture
content becomes greater than or equal to the moisture of extinction, a
fire will no longer spread through that fuel. Here are the formulas
referenced above:
</p>

\begin{align}
  M_{x}^{l} &= \max(M_{x}^{d}, 2.9 \, W' \, (1 - \frac{M_{f}^{d}}{M_{x}^{d}}) - 0.226) \\
  W' &= \frac{\sum_{c \in D}{w_{o}^{c} \> e^{-138/\sigma^{c}}}}{\sum_{c \in L}{w_{o}^{c} \> e^{-500/\sigma^{c}}}} \\
  M_{f}^{d} &= \frac{\sum_{c \in D}{w_{o}^{c} \> M_{f}^{c} \> e^{-138/\sigma^{c}}}}{\sum_{c \in D}{w_{o}^{c} \> e^{-138/\sigma^{c}}}}
\end{align}

<p>
where \(M_{x}^{l}\) is the live moisture of extinction, \(M_{x}^{d}\) is
the dead moisture of extinction, \(D\) is the set of dead fuel size
classes (1hr, 10hr, 100hr, herbaceous), \(L\) is the set of live fuel
size classes (herbaceous, woody), \(w_{o}^{c}\) is the dry weight
loading of size class \(c\), \(\sigma^{c}\) is the surface area to volume
ratio of size class \(c\), and \(M_{f}^{c}\) is the moisture content of
size class \(c\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="orgbe8a1ec"><span style="color: #00ffff;">from</span> math <span style="color: #00ffff;">import</span> exp

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">add_live_moisture_of_extinction</span>(fuel_model):
    <span style="color: #ffa07a;">"""Equation 88 from Rothermel 1972 adjusted by Albini 1976 Appendix III."""</span>
    <span style="color: #eedd82;">w_o</span>                       = fuel_model[<span style="color: #ffa07a;">"w_o"</span>]
    <span style="color: #eedd82;">sigma</span>                     = fuel_model[<span style="color: #ffa07a;">"sigma"</span>]
    <span style="color: #eedd82;">M_f</span>                       = fuel_model[<span style="color: #ffa07a;">"M_f"</span>]
    <span style="color: #eedd82;">M_x</span>                       = fuel_model[<span style="color: #ffa07a;">"M_x"</span>]
    <span style="color: #eedd82;">loading_factors</span>           = map_size_class(<span style="color: #00ffff;">lambda</span> i:
                                               (<span style="color: #00ffff;">lambda</span> sigma_ij, A:
                                                w_o[i] * exp(A / sigma_ij) <span style="color: #00ffff;">if</span> (sigma_ij &gt; 0.0) <span style="color: #00ffff;">else</span> 0.0
                                                )(sigma[i], -138.0 <span style="color: #00ffff;">if</span> (i &lt; 4) <span style="color: #00ffff;">else</span> -500.0))
    [dead_loading_factor,
     live_loading_factor]     = size_class_sum(<span style="color: #00ffff;">lambda</span> i: loading_factors[i])
    [<span style="color: #eedd82;">dead_moisture_factor</span>, <span style="color: #eedd82;">_</span>] = size_class_sum(<span style="color: #00ffff;">lambda</span> i: M_f[i] * loading_factors[i])
    <span style="color: #eedd82;">dead_to_live_ratio</span>        = (dead_loading_factor / live_loading_factor) <span style="color: #00ffff;">if</span> (live_loading_factor &gt; 0.0) <span style="color: #00ffff;">else</span> <span style="color: #7fffd4;">None</span>
    <span style="color: #eedd82;">dead_fuel_moisture</span>        = (dead_moisture_factor / dead_loading_factor) <span style="color: #00ffff;">if</span> (dead_loading_factor &gt; 0.0) <span style="color: #00ffff;">else</span> 0.0
    <span style="color: #eedd82;">M_x_dead</span>                  = M_x[0]
    <span style="color: #eedd82;">M_x_live</span>                  = <span style="color: #b0c4de;">max</span>(M_x_dead,
                                    (2.9 * dead_to_live_ratio * (1.0 - (dead_fuel_moisture / M_x_dead))) - 0.226
                                    ) <span style="color: #00ffff;">if</span> (live_loading_factor &gt; 0.0) <span style="color: #00ffff;">else</span> M_x_dead
    <span style="color: #eedd82;">moisturized_fuel_model</span>    = fuel_model.copy() <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">shallow copy</span>
    <span style="color: #eedd82;">moisturized_fuel_model</span>[<span style="color: #ffa07a;">"M_x"</span>] = [M_x[0],
                                     M_x[1],
                                     M_x[2],
                                     M_x[3],
                                     M_x_live,
                                     M_x_live]
    <span style="color: #00ffff;">return</span> moisturized_fuel_model


<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">TODO: If these functions aren't called anywhere else, create a copy of the fuel model here and mutate it in the called functions</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">moisturize</span>(fuel_model, fuel_moisture):
    <span style="color: #00ffff;">return</span> add_live_moisture_of_extinction(add_weighting_factors(add_dynamic_fuel_loading(fuel_model, fuel_moisture)))
</pre>
</div>

<p>
This concludes our coverage of fuel models and and fuel moisture.
</p>
</div>
</div>
</div>

<div id="outline-container-org256a745" class="outline-3">
<h3 id="org256a745"><span class="section-number-3">5.2.</span> Surface Fire Formulas</h3>
<div class="outline-text-3" id="text-5-2">
<p>
To simulate fire behavior in as similar a way as possible to the US
government-sponsored fire models (e.g., FARSITE, FlamMap, FPA,
BehavePlus), we adopt the surface fire spread and reaction intensity
formulas from Rothermel's 1972 publication ``A Mathematical Model for
Predicting Fire Spread in Wildland Fuels''.\citep{Rothermel1972}
</p>

<p>
Very briefly, the surface rate of spread of a fire's leading edge \(R\)
is described by the following formula:
</p>

\begin{align}
  R = \frac{I_{R} \, \xi \, (1 + \phi_{W} + \phi_{S})}{\rho_{b} \, \epsilon \, Q_{ig}}
\end{align}

<p>
where these terms have the meanings shown in Table
<a href="#org930aa18">3</a>.
</p>

<p>
<b>FIXME: fill in the units column for the table below.</b>
</p>

<table id="org930aa18">
<caption class="t-above"><span class="table-number">Table 3:</span> Inputs to Rothermel's surface fire rate of spread equation</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Term</th>
<th scope="col" class="org-left">Description</th>
<th scope="col" class="org-left">Units</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">R</td>
<td class="org-left">surface fire spread rate</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">I<sub>R</sub></td>
<td class="org-left">reaction intensity</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&xi;</td>
<td class="org-left">propagating flux ratio</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&phi;<sub>W</sub></td>
<td class="org-left">wind coefficient</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&phi;<sub>S</sub></td>
<td class="org-left">slope factor</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&rho;<sub>b</sub></td>
<td class="org-left">oven-dry fuel bed bulk density</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&epsilon;</td>
<td class="org-left">effective heating number</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Q<sub>ig</sub></td>
<td class="org-left">heat of preignition</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
For a full description of each of the subcomponents of Rothermel's
surface fire spread rate equation, see the Rothermel 1972 reference
above.
</p>

<p>
For efficiency, the surface fire spread equation given above is
computed first without introducing the effects of wind and slope
(\(\phi_{W} = \phi_{S} = 0\)).
</p>

<div class="org-src-container">
<pre class="src src-python" id="org303991e"><span style="color: #00ffff;">from</span> math <span style="color: #00ffff;">import</span> exp
<span style="color: #00ffff;">from</span> pyretechnics.fuel_models <span style="color: #00ffff;">import</span> map_category, map_size_class, category_sum, size_class_sum

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_mineral_damping_coefficients</span>(f_ij, S_e):
    <span style="color: #eedd82;">S_e_i</span> = size_class_sum(<span style="color: #00ffff;">lambda</span> i: f_ij[i] * S_e[i])
    <span style="color: #00ffff;">return</span> map_category(<span style="color: #00ffff;">lambda</span> i:
                        (<span style="color: #00ffff;">lambda</span> S_e_i:
                         0.174 / (S_e_i ** 0.19) <span style="color: #00ffff;">if</span> (S_e_i &gt; 0.0) <span style="color: #00ffff;">else</span> 1.0
                         )(S_e_i[i]))


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_moisture_damping_coefficients</span>(f_ij, M_f, M_x):
    <span style="color: #eedd82;">M_f_i</span> = size_class_sum(<span style="color: #00ffff;">lambda</span> i: f_ij[i] * M_f[i])
    <span style="color: #eedd82;">M_x_i</span> = size_class_sum(<span style="color: #00ffff;">lambda</span> i: f_ij[i] * M_x[i])
    <span style="color: #00ffff;">return</span> map_category(<span style="color: #00ffff;">lambda</span> i:
                        (<span style="color: #00ffff;">lambda</span> M_f, M_x:
                         (<span style="color: #00ffff;">lambda</span> r_M:
                          1.0 - 2.59 * r_M + 5.11 * r_M ** 2.0 - 3.52 * r_M ** 3.0
                          )(<span style="color: #b0c4de;">min</span>(1.0, M_f / M_x) <span style="color: #00ffff;">if</span> (M_x &gt; 0.0) <span style="color: #00ffff;">else</span> 1.0)
                         )(M_f_i[i], M_x_i[i]))


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_low_heat_content</span>(f_ij, h):
    <span style="color: #00ffff;">return</span> size_class_sum(<span style="color: #00ffff;">lambda</span> i: f_ij[i] * h[i])


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_net_fuel_loading</span>(g_ij, w_o, S_T):
    <span style="color: #00ffff;">return</span> size_class_sum(<span style="color: #00ffff;">lambda</span> i:
                          (<span style="color: #00ffff;">lambda</span> g_ij, w_o, S_T:
                           g_ij * w_o * (1.0 - S_T)
                           )(g_ij[i], w_o[i], S_T[i]))


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_packing_ratio</span>(w_o, rho_p, delta):
    <span style="color: #00ffff;">if</span> (delta &gt; 0.0):
        <span style="color: #eedd82;">beta_i</span> = size_class_sum(<span style="color: #00ffff;">lambda</span> i: w_o[i] / rho_p[i])
        <span style="color: #00ffff;">return</span> category_sum(<span style="color: #00ffff;">lambda</span> i: beta_i[i]) / delta
    <span style="color: #00ffff;">else</span>:
        <span style="color: #00ffff;">return</span> 0.0


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_surface_area_to_volume_ratio</span>(f_i, f_ij, sigma):
    <span style="color: #eedd82;">sigma_prime_i</span> = size_class_sum(<span style="color: #00ffff;">lambda</span> i: f_ij[i] * sigma[i])
    <span style="color: #00ffff;">return</span> category_sum(<span style="color: #00ffff;">lambda</span> i: f_i[i] * sigma_prime_i[i])


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_optimum_packing_ratio</span>(sigma_prime):
    <span style="color: #00ffff;">return</span> (3.348 / sigma_prime ** 0.8189) <span style="color: #00ffff;">if</span> (sigma_prime &gt; 0.0) <span style="color: #00ffff;">else</span> 1.0


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_optimum_reaction_velocity</span>(beta, sigma_prime, beta_op):
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Albini 1976 replaces 1 / (4.774 * (sigma_prime ** 0.1) - 7.27)</span>
    <span style="color: #eedd82;">A</span>               = (133.0 / sigma_prime ** 0.7913) <span style="color: #00ffff;">if</span> (sigma_prime &gt; 0.0) <span style="color: #00ffff;">else</span> 0.0
    <span style="color: #eedd82;">B</span>               = sigma_prime ** 1.5
    <span style="color: #eedd82;">C</span>               = beta / beta_op
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Maximum reaction velocity (1/min)</span>
    <span style="color: #eedd82;">Gamma_prime_max</span> = B / (495.0 + 0.0594 * B)
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Optimum reaction velocity (1/min)</span>
    <span style="color: #00ffff;">return</span> Gamma_prime_max * (C ** A) * exp(A * (1.0 - C))


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_heat_per_unit_area</span>(eta_S_i, eta_M_i, h_i, W_n_i):
    <span style="color: #00ffff;">return</span> category_sum(<span style="color: #00ffff;">lambda</span> i: W_n_i[i] * h_i[i] * eta_M_i[i] * eta_S_i[i])


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_reaction_intensity</span>(Gamma_prime, Btus):
    <span style="color: #00ffff;">return</span> Gamma_prime * Btus


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_propagating_flux_ratio</span>(beta, sigma_prime):
    <span style="color: #00ffff;">return</span> exp((0.792 + 0.681 * (sigma_prime ** 0.5)) * (beta + 0.1)) / (192.0 + 0.2595 * sigma_prime)


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_heat_of_preignition</span>(M_f):
    <span style="color: #00ffff;">return</span> map_size_class(<span style="color: #00ffff;">lambda</span> i: 250.0 + 1116.0 * M_f[i])


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_heat_distribution</span>(sigma, Q_ig, f_ij):
    <span style="color: #00ffff;">return</span> size_class_sum(<span style="color: #00ffff;">lambda</span> i:
                          (<span style="color: #00ffff;">lambda</span> sigma:
                           f_ij[i] * exp(-138.0 / sigma) * Q_ig[i] <span style="color: #00ffff;">if</span> (sigma &gt; 0.0) <span style="color: #00ffff;">else</span> 0.0
                           )(sigma[i]))


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_ovendry_bulk_density</span>(w_o, delta):
    <span style="color: #00ffff;">if</span> (delta &gt; 0.0):
        <span style="color: #eedd82;">rho_b_i</span> = size_class_sum(<span style="color: #00ffff;">lambda</span> i: w_o[i])
        <span style="color: #00ffff;">return</span> category_sum(<span style="color: #00ffff;">lambda</span> i: rho_b_i[i]) / delta
    <span style="color: #00ffff;">else</span>:
        <span style="color: #00ffff;">return</span> 0.0


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_heat_total</span>(f_i, epsilon_i):
    <span style="color: #00ffff;">return</span> category_sum(<span style="color: #00ffff;">lambda</span> i: f_i[i] * epsilon_i[i])


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_surface_fire_spread_rate</span>(I_R, xi, rho_b, epsilon):
    <span style="color: #eedd82;">rho_b_epsilon_Q_ig</span> = rho_b * epsilon
    <span style="color: #00ffff;">return</span> ((I_R * xi) / rho_b_epsilon_Q_ig) <span style="color: #00ffff;">if</span> (rho_b_epsilon_Q_ig &gt; 0.0) <span style="color: #00ffff;">else</span> 0.0


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_residence_time</span>(sigma_prime):
    <span style="color: #00ffff;">return</span> 384.0 / sigma_prime


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">get_phi_S_fn</span>(beta):
    <span style="color: #00ffff;">if</span> (beta &gt; 0.0):
        <span style="color: #eedd82;">G</span> = 5.275 * beta ** -0.3
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">lambda</span> slope: (slope ** 2.0) * G <span style="color: #00ffff;">if</span> (slope &gt; 0.0) <span style="color: #00ffff;">else</span> 0.0
    <span style="color: #00ffff;">else</span>:
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">lambda</span> _: 0.0


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">get_phi_W_fn</span>(beta, B, C, F):
    <span style="color: #00ffff;">if</span> (beta &gt; 0.0):
        <span style="color: #eedd82;">C_over_F</span> = C / F
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">lambda</span> midflame_wind_speed: (midflame_wind_speed ** B) * C_over_F <span style="color: #00ffff;">if</span> (midflame_wind_speed &gt; 0.0) <span style="color: #00ffff;">else</span> 0.0
    <span style="color: #00ffff;">else</span>:
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">lambda</span> _: 0.0


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">get_wind_speed_fn</span>(B, C, F):
    <span style="color: #eedd82;">F_over_C</span>  = F / C
    <span style="color: #eedd82;">B_inverse</span> = 1.0 / B
    <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">lambda</span> phi_W: (phi_W * F_over_C) ** B_inverse


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">rothermel_surface_fire_spread_no_wind_no_slope</span>(fuel_model):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Returns the rate of surface fire spread in ft/min and the reaction</span>
<span style="color: #ffa07a;">    intensity (i.e., amount of heat output) of a fire in Btu/ft^2*min</span>
<span style="color: #ffa07a;">    given a map containing these keys:</span>
<span style="color: #ffa07a;">    - delta [fuel depth (ft)]</span>
<span style="color: #ffa07a;">    - w_o [ovendry fuel loading (lb/ft^2)]</span>
<span style="color: #ffa07a;">    - sigma [fuel particle surface-area-to-volume ratio (ft^2/ft^3)]</span>
<span style="color: #ffa07a;">    - h [fuel particle low heat content (Btu/lb)]</span>
<span style="color: #ffa07a;">    - rho_p [ovendry particle density (lb/ft^3)]</span>
<span style="color: #ffa07a;">    - S_T [fuel particle total mineral content (lb minerals/lb ovendry wood)]</span>
<span style="color: #ffa07a;">    - S_e [fuel particle effective mineral content (lb silica-free minerals/lb ovendry wood)]</span>
<span style="color: #ffa07a;">    - M_x [moisture content of extinction (lb moisture/lb ovendry wood)]</span>
<span style="color: #ffa07a;">    - M_f [fuel particle moisture content (lb moisture/lb ovendry wood)]</span>
<span style="color: #ffa07a;">    - f_ij [percent of load per size class (%)]</span>
<span style="color: #ffa07a;">    - f_i [percent of load per category (%)]</span>
<span style="color: #ffa07a;">    - g_ij [percent of load per size class from Albini_1976_FIREMOD, page 20]</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #eedd82;">delta</span>          = fuel_model[<span style="color: #ffa07a;">"delta"</span>]
    <span style="color: #eedd82;">w_o</span>            = fuel_model[<span style="color: #ffa07a;">"w_o"</span>]
    <span style="color: #eedd82;">sigma</span>          = fuel_model[<span style="color: #ffa07a;">"sigma"</span>]
    <span style="color: #eedd82;">h</span>              = fuel_model[<span style="color: #ffa07a;">"h"</span>]
    <span style="color: #eedd82;">rho_p</span>          = fuel_model[<span style="color: #ffa07a;">"rho_p"</span>]
    <span style="color: #eedd82;">S_T</span>            = fuel_model[<span style="color: #ffa07a;">"S_T"</span>]
    <span style="color: #eedd82;">S_e</span>            = fuel_model[<span style="color: #ffa07a;">"S_e"</span>]
    <span style="color: #eedd82;">M_x</span>            = fuel_model[<span style="color: #ffa07a;">"M_x"</span>]
    <span style="color: #eedd82;">M_f</span>            = fuel_model[<span style="color: #ffa07a;">"M_f"</span>]
    <span style="color: #eedd82;">f_ij</span>           = fuel_model[<span style="color: #ffa07a;">"f_ij"</span>]
    <span style="color: #eedd82;">f_i</span>            = fuel_model[<span style="color: #ffa07a;">"f_i"</span>]
    <span style="color: #eedd82;">g_ij</span>           = fuel_model[<span style="color: #ffa07a;">"g_ij"</span>]
    <span style="color: #eedd82;">eta_S_i</span>        = calc_mineral_damping_coefficients(f_ij, S_e)
    <span style="color: #eedd82;">eta_M_i</span>        = calc_moisture_damping_coefficients(f_ij, M_f, M_x)
    <span style="color: #eedd82;">h_i</span>            = calc_low_heat_content(f_ij, h)
    <span style="color: #eedd82;">W_n_i</span>          = calc_net_fuel_loading(g_ij, w_o, S_T)                      <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">(lb/ft^2)</span>
    <span style="color: #eedd82;">beta</span>           = calc_packing_ratio(w_o, rho_p, delta)
    <span style="color: #eedd82;">sigma_prime</span>    = calc_surface_area_to_volume_ratio(f_i, f_ij, sigma)
    <span style="color: #eedd82;">beta_op</span>        = calc_optimum_packing_ratio(sigma_prime)
    <span style="color: #eedd82;">Gamma_prime</span>    = calc_optimum_reaction_velocity(beta, sigma_prime, beta_op) <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">(1/min)</span>
    <span style="color: #eedd82;">Btus</span>           = calc_heat_per_unit_area(eta_S_i, eta_M_i, h_i, W_n_i)      <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">(Btu/ft^2)</span>
    <span style="color: #eedd82;">I_R</span>            = calc_reaction_intensity(Gamma_prime, Btus)                 <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">(Btu/ft^2*min)</span>
    <span style="color: #eedd82;">xi</span>             = calc_propagating_flux_ratio(beta, sigma_prime)
    <span style="color: #eedd82;">Q_ig</span>           = calc_heat_of_preignition(M_f)                              <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">(Btu/lb)</span>
    <span style="color: #eedd82;">epsilon_i</span>      = calc_heat_distribution(sigma, Q_ig, f_ij)                  <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">(Btu/lb)</span>
    <span style="color: #eedd82;">rho_b</span>          = calc_ovendry_bulk_density(w_o, delta)                      <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">(lb/ft^3)</span>
    <span style="color: #eedd82;">epsilon</span>        = calc_heat_total(f_i, epsilon_i)                            <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">(Btu/lb)</span>
    <span style="color: #eedd82;">R</span>              = calc_surface_fire_spread_rate(I_R, xi, rho_b, epsilon)     <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">(ft/min)</span>
    <span style="color: #eedd82;">t_res</span>          = calc_residence_time(sigma_prime)
    <span style="color: #eedd82;">B</span>              = 0.02526 * (sigma_prime ** 0.54)
    <span style="color: #eedd82;">C</span>              = 7.47 * exp(-0.133 * (sigma_prime ** 0.55))
    <span style="color: #eedd82;">E</span>              = 0.715 * exp(-3.59 * (sigma_prime / 10000.0))
    <span style="color: #eedd82;">F</span>              = (beta / beta_op) ** E
    <span style="color: #eedd82;">get_phi_S</span>      = get_phi_S_fn(beta)
    <span style="color: #eedd82;">get_phi_W</span>      = get_phi_W_fn(beta, B, C, F)
    <span style="color: #eedd82;">get_wind_speed</span> = get_wind_speed_fn(B, C, F)
    <span style="color: #00ffff;">return</span> {
        <span style="color: #ffa07a;">"base_spread_rate"</span>  : R,
        <span style="color: #ffa07a;">"reaction_intensity"</span>: I_R,
        <span style="color: #ffa07a;">"residence_time"</span>    : t_res,
        <span style="color: #ffa07a;">"get_phi_S"</span>         : get_phi_S,
        <span style="color: #ffa07a;">"get_phi_W"</span>         : get_phi_W,
        <span style="color: #ffa07a;">"get_wind_speed"</span>    : get_wind_speed,
    }

<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Test with:</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">- moisturize(fuel_models_precomputed[1], [0.05, 0.10, 0.15, 0.05, 0.30, 0.50])   # non-dynamic fuel model</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">- moisturize(fuel_models_precomputed[101], [0.05, 0.10, 0.15, 0.05, 0.30, 0.50]) # dynamic fuel model</span>
</pre>
</div>

<p>
Later, this no-wind-no-slope value is used to compute the maximum
spread rate and direction for the leading edge of the surface fire
under analysis. Since Rothermel's original equations assume that the
wind direction and slope are aligned, the effects of cross-slope winds
must be taken into effect. To accomplish this, Pyretechnics implements
the vector addition procedure defined in Rothermel 1983 that combines
the wind-only and slope-only spread rates independently to calculate
the effective fire spread direction and
magnitude.\citep{Rothermel1983}
</p>

<p>
A minor wrinkle is introduced when putting these calculations into
practice because Rothermel's formulas all expect a measure of midflame
wind speed. However, wind speed data is often collected at a height 20
feet above either unsheltered ground or a tree canopy layer if
present. To convert this 20-ft wind speed to the required midflame
wind speed value, Pyretechnics uses the <b>wind adjustment factor</b>
formula from Albini &amp; Baughman 1979, parameterized as in BehavePlus,
FARSITE, FlamMap, FSPro, and FPA according to Andrews
2012\citep{Albini1979,Andrews2012}. This formula is shown below:
</p>

\begin{align}
  WAF = \left\{
    \begin{array}{lr}
      \frac{1.83}{ \ln(\frac{20.0 + 0.36 FBD}{0.13 FBD}) } & CC = 0 \\
      \frac{0.555}{ \sqrt(CH (CC/3.0)) \ln(\frac{20 + 0.36 CH}{0.13 CH}) } & CC > 0
    \end{array}
  \right.
\end{align}

<p>
where WAF is the unitless wind adjustment factor, FBD is the fuel bed
depth in feet, CH is the canopy height in ft, and CC is the canopy
cover percentage (0-1).
</p>

<div class="org-src-container">
<pre class="src src-python" id="orgb97b149"><span style="color: #00ffff;">from</span> math <span style="color: #00ffff;">import</span> log, sqrt

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">wind_adjustment_factor</span>(fuel_bed_depth, canopy_height, canopy_cover):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    fuel_bed_depth :: ft</span>
<span style="color: #ffa07a;">    canopy_height  :: ft</span>
<span style="color: #ffa07a;">    canopy_cover   :: 0-1</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #00ffff;">if</span> (canopy_cover &gt; 0.0) <span style="color: #00ffff;">and</span> (canopy_height &gt; 0.0):
        <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">sheltered: equation 2 based on CC and CH, CR=1 (Andrews 2012)</span>
        <span style="color: #eedd82;">A</span> = sqrt((canopy_cover / 3.0) * canopy_height)
        <span style="color: #eedd82;">B</span> = log((20.0 + 0.36 * canopy_height) / (0.13 * canopy_height))
        <span style="color: #00ffff;">return</span> 0.555 / (A * B)
    <span style="color: #00ffff;">elif</span> (fuel_bed_depth &gt; 0.0):
        <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">unsheltered: equation 6 H_F = H (Andrews 2012)</span>
        <span style="color: #eedd82;">A</span> = log((20.0 + 0.36 * fuel_bed_depth) / (0.13 * fuel_bed_depth))
        <span style="color: #00ffff;">return</span> 1.83 / A <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">1.83 truncated from 1.8328795184533409</span>
    <span style="color: #00ffff;">else</span>:
        <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">non-burnable fuel model</span>
        <span style="color: #00ffff;">return</span> 0.0
</pre>
</div>

<p>
The midflame wind speed that would be required to produce the combined
spread rate in a no-slope scenario is termed the effective windspeed
\(U_{\text{eff}}\). Following the recommendations given in Appendix
III of Albini 1976, these midflame wind speeds are all limited to \(0.9
I_{R}\).\citep{Albini1976}
</p>

<p>
Next, the effective wind speed is used to compute the length to width
ratio \(\frac{L}{W}\) of an ellipse that approximates the surface fire
front using equation 9 from Rothermel 1991.\citep{Rothermel1991} This
length to width ratio is then converted into an eccentricity measure
of the ellipse using equation 8 from Albini and Chase
1980.\citep{Albini1980} Finally, this eccentricity \(E\) is used to
project the maximum spread rate to any point along the fire front.
Here are the formulas used:
</p>

\begin{align}
  \frac{L}{W} &= 1 + 0.25 \, U_{\text{eff}} \\
  E &= \frac{\sqrt{(\frac{L}{W})^{2} - 1}}{\frac{L}{W}} \\
  R_{\theta} &= R_{\max}\left(\frac{1-E}{1-E\cos\theta}\right)
\end{align}

<p>
where \(U_{eff}\) is the effective wind speed in mph, \(\theta\) is the
angular offset from the direction of maximum fire spread, \(R_{max}\) is
the maximum spread rate, and \(R_{\theta}\) is the spread rate in
direction \(\theta\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="org778c185"><span style="color: #00ffff;">from</span> math <span style="color: #00ffff;">import</span> sin, cos, asin, exp, sqrt, radians, degrees
<span style="color: #00ffff;">from</span> pyretechnics.conversion <span style="color: #00ffff;">import</span> fpm_to_mph

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">almost_zero</span>(x):
    <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">abs</span>(x) &lt; 0.000001


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">smallest_angle_between</span>(theta1, theta2):
  <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">  Computes the absolute difference between two angles as an angle between 0&#176; and 180&#176;.</span>
<span style="color: #ffa07a;">  The return angle has the same cosine as (- theta1 theta2) but may have an opposite sine.</span>
<span style="color: #ffa07a;">  """</span>
  <span style="color: #eedd82;">angle</span> = <span style="color: #b0c4de;">abs</span>(theta1 - theta2)
  <span style="color: #00ffff;">return</span> (360.0 - angle) <span style="color: #00ffff;">if</span> (angle &gt; 180.0) <span style="color: #00ffff;">else</span> angle


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">determine_spread_drivers</span>(midflame_wind_speed, wind_to_direction, slope, slope_direction):
    <span style="color: #00ffff;">if</span> almost_zero(slope):
        <span style="color: #00ffff;">if</span> almost_zero(midflame_wind_speed):
            <span style="color: #00ffff;">return</span> <span style="color: #ffa07a;">"no_wind_no_slope"</span>
        <span style="color: #00ffff;">else</span>:
            <span style="color: #00ffff;">return</span> <span style="color: #ffa07a;">"wind_only"</span>
    <span style="color: #00ffff;">elif</span> almost_zero(midflame_wind_speed):
        <span style="color: #00ffff;">return</span> <span style="color: #ffa07a;">"slope_only"</span>
    <span style="color: #00ffff;">elif</span> smallest_angle_between(wind_to_direction, slope_direction) &lt; 15.0:
        <span style="color: #00ffff;">return</span> <span style="color: #ffa07a;">"wind_blows_upslope"</span>
    <span style="color: #00ffff;">else</span>:
        <span style="color: #00ffff;">return</span> <span style="color: #ffa07a;">"wind_blows_across_slope"</span>


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">spread_info_max_no_wind_no_slope</span>(spread_rate):
    <span style="color: #00ffff;">return</span> {
        <span style="color: #ffa07a;">"max_spread_rate"</span>     : spread_rate,
        <span style="color: #ffa07a;">"max_spread_direction"</span>: 0.0,
        <span style="color: #ffa07a;">"effective_wind_speed"</span>: 0.0,
        <span style="color: #ffa07a;">"eccentricity"</span>        : 0.0,
    }


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">spread_info_max_wind_only</span>(spread_rate, phi_W, midflame_wind_speed, wind_to_direction):
    <span style="color: #00ffff;">return</span> {
        <span style="color: #ffa07a;">"max_spread_rate"</span>     : spread_rate * (1.0 + phi_W),
        <span style="color: #ffa07a;">"max_spread_direction"</span>: wind_to_direction,
        <span style="color: #ffa07a;">"effective_wind_speed"</span>: midflame_wind_speed,
        <span style="color: #ffa07a;">"eccentricity"</span>        : 0.0,
    }


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">spread_info_max_slope_only</span>(spread_rate, phi_S, slope_direction, get_wind_speed):
    <span style="color: #00ffff;">return</span> {
        <span style="color: #ffa07a;">"max_spread_rate"</span>     : spread_rate * (1.0 + phi_S),
        <span style="color: #ffa07a;">"max_spread_direction"</span>: slope_direction,
        <span style="color: #ffa07a;">"effective_wind_speed"</span>: get_wind_speed(phi_S),
        <span style="color: #ffa07a;">"eccentricity"</span>        : 0.0,
    }


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">spread_info_max_wind_blows_upslope</span>(spread_rate, phi_combined, slope_direction, get_wind_speed):
    <span style="color: #00ffff;">return</span> {
        <span style="color: #ffa07a;">"max_spread_rate"</span>     : spread_rate * (1.0 + phi_combined),
        <span style="color: #ffa07a;">"max_spread_direction"</span>: slope_direction,
        <span style="color: #ffa07a;">"effective_wind_speed"</span>: get_wind_speed(phi_combined),
        <span style="color: #ffa07a;">"eccentricity"</span>        : 0.0,
    }


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">get_offset_prime</span>(x, y, offset):
    <span style="color: #00ffff;">if</span> (x &gt;= 0.0):
        <span style="color: #00ffff;">if</span> (y &gt;= 0.0):
            <span style="color: #00ffff;">return</span> offset
        <span style="color: #00ffff;">else</span>:
            <span style="color: #00ffff;">return</span> 360.0 - offset
    <span style="color: #00ffff;">elif</span> (y &gt;= 0.0):
        <span style="color: #00ffff;">return</span> 180.0 - offset
    <span style="color: #00ffff;">else</span>:
        <span style="color: #00ffff;">return</span> 180.0 + offset


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">spread_info_max_wind_blows_across_slope</span>(spread_rate, phi_W, phi_S, wind_to_direction,
                                            slope_direction, get_wind_speed):
    <span style="color: #eedd82;">wind_magnitude</span>     = spread_rate * phi_W
    <span style="color: #eedd82;">slope_magnitude</span>    = spread_rate * phi_S
    <span style="color: #eedd82;">difference_angle</span>   = radians((wind_to_direction - slope_direction) % 360.0)
    <span style="color: #eedd82;">x</span>                  = slope_magnitude + wind_magnitude * cos(difference_angle)
    <span style="color: #eedd82;">y</span>                  = wind_magnitude * sin(difference_angle)
    <span style="color: #eedd82;">combined_magnitude</span> = sqrt(x * x + y * y)
    <span style="color: #00ffff;">if</span> almost_zero(combined_magnitude):
        <span style="color: #00ffff;">return</span> {
            <span style="color: #ffa07a;">"max_spread_rate"</span>     : spread_rate,
            <span style="color: #ffa07a;">"max_spread_direction"</span>: 0.0,
            <span style="color: #ffa07a;">"effective_wind_speed"</span>: 0.0,
            <span style="color: #ffa07a;">"eccentricity"</span>        : 0.0,
        }
    <span style="color: #00ffff;">else</span>:
        <span style="color: #eedd82;">max_spread_rate</span>      = spread_rate + combined_magnitude
        <span style="color: #eedd82;">phi_combined</span>         = (max_spread_rate / spread_rate) - 1.0
        <span style="color: #eedd82;">offset</span>               = degrees(asin(<span style="color: #b0c4de;">abs</span>(y) / combined_magnitude))
        <span style="color: #eedd82;">offset_prime</span>         = get_offset_prime(x, y, offset)
        <span style="color: #eedd82;">max_spread_direction</span> = (slope_direction + offset_prime) % 360.0
        <span style="color: #eedd82;">effective_wind_speed</span> = get_wind_speed(phi_combined)
        <span style="color: #00ffff;">return</span> {
            <span style="color: #ffa07a;">"max_spread_rate"</span>     : max_spread_rate,
            <span style="color: #ffa07a;">"max_spread_direction"</span>: max_spread_direction,
            <span style="color: #ffa07a;">"effective_wind_speed"</span>: effective_wind_speed,
            <span style="color: #ffa07a;">"eccentricity"</span>        : 0.0,
        }


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">get_spread_info_max</span>(spread_drivers, spread_rate, phi_W, phi_S, midflame_wind_speed,
                        wind_to_direction, slope_direction, get_wind_speed):
    <span style="color: #00ffff;">match</span> spread_drivers:
        <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">"no_wind_no_slope"</span>:
            <span style="color: #00ffff;">return</span> spread_info_max_no_wind_no_slope(spread_rate)
        <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">"wind_only"</span>:
            <span style="color: #00ffff;">return</span> spread_info_max_wind_only(spread_rate, phi_W, midflame_wind_speed, wind_to_direction)
        <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">"slope_only"</span>:
            <span style="color: #00ffff;">return</span> spread_info_max_slope_only(spread_rate, phi_S, slope_direction, get_wind_speed)
        <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">"wind_blows_upslope"</span>:
            <span style="color: #00ffff;">return</span> spread_info_max_wind_blows_upslope(spread_rate, (phi_W + phi_S), slope_direction, get_wind_speed)
        <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">"wind_blows_across_slope"</span>:
            <span style="color: #00ffff;">return</span> spread_info_max_wind_blows_across_slope(spread_rate, phi_W, phi_S, wind_to_direction,
                                                           slope_direction, get_wind_speed)


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">scale_spread_to_max_wind_speed</span>(spread_properties, spread_rate, max_wind_speed, phi_max):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Warning: Mutates spread_properties</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #eedd82;">effective_wind_speed</span> = spread_properties[<span style="color: #ffa07a;">"effective_wind_speed"</span>]
    <span style="color: #00ffff;">if</span> (effective_wind_speed &gt; max_wind_speed):
        <span style="color: #eedd82;">spread_properties</span>[<span style="color: #ffa07a;">"max_spread_rate"</span>]      = spread_rate * (1.0 + phi_max)
        <span style="color: #eedd82;">spread_properties</span>[<span style="color: #ffa07a;">"effective_wind_speed"</span>] = max_wind_speed
        <span style="color: #00ffff;">return</span> spread_properties
    <span style="color: #00ffff;">else</span>:
        <span style="color: #00ffff;">return</span> spread_properties


<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">FIXME: Surface L/W uses 0.25 but Crown L/W uses 0.125. Check Rothermel 1991.</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">surface_length_to_width_ratio</span>(effective_wind_speed):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Calculate the length_to_width_ratio of the surface fire front using eq. 9 from</span>
<span style="color: #ffa07a;">    Rothermel 1991 given:</span>
<span style="color: #ffa07a;">    - effective_wind_speed (ft/min)</span>

<span style="color: #ffa07a;">    L/W = 1 + 0.25 * Ueff_mph</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #eedd82;">effective_wind_speed_mph</span> = fpm_to_mph(effective_wind_speed)
    <span style="color: #00ffff;">return</span> 1.0 + 0.25 * effective_wind_speed_mph


<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">FIXME: unused</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">surface_length_to_width_ratio_elmfire</span>(effective_wind_speed):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Calculate the length_to_width_ratio of the surface fire front given:</span>
<span style="color: #ffa07a;">    - effective_wind_speed (ft/min)</span>

<span style="color: #ffa07a;">    L/W = min(0.936 * e^(0.2566 * Ueff_mph) + 0.461 * e^(-0.1548 * Ueff_mph) - 0.397, 8.0)</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #eedd82;">effective_wind_speed_mph</span> = fpm_to_mph(effective_wind_speed)
    <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">min</span>((0.936 * exp(0.2566 * effective_wind_speed_mph))
               +
               (0.461 * exp(-0.1548 * effective_wind_speed_mph))
               -
               0.397,
               8.0)


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">surface_fire_eccentricity</span>(effective_wind_speed):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Calculate the eccentricity (E) of the surface fire front using eq. 9 from</span>
<span style="color: #ffa07a;">    Rothermel 1991 and eq. 8 from Albini and Chase 1980 given:</span>
<span style="color: #ffa07a;">    - effective_wind_speed (ft/min)</span>

<span style="color: #ffa07a;">    L/W = 1 + 0.25 * Ueff_mph</span>
<span style="color: #ffa07a;">    E = sqrt( L/W^2 - 1 ) / L/W</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #eedd82;">length_width_ratio</span> = surface_length_to_width_ratio(effective_wind_speed)
    <span style="color: #00ffff;">return</span> sqrt(length_width_ratio ** 2.0 - 1.0) / length_width_ratio


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">add_eccentricity</span>(spread_properties):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Warning: Mutates spread_properties</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #eedd82;">effective_wind_speed</span>              = spread_properties[<span style="color: #ffa07a;">"effective_wind_speed"</span>] <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">ft/min</span>
    <span style="color: #eedd82;">spread_properties</span>[<span style="color: #ffa07a;">"eccentricity"</span>] = surface_fire_eccentricity(effective_wind_speed)
    <span style="color: #00ffff;">return</span> spread_properties


<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">NOTE: No longer takes ellipse_adjustment_factor parameter</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">rothermel_surface_fire_spread_max</span>(surface_fire_min, midflame_wind_speed, wind_from_direction,
                                      slope, aspect, spread_rate_adjustment=1.0):
    <span style="color: #eedd82;">spread_rate</span>        = surface_fire_min[<span style="color: #ffa07a;">"base_spread_rate"</span>] * spread_rate_adjustment
    <span style="color: #eedd82;">reaction_intensity</span> = surface_fire_min[<span style="color: #ffa07a;">"reaction_intensity"</span>]
    <span style="color: #eedd82;">get_phi_S</span>          = surface_fire_min[<span style="color: #ffa07a;">"get_phi_S"</span>]
    <span style="color: #eedd82;">get_phi_W</span>          = surface_fire_min[<span style="color: #ffa07a;">"get_phi_W"</span>]
    <span style="color: #eedd82;">get_wind_speed</span>     = surface_fire_min[<span style="color: #ffa07a;">"get_wind_speed"</span>]
    <span style="color: #eedd82;">slope_direction</span>    = (aspect + 180.0) % 360.0
    <span style="color: #eedd82;">wind_to_direction</span>  = (wind_from_direction + 180.0) % 360.0
    <span style="color: #eedd82;">max_wind_speed</span>     = 0.9 * reaction_intensity
    <span style="color: #eedd82;">phi_S</span>              = get_phi_S(slope)
    <span style="color: #eedd82;">phi_W</span>              = get_phi_W(midflame_wind_speed)
    <span style="color: #eedd82;">phi_max</span>            = get_phi_W(max_wind_speed)
    <span style="color: #eedd82;">spread_drivers</span>     = determine_spread_drivers(midflame_wind_speed, wind_to_direction, slope, slope_direction)
    <span style="color: #eedd82;">spread_info_max</span>    = get_spread_info_max(spread_drivers, spread_rate, phi_W, phi_S, midflame_wind_speed,
                                             wind_to_direction, slope_direction, get_wind_speed)
    <span style="color: #00ffff;">return</span> add_eccentricity(scale_spread_to_max_wind_speed(spread_info_max, spread_rate, max_wind_speed, phi_max))


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">compute_spread_rate</span>(max_spread_rate, max_spread_direction, eccentricity, spread_direction):
    <span style="color: #eedd82;">theta</span> = smallest_angle_between(max_spread_direction, spread_direction)
    <span style="color: #00ffff;">if</span> almost_zero(eccentricity) <span style="color: #00ffff;">or</span> almost_zero(theta):
        <span style="color: #00ffff;">return</span> max_spread_rate
    <span style="color: #00ffff;">else</span>:
        <span style="color: #00ffff;">return</span> max_spread_rate * (1.0 - eccentricity) / (1.0 - eccentricity * cos(radians(theta)))
</pre>
</div>

<p>
Using these surface fire spread rate and reaction intensity values, we
next calculate fire intensity values by applying Anderson's flame
depth formula and Byram's fire line intensity and flame length
equations as described below.\citep{Anderson1969,Byram1959}
</p>

\begin{align}
  t &= \frac{384}{\sigma} \\
  D &= Rt \\
  I &= \frac{I_{R}D}{60} \\
  L &= 0.45(I)^{0.46}
\end{align}

<p>
where \(\sigma\) is the weighted sum by size class of the fuel model's
surface area to volume ratio in ft<sup>2</sup>/ft<sup>3</sup>, \(t\) is the residence
time in minutes, \(R\) is the surface fire spread rate in ft/min, \(D\) is
the flame depth in ft, \(I_{R}\) is the reaction intensity in
Btu/ft<sup>2</sup>/min, \(I\) is the fire line intensity in Btu/ft/s, and \(L\) is
the flame length in ft.
</p>

<div class="org-src-container">
<pre class="src src-python" id="org7f81ab1"><span style="color: #00ffff;">def</span> <span style="color: #87cefa;">anderson_flame_depth</span>(spread_rate, residence_time):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Returns the depth, or front-to-back distance, of the actively flaming zone</span>
<span style="color: #ffa07a;">    of a free-spreading fire in ft given:</span>
<span style="color: #ffa07a;">    - spread-rate (ft/min) orthogonal to the fire line.</span>
<span style="color: #ffa07a;">    - residence-time (min)</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #00ffff;">return</span> spread_rate * residence_time


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">byram_fire_line_intensity</span>(reaction_intensity, flame_depth):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Returns the rate of heat release per unit of fire edge in Btu/ft*s given:</span>
<span style="color: #ffa07a;">    - reaction-intensity (Btu/ft^2*min)</span>
<span style="color: #ffa07a;">    - flame-depth (ft)</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #00ffff;">return</span> (reaction_intensity * flame_depth) / 60.0


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">byram_flame_length</span>(fire_line_intensity):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Returns the average flame length in ft given:</span>
<span style="color: #ffa07a;">    - fire-line-intensity (Btu/ft*s)</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #00ffff;">return</span> 0.45 * (fire_line_intensity ** 0.46)
</pre>
</div>

<p>
This concludes our coverage of the surface fire behavior equations
implemented in Pyretechnics. In Section <a href="#org598edc7">9</a>,
these formulas will be translated from one-dimension to
two-dimensional spread on a raster grid. Before we move on to that,
however, the following section explains how crown fire behavior
metrics are incorporated into our model.
</p>
</div>
</div>

<div id="outline-container-orgc78373c" class="outline-3">
<h3 id="orgc78373c"><span class="section-number-3">5.3.</span> Crown Fire Formulas</h3>
<div class="outline-text-3" id="text-5-3">
<p>
In order to incorporate the effects of crown fire behavior,
Pyretechnics includes the crown fire initiation routine from Van
Wagner 1977.\citep{VanWagner1977} According to this approach, there
are two threshold values (<i>critical intensity</i> and <i>critical spread
rate</i>) that must be calculated in order to determine whether a fire
will become an active or passive crown fire or simply remain a surface
fire. The formulas for these thresholds are as follows:
</p>

\begin{align}
  H &= 460 + 2600 M^{f} \\
  I^{*} &= (0.01 \, Z_{b} \, H)^{1.5} \\
  R^{*} &= \frac{3.0}{B_{m}}
\end{align}

<p>
where \(H\) is the heat of ignition for the herbaceous material in the
canopy in kJ/kg, \(M^{f}\) is the foliar moisture content in lb
moisture/lb ovendry weight, \(Z_{b}\) is the canopy base height in
meters, \(I^{*}\) is the critical intensity in kW/m, \(B_{m}\) is the
crown bulk density in kg/m<sup>3</sup>, and \(R^{*}\) is the critical spread
rate in m/min.
</p>

<p>
If the canopy cover is greater than 40% and the surface fire line
intensity is greater than the critical intensity (\(I > I^{*}\)), then
crown fire initiation occurs.
</p>

<div class="org-src-container">
<pre class="src src-python" id="org915ff97"><span style="color: #00ffff;">def</span> <span style="color: #87cefa;">van_wagner_critical_fire_line_intensity</span>(canopy_base_height, foliar_moisture):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Ouputs the critical fire line intensity (kW/m) using:</span>
<span style="color: #ffa07a;">    - canopy_base_height (m)</span>
<span style="color: #ffa07a;">    - foliar_moisture (0-1)</span>

<span style="color: #ffa07a;">    Constants used:</span>
<span style="color: #ffa07a;">    460.0 = heat-of-ignition (kJ/kg)</span>
<span style="color: #ffa07a;">    0.01 = empirical estimate for C in eq. 4</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #00ffff;">return</span> ((foliar_moisture * 2600.0 + 460.0) * 0.01 * canopy_base_height) ** 1.5


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">van_wagner_crown_fire_initiation</span>(canopy_cover, canopy_base_height, foliar_moisture, fire_line_intensity):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    - canopy_cover (0-1)</span>
<span style="color: #ffa07a;">    - canopy_base_height (m)</span>
<span style="color: #ffa07a;">    - foliar_moisture (0-1)</span>
<span style="color: #ffa07a;">    - fire_line_intensity (kW/m)</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #00ffff;">return</span> ((canopy_cover &gt; 0.4)
            <span style="color: #00ffff;">and</span>
            (fire_line_intensity &gt; 0.0)
            <span style="color: #00ffff;">and</span>
            (canopy_base_height &gt; 0.0)
            <span style="color: #00ffff;">and</span>
            (fire_line_intensity &gt;= van_wagner_critical_fire_line_intensity(canopy_base_height, foliar_moisture)))
</pre>
</div>

<p>
If crowning occurs, then the active and passive crown fire spread
rates are calculated from the formulas given in Cruz
2005.\citep{Cruz2005}
</p>

\begin{align}
  \text{CROS}_{A} &= 11.02 \> U_{10m}^{0.90} \> B_{m}^{0.19} \> e^{-17 \, \text{EFFM}} \\
  \text{CROS}_{P} &= \text{CROS}_{A} \> e^{\frac{-\text{CROS}_{A}}{R^{*}}}
\end{align}

<p>
where \(\text{CROS}_{A}\) is the active crown fire spread rate in
m/min, \(U_{10m}\) is the 10 meter windspeed in km/hr, \(B_{m}\) is the
crown bulk density in kg/m<sup>3</sup>, EFFM is the estimated fine fuel
moisture as a percent (0-1), and \(\text{CROS}_{P}\) is the passive
crown fire spread rate in m/min.
</p>

<p>
If the active crown fire spread rate is greater than the critical
spread rate (\(\text{CROS}_{A} > R^{*}\)), then the crown fire will be
active, otherwise passive.
</p>

<div class="org-src-container">
<pre class="src src-python" id="orgde576a8"><span style="color: #00ffff;">from</span> math <span style="color: #00ffff;">import</span> exp

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">cruz_active_crown_fire_spread</span>(wind_speed_10m, canopy_bulk_density, estimated_fine_fuel_moisture):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Returns active spread-rate in m/min given:</span>
<span style="color: #ffa07a;">    - wind_speed_10m (km/hr)</span>
<span style="color: #ffa07a;">    - canopy_bulk_density (kg/m^3)</span>
<span style="color: #ffa07a;">    - estimated_fine_fuel_moisture (M_f[0] "dead-1hr") (0-1)</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #00ffff;">return</span> (11.02
            * wind_speed_10m ** 0.90
            * canopy_bulk_density ** 0.19
            * exp(-17.0 * estimated_fine_fuel_moisture))


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">cruz_passive_crown_fire_spread</span>(active_spread_rate, critical_spread_rate):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Returns passive spread-rate in m/min given:</span>
<span style="color: #ffa07a;">    - active_spread_rate (m/min)</span>
<span style="color: #ffa07a;">    - critical_spread_rate (m/min)</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #00ffff;">return</span> active_spread_rate * exp(-1.0 * active_spread_rate / critical_spread_rate)


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">cruz_crown_fire_spread</span>(wind_speed_10m, canopy_bulk_density, estimated_fine_fuel_moisture):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Returns spread-rate in m/min given:</span>
<span style="color: #ffa07a;">    - wind_speed_10m (km/hr)</span>
<span style="color: #ffa07a;">    - canopy_bulk_density (kg/m^3)</span>
<span style="color: #ffa07a;">    - estimated_fine_fuel_moisture (M_f[0] "dead-1hr") (0-1)</span>
<span style="color: #ffa07a;">    NOTE: A positive spread-rate indicates active crowning.</span>
<span style="color: #ffa07a;">          A negative spread-rate indicates passive crowning.</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #eedd82;">active_spread_rate</span>   = cruz_active_crown_fire_spread(wind_speed_10m,
                                                         canopy_bulk_density,
                                                         estimated_fine_fuel_moisture)
    <span style="color: #eedd82;">critical_spread_rate</span> = 3.0 / canopy_bulk_density <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">m/min</span>
    <span style="color: #00ffff;">if</span> (active_spread_rate &gt; critical_spread_rate):
        <span style="color: #00ffff;">return</span> active_spread_rate
    <span style="color: #00ffff;">else</span>:
        <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">NOTE: Use minus as passive flag</span>
        <span style="color: #00ffff;">return</span> -1.0 * cruz_passive_crown_fire_spread(active_spread_rate, critical_spread_rate)
</pre>
</div>

<p>
Once the crown fire spread rate is determined, the crown fire line
intensity and flame lengths may be derived using the following
formulas:
</p>

\begin{align}
  I_{c} &= \frac{R_{c} B (Z - Z_{b}) h}{60} \\
  L_{c} &= 0.45(I + I_{c})^{0.46}
\end{align}

<p>
where \(I_{c}\) is the crown fire line intensity in Btu/ft/s, \(R_{c}\) is
the crown fire spread rate (either \(\text{CROS}_{A}\) or
\(\text{CROS}_{P}\)) in ft/min, \(B\) is the crown bulk density in
lb/ft<sup>3</sup>, \(Z\) is the canopy height in ft, \(Z_{b}\) is the canopy base
height in ft, \(h\) is the fuel model heat of combustion (generally 8000
Btu/lb), \(L_{c}\) is the crown flame length in ft, and \(I\) is the
surface fire line intensity in Btu/ft/s.
</p>

<div class="org-src-container">
<pre class="src src-python" id="orgafae0ea"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">NOTE: heat_of_combustion is h from the fuel models (generally 8000 Btu/lb)</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">NOTE: ELMFIRE hard-codes heat_of_combustion to 18000 kJ/kg = 7738.6 Btu/lb</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">crown_fire_line_intensity</span>(crown_spread_rate, canopy_bulk_density, canopy_height_difference, heat_of_combustion):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Returns the crown_fire_line_intensity in Btu/ft*s OR kW/m, given:</span>
<span style="color: #ffa07a;">    - crown_spread_rate (ft/min OR m/min)</span>
<span style="color: #ffa07a;">    - canopy_bulk_density (lb/ft^3 OR kg/m^3)</span>
<span style="color: #ffa07a;">    - canopy_height_difference (canopy_height - canopy_base_height) (ft OR m)</span>
<span style="color: #ffa07a;">    - heat_of_combustion (Btu/lb OR kJ/kg)</span>

<span style="color: #ffa07a;">    (ft/min * lb/ft^3 * ft * Btu/lb)/60 = (Btu/ft*min)/60 = Btu/ft*s</span>
<span style="color: #ffa07a;">    OR</span>
<span style="color: #ffa07a;">    (m/min * kg/m^3 * m * kJ/kg)/60 = (kJ/m*min)/60 = kJ/m*s = kW/m</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #00ffff;">return</span> (crown_spread_rate * canopy_bulk_density * canopy_height_difference * heat_of_combustion) / 60.0
</pre>
</div>

<p>
As with surface fire spread, the wind speed (this time the 20-ft wind
speed in mph \(U_{20}\)) is used to compute the length to width ratio
\(\frac{L}{W}\) of an ellipse that approximates the crown fire front
using equation 9 from Rothermel 1991.\citep{Rothermel1991} This length
to width ratio is then converted into an eccentricity measure of the
ellipse using equation 8 from Albini and Chase 1980.\citep{Albini1980}
Finally, this eccentricity \(E\) is used to project the maximum spread
rate to any point along the fire front. Here are the formulas used:
</p>

\begin{align}
  \frac{L}{W} &= 1 + 0.125 \, U_{20} \\
  E &= \frac{\sqrt{(\frac{L}{W})^{2} - 1}}{\frac{L}{W}} \\
  R_{\theta} &= R_{\max}\left(\frac{1-E}{1-E\cos\theta}\right)
\end{align}

<p>
where \(\theta\) is the angular offset from the direction of maximum fire
spread, \(R_{max}\) is the maximum spread rate, and \(R_{\theta}\) is the
spread rate in direction \(\theta\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="orga1feaf6"><span style="color: #00ffff;">from</span> math <span style="color: #00ffff;">import</span> sqrt

<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">NOTE: No longer takes ellipse_adjustment_factor argument</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">FIXME: Surface L/W uses 0.25 but Crown L/W uses 0.125. Check Rothermel 1991.</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">crown_length_to_width_ratio</span>(wind_speed_20ft):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Calculate the length_to_width_ratio of the crown fire front using eq. 9 from</span>
<span style="color: #ffa07a;">    Rothermel 1991 given:</span>
<span style="color: #ffa07a;">    - wind_speed_20ft (mph)</span>

<span style="color: #ffa07a;">    L/W = 1 + 0.125 * U20_mph</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #00ffff;">return</span> 1.0 + 0.125 * wind_speed_20ft


<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">FIXME: unused</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">crown_length_to_width_ratio_elmfire</span>(wind_speed_20ft, max_length_to_width_ratio):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Calculate the length_to_width_ratio of the crown fire front using eq. 9 from</span>
<span style="color: #ffa07a;">    Rothermel 1991 given:</span>
<span style="color: #ffa07a;">    - wind_speed_20ft (mph)</span>
<span style="color: #ffa07a;">    - max_length_to_width_ratio (int &gt; 0)</span>

<span style="color: #ffa07a;">    L/W = min(1.0 + 0.125 * U20_mph, L/W_max)</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">min</span>((1.0 + 0.125 * wind_speed_20ft), max_length_to_width_ratio)


<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">NOTE: No longer takes ellipse_adjustment_factor argument</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">crown_fire_eccentricity</span>(wind_speed_20ft):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Calculate the eccentricity (E) of the crown fire front using eq. 9 from</span>
<span style="color: #ffa07a;">    Rothermel 1991 and eq. 8 from Albini and Chase 1980 given:</span>
<span style="color: #ffa07a;">    - wind_speed_20ft (mph)</span>

<span style="color: #ffa07a;">    L/W = 1 + 0.125 * U20_mph</span>
<span style="color: #ffa07a;">    E = sqrt( L/W^2 - 1 ) / L/W</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #eedd82;">length_width_ratio</span> = crown_length_to_width_ratio(wind_speed_20ft)
    <span style="color: #00ffff;">return</span> sqrt(length_width_ratio ** 2.0 - 1.0) / length_width_ratio
</pre>
</div>

<p>
This concludes our discussion of the crown fire behavior formulas used
in Pyretechnics.
</p>
</div>
</div>
</div>

<div id="outline-container-org16dd555" class="outline-2">
<h2 id="org16dd555"><span class="section-number-2">6.</span> Burning All Cells as a Head-Fire (similar to FLAMMAP)</h2>
<div class="outline-text-2" id="text-6">
<div class="org-src-container">
<pre class="src src-python" id="org0138738"><span style="color: #00ffff;">from</span> math <span style="color: #00ffff;">import</span> sqrt, atan2, degrees
<span style="color: #00ffff;">from</span> pyretechnics.conversion <span style="color: #00ffff;">import</span> wind_speed_10m_to_wind_speed_20ft, m_to_ft, Btu_ft_s_to_kW_m, kW_m_to_Btu_ft_s, m_min_to_km_hr, m_min_to_mph, ft_to_m, Btu_lb_to_kJ_kg
<span style="color: #00ffff;">from</span> pyretechnics.fuel_models <span style="color: #00ffff;">import</span> fuel_models_precomputed, moisturize, is_burnable_fuel_model_number
<span style="color: #00ffff;">import</span> pyretechnics.surface_fire <span style="color: #00ffff;">as</span> sf
<span style="color: #00ffff;">import</span> pyretechnics.crown_fire <span style="color: #00ffff;">as</span> cf

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">one_everywhere</span>(t, y, x):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Return 1.0 for all t, y, x values.</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #00ffff;">return</span> 1.0


<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">NOTE: Name change (no more !)</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">compute_max_in_situ_values</span>(inputs, t, y, x):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Returns the following fire behavior values for the space-time cell at location (t,y,x):</span>
<span style="color: #ffa07a;">    - max_spread_rate        : m/min</span>
<span style="color: #ffa07a;">    - max_spread_direction   : deg</span>
<span style="color: #ffa07a;">    - max_fire_line_intensity: kW/m</span>
<span style="color: #ffa07a;">    - max_flame_length       : m</span>
<span style="color: #ffa07a;">    - fire_type              : 0=unburned, 1=surface, 2=passive crown, 3=active crown</span>
<span style="color: #ffa07a;">    - eccentricity           : unitless (0: circular fire, &gt;0: elliptical fire)</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Topography, Fuel Model, and Vegetation</span>
    <span style="color: #eedd82;">slope</span>                         = inputs[<span style="color: #ffa07a;">"slope"</span>](t,y,x)
    <span style="color: #eedd82;">aspect</span>                        = inputs[<span style="color: #ffa07a;">"aspect"</span>](t,y,x)
    <span style="color: #eedd82;">fuel_model_number</span>             = inputs[<span style="color: #ffa07a;">"fuel_model"</span>](t,y,x)
    <span style="color: #eedd82;">canopy_cover</span>                  = inputs[<span style="color: #ffa07a;">"canopy_cover"</span>](t,y,x)
    <span style="color: #eedd82;">canopy_height</span>                 = inputs[<span style="color: #ffa07a;">"canopy_height"</span>](t,y,x)
    <span style="color: #eedd82;">canopy_base_height</span>            = inputs[<span style="color: #ffa07a;">"canopy_base_height"</span>](t,y,x)
    <span style="color: #eedd82;">canopy_bulk_density</span>           = inputs[<span style="color: #ffa07a;">"canopy_bulk_density"</span>](t,y,x)
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Wind, Surface Moisture, and Foliar Moisture</span>
    <span style="color: #eedd82;">wind_speed_10m_x</span>              = inputs[<span style="color: #ffa07a;">"wind_speed_10m_x"</span>](t,y,x)
    <span style="color: #eedd82;">wind_speed_10m_y</span>              = inputs[<span style="color: #ffa07a;">"wind_speed_10m_y"</span>](t,y,x)
    <span style="color: #eedd82;">fuel_moisture_dead_1hr</span>        = inputs[<span style="color: #ffa07a;">"fuel_moisture_dead_1hr"</span>](t,y,x)
    <span style="color: #eedd82;">fuel_moisture_dead_10hr</span>       = inputs[<span style="color: #ffa07a;">"fuel_moisture_dead_10hr"</span>](t,y,x)
    <span style="color: #eedd82;">fuel_moisture_dead_100hr</span>      = inputs[<span style="color: #ffa07a;">"fuel_moisture_dead_100hr"</span>](t,y,x)
    <span style="color: #eedd82;">fuel_moisture_live_herbaceous</span> = inputs[<span style="color: #ffa07a;">"fuel_moisture_live_herbaceous"</span>](t,y,x)
    <span style="color: #eedd82;">fuel_moisture_live_woody</span>      = inputs[<span style="color: #ffa07a;">"fuel_moisture_live_woody"</span>](t,y,x)
    <span style="color: #eedd82;">foliar_moisture</span>               = inputs[<span style="color: #ffa07a;">"foliar_moisture"</span>](t,y,x)
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Spread Rate Adjustments</span>
    <span style="color: #eedd82;">fuel_spread_adjustment</span>        = inputs.get(<span style="color: #ffa07a;">"fuel_spread_adjustment"</span>   , one_everywhere)(t,y,x)
    <span style="color: #eedd82;">weather_spread_adjustment</span>     = inputs.get(<span style="color: #ffa07a;">"weather_spread_adjustment"</span>, one_everywhere)(t,y,x)
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Check Whether Cell is Burnable</span>
    <span style="color: #00ffff;">if</span> <span style="color: #00ffff;">not</span> is_burnable_fuel_model_number(fuel_model_number):
        <span style="color: #00ffff;">return</span> {
            <span style="color: #ffa07a;">"max_spread_rate"</span>        : 0.0, <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">m/min</span>
            <span style="color: #ffa07a;">"max_spread_direction"</span>   : 0.0, <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">deg</span>
            <span style="color: #ffa07a;">"max_fire_line_intensity"</span>: 0.0, <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">kW/m</span>
            <span style="color: #ffa07a;">"max_flame_length"</span>       : 0.0, <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">m</span>
            <span style="color: #ffa07a;">"fire_type"</span>              : 0,   <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">0=unburned</span>
            <span style="color: #ffa07a;">"eccentricity"</span>           : 0.0, <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">unitless</span>
        }
    <span style="color: #00ffff;">else</span>:
        <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Moisturized Fuel Model</span>
        <span style="color: #eedd82;">fuel_model</span>              = fuel_models_precomputed[fuel_model_number]
        <span style="color: #eedd82;">fuel_moisture</span>           = [fuel_moisture_dead_1hr,
                                   fuel_moisture_dead_10hr,
                                   fuel_moisture_dead_100hr,
                                   0.0, <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">fuel_moisture_dead_herbaceous</span>
                                   fuel_moisture_live_herbaceous,
                                   fuel_moisture_live_woody]
        <span style="color: #eedd82;">moisturized_fuel_model</span>  = moisturize(fuel_model, fuel_moisture)
        <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Baseline Surface Spread Rate, Residence Time, and Reaction Intensity</span>
        <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">TODO: Memoize rothermel_surface_fire_spread_no_wind_no_slope</span>
        <span style="color: #eedd82;">surface_fire_min</span>        = sf.rothermel_surface_fire_spread_no_wind_no_slope(moisturized_fuel_model)
        <span style="color: #eedd82;">residence_time</span>          = surface_fire_min[<span style="color: #ffa07a;">"residence_time"</span>] <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">min</span>
        <span style="color: #eedd82;">reaction_intensity</span>      = surface_fire_min[<span style="color: #ffa07a;">"reaction_intensity"</span>] <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Btu/ft^2*min</span>
        <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Midflame Wind Speed</span>
        <span style="color: #eedd82;">wind_speed_10m</span>          = sqrt(wind_speed_10m_x ** 2.0 + wind_speed_10m_y ** 2.0) <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">m/min</span>
        <span style="color: #eedd82;">wind_speed_20ft</span>         = wind_speed_10m_to_wind_speed_20ft(wind_speed_10m) <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">m/min</span>
        <span style="color: #eedd82;">wind_from_direction</span>     = (90.0 - degrees(atan2(wind_speed_10m_y, wind_speed_10m_x)) % 360.0) % 360.0 <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">deg</span>
        <span style="color: #eedd82;">wind_adj_factor</span>         = sf.wind_adjustment_factor(fuel_model[<span style="color: #ffa07a;">"delta"</span>],
                                                            m_to_ft(canopy_height),
                                                            canopy_cover) <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">unitless</span>
        <span style="color: #eedd82;">midflame_wind_speed</span>     = m_to_ft(wind_speed_20ft * wind_adj_factor) <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">ft/min</span>
        <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Max Surface Spread Rate/Direction and Surface Eccentricity</span>
        <span style="color: #eedd82;">spread_rate_adjustment</span>  = fuel_spread_adjustment * weather_spread_adjustment <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">unitless</span>
        <span style="color: #eedd82;">surface_fire_max</span>        = sf.rothermel_surface_fire_spread_max(surface_fire_min,
                                                                       midflame_wind_speed,
                                                                       wind_from_direction,
                                                                       slope,
                                                                       aspect,
                                                                       spread_rate_adjustment)
        <span style="color: #eedd82;">max_surface_spread_rate</span> = surface_fire_max[<span style="color: #ffa07a;">"max_spread_rate"</span>] <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">ft/min</span>
        <span style="color: #eedd82;">max_spread_direction</span>    = surface_fire_max[<span style="color: #ffa07a;">"max_spread_direction"</span>] <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">deg</span>
        <span style="color: #eedd82;">surface_eccentricity</span>    = surface_fire_max[<span style="color: #ffa07a;">"eccentricity"</span>] <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">unitless</span>
        <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Max Surface Intensity</span>
        <span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">=======================================================================================</span>
        <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">NOTE: The calculations to determine the fireline_normal_spread_rate have been elided.</span>
        <span style="color: #ff7f24;">#       </span><span style="color: #ff7f24;">Consider ending this function here and making another function to compute the</span>
        <span style="color: #ff7f24;">#       </span><span style="color: #ff7f24;">surface/crown values based on the provided perimeter spread direction.</span>
        <span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">=======================================================================================</span>
        <span style="color: #eedd82;">max_flame_depth</span>         = sf.anderson_flame_depth(max_surface_spread_rate, residence_time) <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">ft</span>
        <span style="color: #eedd82;">max_surface_intensity</span>   = Btu_ft_s_to_kW_m(sf.byram_fire_line_intensity(reaction_intensity,
                                                                                max_flame_depth)) <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">kW/m</span>
        <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Check for Crown Fire Initiation</span>
        <span style="color: #00ffff;">if</span> cf.van_wagner_crown_fire_initiation(canopy_cover,
                                               canopy_base_height,
                                               foliar_moisture,
                                               max_surface_intensity):
            <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Max Crown Spread Rate, Fire Type, and Crown Eccentricity</span>
            <span style="color: #eedd82;">max_crown_spread_rate</span> = m_to_ft(cf.cruz_crown_fire_spread(m_min_to_km_hr(wind_speed_10m),
                                                                      canopy_bulk_density,
                                                                      fuel_moisture_dead_1hr)) <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">ft/min</span>
            <span style="color: #eedd82;">fire_type</span>             = 2 <span style="color: #00ffff;">if</span> (max_crown_spread_rate &lt; 0.0) <span style="color: #00ffff;">else</span> 3 <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">2=passive crown, 3=active crown</span>
            <span style="color: #eedd82;">max_crown_spread_rate</span> = <span style="color: #b0c4de;">abs</span>(max_crown_spread_rate) <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">ft/min</span>
            <span style="color: #eedd82;">crown_eccentricity</span>    = (surface_eccentricity
                                     <span style="color: #00ffff;">if</span> (max_surface_spread_rate &gt; max_crown_spread_rate)
                                     <span style="color: #00ffff;">else</span> cf.crown_fire_eccentricity(m_min_to_mph(wind_speed_20ft))) <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">unitless</span>
            <span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">=======================================================================================</span>
            <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">NOTE: The calculations to determine the fireline_normal_spread_rate have been elided.</span>
            <span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">=======================================================================================</span>
            <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Max Crown Intensity</span>
            <span style="color: #eedd82;">max_crown_intensity</span>   = cf.crown_fire_line_intensity(ft_to_m(max_crown_spread_rate),
                                                                 canopy_bulk_density,
                                                                 (canopy_height - canopy_base_height),
                                                                 Btu_lb_to_kJ_kg(fuel_model[<span style="color: #ffa07a;">"h"</span>][0])) <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">kW/m</span>
            <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Max Combined Spread Rate, Intensity, and Flame Length</span>
            <span style="color: #eedd82;">max_spread_rate</span>       = ft_to_m(<span style="color: #b0c4de;">max</span>(max_surface_spread_rate, max_crown_spread_rate)) <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">m/min</span>
            <span style="color: #eedd82;">max_intensity</span>         = max_surface_intensity + max_crown_intensity <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">kW/m</span>
            <span style="color: #eedd82;">max_flame_length</span>      = ft_to_m(sf.byram_flame_length(kW_m_to_Btu_ft_s(max_intensity))) <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">m</span>
            <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Return Fire Behavior Values</span>
            <span style="color: #00ffff;">return</span> {
                <span style="color: #ffa07a;">"max_spread_rate"</span>        : max_spread_rate,      <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">m/min</span>
                <span style="color: #ffa07a;">"max_spread_direction"</span>   : max_spread_direction, <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">deg</span>
                <span style="color: #ffa07a;">"max_fire_line_intensity"</span>: max_intensity,        <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">kW/m</span>
                <span style="color: #ffa07a;">"max_flame_length"</span>       : max_flame_length,     <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">m</span>
                <span style="color: #ffa07a;">"fire_type"</span>              : fire_type,            <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">2=passive crown, 3=active crown</span>
                <span style="color: #ffa07a;">"eccentricity"</span>           : crown_eccentricity,   <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">unitless</span>
            }
        <span style="color: #00ffff;">else</span>:
            <span style="color: #eedd82;">fire_type</span>                = 1 <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">1=surface</span>
            <span style="color: #eedd82;">max_surface_flame_length</span> = ft_to_m(sf.byram_flame_length(kW_m_to_Btu_ft_s(max_surface_intensity))) <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">m</span>
            <span style="color: #00ffff;">return</span> {
                <span style="color: #ffa07a;">"max_spread_rate"</span>        : ft_to_m(max_surface_spread_rate), <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">m/min</span>
                <span style="color: #ffa07a;">"max_spread_direction"</span>   : max_spread_direction,             <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">deg</span>
                <span style="color: #ffa07a;">"max_fire_line_intensity"</span>: max_surface_intensity,            <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">kW/m</span>
                <span style="color: #ffa07a;">"max_flame_length"</span>       : max_surface_flame_length,         <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">m</span>
                <span style="color: #ffa07a;">"fire_type"</span>              : fire_type,                        <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">1=surface</span>
                <span style="color: #ffa07a;">"eccentricity"</span>           : surface_eccentricity,             <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">unitless</span>
            }
</pre>
</div>
</div>
</div>

<div id="outline-container-orged45365" class="outline-2">
<h2 id="orged45365"><span class="section-number-2">7.</span> Loading LANDFIRE Inputs</h2>
<div class="outline-text-2" id="text-7">
<p>
To test out the <code>burn_cells</code> function, we will need to populate a 3D
space-time world cube with all of the values that it requires. In this
section, we will provide the space-varying topography, fuels, and
vegetation layers by using the latest 30m raster layers from the US
LANDFIRE program.<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>
</p>

<table id="orgf8a51df">
<caption class="t-above"><span class="table-number">Table 4:</span> 2022 LANDFIRE Raster Layers</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Layer Name</th>
<th scope="col" class="org-left">Label</th>
<th scope="col" class="org-left">Units</th>
<th scope="col" class="org-right">Min</th>
<th scope="col" class="org-right">Max</th>
<th scope="col" class="org-right">NoData</th>
<th scope="col" class="org-left">Notes</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">SRID</th>
<th scope="col" class="org-left">Cell Size</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Elevation</td>
<td class="org-left">DEM</td>
<td class="org-left">meters above sea level</td>
<td class="org-right">0</td>
<td class="org-right">8850</td>
<td class="org-right">32767</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Slope</td>
<td class="org-left">SLP</td>
<td class="org-left">percent (100 * meters rise / meters run)</td>
<td class="org-right">0</td>
<td class="org-right">400</td>
<td class="org-right">32767</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Aspect</td>
<td class="org-left">ASP</td>
<td class="org-left">degrees CW from North</td>
<td class="org-right">0</td>
<td class="org-right">359</td>
<td class="org-right">32767</td>
<td class="org-left">-1 = no slope</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Fuel Model (S&amp;B 40)</td>
<td class="org-left">FBFM40</td>
<td class="org-left">integer classes</td>
<td class="org-right">91</td>
<td class="org-right">204</td>
<td class="org-right">32767</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Canopy Cover</td>
<td class="org-left">CC</td>
<td class="org-left">percent (100 * canopy area / total area)</td>
<td class="org-right">0</td>
<td class="org-right">95</td>
<td class="org-right">32767</td>
<td class="org-left">0 = no canopy</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Canopy Height</td>
<td class="org-left">CH</td>
<td class="org-left">meters * 10</td>
<td class="org-right">0</td>
<td class="org-right">510</td>
<td class="org-right">32767</td>
<td class="org-left">0 = no canopy</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Canopy Base Height</td>
<td class="org-left">CBH</td>
<td class="org-left">meters * 10</td>
<td class="org-right">0</td>
<td class="org-right">100</td>
<td class="org-right">32767</td>
<td class="org-left">0 = no canopy</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Canopy Bulk Density</td>
<td class="org-left">CBD</td>
<td class="org-left">kg/m^3 * 100</td>
<td class="org-right">0</td>
<td class="org-right">45</td>
<td class="org-right">32767</td>
<td class="org-left">0 = no canopy</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-orgec2db32" class="outline-3">
<h3 id="orgec2db32"><span class="section-number-3">7.1.</span> Loading Raster Files with Python Rasterio</h3>
<div class="outline-text-3" id="text-7-1">
<p>
We will begin by defining a <code>load_raster</code> function that takes a path
to a raster file (e.g., a GeoTIFF) and returns a dictionary containing
these keys:
</p>

<dl class="org-dl">
<dt>array</dt><dd>raster data as a 3D Numpy array <code>(bands, rows, cols)</code> of the specified <code>dtype</code> (default: <code>float32</code>)</dd>
<dt>metadata</dt><dd>dictionary of raster metadata values (e.g., number of bands/rows/cols, band dtypes, nodata value, georeferencing info)</dd>
</dl>

<div class="org-src-container">
<pre class="src src-python" id="orgd91293d"><span style="color: #00ffff;">import</span> rasterio

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">raster_metadata</span>(raster):
    <span style="color: #00ffff;">return</span> {
        <span style="color: #ffa07a;">"name"</span>      : raster.name,
        <span style="color: #ffa07a;">"bands"</span>     : raster.count,
        <span style="color: #ffa07a;">"rows"</span>      : raster.height,
        <span style="color: #ffa07a;">"cols"</span>      : raster.width,
        <span style="color: #ffa07a;">"band_types"</span>: {i: dtype <span style="color: #00ffff;">for</span> i, dtype <span style="color: #00ffff;">in</span> <span style="color: #b0c4de;">zip</span>(raster.indexes, raster.dtypes)},
        <span style="color: #ffa07a;">"nodata"</span>    : raster.nodata,
        <span style="color: #ffa07a;">"crs"</span>       : raster.crs,
        <span style="color: #ffa07a;">"bounds"</span>    : raster.bounds,
        <span style="color: #ffa07a;">"transform"</span> : raster.transform,
    }


<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">TODO: rasterio.open can also load chunks of a raster file: https://pypi.org/project/rasterio/</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">load_raster</span>(file_path, dtype=<span style="color: #7fffd4;">None</span>):
    <span style="color: #00ffff;">with</span> rasterio.<span style="color: #b0c4de;">open</span>(file_path, <span style="color: #ffa07a;">"r"</span>) <span style="color: #00ffff;">as</span> input_raster:
        <span style="color: #00ffff;">return</span> {
            <span style="color: #ffa07a;">"array"</span>   : input_raster.read(out_dtype=dtype),
            <span style="color: #ffa07a;">"metadata"</span>: raster_metadata(input_raster),
        }
</pre>
</div>
</div>
</div>

<div id="outline-container-org0760711" class="outline-3">
<h3 id="org0760711"><span class="section-number-3">7.2.</span> Convert LANDFIRE Units and Datatypes</h3>
<div class="outline-text-3" id="text-7-2">
<p>
The units and datatypes of our LANDFIRE GeoTIFFs are documented in
Table <a href="#orgf8a51df">4</a>. In order to make them match those required
by the Pyretechnics Fire Spread API, we need to apply some conversions
during the layer loading process.
</p>

<div class="org-src-container">
<pre class="src src-python" id="orgfef7a62"><span style="color: #eedd82;">landfire_array_conversions</span> = {
    <span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">==============================================================================</span>
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Layer Name         : (New dtype, Mult), # New Units                [Min-Max]</span>
    <span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">==============================================================================</span>
    <span style="color: #ffa07a;">"elevation"</span>          : (<span style="color: #ffa07a;">"float32"</span>, 1.00), <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">meters above sea level   [0-8850]</span>
    <span style="color: #ffa07a;">"slope"</span>              : (<span style="color: #ffa07a;">"float32"</span>, 0.01), <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">meters rise / meters run [0-4]</span>
    <span style="color: #ffa07a;">"aspect"</span>             : (<span style="color: #ffa07a;">"int16"</span>  , 1   ), <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">degrees CW from North    [0-359]</span>
    <span style="color: #ffa07a;">"fuel_model"</span>         : (<span style="color: #ffa07a;">"int16"</span>  , 1   ), <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">integer classes          [1-204]</span>
    <span style="color: #ffa07a;">"canopy_cover"</span>       : (<span style="color: #ffa07a;">"float32"</span>, 0.01), <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">canopy area / total area [0-0.95]</span>
    <span style="color: #ffa07a;">"canopy_height"</span>      : (<span style="color: #ffa07a;">"float32"</span>, 0.10), <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">meters                   [0-51]</span>
    <span style="color: #ffa07a;">"canopy_base_height"</span> : (<span style="color: #ffa07a;">"float32"</span>, 0.10), <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">meters                   [0-10]</span>
    <span style="color: #ffa07a;">"canopy_bulk_density"</span>: (<span style="color: #ffa07a;">"float32"</span>, 0.01), <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">kilograms/meters^3       [0-0.45]</span>
}


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">load_and_convert_landfire_rasters</span>(landfire_file_paths):
    <span style="color: #eedd82;">landfire_rasters</span> = {}

    <span style="color: #00ffff;">for</span> name, path <span style="color: #00ffff;">in</span> landfire_file_paths.items():
        (<span style="color: #eedd82;">dtype</span>, <span style="color: #eedd82;">multiplier</span>) = landfire_array_conversions[name]
        <span style="color: #eedd82;">landfire_rasters</span>[name] = load_raster(path, dtype)
        <span style="color: #00ffff;">if</span> multiplier != 1:
            <span style="color: #eedd82;">array</span>  = landfire_rasters[name][<span style="color: #ffa07a;">"array"</span>]
            <span style="color: #eedd82;">nodata</span> = landfire_rasters[name][<span style="color: #ffa07a;">"metadata"</span>][<span style="color: #ffa07a;">"nodata"</span>]
            <span style="color: #eedd82;">array</span>[array != nodata] *= multiplier

    <span style="color: #00ffff;">return</span> landfire_rasters
</pre>
</div>
</div>
</div>

<div id="outline-container-org75eeefb" class="outline-3">
<h3 id="org75eeefb"><span class="section-number-3">7.3.</span> Verifying Raster Constraints</h3>
<div class="outline-text-3" id="text-7-3">
<p>
In order to work with the Pyretechnics Fire Spread API, all rasters
must meet certain requirements:
</p>

<p>
<b>TODO: Extend this to support multi-resolution rasters.</b>
</p>

<ol class="org-ol">
<li>All rasters must share the same array shape <code>(bands, rows, cols)</code>.</li>
<li>All rasters must share the same spatial extent and projection.</li>
</ol>

<p>
Below we implement functions to check these constraints:
</p>

<div class="org-src-container">
<pre class="src src-python" id="org131a6af"><span style="color: #00ffff;">def</span> <span style="color: #87cefa;">verify_same_dimensions</span>(rasters):
    <span style="color: #eedd82;">dimensions</span> = [
        (r[<span style="color: #ffa07a;">"metadata"</span>][<span style="color: #ffa07a;">"bands"</span>],
         r[<span style="color: #ffa07a;">"metadata"</span>][<span style="color: #ffa07a;">"rows"</span>],
         r[<span style="color: #ffa07a;">"metadata"</span>][<span style="color: #ffa07a;">"cols"</span>])
        <span style="color: #00ffff;">for</span> r <span style="color: #00ffff;">in</span> rasters
    ]
    <span style="color: #00ffff;">if</span> <span style="color: #b0c4de;">len</span>(<span style="color: #b0c4de;">set</span>(dimensions)) == 1:
        <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">True</span>
    <span style="color: #00ffff;">else</span>:
        <span style="color: #00ffff;">raise</span> <span style="color: #98fb98;">ValueError</span>(<span style="color: #ffa07a;">"All rasters do not share the same dimensions."</span>)


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">verify_same_georeferences</span>(rasters):
    <span style="color: #eedd82;">georeferences</span> = [
        (r[<span style="color: #ffa07a;">"metadata"</span>][<span style="color: #ffa07a;">"crs"</span>],
         r[<span style="color: #ffa07a;">"metadata"</span>][<span style="color: #ffa07a;">"bounds"</span>],
         r[<span style="color: #ffa07a;">"metadata"</span>][<span style="color: #ffa07a;">"transform"</span>])
        <span style="color: #00ffff;">for</span> r <span style="color: #00ffff;">in</span> rasters
    ]
    <span style="color: #00ffff;">if</span> <span style="color: #b0c4de;">len</span>(<span style="color: #b0c4de;">set</span>(georeferences)) == 1:
        <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">True</span>
    <span style="color: #00ffff;">else</span>:
        <span style="color: #00ffff;">raise</span> <span style="color: #98fb98;">ValueError</span>(<span style="color: #ffa07a;">"All rasters do not share the same georeferences."</span>)


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">verify_raster_constraints</span>(rasters):
    <span style="color: #00ffff;">return</span> verify_same_dimensions(rasters) <span style="color: #00ffff;">and</span> verify_same_georeferences(rasters)
</pre>
</div>
</div>
</div>

<div id="outline-container-org35d4cde" class="outline-3">
<h3 id="org35d4cde"><span class="section-number-3">7.4.</span> Converting Rasters to 3D Lookup Functions</h3>
<div class="outline-text-3" id="text-7-4">
<p>
Another requirement of the Pyretechnics Fire Spread API is that each
input layer must be specified as a 3D space-time lookup function. This
abstracts away the underlying data representation (e.g. an ND array, a
single constant value, a random sampling function), allowing many
different sources of information to interoperate through a simple
unified interface.
</p>

<p>
For our LANDFIRE use case, the following function converts a
dictionary of single-band rasters <code>(1, rows, cols)</code> into a dictionary
of 3D anonymous functions, that always return the same value for each
<code>(t,y,x)</code> coordinate regardless of the time value <code>t</code> specified.
</p>

<div class="org-src-container">
<pre class="src src-python" id="orgc144e8e"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">TODO: This does not use the lazy chunking, multi-resolution functions defined earlier.</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">convert_rasters_to_2d_fns</span>(raster_dict):
    <span style="color: #eedd82;">fn_dict</span> = {}

    <span style="color: #00ffff;">for</span> name, raster <span style="color: #00ffff;">in</span> raster_dict.items():
        <span style="color: #eedd82;">fn_dict</span>[name] = (<span style="color: #00ffff;">lambda</span> array: <span style="color: #00ffff;">lambda</span> t,y,x: array[0,y,x])(raster[<span style="color: #ffa07a;">"array"</span>])

    <span style="color: #00ffff;">return</span> fn_dict
</pre>
</div>
</div>
</div>

<div id="outline-container-org3f1c4b1" class="outline-3">
<h3 id="org3f1c4b1"><span class="section-number-3">7.5.</span> Putting It All Together</h3>
<div class="outline-text-3" id="text-7-5">
<p>
By combining the functions defined in the previous sections, we can
now read in a dictionary of layer names to file paths, load the
associated rasters and apply the correct dtype and unit conversions,
verify all of our raster constraints, and wrap each raster's array
with a 3D lookup function.
</p>

<div class="org-src-container">
<pre class="src src-python" id="org734a44b"><span style="color: #00ffff;">def</span> <span style="color: #87cefa;">read_landfire_rasters_as_pyretechnics_inputs</span>(landfire_file_paths):
    <span style="color: #eedd82;">landfire_rasters</span> = load_and_convert_landfire_rasters(landfire_file_paths)
    <span style="color: #00ffff;">if</span> verify_raster_constraints(landfire_rasters.values()):
        <span style="color: #00ffff;">return</span> convert_rasters_to_2d_fns(landfire_rasters)
</pre>
</div>

<p>
We will use this function to load a clipped set of LANDFIRE GeoTIFFs
in section <a href="#orgb08adfd">8</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb08adfd" class="outline-2">
<h2 id="orgb08adfd"><span class="section-number-2">8.</span> Testing burn_cells on Worcester, VT</h2>
<div class="outline-text-2" id="text-8">
<p>
For testing purposes, we have downloaded these layers, clipped to a
small region in central Vermont, and stored them in the
<a href="../test/data/landfire_inputs">../test/data/landfire_inputs</a> directory of this repository.
</p>
</div>

<div id="outline-container-org95c374b" class="outline-3">
<h3 id="org95c374b"><span class="section-number-3">8.1.</span> Loading Topography, Fuel Model, and Vegetation Inputs from LANDFIRE GeoTIFFs</h3>
<div class="outline-text-3" id="text-8-1">
<p>
We begin by loading in the eight LANDFIRE GeoTIFFs that we downloaded
from <a href="https://landfire.gov">https://landfire.gov</a>, using the function we defined in section
<a href="#org3f1c4b1">7.5</a>.
</p>

<div class="org-src-container">
<pre class="src src-python" id="orgf96577f"><span style="color: #00ffff;">import</span> os
<span style="color: #00ffff;">from</span> pyretechnics.load_landfire <span style="color: #00ffff;">import</span> read_landfire_rasters_as_pyretechnics_inputs

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">get_project_root</span>(current_dir=os.curdir):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Search up the directory tree from current_dir until we find a directory containing guix.scm,</span>
<span style="color: #ffa07a;">    and return this directory path. If the filesystem root directory (/) is reached, return None.</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #00ffff;">if</span> current_dir == <span style="color: #ffa07a;">"/"</span>:
        <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">None</span>
    <span style="color: #00ffff;">elif</span> os.path.exists(current_dir + <span style="color: #ffa07a;">"/guix.scm"</span>):
        <span style="color: #00ffff;">return</span> current_dir
    <span style="color: #00ffff;">else</span>:
        <span style="color: #00ffff;">return</span> get_project_root(os.path.dirname(os.path.abspath(current_dir)))


<span style="color: #eedd82;">project_root</span> = get_project_root()


<span style="color: #eedd82;">landfire_file_paths</span> = {
    <span style="color: #ffa07a;">"elevation"</span>          : project_root + <span style="color: #ffa07a;">"/test/data/landfire_inputs/LF2020_Elev_220_CONUS/LC20_Elev_220.tif"</span>,
    <span style="color: #ffa07a;">"slope"</span>              : project_root + <span style="color: #ffa07a;">"/test/data/landfire_inputs/LF2020_SlpP_220_CONUS/LC20_SlpP_220.tif"</span>,
    <span style="color: #ffa07a;">"aspect"</span>             : project_root + <span style="color: #ffa07a;">"/test/data/landfire_inputs/LF2020_Asp_220_CONUS/LC20_Asp_220.tif"</span>,
    <span style="color: #ffa07a;">"fuel_model"</span>         : project_root + <span style="color: #ffa07a;">"/test/data/landfire_inputs/LF2022_FBFM40_230_CONUS/LC22_F40_230.tif"</span>,
    <span style="color: #ffa07a;">"canopy_cover"</span>       : project_root + <span style="color: #ffa07a;">"/test/data/landfire_inputs/LF2022_CC_230_CONUS/LC22_CC_230.tif"</span>,
    <span style="color: #ffa07a;">"canopy_height"</span>      : project_root + <span style="color: #ffa07a;">"/test/data/landfire_inputs/LF2022_CH_230_CONUS/LC22_CH_230.tif"</span>,
    <span style="color: #ffa07a;">"canopy_base_height"</span> : project_root + <span style="color: #ffa07a;">"/test/data/landfire_inputs/LF2022_CBH_230_CONUS/LC22_CBH_230.tif"</span>,
    <span style="color: #ffa07a;">"canopy_bulk_density"</span>: project_root + <span style="color: #ffa07a;">"/test/data/landfire_inputs/LF2022_CBD_230_CONUS/LC22_CBD_230.tif"</span>,
}


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">test_read_landfire_rasters</span>():
    <span style="color: #eedd82;">input_layer_dict</span> = read_landfire_rasters_as_pyretechnics_inputs(landfire_file_paths)
    <span style="color: #00ffff;">assert</span> <span style="color: #b0c4de;">type</span>(input_layer_dict) == <span style="color: #b0c4de;">dict</span>
    <span style="color: #00ffff;">assert</span> input_layer_dict.keys() == landfire_file_paths.keys()
    <span style="color: #00ffff;">assert</span> <span style="color: #b0c4de;">all</span>(<span style="color: #b0c4de;">map</span>(<span style="color: #00ffff;">lambda</span> v: <span style="color: #b0c4de;">callable</span>(v), input_layer_dict.values()))
    <span style="color: #00ffff;">return</span> input_layer_dict
</pre>
</div>
</div>
</div>

<div id="outline-container-org09f9a48" class="outline-3">
<h3 id="org09f9a48"><span class="section-number-3">8.2.</span> Adding Constant Wind and Moisture Values</h3>
<div class="outline-text-3" id="text-8-2">
<p>
In order to complete our input dataset for a test run of the
<code>burn_cells</code> function, we need to provide the remaining required wind
and moisture layers as 3D lookup functions. The following example
shows how we can easily set constant values for each of these layers:
</p>

<div class="org-src-container">
<pre class="src src-python" id="org97b68a3"><span style="color: #eedd82;">weather_functions</span> = {
    <span style="color: #ffa07a;">"wind_speed_10m_x"</span>             : <span style="color: #00ffff;">lambda</span> t,y,x: 0.00, <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">meters/minute</span>
    <span style="color: #ffa07a;">"wind_speed_10m_y"</span>             : <span style="color: #00ffff;">lambda</span> t,y,x: 0.00, <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">meters/minute</span>
    <span style="color: #ffa07a;">"fuel_moisture_dead_1hr"</span>       : <span style="color: #00ffff;">lambda</span> t,y,x: 0.06, <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">ratio [0-1+] grams moisture/grams ovendry wood</span>
    <span style="color: #ffa07a;">"fuel_moisture_dead_10hr"</span>      : <span style="color: #00ffff;">lambda</span> t,y,x: 0.08, <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">ratio [0-1+] grams moisture/grams ovendry wood</span>
    <span style="color: #ffa07a;">"fuel_moisture_dead_100hr"</span>     : <span style="color: #00ffff;">lambda</span> t,y,x: 0.10, <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">ratio [0-1+] grams moisture/grams ovendry wood</span>
    <span style="color: #ffa07a;">"fuel_moisture_live_herbaceous"</span>: <span style="color: #00ffff;">lambda</span> t,y,x: 0.75, <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">ratio [0-1+] grams moisture/grams ovendry wood</span>
    <span style="color: #ffa07a;">"fuel_moisture_live_woody"</span>     : <span style="color: #00ffff;">lambda</span> t,y,x: 0.60, <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">ratio [0-1+] grams moisture/grams ovendry wood</span>
    <span style="color: #ffa07a;">"foliar_moisture"</span>              : <span style="color: #00ffff;">lambda</span> t,y,x: 1.20, <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">ratio [0-1+] grams moisture/grams ovendry foliage</span>
}


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">test_add_weather_functions</span>():
    <span style="color: #eedd82;">input_layer_dict</span> = test_read_landfire_rasters()
    input_layer_dict.update(weather_functions)
    <span style="color: #00ffff;">assert</span> <span style="color: #b0c4de;">type</span>(input_layer_dict) == <span style="color: #b0c4de;">dict</span>
    <span style="color: #00ffff;">assert</span> <span style="color: #b0c4de;">set</span>(input_layer_dict.keys()) == <span style="color: #b0c4de;">set</span>(landfire_file_paths.keys()).union(<span style="color: #b0c4de;">set</span>(weather_functions.keys()))
    <span style="color: #00ffff;">assert</span> <span style="color: #b0c4de;">all</span>(<span style="color: #b0c4de;">map</span>(<span style="color: #00ffff;">lambda</span> v: <span style="color: #b0c4de;">callable</span>(v), input_layer_dict.values()))
    <span style="color: #00ffff;">return</span> input_layer_dict
</pre>
</div>
</div>
</div>

<div id="outline-container-org8efba36" class="outline-3">
<h3 id="org8efba36"><span class="section-number-3">8.3.</span> Burning a Single Cell in the Dataset</h3>
<div class="outline-text-3" id="text-8-3">
<p>
Now that our input layers are all loaded, our next step will be to
make sure that we can burn a single cell as a head fire and get back
meaningful results.
</p>

<div class="org-src-container">
<pre class="src src-python" id="org22934d9"><span style="color: #00ffff;">from</span> pyretechnics.burn_cells <span style="color: #00ffff;">import</span> compute_max_in_situ_values

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">test_burn_one_cell</span>():
    <span style="color: #eedd82;">input_layer_dict</span> = test_add_weather_functions()
    (<span style="color: #eedd82;">t</span>,<span style="color: #eedd82;">y</span>,<span style="color: #eedd82;">x</span>) = (0,100,100)
    <span style="color: #eedd82;">result</span> = compute_max_in_situ_values(input_layer_dict, t, y, x)
    <span style="color: #00ffff;">assert</span> result == {
        <span style="color: #ffa07a;">"max_spread_rate"</span>        : 0.32044995422500566,
        <span style="color: #ffa07a;">"max_spread_direction"</span>   : 41.0,
        <span style="color: #ffa07a;">"max_fire_line_intensity"</span>: 26.661398424207746,
        <span style="color: #ffa07a;">"max_flame_length"</span>       : 0.35078585296988984,
        <span style="color: #ffa07a;">"fire_type"</span>              : 1,
        <span style="color: #ffa07a;">"eccentricity"</span>           : 0.5583790663230914,
    }
    <span style="color: #00ffff;">return</span> result
</pre>
</div>
</div>
</div>

<div id="outline-container-org3c6d089" class="outline-3">
<h3 id="org3c6d089"><span class="section-number-3">8.4.</span> Running Burn Cells on the Test Dataset</h3>
<div class="outline-text-3" id="text-8-4">
<div class="org-src-container">
<pre class="src src-python" id="orgb0fc3d2"><span style="color: #00ffff;">import</span> numpy <span style="color: #00ffff;">as</span> np

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">slow_test_burn_all_cells</span>():
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">TODO: Extract these dimensions from the input layers</span>
    <span style="color: #eedd82;">rows</span> = 613
    <span style="color: #eedd82;">cols</span> = 549

    <span style="color: #eedd82;">max_spread_rate_matrix</span>         = np.zeros((rows, cols), dtype=<span style="color: #ffa07a;">"float32"</span>)
    <span style="color: #eedd82;">max_spread_direction_matrix</span>    = np.zeros((rows, cols), dtype=<span style="color: #ffa07a;">"int16"</span>)
    <span style="color: #eedd82;">max_fire_line_intensity_matrix</span> = np.zeros((rows, cols), dtype=<span style="color: #ffa07a;">"float32"</span>)
    <span style="color: #eedd82;">max_flame_length_matrix</span>        = np.zeros((rows, cols), dtype=<span style="color: #ffa07a;">"float32"</span>)
    <span style="color: #eedd82;">fire_type_matrix</span>               = np.zeros((rows, cols), dtype=<span style="color: #ffa07a;">"uint8"</span>)
    <span style="color: #eedd82;">eccentricity_matrix</span>            = np.zeros((rows, cols), dtype=<span style="color: #ffa07a;">"float32"</span>)

    <span style="color: #eedd82;">input_layer_dict</span> = test_add_weather_functions()

    <span style="color: #00ffff;">for</span> y <span style="color: #00ffff;">in</span> <span style="color: #b0c4de;">range</span>(rows):
        <span style="color: #00ffff;">for</span> x <span style="color: #00ffff;">in</span> <span style="color: #b0c4de;">range</span>(cols):
            <span style="color: #eedd82;">results</span>                             = compute_max_in_situ_values(input_layer_dict, 0, y, x)
            <span style="color: #eedd82;">max_spread_rate_matrix</span>[<span style="color: #eedd82;">y</span>,<span style="color: #eedd82;">x</span>]         = results[<span style="color: #ffa07a;">"max_spread_rate"</span>]
            <span style="color: #eedd82;">max_spread_direction_matrix</span>[<span style="color: #eedd82;">y</span>,<span style="color: #eedd82;">x</span>]    = results[<span style="color: #ffa07a;">"max_spread_direction"</span>]
            <span style="color: #eedd82;">max_fire_line_intensity_matrix</span>[<span style="color: #eedd82;">y</span>,<span style="color: #eedd82;">x</span>] = results[<span style="color: #ffa07a;">"max_fire_line_intensity"</span>]
            <span style="color: #eedd82;">max_flame_length_matrix</span>[<span style="color: #eedd82;">y</span>,<span style="color: #eedd82;">x</span>]        = results[<span style="color: #ffa07a;">"max_flame_length"</span>]
            <span style="color: #eedd82;">fire_type_matrix</span>[<span style="color: #eedd82;">y</span>,<span style="color: #eedd82;">x</span>]               = results[<span style="color: #ffa07a;">"fire_type"</span>]
            <span style="color: #eedd82;">eccentricity_matrix</span>[<span style="color: #eedd82;">y</span>,<span style="color: #eedd82;">x</span>]            = results[<span style="color: #ffa07a;">"eccentricity"</span>]

    <span style="color: #00ffff;">return</span> {
        <span style="color: #ffa07a;">"max_spread_rate"</span>        : max_spread_rate_matrix,
        <span style="color: #ffa07a;">"max_spread_direction"</span>   : max_spread_direction_matrix,
        <span style="color: #ffa07a;">"max_fire_line_intensity"</span>: max_fire_line_intensity_matrix,
        <span style="color: #ffa07a;">"max_flame_length"</span>       : max_flame_length_matrix,
        <span style="color: #ffa07a;">"fire_type"</span>              : fire_type_matrix,
        <span style="color: #ffa07a;">"eccentricity"</span>           : eccentricity_matrix,
    }
</pre>
</div>
</div>
</div>

<div id="outline-container-org5ece7b6" class="outline-3">
<h3 id="org5ece7b6"><span class="section-number-3">8.5.</span> Visualizing the Burned Layers</h3>
<div class="outline-text-3" id="text-8-5">
<div class="org-src-container">
<pre class="src src-python" id="org47a6495"><span style="color: #00ffff;">from</span> pyretechnics_test.test_burn_cells <span style="color: #00ffff;">import</span> slow_test_burn_all_cells, slow_test_read_flammap_outputs

<span style="color: #eedd82;">pyretechnics</span> = slow_test_burn_all_cells()
<span style="color: #eedd82;">flammap</span>      = slow_test_read_flammap_outputs()
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python" id="org3491413"><span style="color: #00ffff;">import</span> matplotlib.pyplot <span style="color: #00ffff;">as</span> plt

<span style="color: #eedd82;">title</span>     = <span style="color: #ffa07a;">"Worcester, VT - "</span> + title
<span style="color: #eedd82;">file_name</span> = <span style="color: #ffa07a;">"../doc/pics/worcester_"</span> + layer + <span style="color: #ffa07a;">".png"</span>
<span style="color: #eedd82;">image</span>     = plt.imshow(pyretechnics[layer], cmap=colors)
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">image     = plt.imshow(flammap[layer][0], cmap=colors)</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">image     = plt.imshow(pyretechnics[layer] - flammap[layer][0], cmap=colors)</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">copy      = np.zeros((613, 549))</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">copy[crown_fire == 0] = (pyretechnics[layer][crown_fire == 0] - flammap[layer][0][crown_fire == 0])</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">image     = plt.imshow(copy, clim=(-0.05,0.05))</span>
<span style="color: #eedd82;">colorbar</span>  = plt.colorbar(image, orientation=<span style="color: #ffa07a;">"vertical"</span>)

colorbar.set_label(units)
plt.title(title)
plt.savefig(file_name)
plt.close(<span style="color: #ffa07a;">"all"</span>)
file_name
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #eedd82;">frq</span>, <span style="color: #eedd82;">edges</span> = np.histogram(copy)
<span style="color: #eedd82;">fig</span>, <span style="color: #eedd82;">ax</span> = plt.subplots()
ax.bar(edges[:-1], frq, width=np.diff(edges), edgecolor=<span style="color: #ffa07a;">"black"</span>, align=<span style="color: #ffa07a;">"edge"</span>)
plt.savefig(<span style="color: #ffa07a;">"../doc/pics/worcester_max_spread_rate_diff.png"</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">&lt;&lt;savefig(title=<span style="color: #ffa07a;">"Max Spread Rate"</span>, layer=<span style="color: #ffa07a;">"max_spread_rate"</span>, units=<span style="color: #ffa07a;">"m/min"</span>, colors=<span style="color: #ffa07a;">"hot"</span>)&gt;&gt;
</pre>
</div>


<div id="org7ce0508" class="figure">
<p><img src="../doc/pics/worcester_max_spread_rate.png" alt="worcester_max_spread_rate.png">
</p>
</div>

<p>
Layer Disagreement: [-10.93608, 8.9857025] inches/min
</p>

<div class="org-src-container">
<pre class="src src-python">&lt;&lt;savefig(title=<span style="color: #ffa07a;">"Max Spread Direction"</span>, layer=<span style="color: #ffa07a;">"max_spread_direction"</span>, units=<span style="color: #ffa07a;">"degrees"</span>, colors=<span style="color: #ffa07a;">"viridis"</span>)&gt;&gt;
</pre>
</div>


<div id="org3ed0660" class="figure">
<p><img src="../doc/pics/worcester_max_spread_direction.png" alt="worcester_max_spread_direction.png">
</p>
</div>

<div class="org-src-container">
<pre class="src src-python">&lt;&lt;savefig(title=<span style="color: #ffa07a;">"Max Fire Line Intensity"</span>, layer=<span style="color: #ffa07a;">"max_fire_line_intensity"</span>, units=<span style="color: #ffa07a;">"kW/m"</span>, colors=<span style="color: #ffa07a;">"hot"</span>)&gt;&gt;
</pre>
</div>


<div id="org9476e25" class="figure">
<p><img src="../doc/pics/worcester_max_fire_line_intensity.png" alt="worcester_max_fire_line_intensity.png">
</p>
</div>

<div class="org-src-container">
<pre class="src src-python">&lt;&lt;savefig(title=<span style="color: #ffa07a;">"Max Flame Length"</span>, layer=<span style="color: #ffa07a;">"max_flame_length"</span>, units=<span style="color: #ffa07a;">"m"</span>, colors=<span style="color: #ffa07a;">"hot"</span>)&gt;&gt;
</pre>
</div>


<div id="orgec6f4d4" class="figure">
<p><img src="../doc/pics/worcester_max_flame_length.png" alt="worcester_max_flame_length.png">
</p>
</div>

<div class="org-src-container">
<pre class="src src-python">&lt;&lt;savefig(title=<span style="color: #ffa07a;">"Fire Type"</span>, layer=<span style="color: #ffa07a;">"fire_type"</span>, units=<span style="color: #ffa07a;">"1=surface,2=passive crown,3=active crown"</span>, colors=<span style="color: #ffa07a;">"viridis"</span>)&gt;&gt;
</pre>
</div>


<div id="orgcc47ae9" class="figure">
<p><img src="../doc/pics/worcester_fire_type.png" alt="worcester_fire_type.png">
</p>
</div>

<div class="org-src-container">
<pre class="src src-python">&lt;&lt;savefig(title=<span style="color: #ffa07a;">"Eccentricity"</span>, layer=<span style="color: #ffa07a;">"eccentricity"</span>, units=<span style="color: #ffa07a;">"0=circular,&gt;0=elliptical"</span>, colors=<span style="color: #ffa07a;">"viridis"</span>)&gt;&gt;
</pre>
</div>


<div id="org3488431" class="figure">
<p><img src="../doc/pics/worcester_eccentricity.png" alt="worcester_eccentricity.png">
</p>
</div>
</div>
</div>

<div id="outline-container-org29db06b" class="outline-3">
<h3 id="org29db06b"><span class="section-number-3">8.6.</span> Comparing Pyretechnics Outputs with FLAMMAP Outputs</h3>
<div class="outline-text-3" id="text-8-6">
<div class="org-src-container">
<pre class="src src-python" id="org537149c"><span style="color: #00ffff;">import</span> numpy <span style="color: #00ffff;">as</span> np
<span style="color: #00ffff;">from</span> pyretechnics.load_landfire <span style="color: #00ffff;">import</span> load_raster, verify_raster_constraints

<span style="color: #eedd82;">flammap_file_paths</span> = {
    <span style="color: #ffa07a;">"max_spread_rate"</span>        : project_root + <span style="color: #ffa07a;">"/test/data/flammap_outputs/ROS_ch_hr.tif"</span>,
    <span style="color: #ffa07a;">"max_spread_direction"</span>   : project_root + <span style="color: #ffa07a;">"/test/data/flammap_outputs/max_spread_direction_radians.tif"</span>,
    <span style="color: #ffa07a;">"max_fire_line_intensity"</span>: project_root + <span style="color: #ffa07a;">"/test/data/flammap_outputs/FLI_BTU_ft-s.tif"</span>,
    <span style="color: #ffa07a;">"max_flame_length"</span>       : project_root + <span style="color: #ffa07a;">"/test/data/flammap_outputs/FL_ft.tif"</span>,
    <span style="color: #ffa07a;">"fire_type"</span>              : project_root + <span style="color: #ffa07a;">"/test/data/flammap_outputs/fire_type.tif"</span>,
}


<span style="color: #eedd82;">flammap_array_conversions</span> = {
    <span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">====================================================================================</span>
    <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Layer Name             : (New dtype, Mult),                # In Units -&gt; Out Units</span>
    <span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">====================================================================================</span>
    <span style="color: #ffa07a;">"max_spread_rate"</span>        : (<span style="color: #ffa07a;">"float32"</span>, 0.33528),             <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">ch/hr -&gt; m/min</span>
    <span style="color: #ffa07a;">"max_spread_direction"</span>   : (<span style="color: #ffa07a;">"int16"</span>  , 1),                   <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">rad -&gt; rad</span>
    <span style="color: #ffa07a;">"max_fire_line_intensity"</span>: (<span style="color: #ffa07a;">"float32"</span>, 3.46165186),          <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Btu/ft/s -&gt; kW/m</span>
    <span style="color: #ffa07a;">"max_flame_length"</span>       : (<span style="color: #ffa07a;">"float32"</span>, 0.30478512648582745), <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">ft -&gt; m</span>
    <span style="color: #ffa07a;">"fire_type"</span>              : (<span style="color: #ffa07a;">"uint8"</span>  , 1.0),                 <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">0=unburned,1=surface,2=passive crown,3=active crown</span>
}


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">load_and_convert_flammap_rasters</span>(flammap_file_paths):
    <span style="color: #eedd82;">flammap_rasters</span> = {}

    <span style="color: #00ffff;">for</span> name, path <span style="color: #00ffff;">in</span> flammap_file_paths.items():
        (<span style="color: #eedd82;">dtype</span>, <span style="color: #eedd82;">multiplier</span>)   = flammap_array_conversions[name]
        <span style="color: #eedd82;">flammap_rasters</span>[name] = load_raster(path, dtype)
        <span style="color: #eedd82;">array</span>                 = flammap_rasters[name][<span style="color: #ffa07a;">"array"</span>]
        <span style="color: #eedd82;">nodata</span>                = flammap_rasters[name][<span style="color: #ffa07a;">"metadata"</span>][<span style="color: #ffa07a;">"nodata"</span>]
        <span style="color: #eedd82;">array</span>[array == nodata] = 0
        <span style="color: #00ffff;">if</span> multiplier != 1:
            <span style="color: #eedd82;">array</span>[array != nodata] *= multiplier

    <span style="color: #00ffff;">return</span> flammap_rasters


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">read_flammap_outputs</span>(flammap_file_paths):
    <span style="color: #eedd82;">raster_dict</span> = load_and_convert_flammap_rasters(flammap_file_paths)
    <span style="color: #00ffff;">if</span> verify_raster_constraints(raster_dict.values()):
        <span style="color: #eedd82;">array_dict</span> = {name: raster[<span style="color: #ffa07a;">"array"</span>] <span style="color: #00ffff;">for</span> name, raster <span style="color: #00ffff;">in</span> raster_dict.items()}
        <span style="color: #eedd82;">array_dict</span>[<span style="color: #ffa07a;">"max_spread_direction"</span>] = np.rad2deg(array_dict[<span style="color: #ffa07a;">"max_spread_direction"</span>]) <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">rad -&gt; deg</span>
        <span style="color: #00ffff;">return</span> array_dict


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">slow_test_read_flammap_outputs</span>():
    <span style="color: #00ffff;">return</span> read_flammap_outputs(flammap_file_paths)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org598edc7" class="outline-2">
<h2 id="org598edc7"><span class="section-number-2">9.</span> Fire Spread on a Raster Grid</h2>
<div class="outline-text-2" id="text-9">
<p>
In order to simulate the spread of a fire from a starting point or
perimeter, we will need to implement a model that projects the
one-dimensional spread and intensity equations presented above into
the three-dimensional space-time cube introduced in section <a href="#orgae234cc">2</a>.
</p>

<p>
As a library, Pyretechnics has the flexibility to implement more than
one such algorithm for the purposes of comparison in both performance
and accuracy. The following sections will introduce the spread
algorithms implemented thus far.
</p>
</div>

<div id="outline-container-orge878469" class="outline-4">
<h4 id="orge878469"><span class="section-number-4">9.0.1.</span> Eulerian Level Set Method</h4>
<div class="outline-text-4" id="text-9-0-1">
</div>
<ol class="org-ol">
<li><a id="orga232bb2"></a>The \(\phi\) Field<br>
<div class="outline-text-5" id="text-9-0-1-1">
<p>
In the Eulerian level set method of fire spread, operationalized in
Chris Lautenberger's ELMFire model<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup>, a
continuous field called \(\phi\) fills the simulation space and is used
to track the progression of the fire front through space and time.
Within Pyretechnics, the \(\phi\) field is discretized into grid cells
and initialized with the following values:
</p>

<ul class="org-ul">
<li>-1 for cells that have already been burned and are inside the fire perimeter</li>
<li>1 for cells that have not been burned and are outside the fire perimeter</li>
</ul>

<p>
If a fire is being simulated starting from an actively burning
perimeter, the \(\phi\) grid cells indicate the initially burning region.
If a point fire is being simulated, then a single \(\phi\) cell will be
set to -1 and the remaining cells will have the value 1.
</p>
</div>
</li>

<li><a id="orgb3abc99"></a>Fire Front Normal Vector<br>
<div class="outline-text-5" id="text-9-0-1-2">
<p>
In this fire spread algorithm, the fire front only propagates normal
to itself. Given a \(\phi\) raster, we can calculate the normal vector to
the \(\phi\) field by using the following formula:
</p>

\begin{align}
  \hat{n} &= n_x\hat{i} + n_y\hat{j} = \frac{1}{|\nabla\phi|}\left(\frac{\partial{\phi}}{\partial x}\hat{i} + \frac{\partial{\phi}}{\partial y}\hat{j}\right) \\
  |\nabla\phi| &= \sqrt{\left(\frac{\partial{\phi}}{\partial x}\right)^2 + \left(\frac{\partial{\phi}}{\partial y}\right)^2}
\end{align}

<p>
We begin by approximating the spatial gradients of the \(\phi\) field with
node-centered central differences, represented by the values in the
\(\phi\) raster's grid cells.
</p>

\begin{align}
  \left(\frac{\partial{\phi}}{\partial x}\right)_{i,j} &\approx \frac{\phi_{i+1,j} - \phi_{i-1,j}}{2 \Delta x} \\
  \left(\frac{\partial{\phi}}{\partial y}\right)_{i,j} &\approx \frac{\phi_{i,j+1} - \phi_{i,j-1}}{2 \Delta y}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="org9099669"><span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_dphi_dx_approx</span>(phi, x, y, dx):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Calculate the spatial gradient of the phi raster in the x (west-&gt;east)</span>
<span style="color: #ffa07a;">    direction at grid cell (x,y) given the cell width dx.</span>

<span style="color: #ffa07a;">    NOTE: The origin cell (x=0,y=0) is located in the upper left corner</span>
<span style="color: #ffa07a;">          of the grid in Python arrays. Thus, as x increases, we move</span>
<span style="color: #ffa07a;">          to the east, and as y increases, we move to the south.</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #00ffff;">return</span> (phi[y][x+1] - phi[y][x-1]) / (2.0 * dx)


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_dphi_dy_approx</span>(phi, x, y, dy):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Calculate the spatial gradient of the phi raster in the y (south-&gt;north)</span>
<span style="color: #ffa07a;">    direction at grid cell (x,y) given the cell height dy.</span>

<span style="color: #ffa07a;">    NOTE: The origin cell (x=0,y=0) is located in the upper left corner</span>
<span style="color: #ffa07a;">          of the grid in Python arrays. Thus, as x increases, we move</span>
<span style="color: #ffa07a;">          to the east, and as y increases, we move to the south.</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #00ffff;">return</span> (phi[y-1][x] - phi[y+1][x]) / (2.0 * dy)
</pre>
</div>

<p>
We can now combine these spatial gradients with the magnitude of the
gradient of the \(\phi\) field at any location on the grid to compute
the fire front normal vector as follows:
</p>

<div class="org-src-container">
<pre class="src src-python" id="orgb8e8e6b"><span style="color: #00ffff;">from</span> math <span style="color: #00ffff;">import</span> sqrt

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_phi_gradient_magnitude</span>(dphi_dx, dphi_dy):
    <span style="color: #ffa07a;">"""Calculate the magnitude of the gradient of the phi field."""</span>
    <span style="color: #00ffff;">return</span> sqrt(dphi_dx ** 2 + dphi_dy ** 2)


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_phi_normal_vector</span>(phi, dx, dy, x, y):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Calculate the phi field normal vector in the x and y dimensions.</span>

<span style="color: #ffa07a;">    n_x: eastward component of the unit normal vector</span>
<span style="color: #ffa07a;">    n_y: northward component of the unit normal vector</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #eedd82;">dphi_dx</span> = calc_dphi_dx_approx(phi, x, y, dx)
    <span style="color: #eedd82;">dphi_dy</span> = calc_dphi_dy_approx(phi, x, y, dy)
    <span style="color: #00ffff;">if</span> dphi_dx == 0.0 <span style="color: #00ffff;">and</span> dphi_dy == 0.0:
        <span style="color: #00ffff;">return</span> {
            <span style="color: #ffa07a;">"n_x"</span>: 0.0,
            <span style="color: #ffa07a;">"n_y"</span>: 0.0,
        }
    <span style="color: #00ffff;">else</span>:
        <span style="color: #eedd82;">phi_gradient_magnitude</span> = calc_phi_gradient_magnitude(dphi_dx, dphi_dy)
        <span style="color: #00ffff;">return</span> {
            <span style="color: #ffa07a;">"n_x"</span>: dphi_dx / phi_gradient_magnitude,
            <span style="color: #ffa07a;">"n_y"</span>: dphi_dy / phi_gradient_magnitude,
        }
</pre>
</div>

<p>
Next, we can use the following geometrical relations to calculate the
angle \(\theta_n\) (measured clockwise from North) to which the normal
vector points:
</p>

\begin{equation}
  \theta_n =
  \begin{cases}
    \frac{1}{2}\pi - \tan^{-1}(\frac{n_y}{n_x}) & \text{for}\ n_x > 0 & \text{and}\ n_y \geq 0 \\
    \frac{1}{2}\pi + \tan^{-1}(\frac{|n_y|}{n_x}) & \text{for}\ n_x > 0 & \text{and}\ n_y < 0 \\
    \frac{3}{2}\pi + \tan^{-1}(\frac{n_y}{|n_x|}) & \text{for}\ n_x < 0 & \text{and}\ n_y \geq 0 \\
    \frac{3}{2}\pi - \tan^{-1}(\frac{n_y}{n_x}) & \text{for}\ n_x < 0 & \text{and}\ n_y < 0 \\
    0 & \text{for}\ n_x = 0 & \text{and}\ n_y \geq 0 \\
    \pi & \text{for}\ n_x = 0 & \text{and}\ n_y < 0
  \end{cases}
\end{equation}

<div class="org-src-container">
<pre class="src src-python" id="org8ded138"><span style="color: #00ffff;">from</span> math <span style="color: #00ffff;">import</span> atan, pi

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_phi_normal_vector_angle</span>(phi_normal_vector):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    Calculate the angle (measured in radians clockwise from North)</span>
<span style="color: #ffa07a;">    to which the phi field's normal vector points.</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #eedd82;">n_x</span> = phi_normal_vector[<span style="color: #ffa07a;">"n_x"</span>]
    <span style="color: #eedd82;">n_y</span> = phi_normal_vector[<span style="color: #ffa07a;">"n_y"</span>]
    <span style="color: #00ffff;">if</span> n_x &gt; 0:
        <span style="color: #00ffff;">if</span> n_y &gt;= 0:
            <span style="color: #00ffff;">return</span> 1/2 * pi - atan(n_y / n_x)
        <span style="color: #00ffff;">elif</span> n_y &lt; 0:
            <span style="color: #00ffff;">return</span> 1/2 * pi + atan(<span style="color: #b0c4de;">abs</span>(n_y) / n_x)
    <span style="color: #00ffff;">elif</span> n_x &lt; 0:
        <span style="color: #00ffff;">if</span> n_y &gt;= 0:
            <span style="color: #00ffff;">return</span> 3/2 * pi + atan(n_y / <span style="color: #b0c4de;">abs</span>(n_x))
        <span style="color: #00ffff;">elif</span> n_y &lt; 0:
            <span style="color: #00ffff;">return</span> 3/2 * pi - atan(n_y / n_x)
    <span style="color: #00ffff;">else</span>:
        <span style="color: #00ffff;">if</span> n_y &gt;= 0:
            <span style="color: #00ffff;">return</span> 0.0
        <span style="color: #00ffff;">elif</span> n_y &lt; 0:
            <span style="color: #00ffff;">return</span> pi
</pre>
</div>

<p>
Now that we can compute the fire front normal vector, we can find the
spread rate in this direction by combining this vector with the
maximum spread rate vector and elliptical eccentricity values
calculated for each grid cell, using the approaches described in
sections <a href="#org256a745">5.2</a> and <a href="#orgc78373c">5.3</a>.
</p>

<p>
We will refer to the spread rate vector normal to the fire front in
the following sections as \(U\) with spatial components \(U_x\) and \(U_y\).
</p>
</div>
</li>

<li><a id="orgeddff80"></a>Numerical Solution of the \(\phi\) Field Equation<br>
<div class="outline-text-5" id="text-9-0-1-3">
<p>
In order to evolve the \(\phi\) field through time and space, we must
solve the following hyperbolic differential equation for the scalar
variable \(\phi\).
</p>

\begin{align}
  \frac{\partial{\phi}}{\partial t} + {U_x}\frac{\partial{\phi}}{\partial x} + {U_y}\frac{\partial{\phi}}{\partial y} = 0
\end{align}

<p>
This is accomplished after applying a flux limiter to the convective
terms, in order to ensure solution monotonicity and prevent spurious
oscillations that can be induced in its absence.
</p>

<p>
First, we define the parameter \(r\) and the Superbee flux limiter
\(B(r)\) as follows:
</p>

\begin{align}
  r &= \frac{\delta\phi_{\text{up}}}{\delta\phi_{\text{loc}}} \\
  B(r) &= \text{max}(0, \text{min}(2r, 1), \text{min}(r, 2))
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="orgb53ecfe"><span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_superbee_flux_limiter</span>(dphi_up, dphi_loc):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    TODO: Add docstring</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #eedd82;">r</span> = dphi_up / dphi_loc
    <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">max</span>(0,
               <span style="color: #b0c4de;">min</span>(2 * r, 1),
               <span style="color: #b0c4de;">min</span>(r, 2))
</pre>
</div>

<p>
To compute the inputs to this function, we build up the partial
derivatives of the \(\phi\) field in terms of "east", "west", "north",
and "south" values as follows:
</p>

\begin{align}
  \frac{\partial{\phi}}{\partial x} &\approx \frac{\phi_{\text{east}} - \phi_{\text{west}}}{\Delta x} \\
  \frac{\partial{\phi}}{\partial y} &\approx \frac{\phi_{\text{north}} - \phi_{\text{south}}}{\Delta y}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="org77fe2b4"><span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_dphi_dx</span>(phi_east, phi_west, dx):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    TODO: Add docstring</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #00ffff;">return</span> (phi_east - phi_west) / dx

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_dphi_dy</span>(phi_north, phi_south, dy):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    TODO: Add docstring</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #00ffff;">return</span> (phi_north - phi_south) / dy
</pre>
</div>

<p>
For the east face:
</p>

\begin{align}
  \delta\phi_{\text{loc}} &= \phi_{i+1,j} - \phi{i,j} \\
  \delta\phi_{\text{up}} &= \begin{cases}
                              \phi_{i,j} - \phi_{i-1,j} & \text{for}\ u_{x,i,j} > 0 \\
                              \phi_{i+2,j} - \phi_{i+1,j} & \text{for}\ u_{x,i,j} < 0
                            \end{cases} \\
  \phi_{\text{east}} &= \begin{cases}
                          \phi_{i,j} + \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{x,i,j} > 0 \\
                          \phi_{i+1,j} - \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{x,i,j} < 0
                        \end{cases}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="org3deccc8"><span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_phi_east</span>(phi, u_x, x, y):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    TODO: Add docstring</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #eedd82;">dphi_loc</span> = phi[y][x+1] - phi[y][x]
    <span style="color: #eedd82;">u_xij</span> = u_x[y][x]
    <span style="color: #00ffff;">if</span> u_xij &gt; 0:
        <span style="color: #eedd82;">dphi_up</span> = phi[y][x] - phi[y][x-1]
        <span style="color: #eedd82;">B</span> = calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span style="color: #00ffff;">return</span> phi[y][x] + 0.5 * B * dphi_loc
    <span style="color: #00ffff;">elif</span> u_xij &lt; 0:
        <span style="color: #eedd82;">dphi_up</span> = phi[y][x+2] - phi[y][x+1]
        <span style="color: #eedd82;">B</span> = calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span style="color: #00ffff;">return</span> phi[y][x+1] - 0.5 * B * dphi_loc
    <span style="color: #00ffff;">else</span>:
        <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">FIXME: What is the correct value for this case? Update the equation above accordingly.</span>
        <span style="color: #00ffff;">return</span> 0.0
</pre>
</div>

<p>
For the west face:
</p>

\begin{align}
  \delta\phi_{\text{loc}} &= \phi_{i-1,j} - \phi{i,j} \\
  \delta\phi_{\text{up}} &= \begin{cases}
                              \phi_{i-2,j} - \phi_{i-1,j} & \text{for}\ u_{x,i,j} > 0 \\
                              \phi_{i,j} - \phi_{i+1,j} & \text{for}\ u_{x,i,j} < 0
                            \end{cases} \\
  \phi_{\text{west}} &= \begin{cases}
                          \phi_{i-1,j} - \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{x,i,j} > 0 \\
                          \phi_{i,j} + \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{x,i,j} < 0
                        \end{cases}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="org30177f1"><span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_phi_west</span>(phi, u_x, x, y):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    TODO: Add docstring</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #eedd82;">dphi_loc</span> = phi[y][x-1] - phi[y][x]
    <span style="color: #eedd82;">u_xij</span> = u_x[y][x]
    <span style="color: #00ffff;">if</span> u_xij &gt; 0:
        <span style="color: #eedd82;">dphi_up</span> = phi[y][x-2] - phi[y][x-1]
        <span style="color: #eedd82;">B</span> = calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span style="color: #00ffff;">return</span> phi[y][x-1] - 0.5 * B * dphi_loc
    <span style="color: #00ffff;">elif</span> u_xij &lt; 0:
        <span style="color: #eedd82;">dphi_up</span> = phi[y][x] - phi[y][x+1]
        <span style="color: #eedd82;">B</span> = calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span style="color: #00ffff;">return</span> phi[y][x] + 0.5 * B * dphi_loc
    <span style="color: #00ffff;">else</span>:
        <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">FIXME: What is the correct value for this case? Update the equation above accordingly.</span>
        <span style="color: #00ffff;">return</span> 0.0
</pre>
</div>

<p>
For the north face:
</p>

\begin{align}
  \delta\phi_{\text{loc}} &= \phi_{i,j+1} - \phi{i,j} \\
  \delta\phi_{\text{up}} &= \begin{cases}
                              \phi_{i,j} - \phi_{i,j-1} & \text{for}\ u_{y,i,j} > 0 \\
                              \phi_{i,j+2} - \phi_{i,j+1} & \text{for}\ u_{y,i,j} < 0
                            \end{cases} \\
  \phi_{\text{north}} &= \begin{cases}
                           \phi_{i,j} + \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{y,i,j} > 0 \\
                           \phi_{i,j+1} - \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{y,i,j} < 0
                         \end{cases}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="orgc9660d6"><span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_phi_north</span>(phi, u_y, x, y):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    TODO: Add docstring</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #eedd82;">dphi_loc</span> = phi[y-1][x] - phi[y][x]
    <span style="color: #eedd82;">u_yij</span> = u_y[y][x]
    <span style="color: #00ffff;">if</span> u_yij &gt; 0:
        <span style="color: #eedd82;">dphi_up</span> = phi[y][x] - phi[y+1][x]
        <span style="color: #eedd82;">B</span> = calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span style="color: #00ffff;">return</span> phi[y][x] + 0.5 * B * dphi_loc
    <span style="color: #00ffff;">elif</span> u_yij &lt; 0:
        <span style="color: #eedd82;">dphi_up</span> = phi[y-2][x] - phi[y-1][x]
        <span style="color: #eedd82;">B</span> = calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span style="color: #00ffff;">return</span> phi[y-1][x] - 0.5 * B * dphi_loc
    <span style="color: #00ffff;">else</span>:
        <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">FIXME: What is the correct value for this case? Update the equation above accordingly.</span>
        <span style="color: #00ffff;">return</span> 0.0
</pre>
</div>

<p>
For the south face:
</p>

\begin{align}
  \delta\phi_{\text{loc}} &= \phi_{i,j-1} - \phi{i,j} \\
  \delta\phi_{\text{up}} &= \begin{cases}
                              \phi_{i,j-2} - \phi_{i,j-1} & \text{for}\ u_{y,i,j} > 0 \\
                              \phi_{i,j} - \phi_{i,j+1} & \text{for}\ u_{y,i,j} < 0
                            \end{cases} \\
  \phi_{\text{south}} &= \begin{cases}
                           \phi_{i,j-1} - \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{y,i,j} > 0 \\
                           \phi_{i,j} + \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{y,i,j} < 0
                         \end{cases}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="orga7c12d0"><span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_phi_south</span>(phi, u_y, x, y):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    TODO: Add docstring</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #eedd82;">dphi_loc</span> = phi[y+1][x] - phi[y][x]
    <span style="color: #eedd82;">u_yij</span> = u_y[y][x]
    <span style="color: #00ffff;">if</span> u_yij &gt; 0:
        <span style="color: #eedd82;">dphi_up</span> = phi[y+2][x] - phi[y+1][x]
        <span style="color: #eedd82;">B</span> = calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span style="color: #00ffff;">return</span> phi[y+1][x] - 0.5 * B * dphi_loc
    <span style="color: #00ffff;">elif</span> u_yij &lt; 0:
        <span style="color: #eedd82;">dphi_up</span> = phi[y][x] - phi[y-1][x]
        <span style="color: #eedd82;">B</span> = calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span style="color: #00ffff;">return</span> phi[y][x] + 0.5 * B * dphi_loc
    <span style="color: #00ffff;">else</span>:
        <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">FIXME: What is the correct value for this case? Update the equation above accordingly.</span>
        <span style="color: #00ffff;">return</span> 0.0
</pre>
</div>

<p>
Once the various spatial partial derivatives have been calculated, we
can march the \(\phi\) field solution forward in time using a second
order Runge Kutta method as follows:
</p>

\begin{align}
  \phi^* &= \phi^t - \Delta t \left(U_x \frac{\phi^t_{\text{east}} - \phi^t_{\text{west}}}{\Delta x} + U_y \frac{\phi^t_{\text{north}} - \phi^t_{\text{south}}}{\Delta y} \right) \\
  \phi^{t + \Delta t} &= \frac{1}{2}\phi^t + \frac{1}{2} \left( \phi^* - \Delta t \left(U_x \frac{\phi^*_{\text{east}} - \phi^*_{\text{west}}}{\Delta x} + U_y \frac{\phi^*_{\text{north}} - \phi^*_{\text{south}}}{\Delta y} \right) \right)
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="org4c50539"><span style="color: #00ffff;">import</span> numpy <span style="color: #00ffff;">as</span> np

<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">FIXME: stub</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">identify_perimeter_cells</span>(phi):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    TODO: Add docstring</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #00ffff;">return</span> [[0,0]]


<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">FIXME: stub</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_u_x</span>(phi, y, x):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    TODO: Add docstring</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #00ffff;">return</span> 0.5


<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">FIXME: stub</span>
<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_u_y</span>(phi, y, x):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    TODO: Add docstring</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #00ffff;">return</span> 0.5


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_phi_star</span>(phi, u_x, u_y, dx, dy, dt, x, y):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    TODO: Add docstring</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #eedd82;">phi_east</span>  = calc_phi_east(phi, u_x, x, y)
    <span style="color: #eedd82;">phi_west</span>  = calc_phi_west(phi, u_x, x, y)
    <span style="color: #eedd82;">phi_north</span> = calc_phi_north(phi, u_y, x, y)
    <span style="color: #eedd82;">phi_south</span> = calc_phi_south(phi, u_y, x, y)
    <span style="color: #eedd82;">dphi_dx</span>   = calc_dphi_dx(phi_east, phi_west, dx)
    <span style="color: #eedd82;">dphi_dy</span>   = calc_dphi_dy(phi_north, phi_south, dy)
    <span style="color: #eedd82;">dphi_dt</span>   = u_x[y][x] * dphi_dx + u_y[y][x] * dphi_dy
    <span style="color: #00ffff;">return</span> phi[y][x] - dphi_dt * dt


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">calc_phi_next_timestep</span>(phi, u_x, u_y, dx, dy, dt, perimeter_cells):
    <span style="color: #ffa07a;">"""</span>
<span style="color: #ffa07a;">    TODO: Add docstring</span>
<span style="color: #ffa07a;">    """</span>
    <span style="color: #eedd82;">phi_star</span> = np.copy(phi)
    <span style="color: #00ffff;">for</span> [y, x] <span style="color: #00ffff;">in</span> perimeter_cells:
        phi_star[y][x] = calc_phi_star(phi, u_x, u_y, dx, dy, dt, x, y)

    <span style="color: #eedd82;">perimeter_cells_star</span> = identify_perimeter_cells(phi_star)

    <span style="color: #eedd82;">u_x_star</span> = np.zeros_like(u_x)
    <span style="color: #eedd82;">u_y_star</span> = np.zeros_like(u_y)
    <span style="color: #00ffff;">for</span> [y, x] <span style="color: #00ffff;">in</span> perimeter_cells_star:
        u_x_star[y][x] = calc_u_x(phi_star, y, x)
        u_y_star[y][x] = calc_u_y(phi_star, y, x)

    <span style="color: #eedd82;">phi_star_star</span> = np.copy(phi_star)
    <span style="color: #00ffff;">for</span> [y, x] <span style="color: #00ffff;">in</span> perimeter_cells_star:
        phi_star_star[y][x] = calc_phi_star(phi_star, u_x_star, u_y_star, dx, dy, dt, x, y)

    <span style="color: #00ffff;">return</span> (phi + phi_star_star) / 2.0
</pre>
</div>

<p>
In the above equations, timestep (\(\Delta t\)) is constrained by the
Courant-Friedrichs-Lewy (CFL) condition. The location of the fire
perimeter is determined by interpolation of the \(\phi\) field as the
level set corresponding to \(\phi = 0\).
</p>

<p>
&#x2026;RESUME HERE&#x2026;
</p>

<p>
<a href="https://github.com/lautenberger/elmfire/blob/main/docs/tech_ref.rst">https://github.com/lautenberger/elmfire/blob/main/docs/tech_ref.rst</a>
</p>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-orgd1d16dc" class="outline-2">
<h2 id="orgd1d16dc"><span class="section-number-2">10.</span> Appendix: Units Conversion Functions</h2>
<div class="outline-text-2" id="text-10">
<div class="org-src-container">
<pre class="src src-python" id="org3866179"><span style="color: #00ffff;">from</span> math <span style="color: #00ffff;">import</span> degrees, radians, tan, atan

<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">F_to_K</span>(degrees):
    <span style="color: #ffa07a;">"""Convert fahrenheit to kelvin."""</span>
    <span style="color: #00ffff;">return</span> (degrees + 459.67) * 0.5555555555555556


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">K_to_F</span>(degrees):
    <span style="color: #ffa07a;">"""Convert kelvin to fahrenheit."""</span>
    <span style="color: #00ffff;">return</span> (degrees * 1.8) - 459.67


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">F_to_C</span>(degrees):
    <span style="color: #ffa07a;">"""Convert fahrenheit to celsius."""</span>
    <span style="color: #00ffff;">return</span> (degrees - 32.0) * 0.5555555555555556


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">C_to_F</span>(degrees):
    <span style="color: #ffa07a;">"""Convert celsius to fahrenheit."""</span>
    <span style="color: #00ffff;">return</span> (degrees * 1.8) + 32.0


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">deg_to_ratio</span>(degrees):
    <span style="color: #ffa07a;">"""Convert degrees to ratio."""</span>
    <span style="color: #00ffff;">return</span> tan(radians(degrees))


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">ratio_to_deg</span>(ratio):
    <span style="color: #ffa07a;">"""Convert ratio to degrees."""</span>
    <span style="color: #00ffff;">return</span> degrees(atan(ratio))


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">ch_to_m</span>(ch):
    <span style="color: #ffa07a;">"""Convert chains to meters."""</span>
    <span style="color: #00ffff;">return</span> ch * 20.1168


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">m_to_ch</span>(m):
    <span style="color: #ffa07a;">"""Convert meters to chains."""</span>
    <span style="color: #00ffff;">return</span> m * 0.0497097


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">m_to_ft</span>(m):
    <span style="color: #ffa07a;">"""Convert meters to feet."""</span>
    <span style="color: #00ffff;">return</span> m * 3.281


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">ft_to_m</span>(ft):
    <span style="color: #ffa07a;">"""Convert feet to meters."""</span>
    <span style="color: #00ffff;">return</span> ft * 0.30478512648582745


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">mph_to_mps</span>(mph):
    <span style="color: #ffa07a;">"""Convert miles per hour to meters per second."""</span>
    <span style="color: #00ffff;">return</span> mph * 0.44701818551254696


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">mps_to_mph</span>(mps):
    <span style="color: #ffa07a;">"""Convert meters per second to miles per hour."""</span>
    <span style="color: #00ffff;">return</span> mps * 2.237045454545455


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">mph_to_km_hr</span>(mph):
    <span style="color: #ffa07a;">"""Convert miles per hour to kilometers per hour."""</span>
    <span style="color: #00ffff;">return</span> mph * 1.609344


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">km_hr_to_mph</span>(km_hr):
    <span style="color: #ffa07a;">"""Convert kilometers per hour to miles per hour."""</span>
    <span style="color: #00ffff;">return</span> km_hr * 0.621371192237334


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">m_min_to_km_hr</span>(m_min):
    <span style="color: #ffa07a;">"""Convert meters per minute to kilometers per hour."""</span>
    <span style="color: #00ffff;">return</span> m_min * 0.06


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">km_hr_to_m_min</span>(km_hr):
    <span style="color: #ffa07a;">"""Convert kilometers per hour to meters per minute."""</span>
    <span style="color: #00ffff;">return</span> km_hr / 0.06


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">m_min_to_mph</span>(m_min):
    <span style="color: #ffa07a;">"""Convert meters per minute to miles per hour."""</span>
    <span style="color: #00ffff;">return</span> m_min * 0.0372840909091


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">mph_to_m_min</span>(mph):
    <span style="color: #ffa07a;">"""Convert miles per hour to meters per minute."""</span>
    <span style="color: #00ffff;">return</span> mph * 26.8210911307


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">mps_to_fpm</span>(mps):
    <span style="color: #ffa07a;">"""Convert meters per second to feet per minute."""</span>
    <span style="color: #00ffff;">return</span> mps * 196.86


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">fpm_to_mps</span>(fpm):
    <span style="color: #ffa07a;">"""Convert feet per minute to meters per second."""</span>
    <span style="color: #00ffff;">return</span> fpm / 196.86


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">mph_to_fpm</span>(mph):
    <span style="color: #ffa07a;">"""Convert miles per hour to feet per minute."""</span>
    <span style="color: #00ffff;">return</span> mph * 88.0


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">fpm_to_mph</span>(fpm):
    <span style="color: #ffa07a;">"""Convert feet per minute to miles per hour."""</span>
    <span style="color: #00ffff;">return</span> fpm / 88.0


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">wind_speed_20ft_to_wind_speed_10m</span>(wind_speed_20ft):
    <span style="color: #ffa07a;">"""Convert wind speed at 20ft to wind speed at 10m."""</span>
    <span style="color: #00ffff;">return</span> wind_speed_20ft / 0.87


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">wind_speed_10m_to_wind_speed_20ft</span>(wind_speed_10m):
    <span style="color: #ffa07a;">"""Convert wind speed at 10m to wind speed at 20ft."""</span>
    <span style="color: #00ffff;">return</span> 0.87 * wind_speed_10m


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">Btu_ft_s_to_kW_m</span>(Btu_ft_s):
    <span style="color: #ffa07a;">"""Convert BTU per feet per second to kilowatt per meter."""</span>
    <span style="color: #00ffff;">return</span> Btu_ft_s * 3.46165186


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">kW_m_to_Btu_ft_s</span>(kW_m):
    <span style="color: #ffa07a;">"""Convert kilowatt per meter to BTU per feet per second."""</span>
    <span style="color: #00ffff;">return</span> kW_m * 0.28887942532730604


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">Btu_lb_to_kJ_kg</span>(Btu_lb):
    <span style="color: #ffa07a;">"""Convert BTU per lb to kilojoule per kilogram."""</span>
    <span style="color: #00ffff;">return</span> Btu_lb * 2.3259999996185


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">kJ_kg_to_Btu_lb</span>(kJ_kg):
    <span style="color: #ffa07a;">"""Convert kilojoule per kilogram to BTU per lb."""</span>
    <span style="color: #00ffff;">return</span> kJ_kg / 2.3259999996185


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">kg_m3_to_lb_ft3</span>(kg_m3):
    <span style="color: #ffa07a;">"""Convert kilogram per cubic meter to pound per cubic foot."""</span>
    <span style="color: #00ffff;">return</span> kg_m3 * 0.0624


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">lb_ft3_to_kg_m3</span>(lb_ft3):
    <span style="color: #ffa07a;">"""Convert pound per cubic foot to kilogram per cubic meter."""</span>
    <span style="color: #00ffff;">return</span> lb_ft3 * 16.025641025641026


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">percent_to_dec</span>(percent):
    <span style="color: #ffa07a;">"""Convert percent to decimal."""</span>
    <span style="color: #00ffff;">return</span> percent * 0.01


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">dec_to_percent</span>(decimal):
    <span style="color: #ffa07a;">"""Convert decimal to percent."""</span>
    <span style="color: #00ffff;">return</span> decimal * 100.0


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">sec_to_min</span>(seconds):
    <span style="color: #ffa07a;">"""Convert seconds to minutes."""</span>
    <span style="color: #00ffff;">return</span> seconds * 0.016666666666666666


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">min_to_sec</span>(minutes):
    <span style="color: #ffa07a;">"""Convert minutes to seconds."""</span>
    <span style="color: #00ffff;">return</span> minutes * 60.0


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">ms_to_min</span>(milliseconds):
    <span style="color: #ffa07a;">"""Convert milliseconds to minutes."""</span>
    <span style="color: #00ffff;">return</span> milliseconds * 0.000016667


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">min_to_ms</span>(minutes):
    <span style="color: #ffa07a;">"""Convert minutes to milliseconds."""</span>
    <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">int</span>(minutes * 60000.0)


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">hour_to_min</span>(hours):
    <span style="color: #ffa07a;">"""Converts hours to minutes."""</span>
    <span style="color: #00ffff;">return</span> hours * 60.0


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">min_to_hour</span>(minutes):
    <span style="color: #ffa07a;">"""Converts minutes to hours. (rounds down)"""</span>
    <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">int</span>(minutes / 60.0)


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">day_to_min</span>(days):
    <span style="color: #ffa07a;">"""Convert days to minutes."""</span>
    <span style="color: #00ffff;">return</span> days * 1440.0


<span style="color: #00ffff;">def</span> <span style="color: #87cefa;">min_to_day</span>(minutes):
    <span style="color: #ffa07a;">"""Convert minutes to days."""</span>
    <span style="color: #00ffff;">return</span> minutes / 1440.0
</pre>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://en.wikipedia.org/wiki/Literate_programming">https://en.wikipedia.org/wiki/Literate_programming</a></p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://landfire.gov">https://landfire.gov</a></p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://elmfire.io">https://elmfire.io</a></p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Gary W. Johnson, Valentin Waeselynck, Chris Lautenberger</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
