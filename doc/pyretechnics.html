<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Pyretechnics Fire Behavior Library</title>
<meta name="author" content="Gary W. Johnson, Valentin Waeselynck, Chris Lautenberger" />
<meta name="description" content="A Python library for simulating fire behavior in a variety of ways." />
<meta name="keywords" content="pyretechnics fire behavior model python library pyregence pyrecast" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="pyretechnics-base.css" />
<link rel="stylesheet" type="text/css" href="pyretechnics-custom.css" />

<script src="../doc/org-info.js">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
// @license-end
</script>

<script>
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
org_html_manager.set("TOC_DEPTH", "3");
org_html_manager.set("LINK_HOME", "");
org_html_manager.set("LINK_UP", "");
org_html_manager.set("LOCAL_TOC", "1");
org_html_manager.set("VIEW_BUTTONS", "0");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "1");
org_html_manager.set("VIEW", "info");
org_html_manager.setup();  // activate after the parameters are set
// @license-end
</script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">The Pyretechnics Fire Behavior Library
<br>
<span class="subtitle">Copyright Â© 2023-2024 Spatial Informatics Group, LLC</span>
</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#Preface">1. Preface</a></li>
<li><a href="#Data Model">2. Data Model</a>
<ul>
<li><a href="#Working in a 3D Space-Time Cube">2.1. Working in a 3D Space-Time Cube</a></li>
<li><a href="#Fires as Conical Shapes in Space-Time">2.2. Fires as Conical Shapes in Space-Time</a></li>
<li><a href="#Support for Input Datasets of Varying Dimensionality">2.3. Support for Input Datasets of Varying Dimensionality</a></li>
<li><a href="#Support for Input Datasets of Varying Resolution">2.4. Support for Input Datasets of Varying Resolution</a></li>
</ul>
</li>
<li><a href="#Loading Data into the 3D Space-Time Cube (pyretechnics.space_time_cube)">3. Loading Data into the 3D Space-Time Cube (pyretechnics.space_time_cube)</a>
<ul>
<li><a href="#For Developers">3.1. For Developers</a>
<ul>
<li><a href="#Module Imports">3.1.1. Module Imports</a></li>
<li><a href="#Utility Functions">3.1.2. Utility Functions</a></li>
<li><a href="#SpaceTimeCube Class">3.1.3. SpaceTimeCube Class</a></li>
<li><a href="#LazySpaceTimeCube Class">3.1.4. LazySpaceTimeCube Class</a></li>
</ul>
</li>
<li><a href="#For Users">3.2. For Users</a>
<ul>
<li><a href="#How to Use SpaceTimeCube">3.2.1. How to Use SpaceTimeCube</a></li>
<li><a href="#How to Use LazySpaceTimeCube">3.2.2. How to Use LazySpaceTimeCube</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#[WIP] Fire Behavior Model">4. [WIP] Fire Behavior Model</a></li>
<li><a href="#Fuel Model and Moisture Definitions (pyretechnics.fuel_models)">5. Fuel Model and Moisture Definitions (pyretechnics.fuel_models)</a>
<ul>
<li><a href="#For Developers">5.1. For Developers</a>
<ul>
<li><a href="#Fuel Model Properties">5.1.1. Fuel Model Properties</a></li>
<li><a href="#Fuel Model Definitions">5.1.2. Fuel Model Definitions</a></li>
<li><a href="#Fuel Categories and Size Classes">5.1.3. Fuel Categories and Size Classes</a></li>
<li><a href="#Dynamic Fuel Loading">5.1.4. Dynamic Fuel Loading</a></li>
<li><a href="#Size Class Weighting Factors">5.1.5. Size Class Weighting Factors</a></li>
<li><a href="#Live Moisture of Extinction">5.1.6. Live Moisture of Extinction</a></li>
<li><a href="#Applying Fuel Moisture to a Fuel Model">5.1.7. Applying Fuel Moisture to a Fuel Model</a></li>
</ul>
</li>
<li><a href="#For Users">5.2. For Users</a>
<ul>
<li><a href="#How to Look Up a Fuel Model's Properties">5.2.1. How to Look Up a Fuel Model's Properties</a></li>
<li><a href="#How to Apply Fuel Moisture to a Fuel Model">5.2.2. How to Apply Fuel Moisture to a Fuel Model</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Surface Fire Equations (pyretechnics.surface_fire)">6. Surface Fire Equations (pyretechnics.surface_fire)</a>
<ul>
<li><a href="#For Developers">6.1. For Developers</a>
<ul>
<li><a href="#Rothermel's Surface Fire Rate of Spread Equation">6.1.1. Rothermel's Surface Fire Rate of Spread Equation</a></li>
<li><a href="#Surface Fire Spread Rate Functions (No Wind No Slope)">6.1.2. Surface Fire Spread Rate Functions (No Wind No Slope)</a></li>
<li><a href="#Surface Fire Intensity Functions">6.1.3. Surface Fire Intensity Functions</a></li>
<li><a href="#Wind and Slope Factor Functions">6.1.4. Wind and Slope Factor Functions</a></li>
<li><a href="#Surface Fire Behavior Functions (No Wind No Slope)">6.1.5. Surface Fire Behavior Functions (No Wind No Slope)</a></li>
<li><a href="#Midflame Wind Speed">6.1.6. Midflame Wind Speed</a></li>
<li><a href="#Combining Wind and Slope Vectors">6.1.7. Combining Wind and Slope Vectors</a></li>
<li><a href="#Elliptical Eccentricity">6.1.8. Elliptical Eccentricity</a></li>
<li><a href="#Surface Fire Behavior in the Direction of Maximum Spread">6.1.9. Surface Fire Behavior in the Direction of Maximum Spread</a></li>
<li><a href="#Surface Fire Behavior in Any Direction">6.1.10. Surface Fire Behavior in Any Direction</a></li>
</ul>
</li>
<li><a href="#For Users">6.2. For Users</a>
<ul>
<li><a href="#How to Calculate the No-Wind-No-Slope Surface Fire Behavior">6.2.1. How to Calculate the No-Wind-No-Slope Surface Fire Behavior</a></li>
<li><a href="#How to Translate the 10m Wind Speed Vector into the Midflame Wind Speed Vector">6.2.2. How to Translate the 10m Wind Speed Vector into the Midflame Wind Speed Vector</a></li>
<li><a href="#How to Calculate the Surface Fire Behavior in the Direction of Maximum Spread">6.2.3. How to Calculate the Surface Fire Behavior in the Direction of Maximum Spread</a></li>
<li><a href="#How to Calculate the Surface Fire Behavior in Any Direction">6.2.4. How to Calculate the Surface Fire Behavior in Any Direction</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Crown Fire Equations (pyretechnics.crown_fire)">7. Crown Fire Equations (pyretechnics.crown_fire)</a>
<ul>
<li><a href="#For Developers">7.1. For Developers</a>
<ul>
<li><a href="#Crown Fire Initiation">7.1.1. Crown Fire Initiation</a></li>
<li><a href="#Passive and Active Crown Fire Spread Rate Functions">7.1.2. Passive and Active Crown Fire Spread Rate Functions</a></li>
<li><a href="#Crown Fire Intensity Functions">7.1.3. Crown Fire Intensity Functions</a></li>
<li><a href="#Elliptical Eccentricity">7.1.4. Elliptical Eccentricity</a></li>
<li><a href="#Crown Fire Behavior in the Direction of Maximum Spread">7.1.5. Crown Fire Behavior in the Direction of Maximum Spread</a></li>
<li><a href="#Crown Fire Behavior in Any Direction">7.1.6. Crown Fire Behavior in Any Direction</a></li>
<li><a href="#Combining Surface and Crown Fire Behavior">7.1.7. Combining Surface and Crown Fire Behavior</a></li>
</ul>
</li>
<li><a href="#For Users">7.2. For Users</a>
<ul>
<li><a href="#How to Determine Whether a Surface Fire Transitions to a Crown Fire">7.2.1. How to Determine Whether a Surface Fire Transitions to a Crown Fire</a></li>
<li><a href="#How to Calculate the Crown Fire Behavior in the Direction of Maximum Spread">7.2.2. How to Calculate the Crown Fire Behavior in the Direction of Maximum Spread</a></li>
<li><a href="#How to Calculate the Crown Fire Behavior in Any Direction">7.2.3. How to Calculate the Crown Fire Behavior in Any Direction</a></li>
<li><a href="#How to Calculate the Combined Surface and Crown Fire Behavior in Any Direction">7.2.4. How to Calculate the Combined Surface and Crown Fire Behavior in Any Direction</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Burning Cells on a Grid (pyretechnics.burn_cells)">8. Burning Cells on a Grid (pyretechnics.burn_cells)</a>
<ul>
<li><a href="#For Developers">8.1. For Developers</a>
<ul>
<li><a href="#Burn Cell as a Head Fire">8.1.1. Burn Cell as a Head Fire</a></li>
<li><a href="#Burn Cell in Any Direction">8.1.2. Burn Cell in Any Direction</a></li>
</ul>
</li>
<li><a href="#For Users">8.2. For Users</a>
<ul>
<li><a href="#How to Burn a Cell as a Head Fire">8.2.1. How to Burn a Cell as a Head Fire</a></li>
<li><a href="#How to Burn a Cell in Any Direction">8.2.2. How to Burn a Cell in Any Direction</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#[WIP] Fire Spread Algorithm: Eulerian Level Set Method (pyretechnics.eulerian_level_set)">9. [WIP] Fire Spread Algorithm: Eulerian Level Set Method (pyretechnics.eulerian_level_set)</a>
<ul>
<li><a href="#For Developers">9.1. For Developers</a>
<ul>
<li><a href="#The $\phi$ Field">9.1.1. The \(\phi\) Field</a></li>
<li><a href="#Fire Front Normal Vector">9.1.2. Fire Front Normal Vector</a></li>
<li><a href="#Numerical Solution of the $\phi$ Field Equation">9.1.3. Numerical Solution of the \(\phi\) Field Equation</a></li>
<li><a href="#Calculate the Surface/Crown Fireline Normal Behavior">9.1.4. Calculate the Surface/Crown Fireline Normal Behavior</a></li>
<li><a href="#Burn Cell Normal to the Fire Perimeter">9.1.5. Burn Cell Normal to the Fire Perimeter</a></li>
<li><a href="#Identify Cells Near the Fire Perimeter ($\phi = 0$)">9.1.6. Identify Cells Near the Fire Perimeter (\(\phi = 0\))</a></li>
<li><a href="#Spread Phi Field">9.1.7. Spread Phi Field</a></li>
</ul>
</li>
<li><a href="#For Users">9.2. For Users</a>
<ul>
<li><a href="#How to Spread a Fire from a Point Ignition">9.2.1. How to Spread a Fire from a Point Ignition</a></li>
<li><a href="#How to Create Images of Fire Behavior Outputs">9.2.2. How to Create Images of Fire Behavior Outputs</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#[WIP] Spot Fire Equations (pyretechnics.spot_fire)">10. [WIP] Spot Fire Equations (pyretechnics.spot_fire)</a>
<ul>
<li><a href="#For Developers">10.1. For Developers</a></li>
<li><a href="#For Users">10.2. For Users</a></li>
</ul>
</li>
<li><a href="#[WIP] Fire Suppression Algorithms (pyretechnics.suppression)">11. [WIP] Fire Suppression Algorithms (pyretechnics.suppression)</a>
<ul>
<li><a href="#For Developers">11.1. For Developers</a></li>
<li><a href="#For Users">11.2. For Users</a></li>
</ul>
</li>
<li><a href="#[WIP] Urban Spread Algorithms">12. [WIP] Urban Spread Algorithms</a>
<ul>
<li><a href="#For Developers">12.1. For Developers</a></li>
<li><a href="#For Users">12.2. For Users</a></li>
</ul>
</li>
<li><a href="#[WIP] Fire Spread API">13. [WIP] Fire Spread API</a>
<ul>
<li><a href="#grow_fire">13.1. grow_fire</a>
<ul>
<li><a href="#Inputs">13.1.1. Inputs</a></li>
<li><a href="#Outputs">13.1.2. Outputs</a></li>
<li><a href="#Play/Pause/Continue Workflow">13.1.3. Play/Pause/Continue Workflow</a></li>
</ul>
</li>
<li><a href="#burn_cells">13.2. burn_cells</a></li>
</ul>
</li>
<li><a href="#[WIP] Fire Spread Functions">14. [WIP] Fire Spread Functions</a>
<ul>
<li><a href="#ELMFIRE Inputs">14.1. ELMFIRE Inputs</a></li>
</ul>
</li>
<li><a href="#Appendices">15. Appendices</a>
<ul>
<li><a href="#Units Conversion Functions (pyretechnics.conversion)">15.1. Units Conversion Functions (pyretechnics.conversion)</a></li>
<li><a href="#Vector Utility Functions (pyretechnics.vector_utils)">15.2. Vector Utility Functions (pyretechnics.vector_utils)</a></li>
<li><a href="#SpaceTimeCube and LazySpaceTimeCube Tests (pyretechnics_test.test_space_time_cube)">15.3. SpaceTimeCube and LazySpaceTimeCube Tests (pyretechnics_test.test_space_time_cube)</a></li>
<li><a href="#Loading LANDFIRE Inputs (pyretechnics.load_landfire)">15.4. Loading LANDFIRE Inputs (pyretechnics.load_landfire)</a>
<ul>
<li><a href="#Loading Raster Files with Python Rasterio">15.4.1. Loading Raster Files with Python Rasterio</a></li>
<li><a href="#Converting LANDFIRE Units and Datatypes">15.4.2. Converting LANDFIRE Units and Datatypes</a></li>
<li><a href="#Verifying Raster Constraints">15.4.3. Verifying Raster Constraints</a></li>
<li><a href="#Converting Rasters to SpaceTimeCubes">15.4.4. Converting Rasters to SpaceTimeCubes</a></li>
<li><a href="#Putting It All Together">15.4.5. Putting It All Together</a></li>
</ul>
</li>
<li><a href="#[WIP] Testing pyretechnics.burn_cells on Worcester, VT (pyretechnics_test.test_burn_cells)">15.5. [WIP] Testing pyretechnics.burn_cells on Worcester, VT (pyretechnics_test.test_burn_cells)</a>
<ul>
<li><a href="#Loading Topography, Fuel Model, and Tree Canopy Inputs from LANDFIRE GeoTIFFs">15.5.1. Loading Topography, Fuel Model, and Tree Canopy Inputs from LANDFIRE GeoTIFFs</a></li>
<li><a href="#Adding Constant Wind and Moisture Values">15.5.2. Adding Constant Wind and Moisture Values</a></li>
<li><a href="#Burning a Single Cell in the Dataset as a Head Fire">15.5.3. Burning a Single Cell in the Dataset as a Head Fire</a></li>
<li><a href="#Burning All Cells in the Dataset as a Head Fire">15.5.4. Burning All Cells in the Dataset as a Head Fire</a></li>
<li><a href="#Comparing Pyretechnics Outputs with FLAMMAP Outputs">15.5.5. Comparing Pyretechnics Outputs with FLAMMAP Outputs</a></li>
</ul>
</li>
<li><a href="#[WIP] Visualizing the Burned Layers">15.6. [WIP] Visualizing the Burned Layers</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-Preface" class="outline-2">
<h2 id="Preface"><span class="section-number-2">1.</span> Preface</h2>
<div class="outline-text-2" id="text-Preface">
<p>
This document is a Literate
Program<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>,
containing both the source code of the software it describes as well
as the rationale used in each step of its design and implementation.
The purpose of this approach is to enable both programmers and
non-programmers alike to retrace the author's footsteps as they read
through the text and code. By the time they have reached the end of
this document, the reader should have just as strong a grasp of the
system as the original programmer.
</p>

<p>
The source code repository containing this document provides a
comprehensive reproducible development environment through the use of
the open source GNU Guix<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup> transactional
package manager. This tool will automatically install all the software
needed to tangle, detangle, weave, test, build, and install this
library on your machine without conflicting with the main package
manager of your operating system. See <a href="../README.md">README.md</a> for more details.
</p>
</div>
</div>
<div id="outline-container-Data Model" class="outline-2">
<h2 id="Data Model"><span class="section-number-2">2.</span> Data Model</h2>
<div class="outline-text-2" id="text-Data Model">
</div>
<div id="outline-container-Working in a 3D Space-Time Cube" class="outline-3">
<h3 id="Working in a 3D Space-Time Cube"><span class="section-number-3">2.1.</span> Working in a 3D Space-Time Cube</h3>
<div class="outline-text-3" id="text-Working in a 3D Space-Time Cube">
<p>
In Pyretechnics, a fire is viewed as a three-dimensional event
occurring within a bounded region of space-time \((T,Y,X)\). In this
mental model, the environment in which a fire develops can be
visualized as a cube in which space is described in 2D by the \(X\) and
\(Y\) dimensions and time projects this 2D world into 3D along the \(T\)
dimension.
</p>

<p>
Note, in particular, that this is not the same thing as a
three-dimensional model of fire behavior that incorporates surface
elevation as the third dimension. Although terrain data (such as
elevation, slope, and aspect) and tree cover characteristics (such as
canopy height and canopy base height) are incorporated into the
implemented spread equations in order to determine the rate,
direction, and mode of fire spread, the outputs of the fire behavior
algorithms in Pyretechnics currently only use two dimensions to
describe spatial heterogeneity within the simulation environment. The
third dimension is instead reserved for temporal variations in the
model inputs and outputs.
</p>
</div>
</div>
<div id="outline-container-Fires as Conical Shapes in Space-Time" class="outline-3">
<h3 id="Fires as Conical Shapes in Space-Time"><span class="section-number-3">2.2.</span> Fires as Conical Shapes in Space-Time</h3>
<div class="outline-text-3" id="text-Fires as Conical Shapes in Space-Time">
<p>
All fire events begin from an ignition somewhere in space-time. As
combustion and propagation occur in burnable fuels, the burned area
(a.k.a "burn scar") of a fire spreads monotonically outward in space.
Viewed from the lens of our 3D space-time cube, these monotonically
expanding burn scars form conical solids within the simulation
environment, with the bottom point of the cone representing the
initial ignition point and the upper edge of the cone representing the
actively burning fire perimeter. Of course, we only expect idealized
fire cones to appear in environments with homogeneous topography,
weather, fuels, and fuel moisture. As these inputs become more
heterogenous throughout the burned region of space-time, these
idealized cones will become distorted in the directions of faster or
slower spread and their perimeters may become more finely dissected.
However, we use this conical shape description of fire events within
the simulated space-time cube to convey both their monotonically
increasing spatial area over time as well as to provide the foundation
for a more visually intuitive understanding of the effect of
temporally varying environmental conditions on the behavior (and thus
shape) of fires.
</p>
</div>
</div>
<div id="outline-container-Support for Input Datasets of Varying Dimensionality" class="outline-3">
<h3 id="Support for Input Datasets of Varying Dimensionality"><span class="section-number-3">2.3.</span> Support for Input Datasets of Varying Dimensionality</h3>
<div class="outline-text-3" id="text-Support for Input Datasets of Varying Dimensionality">
<p>
At the beginning of a fire behavior simulation, our 3D space-time cube
will be populated with all of the information that describes the
environment and will remain effectively static as the fire event
unfolds. This includes (but is not limited to) topography, weather,
fuels, and fuel moisture. In many common simulation scenarios, we
expect that topography and fuels will probably vary in space but not
in time, and weather and fuel moisture may vary in both space and
time. However, we use "may" in these statements because the data model
within Pyretechnics is flexibly designed to allow any of these
environmental input variables to take on any of these forms:
</p>

<dl class="org-dl">
<dt>Constant</dt><dd>Constant in both space and time. <br>
<b>Ex</b>: A single constant foliar moisture value could be used over the
simulation area for the entire simulation duration.</dd>

<dt>Temporal</dt><dd>Constant in space but variable in time. <br>
<b>Ex</b>: An hourly sequence of spread rate adjustment factors could be
used to globally ramp up and down fire spread rates throughout a
day/night cycle, creating burn periods of arbitrary length and
intensity.</dd>

<dt>Spatial</dt><dd>Variable in space but constant in time. <br>
<b>Ex</b>: A raster layer downloaded from
LANDFIRE<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup> can be used to specify the
spatial distribution of FBFM40 fuel model values on a landscape.</dd>

<dt>Spatio-temporal</dt><dd>Variable in both space and time. <br>
<b>Ex</b>: Hourly
RTMA<sup><a id="fnr.4" class="footref" href="#fn.4" role="doc-backlink">4</a></sup> weather
data can be loaded from a multi-band raster and used to specify the
spatio-temporal distribution of wind speed and direction throughout
the simulation domain.</dd>
</dl>

<p>
This is accomplished by representing each such input value as an
abstract datatype with a set of 3D space-time lookup functions for
accessing its values within 0D, 1D, 2D, and 3D slices of the
space-time cube at the simulation resolution. Such lookups should
always be referentially transparent, so as to ensure that subsequent
lookups with the same coordinate will always yield the same values.
See section <a href="#Loading Data into the 3D Space-Time Cube (pyretechnics.space_time_cube)">3</a> for implementation details.
</p>
</div>
</div>
<div id="outline-container-Support for Input Datasets of Varying Resolution" class="outline-3">
<h3 id="Support for Input Datasets of Varying Resolution"><span class="section-number-3">2.4.</span> Support for Input Datasets of Varying Resolution</h3>
<div class="outline-text-3" id="text-Support for Input Datasets of Varying Resolution">
<p>
Even when dimensions are the same between input datasets, they may be
provided at different resolutions from one another, provided that the
following conditions are met:
</p>

<dl class="org-dl">
<dt>Same Projection</dt><dd>All spatially varying datasets must share the
same projection.</dd>

<dt>Same Extent</dt><dd>All spatial and temporal extents must match.</dd>

<dt>Data Resolutions Divide Simulation Resolutions Evenly</dt><dd>All
spatial and temporal resolutions must be exact divisors of the
simulation resolution.</dd>
</dl>

<p>
The simulated space-time cube will share the same projection and
extent as the input datasets, but its resolution may be specified by
the user, provided that it meets condition 3 above. The 3D lookup
functions for each input will then be responsible for translating the
space-time coordinates they receive at the simulation resolution into
the correct coordinates for their underlying dataset's native
resolution. See section <a href="#Loading Data into the 3D Space-Time Cube (pyretechnics.space_time_cube)">3</a> for implementation details.
</p>
</div>
</div>
</div>
<div id="outline-container-Loading Data into the 3D Space-Time Cube (pyretechnics.space_time_cube)" class="outline-2">
<h2 id="Loading Data into the 3D Space-Time Cube (pyretechnics.space_time_cube)"><span class="section-number-2">3.</span> Loading Data into the 3D Space-Time Cube (pyretechnics.space_time_cube)</h2>
<div class="outline-text-2" id="text-Loading Data into the 3D Space-Time Cube (pyretechnics.space_time_cube)">
</div>
<div id="outline-container-For Developers" class="outline-3">
<h3 id="For Developers"><span class="section-number-3">3.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-For Developers">
<p>
The following sections define Python classes that construct 3D
space-time cubes corresponding to the data model described above for
various types of input datasets.
</p>
</div>
<div id="outline-container-Module Imports" class="outline-4">
<h4 id="Module Imports"><span class="section-number-4">3.1.1.</span> Module Imports</h4>
<div class="outline-text-4" id="text-Module Imports">
<div class="org-src-container">
<pre class="src src-python" id="space-time-cube-imports"><span class="org-keyword">from</span> functools <span class="org-keyword">import</span> <span class="org-builtin">reduce</span>
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
</pre>
</div>
</div>
</div>
<div id="outline-container-Utility Functions" class="outline-4">
<h4 id="Utility Functions"><span class="section-number-4">3.1.2.</span> Utility Functions</h4>
<div class="outline-text-4" id="text-Utility Functions">
<div class="org-src-container">
<pre class="src src-python" id="space-time-cube-utilities"><span class="org-keyword">def</span> <span class="org-function-name">is_pos_int</span>(x):
    <span class="org-keyword">return</span> <span class="org-builtin">isinstance</span>(x, <span class="org-builtin">int</span>) <span class="org-keyword">and</span> x <span class="org-operator">&gt;</span> 0


<span class="org-keyword">def</span> <span class="org-function-name">divide_evenly</span>(dividend, divisor):
    (<span class="org-variable-name">quotient</span>, <span class="org-variable-name">remainder</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(dividend, divisor)
    <span class="org-keyword">if</span> remainder <span class="org-operator">==</span> 0:
        <span class="org-keyword">return</span> quotient
    <span class="org-keyword">else</span>:
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-builtin">str</span>(dividend) <span class="org-operator">+</span> <span class="org-string">" must be an exact multiple of "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(divisor) <span class="org-operator">+</span> <span class="org-string">"."</span>)


<span class="org-keyword">def</span> <span class="org-function-name">to_positive_index_range</span>(index_range, axis_length):
    <span class="org-doc">"""</span>
<span class="org-doc">    Translate None and negative indices to positive indices.</span>
<span class="org-doc">    """</span>
    (<span class="org-variable-name">start</span>, <span class="org-variable-name">stop</span>) <span class="org-operator">=</span> index_range
    <span class="org-keyword">return</span> (
        0 <span class="org-keyword">if</span> start <span class="org-operator">==</span> <span class="org-constant">None</span> <span class="org-keyword">else</span> axis_length <span class="org-operator">+</span> start <span class="org-keyword">if</span> start <span class="org-operator">&lt;</span> 0 <span class="org-keyword">else</span> start,
        axis_length <span class="org-keyword">if</span> stop <span class="org-operator">==</span> <span class="org-constant">None</span> <span class="org-keyword">else</span> axis_length <span class="org-operator">+</span> stop <span class="org-keyword">if</span> stop <span class="org-operator">&lt;</span> 0 <span class="org-keyword">else</span> stop
    )


<span class="org-keyword">def</span> <span class="org-function-name">maybe_repeat_array</span>(array, axis_repetitions):
    <span class="org-doc">"""</span>
<span class="org-doc">    Return a new array that is created by repeating the elements from the input</span>
<span class="org-doc">    array repetitions times along the specified array axis. Avoid allocating</span>
<span class="org-doc">    new memory if repetitions == 1 or if the repeated array axis has length 1.</span>
<span class="org-doc">    """</span>
    (<span class="org-variable-name">axis</span>, <span class="org-variable-name">repetitions</span>) <span class="org-operator">=</span> axis_repetitions
    <span class="org-keyword">if</span> repetitions <span class="org-operator">==</span> 1:
        <span class="org-keyword">return</span> array
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">array_shape</span> <span class="org-operator">=</span> <span class="org-builtin">list</span>(np.shape(array))
        <span class="org-keyword">if</span> array_shape[axis] <span class="org-operator">==</span> 1:
            <span class="org-variable-name">array_shape</span>[axis] <span class="org-operator">=</span> repetitions
            <span class="org-keyword">return</span> np.broadcast_to(array, array_shape)
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> np.repeat(array, repetitions, axis)
</pre>
</div>
</div>
</div>
<div id="outline-container-SpaceTimeCube Class" class="outline-4">
<h4 id="SpaceTimeCube Class"><span class="section-number-4">3.1.3.</span> SpaceTimeCube Class</h4>
<div class="outline-text-4" id="text-SpaceTimeCube Class">
<p>
When an input dataset is already loaded into memory as either a single
scalar value or a 1D, 2D, or 3D array of values, it can be made
available to the various Pyretechnics algorithms by wrapping it in a
<code>SpaceTimeCube</code> object. As described in sections <a href="#Support for Input Datasets of Varying Dimensionality">2.3</a> and <a href="#Support for Input Datasets of Varying Resolution">2.4</a>, this input data can be provided in a variety of
dimensions and resolutions, subject to some simple constraints.
</p>

<p>
The <code>SpaceTimeCube</code> object will be created with a tuple of
user-specified spatio-temporal resolutions, called the <i>cube shape</i>,
which must be equal to or exact multiples of those of the underlying
data. For memory efficiency, input values are stored within the
<code>SpaceTimeCube</code> object at their native resolution but can be accessed
at any spatio-temporal point or region within the <code>SpaceTimeCube</code>'s
extent using coordinates from the <i>cube shape</i> resolution.
</p>

<p>
The various accessor functions provided by this class receive 3D
space-time coordinates at the <i>cube shape</i> resolution and will
correctly map them into the corresponding index within the native
dataset. Whenever a bounded region of space-time is requested via an
accessor function, the underlying data will be expanded to fill a new
Numpy array at the <i>cube shape</i> resolution. Whenever possible, Numpy
array broadcasting will be used instead of data copying for any
constant input dimensions.
</p>

<div class="org-src-container">
<pre class="src src-python" id="space-time-cube-class"><span class="org-keyword">class</span> <span class="org-type">SpaceTimeCube</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Create an object that represents a 3D array with dimensions (T,Y,X) given by cube_shape.</span>
<span class="org-doc">    Internally, data is stored as a 3D Numpy array at the resolution of the provided base data.</span>
<span class="org-doc">    Whenever a point value or contiguous space-time region of values is requested, translate</span>
<span class="org-doc">    the given cube_shape coordinates into base coordinates, look up the values from the base data,</span>
<span class="org-doc">    expand them (if necessary) back into the cube_shape resolution, and return the resulting scalar</span>
<span class="org-doc">    value or array to the caller.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, cube_shape, base):
        <span class="org-doc">"""</span>
<span class="org-doc">        NOTE: The resolutions in cube_shape must be exact multiples of any existing dimensions</span>
<span class="org-doc">              in the base data.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that cube_shape contains 3 values or throw an error</span>
        (<span class="org-variable-name">cube_bands</span>, <span class="org-variable-name">cube_rows</span>, <span class="org-variable-name">cube_cols</span>) <span class="org-operator">=</span> cube_shape

        <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that cube_shape only contains positive integers or throw an error</span>
        <span class="org-keyword">if</span> <span class="org-keyword">not</span>(<span class="org-builtin">all</span>(<span class="org-builtin">map</span>(is_pos_int, cube_shape))):
            <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The cube_shape must only contain positive integers."</span>)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Store the cube metadata for later</span>
        <span class="org-keyword">self</span>.<span class="org-variable-name">ndim</span>  <span class="org-operator">=</span> 3
        <span class="org-keyword">self</span>.<span class="org-variable-name">size</span>  <span class="org-operator">=</span> cube_bands <span class="org-operator">*</span> cube_rows <span class="org-operator">*</span> cube_cols
        <span class="org-keyword">self</span>.<span class="org-variable-name">shape</span> <span class="org-operator">=</span> cube_shape
        <span class="org-keyword">self</span>.<span class="org-variable-name">base</span>  <span class="org-operator">=</span> base

        <span class="org-keyword">match</span> np.ndim(base):
            <span class="org-comment-delimiter"># </span><span class="org-comment">0D: Constant Input</span>
            <span class="org-keyword">case</span> 0:
                <span class="org-keyword">self</span>.<span class="org-variable-name">t_repetitions</span> <span class="org-operator">=</span> cube_bands
                <span class="org-keyword">self</span>.<span class="org-variable-name">y_repetitions</span> <span class="org-operator">=</span> cube_rows
                <span class="org-keyword">self</span>.<span class="org-variable-name">x_repetitions</span> <span class="org-operator">=</span> cube_cols
                <span class="org-keyword">self</span>.<span class="org-variable-name">data</span> <span class="org-operator">=</span> np.asarray([[[base]]])

            <span class="org-comment-delimiter"># </span><span class="org-comment">1D: Time-Series Input</span>
            <span class="org-keyword">case</span> 1:
                <span class="org-variable-name">base_bands</span> <span class="org-operator">=</span> <span class="org-builtin">len</span>(base)
                <span class="org-keyword">self</span>.<span class="org-variable-name">t_repetitions</span> <span class="org-operator">=</span> divide_evenly(cube_bands, base_bands)
                <span class="org-keyword">self</span>.<span class="org-variable-name">y_repetitions</span> <span class="org-operator">=</span> cube_rows
                <span class="org-keyword">self</span>.<span class="org-variable-name">x_repetitions</span> <span class="org-operator">=</span> cube_cols
                <span class="org-comment-delimiter"># </span><span class="org-comment">Expand (base_bands) -&gt; (base_bands,1,1)</span>
                <span class="org-keyword">self</span>.<span class="org-variable-name">data</span> <span class="org-operator">=</span> np.expand_dims(base, axis<span class="org-operator">=</span>(1,2))

            <span class="org-comment-delimiter"># </span><span class="org-comment">2D: Spatial Input</span>
            <span class="org-keyword">case</span> 2:
                (<span class="org-variable-name">base_rows</span>, <span class="org-variable-name">base_cols</span>) <span class="org-operator">=</span> np.shape(base)
                <span class="org-keyword">self</span>.<span class="org-variable-name">t_repetitions</span> <span class="org-operator">=</span> cube_bands
                <span class="org-keyword">self</span>.<span class="org-variable-name">y_repetitions</span> <span class="org-operator">=</span> divide_evenly(cube_rows, base_rows)
                <span class="org-keyword">self</span>.<span class="org-variable-name">x_repetitions</span> <span class="org-operator">=</span> divide_evenly(cube_cols, base_cols)
                <span class="org-comment-delimiter"># </span><span class="org-comment">Expand (base_rows,base_cols) -&gt; (1,base_rows,base_cols)</span>
                <span class="org-keyword">self</span>.<span class="org-variable-name">data</span> <span class="org-operator">=</span> np.expand_dims(base, axis<span class="org-operator">=</span>0)

            <span class="org-comment-delimiter"># </span><span class="org-comment">3D: Spatio-Temporal Input</span>
            <span class="org-keyword">case</span> 3:
                (<span class="org-variable-name">base_bands</span>, <span class="org-variable-name">base_rows</span>, <span class="org-variable-name">base_cols</span>) <span class="org-operator">=</span> np.shape(base)
                <span class="org-keyword">self</span>.<span class="org-variable-name">t_repetitions</span> <span class="org-operator">=</span> divide_evenly(cube_bands, base_bands)
                <span class="org-keyword">self</span>.<span class="org-variable-name">y_repetitions</span> <span class="org-operator">=</span> divide_evenly(cube_rows, base_rows)
                <span class="org-keyword">self</span>.<span class="org-variable-name">x_repetitions</span> <span class="org-operator">=</span> divide_evenly(cube_cols, base_cols)
                <span class="org-keyword">self</span>.<span class="org-variable-name">data</span> <span class="org-operator">=</span> np.asarray(base)

            <span class="org-comment-delimiter"># </span><span class="org-comment">4D+: Invalid Input</span>
            <span class="org-keyword">case</span> _:
                <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"Invalid input: base must have 0-3 dimensions."</span>)


    <span class="org-keyword">def</span> <span class="org-function-name">get</span>(<span class="org-keyword">self</span>, t, y, x):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the scalar value at index (t,y,x) by translating these cube coordinates</span>
<span class="org-doc">        to base coordinates and looking up the value within the base data.</span>

<span class="org-doc">        NOTE: Indices may be negative.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select value by spatio-temporal coordinate</span>
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>.data[t <span class="org-operator">//</span> <span class="org-keyword">self</span>.t_repetitions,
                         y <span class="org-operator">//</span> <span class="org-keyword">self</span>.y_repetitions,
                         x <span class="org-operator">//</span> <span class="org-keyword">self</span>.x_repetitions]


    <span class="org-keyword">def</span> <span class="org-function-name">getTimeSeries</span>(<span class="org-keyword">self</span>, t_range, y, x):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 1D array given by the slice (t_range,y,x) by translating these cube</span>
<span class="org-doc">        coordinates to base coordinates, looking up the array slice within the base data,</span>
<span class="org-doc">        and expanding it back to the cube_shape resolution.</span>

<span class="org-doc">        NOTE: Indices may be negative.</span>
<span class="org-doc">        NOTE: Range indices may include one or more None values and</span>
<span class="org-doc">              provide (inclusion, exclusion) semantics like Python array slice notation.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the argument range</span>
        (<span class="org-variable-name">t_start</span>, <span class="org-variable-name">t_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(t_range, <span class="org-keyword">self</span>.shape[0])
        <span class="org-variable-name">t_stop</span> <span class="org-operator">=</span> t_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res coordinates to low-res coordinates</span>
        <span class="org-variable-name">t_start_chunk</span> <span class="org-operator">=</span> t_start <span class="org-operator">//</span> <span class="org-keyword">self</span>.t_repetitions
        <span class="org-variable-name">t_stop_chunk</span>  <span class="org-operator">=</span> t_stop  <span class="org-operator">//</span> <span class="org-keyword">self</span>.t_repetitions
        <span class="org-variable-name">y_chunk</span>       <span class="org-operator">=</span> y       <span class="org-operator">//</span> <span class="org-keyword">self</span>.y_repetitions
        <span class="org-variable-name">x_chunk</span>       <span class="org-operator">=</span> x       <span class="org-operator">//</span> <span class="org-keyword">self</span>.x_repetitions
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select the array slice that completely contains all low-res coordinates</span>
        <span class="org-variable-name">low_res_time</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.data[t_start_chunk:(t_stop_chunk <span class="org-operator">+</span> 1),
                                 y_chunk,
                                 x_chunk]
        <span class="org-comment-delimiter"># </span><span class="org-comment">Expand the low-res slice into a high-res slice</span>
        <span class="org-variable-name">high_res_time</span> <span class="org-operator">=</span> maybe_repeat_array(low_res_time, (0, <span class="org-keyword">self</span>.t_repetitions))
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res global coordinates to high-res slice coordinates</span>
        <span class="org-variable-name">t_chunk_origin</span> <span class="org-operator">=</span> t_start_chunk <span class="org-operator">*</span> <span class="org-keyword">self</span>.t_repetitions
        <span class="org-variable-name">t_start_idx</span>    <span class="org-operator">=</span> t_start <span class="org-operator">-</span> t_chunk_origin
        <span class="org-variable-name">t_stop_idx</span>     <span class="org-operator">=</span> t_stop  <span class="org-operator">-</span> t_chunk_origin
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select the array slice that matches the high-res slice coordinates</span>
        <span class="org-keyword">return</span> high_res_time[t_start_idx:(t_stop_idx <span class="org-operator">+</span> 1)]


    <span class="org-keyword">def</span> <span class="org-function-name">getSpatialPlane</span>(<span class="org-keyword">self</span>, t, y_range, x_range):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 2D array given by the slice (t,y_range,x_range) by translating these</span>
<span class="org-doc">        cube coordinates to base coordinates, looking up the array slice within the base</span>
<span class="org-doc">        data, and expanding it back to the cube_shape resolution.</span>

<span class="org-doc">        NOTE: Indices may be negative.</span>
<span class="org-doc">        NOTE: Range indices may include one or more None values and</span>
<span class="org-doc">              provide (inclusion, exclusion) semantics like Python array slice notation.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the argument ranges</span>
        (<span class="org-variable-name">y_start</span>, <span class="org-variable-name">y_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(y_range, <span class="org-keyword">self</span>.shape[1])
        (<span class="org-variable-name">x_start</span>, <span class="org-variable-name">x_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(x_range, <span class="org-keyword">self</span>.shape[2])
        <span class="org-variable-name">y_stop</span> <span class="org-operator">=</span> y_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-variable-name">x_stop</span> <span class="org-operator">=</span> x_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res coordinates to low-res coordinates</span>
        <span class="org-variable-name">t_chunk</span>       <span class="org-operator">=</span> t       <span class="org-operator">//</span> <span class="org-keyword">self</span>.t_repetitions
        <span class="org-variable-name">y_start_chunk</span> <span class="org-operator">=</span> y_start <span class="org-operator">//</span> <span class="org-keyword">self</span>.y_repetitions
        <span class="org-variable-name">y_stop_chunk</span>  <span class="org-operator">=</span> y_stop  <span class="org-operator">//</span> <span class="org-keyword">self</span>.y_repetitions
        <span class="org-variable-name">x_start_chunk</span> <span class="org-operator">=</span> x_start <span class="org-operator">//</span> <span class="org-keyword">self</span>.x_repetitions
        <span class="org-variable-name">x_stop_chunk</span>  <span class="org-operator">=</span> x_stop  <span class="org-operator">//</span> <span class="org-keyword">self</span>.x_repetitions
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select the array slice that completely contains all low-res coordinates</span>
        <span class="org-variable-name">low_res_space</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.data[t_chunk,
                                  y_start_chunk:(y_stop_chunk <span class="org-operator">+</span> 1),
                                  x_start_chunk:(x_stop_chunk <span class="org-operator">+</span> 1)]
        <span class="org-comment-delimiter"># </span><span class="org-comment">Expand the low-res slice into a high-res slice</span>
        <span class="org-variable-name">high_res_space</span> <span class="org-operator">=</span> <span class="org-builtin">reduce</span>(maybe_repeat_array,
                                ((0, <span class="org-keyword">self</span>.y_repetitions),
                                 (1, <span class="org-keyword">self</span>.x_repetitions)),
                                low_res_space)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res global coordinates to high-res slice coordinates</span>
        <span class="org-variable-name">y_chunk_origin</span> <span class="org-operator">=</span> y_start_chunk <span class="org-operator">*</span> <span class="org-keyword">self</span>.y_repetitions
        <span class="org-variable-name">x_chunk_origin</span> <span class="org-operator">=</span> x_start_chunk <span class="org-operator">*</span> <span class="org-keyword">self</span>.x_repetitions
        <span class="org-variable-name">y_start_idx</span>    <span class="org-operator">=</span> y_start <span class="org-operator">-</span> y_chunk_origin
        <span class="org-variable-name">y_stop_idx</span>     <span class="org-operator">=</span> y_stop  <span class="org-operator">-</span> y_chunk_origin
        <span class="org-variable-name">x_start_idx</span>    <span class="org-operator">=</span> x_start <span class="org-operator">-</span> x_chunk_origin
        <span class="org-variable-name">x_stop_idx</span>     <span class="org-operator">=</span> x_stop  <span class="org-operator">-</span> x_chunk_origin
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select the array slice that matches the high-res slice coordinates</span>
        <span class="org-keyword">return</span> high_res_space[y_start_idx:(y_stop_idx <span class="org-operator">+</span> 1),
                              x_start_idx:(x_stop_idx <span class="org-operator">+</span> 1)]


    <span class="org-keyword">def</span> <span class="org-function-name">getSubcube</span>(<span class="org-keyword">self</span>, t_range, y_range, x_range):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 3D array given by the slice (t_range,y_range,x_range) by translating</span>
<span class="org-doc">        these cube coordinates to base coordinates, looking up the array slice within the</span>
<span class="org-doc">        base data, and expanding it back to the cube_shape resolution.</span>

<span class="org-doc">        NOTE: Indices may be negative.</span>
<span class="org-doc">        NOTE: Range indices may include one or more None values and</span>
<span class="org-doc">              provide (inclusion, exclusion) semantics like Python array slice notation.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the argument ranges</span>
        (<span class="org-variable-name">t_start</span>, <span class="org-variable-name">t_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(t_range, <span class="org-keyword">self</span>.shape[0])
        (<span class="org-variable-name">y_start</span>, <span class="org-variable-name">y_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(y_range, <span class="org-keyword">self</span>.shape[1])
        (<span class="org-variable-name">x_start</span>, <span class="org-variable-name">x_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(x_range, <span class="org-keyword">self</span>.shape[2])
        <span class="org-variable-name">t_stop</span> <span class="org-operator">=</span> t_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-variable-name">y_stop</span> <span class="org-operator">=</span> y_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-variable-name">x_stop</span> <span class="org-operator">=</span> x_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res coordinates to low-res coordinates</span>
        <span class="org-variable-name">t_start_chunk</span> <span class="org-operator">=</span> t_start <span class="org-operator">//</span> <span class="org-keyword">self</span>.t_repetitions
        <span class="org-variable-name">t_stop_chunk</span>  <span class="org-operator">=</span> t_stop  <span class="org-operator">//</span> <span class="org-keyword">self</span>.t_repetitions
        <span class="org-variable-name">y_start_chunk</span> <span class="org-operator">=</span> y_start <span class="org-operator">//</span> <span class="org-keyword">self</span>.y_repetitions
        <span class="org-variable-name">y_stop_chunk</span>  <span class="org-operator">=</span> y_stop  <span class="org-operator">//</span> <span class="org-keyword">self</span>.y_repetitions
        <span class="org-variable-name">x_start_chunk</span> <span class="org-operator">=</span> x_start <span class="org-operator">//</span> <span class="org-keyword">self</span>.x_repetitions
        <span class="org-variable-name">x_stop_chunk</span>  <span class="org-operator">=</span> x_stop  <span class="org-operator">//</span> <span class="org-keyword">self</span>.x_repetitions
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select the array slice that completely contains all low-res coordinates</span>
        <span class="org-variable-name">low_res_cube</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.data[t_start_chunk:(t_stop_chunk <span class="org-operator">+</span> 1),
                                 y_start_chunk:(y_stop_chunk <span class="org-operator">+</span> 1),
                                 x_start_chunk:(x_stop_chunk <span class="org-operator">+</span> 1)]
        <span class="org-comment-delimiter"># </span><span class="org-comment">Expand the low-res slice into a high-res slice</span>
        <span class="org-variable-name">high_res_cube</span> <span class="org-operator">=</span> <span class="org-builtin">reduce</span>(maybe_repeat_array,
                               ((0, <span class="org-keyword">self</span>.t_repetitions),
                                (1, <span class="org-keyword">self</span>.y_repetitions),
                                (2, <span class="org-keyword">self</span>.x_repetitions)),
                               low_res_cube)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res global coordinates to high-res slice coordinates</span>
        <span class="org-variable-name">t_chunk_origin</span> <span class="org-operator">=</span> t_start_chunk <span class="org-operator">*</span> <span class="org-keyword">self</span>.t_repetitions
        <span class="org-variable-name">y_chunk_origin</span> <span class="org-operator">=</span> y_start_chunk <span class="org-operator">*</span> <span class="org-keyword">self</span>.y_repetitions
        <span class="org-variable-name">x_chunk_origin</span> <span class="org-operator">=</span> x_start_chunk <span class="org-operator">*</span> <span class="org-keyword">self</span>.x_repetitions
        <span class="org-variable-name">t_start_idx</span>    <span class="org-operator">=</span> t_start <span class="org-operator">-</span> t_chunk_origin
        <span class="org-variable-name">t_stop_idx</span>     <span class="org-operator">=</span> t_stop  <span class="org-operator">-</span> t_chunk_origin
        <span class="org-variable-name">y_start_idx</span>    <span class="org-operator">=</span> y_start <span class="org-operator">-</span> y_chunk_origin
        <span class="org-variable-name">y_stop_idx</span>     <span class="org-operator">=</span> y_stop  <span class="org-operator">-</span> y_chunk_origin
        <span class="org-variable-name">x_start_idx</span>    <span class="org-operator">=</span> x_start <span class="org-operator">-</span> x_chunk_origin
        <span class="org-variable-name">x_stop_idx</span>     <span class="org-operator">=</span> x_stop  <span class="org-operator">-</span> x_chunk_origin
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select the array slice that matches the high-res slice coordinates</span>
        <span class="org-keyword">return</span> high_res_cube[t_start_idx:(t_stop_idx <span class="org-operator">+</span> 1),
                             y_start_idx:(y_stop_idx <span class="org-operator">+</span> 1),
                             x_start_idx:(x_stop_idx <span class="org-operator">+</span> 1)]


    <span class="org-keyword">def</span> <span class="org-function-name">__getFullyRealizedCube</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 3D array created by expanding the base data to the cube_shape resolution.</span>
<span class="org-doc">        Wherever possible, Numpy broadcasting is used to avoid memory allocation along</span>
<span class="org-doc">        constant array dimensions.</span>
<span class="org-doc">        """</span>
        <span class="org-keyword">match</span> np.ndim(<span class="org-keyword">self</span>.base):
            <span class="org-comment-delimiter"># </span><span class="org-comment">0D: Constant Input</span>
            <span class="org-keyword">case</span> 0:
                <span class="org-comment-delimiter"># </span><span class="org-comment">Broadcast (0,0,0) -&gt; (t,y,x)</span>
                <span class="org-keyword">return</span> np.broadcast_to(<span class="org-keyword">self</span>.data, <span class="org-keyword">self</span>.shape)

            <span class="org-comment-delimiter"># </span><span class="org-comment">1D: Time-Series Input</span>
            <span class="org-keyword">case</span> 1:
                <span class="org-comment-delimiter"># </span><span class="org-comment">Repeat (t0,1,1) -&gt; (t,1,1)</span>
                <span class="org-variable-name">repeated_array</span> <span class="org-operator">=</span> maybe_repeat_array(<span class="org-keyword">self</span>.data, (0, <span class="org-keyword">self</span>.t_repetitions))
                <span class="org-comment-delimiter"># </span><span class="org-comment">Broadcast (t,1,1) -&gt; (t,y,x)</span>
                <span class="org-keyword">return</span> np.broadcast_to(repeated_array, <span class="org-keyword">self</span>.shape)

            <span class="org-comment-delimiter"># </span><span class="org-comment">2D: Spatial Input</span>
            <span class="org-keyword">case</span> 2:
                <span class="org-comment-delimiter"># </span><span class="org-comment">Repeat (1,y0,x0) -&gt; (1,y,x)</span>
                <span class="org-variable-name">repeated_array</span> <span class="org-operator">=</span> <span class="org-builtin">reduce</span>(maybe_repeat_array,
                                        ((1, <span class="org-keyword">self</span>.y_repetitions),
                                         (2, <span class="org-keyword">self</span>.x_repetitions)),
                                        <span class="org-keyword">self</span>.data)
                <span class="org-comment-delimiter"># </span><span class="org-comment">Broadcast (1,y,x) -&gt; (t,y,x)</span>
                <span class="org-keyword">return</span> np.broadcast_to(repeated_array, <span class="org-keyword">self</span>.shape)

            <span class="org-comment-delimiter"># </span><span class="org-comment">3D: Spatio-Temporal Input</span>
            <span class="org-keyword">case</span> 3:
                <span class="org-comment-delimiter"># </span><span class="org-comment">Repeat (t0,y0,x0) -&gt; (t,y,x)</span>
                <span class="org-keyword">return</span> <span class="org-builtin">reduce</span>(maybe_repeat_array,
                              ((0, <span class="org-keyword">self</span>.t_repetitions),
                               (1, <span class="org-keyword">self</span>.y_repetitions),
                               (2, <span class="org-keyword">self</span>.x_repetitions)),
                              <span class="org-keyword">self</span>.data)


    <span class="org-keyword">def</span> <span class="org-function-name">getFullyRealizedCube</span>(<span class="org-keyword">self</span>, cache<span class="org-operator">=</span><span class="org-constant">False</span>):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 3D array created by expanding the base data to the cube_shape resolution.</span>
<span class="org-doc">        Wherever possible, Numpy broadcasting is used to avoid memory allocation along</span>
<span class="org-doc">        constant array dimensions. When cache == True, this expanded 3D array is cached</span>
<span class="org-doc">        within the SpaceTimeCube object for future immediate retrieval.</span>
<span class="org-doc">        """</span>
        <span class="org-keyword">if</span> <span class="org-builtin">hasattr</span>(<span class="org-keyword">self</span>, <span class="org-string">"cube"</span>):
            <span class="org-keyword">return</span> <span class="org-keyword">self</span>.cube
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">cube</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.__getFullyRealizedCube()
            <span class="org-keyword">if</span> cache <span class="org-keyword">is</span> <span class="org-constant">True</span>:
                <span class="org-keyword">self</span>.<span class="org-variable-name">cube</span> <span class="org-operator">=</span> cube
            <span class="org-keyword">return</span> cube


    <span class="org-keyword">def</span> <span class="org-function-name">releaseFullyRealizedCube</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">"""</span>
<span class="org-doc">        Deletes the cached fully realized cube if it exists.</span>
<span class="org-doc">        """</span>
        <span class="org-keyword">if</span> <span class="org-builtin">hasattr</span>(<span class="org-keyword">self</span>, <span class="org-string">"cube"</span>):
            <span class="org-builtin">delattr</span>(<span class="org-keyword">self</span>, <span class="org-string">"cube"</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-LazySpaceTimeCube Class" class="outline-4">
<h4 id="LazySpaceTimeCube Class"><span class="section-number-4">3.1.4.</span> LazySpaceTimeCube Class</h4>
<div class="outline-text-4" id="text-LazySpaceTimeCube Class">
<p>
When a dataset is too large to fit easily into memory, it can be
partitioned into a collection of subcubes, which will be lazily loaded
on demand into a 3D cache grid of <code>SpaceTimeCube</code> objects provided by
the <code>LazySpaceTimeCube</code> class.
</p>

<p>
The <code>LazySpaceTimeCube</code> object will be created with a tuple of
user-specified spatio-temporal resolutions, called the <i>cube shape</i>,
which must be equal to or exact multiples of the <i>subcube shape</i>.
</p>

<p>
The various accessor functions provided by this class receive 3D
space-time coordinates at the <i>cube shape</i> resolution and will
correctly map them into the corresponding cache and subcube indexes.
Any intersected subcubes that are not already present in the cache
grid will be loaded on demand by calling a user-supplied
<code>load_subcube</code> function and stored in the cache grid for faster
retrieval later. If a bounded region of space-time that spans multiple
subcubes is requested via an accessor function, each of the
intersected subcubes will be loaded and cached, their relevant array
slices will be extracted, and these slices will be merged into a new
array at the <i>cube shape</i> resolution.
</p>

<p>
Fire spread simulations that use the <code>LazySpaceTimeCube</code> class will
only need to load into memory those subcubes which are intersected by
the expanding conical burn scar (see section <a href="#Fires as Conical Shapes in Space-Time">2.2</a>). In simulations of fires that are small relative to the
extent of the full 3D space-time environment, these memory savings may
be substantial and may make it possible to run simulations over larger
extents and/or finer resolutions than have been used previously.
</p>

<div class="org-src-container">
<pre class="src src-python" id="lazy-space-time-cube-class"><span class="org-keyword">class</span> <span class="org-type">LazySpaceTimeCube</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Create an object that represents a 3D array with dimensions (T,Y,X) given by cube_shape.</span>
<span class="org-doc">    Internally, data is stored as an initially empty 3D array of SpaceTimeCube objects.</span>
<span class="org-doc">    Whenever a point value or contiguous space-time region of values is requested, identify</span>
<span class="org-doc">    which SpaceTimeCubes contain the requested coordinates, load them into the cache array</span>
<span class="org-doc">    by calling load_subcube for any that are not already present, request the values from</span>
<span class="org-doc">    these SpaceTimeCubes, combine them together if necessary, and return the resulting scalar</span>
<span class="org-doc">    value or array to the caller.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, cube_shape, subcube_shape, load_subcube):
        <span class="org-doc">"""</span>
<span class="org-doc">        NOTE: The resolutions in cube_shape must be exact multiples of those in subcube_shape.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that cube_shape and subcube_shape both contain 3 values or throw an error</span>
        (<span class="org-variable-name">cube_bands</span>, <span class="org-variable-name">cube_rows</span>, <span class="org-variable-name">cube_cols</span>) <span class="org-operator">=</span> cube_shape
        (<span class="org-variable-name">subcube_bands</span>, <span class="org-variable-name">subcube_rows</span>, <span class="org-variable-name">subcube_cols</span>) <span class="org-operator">=</span> subcube_shape

        <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that cube_shape and subcube_shape only contain positive integers or throw an error</span>
        <span class="org-keyword">if</span> <span class="org-keyword">not</span>(<span class="org-builtin">all</span>(<span class="org-builtin">map</span>(is_pos_int, cube_shape <span class="org-operator">+</span> subcube_shape))):
            <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The cube_shape and subcube_shape must only contain positive integers."</span>)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that cube_shape is divided evenly by subcube_shape or throw an error</span>
        <span class="org-variable-name">cache_bands</span> <span class="org-operator">=</span> divide_evenly(cube_bands, subcube_bands)
        <span class="org-variable-name">cache_rows</span>  <span class="org-operator">=</span> divide_evenly(cube_rows, subcube_rows)
        <span class="org-variable-name">cache_cols</span>  <span class="org-operator">=</span> divide_evenly(cube_cols, subcube_cols)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Store the cube metadata, subcube_shape, cache_shape, cache, and load_subcube functions for later</span>
        <span class="org-keyword">self</span>.<span class="org-variable-name">ndim</span>          <span class="org-operator">=</span> 3
        <span class="org-keyword">self</span>.<span class="org-variable-name">size</span>          <span class="org-operator">=</span> cube_bands <span class="org-operator">*</span> cube_rows <span class="org-operator">*</span> cube_cols
        <span class="org-keyword">self</span>.<span class="org-variable-name">shape</span>         <span class="org-operator">=</span> cube_shape
        <span class="org-keyword">self</span>.<span class="org-variable-name">subcube_shape</span> <span class="org-operator">=</span> subcube_shape
        <span class="org-keyword">self</span>.<span class="org-variable-name">cache_shape</span>   <span class="org-operator">=</span> (cache_bands, cache_rows, cache_cols)
        <span class="org-keyword">self</span>.<span class="org-variable-name">cache</span>         <span class="org-operator">=</span> np.empty(<span class="org-keyword">self</span>.cache_shape, dtype<span class="org-operator">=</span><span class="org-builtin">object</span>)
        <span class="org-keyword">self</span>.<span class="org-variable-name">load_subcube</span>  <span class="org-operator">=</span> load_subcube


    <span class="org-keyword">def</span> <span class="org-function-name">__getOrLoadSubcube</span>(<span class="org-keyword">self</span>, cache_t, cache_y, cache_x):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the SpaceTimeCube stored at self.cache[cache_t, cache_y, cache_x] if it</span>
<span class="org-doc">        has already been loaded. Otherwise, call self.load_subcube to load it, store</span>
<span class="org-doc">        it in self.cache, and return it.</span>
<span class="org-doc">        """</span>
        <span class="org-variable-name">subcube</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.cache[cache_t, cache_y, cache_x]
        <span class="org-keyword">if</span> subcube:
            <span class="org-keyword">return</span> subcube
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">subcube</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.load_subcube((cache_t, cache_y, cache_x), <span class="org-keyword">self</span>.subcube_shape)
            <span class="org-keyword">self</span>.<span class="org-variable-name">cache</span>[<span class="org-variable-name">cache_t</span>, <span class="org-variable-name">cache_y</span>, <span class="org-variable-name">cache_x</span>] <span class="org-operator">=</span> subcube
            <span class="org-keyword">return</span> subcube


    <span class="org-keyword">def</span> <span class="org-function-name">get</span>(<span class="org-keyword">self</span>, t, y, x):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the scalar value at index (t,y,x) by translating these cube coordinates</span>
<span class="org-doc">        to cache and subcube coordinates, loading the matching subcube into the cache grid</span>
<span class="org-doc">        if not already present, and looking up the value within this subcube.</span>

<span class="org-doc">        NOTE: Indices may be negative provided that your load_subcube function can handle</span>
<span class="org-doc">              negative indices in its cache_index argument.</span>
<span class="org-doc">        """</span>
        (<span class="org-variable-name">subcube_bands</span>, <span class="org-variable-name">subcube_rows</span>, <span class="org-variable-name">subcube_cols</span>) <span class="org-operator">=</span> <span class="org-keyword">self</span>.subcube_shape
        (<span class="org-variable-name">cache_t</span>, <span class="org-variable-name">subcube_t</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(t, subcube_bands)
        (<span class="org-variable-name">cache_y</span>, <span class="org-variable-name">subcube_y</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(y, subcube_rows)
        (<span class="org-variable-name">cache_x</span>, <span class="org-variable-name">subcube_x</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(x, subcube_cols)
        <span class="org-variable-name">subcube</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.__getOrLoadSubcube(cache_t, cache_y, cache_x)
        <span class="org-keyword">return</span> subcube.get(subcube_t, subcube_y, subcube_x)


    <span class="org-keyword">def</span> <span class="org-function-name">getTimeSeries</span>(<span class="org-keyword">self</span>, t_range, y, x):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 1D array given by the slice (t_range,y,x) by translating these cube</span>
<span class="org-doc">        coordinates to cache and subcube coordinates, loading the matching subcubes into</span>
<span class="org-doc">        the cache grid if not already present, looking up the array slices within each</span>
<span class="org-doc">        subcube, and merging them together into a single 1D array.</span>

<span class="org-doc">        NOTE: Indices may be negative provided that your load_subcube function can handle</span>
<span class="org-doc">              negative indices in its cache_index argument.</span>
<span class="org-doc">        NOTE: Range indices may include one or more None values and</span>
<span class="org-doc">              provide (inclusion, exclusion) semantics like Python array slice notation.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the argument range</span>
        (<span class="org-variable-name">t_start</span>, <span class="org-variable-name">t_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(t_range, <span class="org-keyword">self</span>.shape[0])
        <span class="org-variable-name">t_stop</span> <span class="org-operator">=</span> t_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res coordinates to cache and subcube coordinates</span>
        (<span class="org-variable-name">subcube_bands</span>, <span class="org-variable-name">subcube_rows</span>, <span class="org-variable-name">subcube_cols</span>) <span class="org-operator">=</span> <span class="org-keyword">self</span>.subcube_shape
        (<span class="org-variable-name">cache_t_start</span>, <span class="org-variable-name">subcube_t_start</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(t_start, subcube_bands)
        (<span class="org-variable-name">cache_t_stop</span>,  <span class="org-variable-name">subcube_t_stop</span>)  <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(t_stop,  subcube_bands)
        (<span class="org-variable-name">cache_y</span>,       <span class="org-variable-name">subcube_y</span>)       <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(y,       subcube_rows)
        (<span class="org-variable-name">cache_x</span>,       <span class="org-variable-name">subcube_x</span>)       <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(x,       subcube_cols)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Load, expand, and combine subcubes</span>
        <span class="org-keyword">return</span> np.concatenate(
            [<span class="org-keyword">self</span>.__getOrLoadSubcube(cache_t,
                                     cache_y,
                                     cache_x
                                    ).getTimeSeries(
                                        (subcube_t_start    <span class="org-keyword">if</span> cache_t <span class="org-operator">==</span> cache_t_start <span class="org-keyword">else</span> 0,
                                         subcube_t_stop <span class="org-operator">+</span> 1 <span class="org-keyword">if</span> cache_t <span class="org-operator">==</span> cache_t_stop  <span class="org-keyword">else</span> subcube_bands),
                                        subcube_y,
                                        subcube_x
                                    )
             <span class="org-keyword">for</span> cache_t <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cache_t_start, cache_t_stop <span class="org-operator">+</span> 1)]
        )


    <span class="org-keyword">def</span> <span class="org-function-name">getSpatialPlane</span>(<span class="org-keyword">self</span>, t, y_range, x_range):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 2D array given by the slice (t,y_range,x_range) by translating these</span>
<span class="org-doc">        cube coordinates to cache and subcube coordinates, loading the matching subcubes</span>
<span class="org-doc">        into the cache grid if not already present, looking up the array slices within each</span>
<span class="org-doc">        subcube, and merging them together into a single 2D array.</span>

<span class="org-doc">        NOTE: Indices may be negative provided that your load_subcube function can handle</span>
<span class="org-doc">              negative indices in its cache_index argument.</span>
<span class="org-doc">        NOTE: Range indices may include one or more None values and</span>
<span class="org-doc">              provide (inclusion, exclusion) semantics like Python array slice notation.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the argument ranges</span>
        (<span class="org-variable-name">y_start</span>, <span class="org-variable-name">y_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(y_range, <span class="org-keyword">self</span>.shape[1])
        (<span class="org-variable-name">x_start</span>, <span class="org-variable-name">x_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(x_range, <span class="org-keyword">self</span>.shape[2])
        <span class="org-variable-name">y_stop</span> <span class="org-operator">=</span> y_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-variable-name">x_stop</span> <span class="org-operator">=</span> x_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res coordinates to cache and subcube coordinates</span>
        (<span class="org-variable-name">subcube_bands</span>, <span class="org-variable-name">subcube_rows</span>, <span class="org-variable-name">subcube_cols</span>) <span class="org-operator">=</span> <span class="org-keyword">self</span>.subcube_shape
        (<span class="org-variable-name">cache_t</span>,       <span class="org-variable-name">subcube_t</span>)       <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(t,       subcube_bands)
        (<span class="org-variable-name">cache_y_start</span>, <span class="org-variable-name">subcube_y_start</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(y_start, subcube_rows)
        (<span class="org-variable-name">cache_y_stop</span>,  <span class="org-variable-name">subcube_y_stop</span>)  <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(y_stop,  subcube_rows)
        (<span class="org-variable-name">cache_x_start</span>, <span class="org-variable-name">subcube_x_start</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(x_start, subcube_cols)
        (<span class="org-variable-name">cache_x_stop</span>,  <span class="org-variable-name">subcube_x_stop</span>)  <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(x_stop,  subcube_cols)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Load, expand, and combine subcubes</span>
        <span class="org-keyword">return</span> np.block(
            [[<span class="org-keyword">self</span>.__getOrLoadSubcube(cache_t,
                                      cache_y,
                                      cache_x
                                      ).getSpatialPlane(
                                          subcube_t,
                                          (subcube_y_start    <span class="org-keyword">if</span> cache_y <span class="org-operator">==</span> cache_y_start <span class="org-keyword">else</span> 0,
                                           subcube_y_stop <span class="org-operator">+</span> 1 <span class="org-keyword">if</span> cache_y <span class="org-operator">==</span> cache_y_stop  <span class="org-keyword">else</span> subcube_rows),
                                          (subcube_x_start    <span class="org-keyword">if</span> cache_x <span class="org-operator">==</span> cache_x_start <span class="org-keyword">else</span> 0,
                                           subcube_x_stop <span class="org-operator">+</span> 1 <span class="org-keyword">if</span> cache_x <span class="org-operator">==</span> cache_x_stop  <span class="org-keyword">else</span> subcube_cols)
                                      )
              <span class="org-keyword">for</span> cache_x <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cache_x_start, cache_x_stop <span class="org-operator">+</span> 1)]
             <span class="org-keyword">for</span> cache_y <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cache_y_start, cache_y_stop <span class="org-operator">+</span> 1)]
        )


    <span class="org-keyword">def</span> <span class="org-function-name">getSubcube</span>(<span class="org-keyword">self</span>, t_range, y_range, x_range):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 3D array given by the slice (t_range,y_range,x_range) by translating</span>
<span class="org-doc">        these cube coordinates to cache and subcube coordinates, loading the matching</span>
<span class="org-doc">        subcubes into the cache grid if not already present, looking up the array slices</span>
<span class="org-doc">        within each subcube, and merging them together into a single 3D array.</span>

<span class="org-doc">        NOTE: Indices may be negative provided that your load_subcube function can handle</span>
<span class="org-doc">              negative indices in its cache_index argument.</span>
<span class="org-doc">        NOTE: Range indices may include one or more None values and</span>
<span class="org-doc">              provide (inclusion, exclusion) semantics like Python array slice notation.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the argument ranges</span>
        (<span class="org-variable-name">t_start</span>, <span class="org-variable-name">t_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(t_range, <span class="org-keyword">self</span>.shape[0])
        (<span class="org-variable-name">y_start</span>, <span class="org-variable-name">y_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(y_range, <span class="org-keyword">self</span>.shape[1])
        (<span class="org-variable-name">x_start</span>, <span class="org-variable-name">x_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(x_range, <span class="org-keyword">self</span>.shape[2])
        <span class="org-variable-name">t_stop</span> <span class="org-operator">=</span> t_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-variable-name">y_stop</span> <span class="org-operator">=</span> y_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-variable-name">x_stop</span> <span class="org-operator">=</span> x_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res coordinates to cache and subcube coordinates</span>
        (<span class="org-variable-name">subcube_bands</span>, <span class="org-variable-name">subcube_rows</span>, <span class="org-variable-name">subcube_cols</span>) <span class="org-operator">=</span> <span class="org-keyword">self</span>.subcube_shape
        (<span class="org-variable-name">cache_t_start</span>, <span class="org-variable-name">subcube_t_start</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(t_start, subcube_bands)
        (<span class="org-variable-name">cache_t_stop</span>,  <span class="org-variable-name">subcube_t_stop</span>)  <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(t_stop,  subcube_bands)
        (<span class="org-variable-name">cache_y_start</span>, <span class="org-variable-name">subcube_y_start</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(y_start, subcube_rows)
        (<span class="org-variable-name">cache_y_stop</span>,  <span class="org-variable-name">subcube_y_stop</span>)  <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(y_stop,  subcube_rows)
        (<span class="org-variable-name">cache_x_start</span>, <span class="org-variable-name">subcube_x_start</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(x_start, subcube_cols)
        (<span class="org-variable-name">cache_x_stop</span>,  <span class="org-variable-name">subcube_x_stop</span>)  <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(x_stop,  subcube_cols)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Load, expand, and combine subcubes</span>
        <span class="org-keyword">return</span> np.block(
            [[[<span class="org-keyword">self</span>.__getOrLoadSubcube(cache_t,
                                       cache_y,
                                       cache_x
                                       ).getSubcube(
                                           (subcube_t_start    <span class="org-keyword">if</span> cache_t <span class="org-operator">==</span> cache_t_start <span class="org-keyword">else</span> 0,
                                            subcube_t_stop <span class="org-operator">+</span> 1 <span class="org-keyword">if</span> cache_t <span class="org-operator">==</span> cache_t_stop  <span class="org-keyword">else</span> subcube_bands),
                                           (subcube_y_start    <span class="org-keyword">if</span> cache_y <span class="org-operator">==</span> cache_y_start <span class="org-keyword">else</span> 0,
                                            subcube_y_stop <span class="org-operator">+</span> 1 <span class="org-keyword">if</span> cache_y <span class="org-operator">==</span> cache_y_stop  <span class="org-keyword">else</span> subcube_rows),
                                           (subcube_x_start    <span class="org-keyword">if</span> cache_x <span class="org-operator">==</span> cache_x_start <span class="org-keyword">else</span> 0,
                                            subcube_x_stop <span class="org-operator">+</span> 1 <span class="org-keyword">if</span> cache_x <span class="org-operator">==</span> cache_x_stop  <span class="org-keyword">else</span> subcube_cols)
                                       )
               <span class="org-keyword">for</span> cache_x <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cache_x_start, cache_x_stop <span class="org-operator">+</span> 1)]
              <span class="org-keyword">for</span> cache_y <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cache_y_start, cache_y_stop <span class="org-operator">+</span> 1)]
             <span class="org-keyword">for</span> cache_t <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cache_t_start, cache_t_stop <span class="org-operator">+</span> 1)]
        )


    <span class="org-keyword">def</span> <span class="org-function-name">getFullyRealizedCube</span>(<span class="org-keyword">self</span>, cache<span class="org-operator">=</span><span class="org-constant">False</span>):
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"getFullyRealizedCube is not implemented for LazySpaceTimeCube.</span><span class="org-constant">\n</span><span class="org-string">"</span>
                         <span class="org-operator">+</span> <span class="org-string">"You probably don't want to do this anyway."</span>)


    <span class="org-keyword">def</span> <span class="org-function-name">releaseFullyRealizedCube</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"releaseFullyRealizedCube is not implemented for LazySpaceTimeCube.</span><span class="org-constant">\n</span><span class="org-string">"</span>
                         <span class="org-operator">+</span> <span class="org-string">"You probably don't want to do this anyway."</span>)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-For Users" class="outline-3">
<h3 id="For Users"><span class="section-number-3">3.2.</span> For Users</h3>
<div class="outline-text-3" id="text-For Users">
<p>
In the following sections, we will use functions from <a href="https://pypi.org/project/numpy/">numpy</a> and the
Python standard library to construct arrays of different resolutions
in memory to use in our <code>SpaceTimeCube</code> and <code>LazySpaceTimeCube</code>
examples. In many real world applications, this array data will
probably be read in from files or databases using Python libraries
such as <a href="https://pypi.org/project/rasterio/">rasterio</a> or <a href="https://pypi.org/project/psycopg2/">psycopg2</a>. All examples should apply equally well
in either case.
</p>
</div>
<div id="outline-container-How to Use SpaceTimeCube" class="outline-4">
<h4 id="How to Use SpaceTimeCube"><span class="section-number-4">3.2.1.</span> How to Use SpaceTimeCube</h4>
<div class="outline-text-4" id="text-How to Use SpaceTimeCube">
</div>
<ol class="org-ol">
<li><a id="Create a SpaceTimeCube from 0D, 1D, 2D, or 3D Input Data"></a>Create a SpaceTimeCube from 0D, 1D, 2D, or 3D Input Data<br>
<div class="outline-text-5" id="text-Create a SpaceTimeCube from 0D, 1D, 2D, or 3D Input Data">
<div class="org-src-container">
<pre class="src src-python" id="space-time-cube-create"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Set a Random Seed</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

np.random.seed(0)

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube Dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (
    240,  <span class="org-comment-delimiter"># </span><span class="org-comment">bands: 10 days @ 1 hour/band</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">rows:  30 km @ 30 meters/row</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">cols:  30 km @ 30 meters/col</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Constant Data: foliar moisture = 70% everywhere</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">foliar_moisture</span> <span class="org-operator">=</span> 0.7
<span class="org-variable-name">constant_cube</span>   <span class="org-operator">=</span> SpaceTimeCube(cube_shape, foliar_moisture)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Temporal Data: 24-hour burn period with ramp up and ramp down for 10 days</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">spread_rate_adjustments</span> <span class="org-operator">=</span> ([0] <span class="org-operator">*</span> 6 <span class="org-operator">+</span> [0.33, 0.66] <span class="org-operator">+</span> [1] <span class="org-operator">*</span> 12 <span class="org-operator">+</span> [0.66, 0.33] <span class="org-operator">+</span> [0] <span class="org-operator">*</span> 2) <span class="org-operator">*</span> 10
<span class="org-variable-name">time_series_cube</span>        <span class="org-operator">=</span> SpaceTimeCube(cube_shape, spread_rate_adjustments)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Spatial Data: 2D elevation raster with 1000 (30m) x 1000 (30m) cells</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">elevation_raster</span> <span class="org-operator">=</span> np.random.normal(500, 100, 1000000).astype(<span class="org-string">"int"</span>).reshape(1000,1000)
<span class="org-variable-name">spatial_cube</span>     <span class="org-operator">=</span> SpaceTimeCube(cube_shape, elevation_raster)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Spatio-Temporal Data: 3D daily max wind speed raster with 10 (days) x 100 (300m) x 100 (300m) cells</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">wind_speed_raster</span>   <span class="org-operator">=</span> np.random.normal(30, 5, 100000).astype(<span class="org-string">"int"</span>).reshape(10,100,100)
<span class="org-variable-name">spatiotemporal_cube</span> <span class="org-operator">=</span> SpaceTimeCube(cube_shape, wind_speed_raster)
</pre>
</div>
</div>
</li>
<li><a id="Retrieve a Scalar Value at a Space-Time Coordinate"></a>Retrieve a Scalar Value at a Space-Time Coordinate<br>
<div class="outline-text-5" id="text-Retrieve a Scalar Value at a Space-Time Coordinate">
<div class="org-src-container">
<pre class="src src-python" id="space-time-cube-get-point"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinate</span>
<span class="org-variable-name">band</span> <span class="org-operator">=</span> 12
<span class="org-variable-name">row</span>  <span class="org-operator">=</span> 100
<span class="org-variable-name">col</span>  <span class="org-operator">=</span> 100

<span class="org-builtin">print</span>(<span class="org-string">"Value from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.get(band, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Value from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.get(band, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Value from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.get(band, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Value from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.get(band, row, col))
</pre>
</div>

<pre class="example" id="org2fd7e81">
Value from Constant Data: Foliar Moisture
0.7 

Value from Time Series Data: Spread Rate Adjustment
1.0 

Value from Spatial Data: Elevation
564 

Value from Spatio-Temporal Data: Wind Speed
32
</pre>
</div>
</li>
<li><a id="Retrieve a Time Series at a Spatial Coordinate"></a>Retrieve a Time Series at a Spatial Coordinate<br>
<div class="outline-text-5" id="text-Retrieve a Time Series at a Spatial Coordinate">
<div class="org-src-container">
<pre class="src src-python" id="space-time-cube-get-time-series"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinates</span>
<span class="org-variable-name">band_range</span> <span class="org-operator">=</span> (18,30)
<span class="org-variable-name">row</span>        <span class="org-operator">=</span> 100
<span class="org-variable-name">col</span>        <span class="org-operator">=</span> 100

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.getTimeSeries(band_range, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.getTimeSeries(band_range, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.getTimeSeries(band_range, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.getTimeSeries(band_range, row, col))
</pre>
</div>

<pre class="example" id="orgbb26206">
Time Series from Constant Data: Foliar Moisture
[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7] 

Time Series from Time Series Data: Spread Rate Adjustment
[1.   1.   0.66 0.33 0.   0.   0.   0.   0.   0.   0.   0.  ] 

Time Series from Spatial Data: Elevation
[564 564 564 564 564 564 564 564 564 564 564 564] 

Time Series from Spatio-Temporal Data: Wind Speed
[32 32 32 32 32 32 37 37 37 37 37 37]
</pre>
</div>
</li>
<li><a id="Retrieve a Spatial Plane at a Temporal Coordinate"></a>Retrieve a Spatial Plane at a Temporal Coordinate<br>
<div class="outline-text-5" id="text-Retrieve a Spatial Plane at a Temporal Coordinate">
<div class="org-src-container">
<pre class="src src-python" id="space-time-cube-get-spatial-plane"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinates</span>
<span class="org-variable-name">band</span>      <span class="org-operator">=</span> 12
<span class="org-variable-name">row_range</span> <span class="org-operator">=</span> (95,105)
<span class="org-variable-name">col_range</span> <span class="org-operator">=</span> (95,105)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.getSpatialPlane(band, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.getSpatialPlane(band, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.getSpatialPlane(band, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.getSpatialPlane(band, row_range, col_range))
</pre>
</div>

<pre class="example" id="org05a6fae">
Spatial Plane from Constant Data: Foliar Moisture
[[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]] 

Spatial Plane from Time Series Data: Spread Rate Adjustment
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]] 

Spatial Plane from Spatial Data: Elevation
[[574 369 544 310 517 488 565 549 450 470]
 [443 551 480 476 432 561 578 361 468 480]
 [520 712 396 393 584 292 424 391 494 586]
 [707 534 246 423 521 500 426 340 288 482]
 [542 285 607 555 645 559 461 603 330 452]
 [498 497 664 445 518 564 461 508 600 380]
 [454 500 276 487 447 591 413 378 458 508]
 [573 890 485 501 357 413 356 635 374 618]
 [535 558 491 482 539 572 598 703 463 329]
 [487 555 580 492 462 484 495 396 711 356]] 

Spatial Plane from Spatio-Temporal Data: Wind Speed
[[31 31 31 31 31 31 31 31 31 31]
 [31 31 31 31 31 31 31 31 31 31]
 [31 31 31 31 31 31 31 31 31 31]
 [31 31 31 31 31 31 31 31 31 31]
 [31 31 31 31 31 31 31 31 31 31]
 [26 26 26 26 26 32 32 32 32 32]
 [26 26 26 26 26 32 32 32 32 32]
 [26 26 26 26 26 32 32 32 32 32]
 [26 26 26 26 26 32 32 32 32 32]
 [26 26 26 26 26 32 32 32 32 32]]
</pre>
</div>
</li>
<li><a id="Retrieve a Subcube within a Space-Time Region"></a>Retrieve a Subcube within a Space-Time Region<br>
<div class="outline-text-5" id="text-Retrieve a Subcube within a Space-Time Region">
<div class="org-src-container">
<pre class="src src-python" id="space-time-cube-get-subcube"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinates</span>
<span class="org-variable-name">band_range</span> <span class="org-operator">=</span> (23,25)
<span class="org-variable-name">row_range</span>  <span class="org-operator">=</span> (95,105)
<span class="org-variable-name">col_range</span>  <span class="org-operator">=</span> (95,105)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.getSubcube(band_range, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.getSubcube(band_range, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.getSubcube(band_range, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.getSubcube(band_range, row_range, col_range))
</pre>
</div>

<pre class="example" id="org56e7da0">
Subcube from Constant Data: Foliar Moisture
[[[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]]

 [[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]]] 

Subcube from Time Series Data: Spread Rate Adjustment
[[[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]]

 [[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]]] 

Subcube from Spatial Data: Elevation
[[[574 369 544 310 517 488 565 549 450 470]
  [443 551 480 476 432 561 578 361 468 480]
  [520 712 396 393 584 292 424 391 494 586]
  [707 534 246 423 521 500 426 340 288 482]
  [542 285 607 555 645 559 461 603 330 452]
  [498 497 664 445 518 564 461 508 600 380]
  [454 500 276 487 447 591 413 378 458 508]
  [573 890 485 501 357 413 356 635 374 618]
  [535 558 491 482 539 572 598 703 463 329]
  [487 555 580 492 462 484 495 396 711 356]]

 [[574 369 544 310 517 488 565 549 450 470]
  [443 551 480 476 432 561 578 361 468 480]
  [520 712 396 393 584 292 424 391 494 586]
  [707 534 246 423 521 500 426 340 288 482]
  [542 285 607 555 645 559 461 603 330 452]
  [498 497 664 445 518 564 461 508 600 380]
  [454 500 276 487 447 591 413 378 458 508]
  [573 890 485 501 357 413 356 635 374 618]
  [535 558 491 482 539 572 598 703 463 329]
  [487 555 580 492 462 484 495 396 711 356]]] 

Subcube from Spatio-Temporal Data: Wind Speed
[[[31 31 31 31 31 31 31 31 31 31]
  [31 31 31 31 31 31 31 31 31 31]
  [31 31 31 31 31 31 31 31 31 31]
  [31 31 31 31 31 31 31 31 31 31]
  [31 31 31 31 31 31 31 31 31 31]
  [26 26 26 26 26 32 32 32 32 32]
  [26 26 26 26 26 32 32 32 32 32]
  [26 26 26 26 26 32 32 32 32 32]
  [26 26 26 26 26 32 32 32 32 32]
  [26 26 26 26 26 32 32 32 32 32]]

 [[30 30 30 30 30 36 36 36 36 36]
  [30 30 30 30 30 36 36 36 36 36]
  [30 30 30 30 30 36 36 36 36 36]
  [30 30 30 30 30 36 36 36 36 36]
  [30 30 30 30 30 36 36 36 36 36]
  [34 34 34 34 34 37 37 37 37 37]
  [34 34 34 34 34 37 37 37 37 37]
  [34 34 34 34 34 37 37 37 37 37]
  [34 34 34 34 34 37 37 37 37 37]
  [34 34 34 34 34 37 37 37 37 37]]]
</pre>
</div>
</li>
</ol>
</div>
<div id="outline-container-How to Use LazySpaceTimeCube" class="outline-4">
<h4 id="How to Use LazySpaceTimeCube"><span class="section-number-4">3.2.2.</span> How to Use LazySpaceTimeCube</h4>
<div class="outline-text-4" id="text-How to Use LazySpaceTimeCube">
</div>
<ol class="org-ol">
<li><a id="Create a LazySpaceTimeCube from 0D, 1D, 2D, or 3D Input Data"></a>Create a LazySpaceTimeCube from 0D, 1D, 2D, or 3D Input Data<br>
<div class="outline-text-5" id="text-Create a LazySpaceTimeCube from 0D, 1D, 2D, or 3D Input Data">
<div class="org-src-container">
<pre class="src src-python" id="lazy-space-time-cube-create"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube, LazySpaceTimeCube

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Set a Random Seed</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

np.random.seed(0)

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube Dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (
    240,  <span class="org-comment-delimiter"># </span><span class="org-comment">bands: 10 days @ 1 hour/band</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">rows:  30 km @ 30 meters/row</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">cols:  30 km @ 30 meters/col</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Constant Data: foliar moisture = 70% everywhere</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">foliar_moisture</span>               <span class="org-operator">=</span> 0.7
<span class="org-variable-name">foliar_moisture_subcube_shape</span> <span class="org-operator">=</span> cube_shape <span class="org-comment-delimiter"># </span><span class="org-comment">Only 1 subcube necessary</span>

<span class="org-keyword">def</span> <span class="org-function-name">foliar_moisture_load_subcube</span>(_, subcube_shape):
    <span class="org-keyword">return</span> SpaceTimeCube(subcube_shape, foliar_moisture)

<span class="org-variable-name">constant_cube</span> <span class="org-operator">=</span> LazySpaceTimeCube(cube_shape,
                                  foliar_moisture_subcube_shape,
                                  foliar_moisture_load_subcube)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Temporal Data: 24-hour burn period with ramp up and ramp down for 10 days</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">spread_rate_adjustments</span>               <span class="org-operator">=</span> ([0] <span class="org-operator">*</span> 6 <span class="org-operator">+</span> [0.33, 0.66] <span class="org-operator">+</span> [1] <span class="org-operator">*</span> 12 <span class="org-operator">+</span> [0.66, 0.33] <span class="org-operator">+</span> [0] <span class="org-operator">*</span> 2) <span class="org-operator">*</span> 10
<span class="org-variable-name">spread_rate_adjustments_subcube_shape</span> <span class="org-operator">=</span> (24, 1000, 1000) <span class="org-comment-delimiter"># </span><span class="org-comment">1 subcube per day (10 total)</span>

<span class="org-keyword">def</span> <span class="org-function-name">spread_rate_adjustments_load_subcube</span>(cache_index, subcube_shape):
    (<span class="org-variable-name">cache_t</span>, <span class="org-variable-name">_</span>, <span class="org-variable-name">_</span>) <span class="org-operator">=</span> cache_index
    <span class="org-variable-name">t_start</span> <span class="org-operator">=</span> 24 <span class="org-operator">*</span> cache_t
    <span class="org-variable-name">t_stop</span>  <span class="org-operator">=</span> 24 <span class="org-operator">*</span> (cache_t <span class="org-operator">+</span> 1)
    <span class="org-keyword">return</span> SpaceTimeCube(subcube_shape,
                         spread_rate_adjustments[t_start:t_stop])

<span class="org-variable-name">time_series_cube</span> <span class="org-operator">=</span> LazySpaceTimeCube(cube_shape,
                                     spread_rate_adjustments_subcube_shape,
                                     spread_rate_adjustments_load_subcube)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Spatial Data: 2D elevation raster with 1000 (30m) x 1000 (30m) cells</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">elevation_raster</span>               <span class="org-operator">=</span> np.random.normal(500, 100, 1000000).astype(<span class="org-string">"int"</span>).reshape(1000,1000)
<span class="org-variable-name">elevation_raster_subcube_shape</span> <span class="org-operator">=</span> (240, 100, 100) <span class="org-comment-delimiter"># </span><span class="org-comment">1 subcube per 100x100 cell region (10x10 = 100 total)</span>

<span class="org-keyword">def</span> <span class="org-function-name">elevation_raster_load_subcube</span>(cache_index, subcube_shape):
    (<span class="org-variable-name">_</span>, <span class="org-variable-name">cache_y</span>, <span class="org-variable-name">cache_x</span>) <span class="org-operator">=</span> cache_index
    <span class="org-variable-name">y_start</span> <span class="org-operator">=</span> 100 <span class="org-operator">*</span> cache_y
    <span class="org-variable-name">y_stop</span>  <span class="org-operator">=</span> 100 <span class="org-operator">*</span> (cache_y <span class="org-operator">+</span> 1)
    <span class="org-variable-name">x_start</span> <span class="org-operator">=</span> 100 <span class="org-operator">*</span> cache_x
    <span class="org-variable-name">x_stop</span>  <span class="org-operator">=</span> 100 <span class="org-operator">*</span> (cache_x <span class="org-operator">+</span> 1)
    <span class="org-keyword">return</span> SpaceTimeCube(subcube_shape,
                         elevation_raster[y_start:y_stop,
                                          x_start:x_stop])

<span class="org-variable-name">spatial_cube</span> <span class="org-operator">=</span> LazySpaceTimeCube(cube_shape,
                                 elevation_raster_subcube_shape,
                                 elevation_raster_load_subcube)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Spatio-Temporal Data: 3D daily max wind speed raster with 10 (days) x 100 (300m) x 100 (300m) cells</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">wind_speed_raster</span>               <span class="org-operator">=</span> np.random.normal(30, 5, 100000).astype(<span class="org-string">"int"</span>).reshape(10,100,100)
<span class="org-variable-name">wind_speed_raster_subcube_shape</span> <span class="org-operator">=</span> (24, 100, 100) <span class="org-comment-delimiter"># </span><span class="org-comment">1 subcube per day per 100x100 cell region (10x10x10 = 1000 total)</span>

<span class="org-keyword">def</span> <span class="org-function-name">wind_speed_raster_load_subcube</span>(cache_index, subcube_shape):
    (<span class="org-variable-name">cache_t</span>, <span class="org-variable-name">cache_y</span>, <span class="org-variable-name">cache_x</span>) <span class="org-operator">=</span> cache_index
    <span class="org-variable-name">t_start</span> <span class="org-operator">=</span> cache_t
    <span class="org-variable-name">t_stop</span>  <span class="org-operator">=</span> cache_t <span class="org-operator">+</span> 1
    <span class="org-variable-name">y_start</span> <span class="org-operator">=</span> 10 <span class="org-operator">*</span> cache_y
    <span class="org-variable-name">y_stop</span>  <span class="org-operator">=</span> 10 <span class="org-operator">*</span> (cache_y <span class="org-operator">+</span> 1)
    <span class="org-variable-name">x_start</span> <span class="org-operator">=</span> 10 <span class="org-operator">*</span> cache_x
    <span class="org-variable-name">x_stop</span>  <span class="org-operator">=</span> 10 <span class="org-operator">*</span> (cache_x <span class="org-operator">+</span> 1)
    <span class="org-keyword">return</span> SpaceTimeCube(subcube_shape,
                         wind_speed_raster[t_start:t_stop,
                                           y_start:y_stop,
                                           x_start:x_stop])

<span class="org-variable-name">spatiotemporal_cube</span> <span class="org-operator">=</span> LazySpaceTimeCube(cube_shape,
                                        wind_speed_raster_subcube_shape,
                                        wind_speed_raster_load_subcube)
</pre>
</div>
</div>
</li>
<li><a id="Retrieve a Scalar Value at a Space-Time Coordinate"></a>Retrieve a Scalar Value at a Space-Time Coordinate<br>
<div class="outline-text-5" id="text-Retrieve a Scalar Value at a Space-Time Coordinate">
<div class="org-src-container">
<pre class="src src-python" id="lazy-space-time-cube-get-point"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinate</span>
<span class="org-variable-name">band</span> <span class="org-operator">=</span> 12
<span class="org-variable-name">row</span>  <span class="org-operator">=</span> 100
<span class="org-variable-name">col</span>  <span class="org-operator">=</span> 100

<span class="org-builtin">print</span>(<span class="org-string">"Value from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.get(band, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Value from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.get(band, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Value from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.get(band, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Value from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.get(band, row, col))
</pre>
</div>

<pre class="example" id="org82b22d0">
Value from Constant Data: Foliar Moisture
0.7 

Value from Time Series Data: Spread Rate Adjustment
1.0 

Value from Spatial Data: Elevation
564 

Value from Spatio-Temporal Data: Wind Speed
32
</pre>
</div>
</li>
<li><a id="Retrieve a Time Series at a Spatial Coordinate"></a>Retrieve a Time Series at a Spatial Coordinate<br>
<div class="outline-text-5" id="text-Retrieve a Time Series at a Spatial Coordinate">
<div class="org-src-container">
<pre class="src src-python" id="lazy-space-time-cube-get-time-series"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinates</span>
<span class="org-variable-name">band_range</span> <span class="org-operator">=</span> (18,30)
<span class="org-variable-name">row</span>        <span class="org-operator">=</span> 100
<span class="org-variable-name">col</span>        <span class="org-operator">=</span> 100

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.getTimeSeries(band_range, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.getTimeSeries(band_range, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.getTimeSeries(band_range, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.getTimeSeries(band_range, row, col))
</pre>
</div>

<pre class="example" id="orga483bbe">
Time Series from Constant Data: Foliar Moisture
[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7] 

Time Series from Time Series Data: Spread Rate Adjustment
[1.   1.   0.66 0.33 0.   0.   0.   0.   0.   0.   0.   0.  ] 

Time Series from Spatial Data: Elevation
[564 564 564 564 564 564 564 564 564 564 564 564] 

Time Series from Spatio-Temporal Data: Wind Speed
[32 32 32 32 32 32 37 37 37 37 37 37]
</pre>
</div>
</li>
<li><a id="Retrieve a Spatial Plane at a Temporal Coordinate"></a>Retrieve a Spatial Plane at a Temporal Coordinate<br>
<div class="outline-text-5" id="text-Retrieve a Spatial Plane at a Temporal Coordinate">
<div class="org-src-container">
<pre class="src src-python" id="lazy-space-time-cube-get-spatial-plane"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinates</span>
<span class="org-variable-name">band</span>      <span class="org-operator">=</span> 12
<span class="org-variable-name">row_range</span> <span class="org-operator">=</span> (95,105)
<span class="org-variable-name">col_range</span> <span class="org-operator">=</span> (95,105)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.getSpatialPlane(band, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.getSpatialPlane(band, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.getSpatialPlane(band, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.getSpatialPlane(band, row_range, col_range))
</pre>
</div>

<pre class="example" id="orgcf14393">
Spatial Plane from Constant Data: Foliar Moisture
[[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]] 

Spatial Plane from Time Series Data: Spread Rate Adjustment
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]] 

Spatial Plane from Spatial Data: Elevation
[[574 369 544 310 517 488 565 549 450 470]
 [443 551 480 476 432 561 578 361 468 480]
 [520 712 396 393 584 292 424 391 494 586]
 [707 534 246 423 521 500 426 340 288 482]
 [542 285 607 555 645 559 461 603 330 452]
 [498 497 664 445 518 564 461 508 600 380]
 [454 500 276 487 447 591 413 378 458 508]
 [573 890 485 501 357 413 356 635 374 618]
 [535 558 491 482 539 572 598 703 463 329]
 [487 555 580 492 462 484 495 396 711 356]] 

Spatial Plane from Spatio-Temporal Data: Wind Speed
[[31 31 31 31 31 31 31 31 31 31]
 [31 31 31 31 31 31 31 31 31 31]
 [31 31 31 31 31 31 31 31 31 31]
 [31 31 31 31 31 31 31 31 31 31]
 [31 31 31 31 31 31 31 31 31 31]
 [26 26 26 26 26 32 32 32 32 32]
 [26 26 26 26 26 32 32 32 32 32]
 [26 26 26 26 26 32 32 32 32 32]
 [26 26 26 26 26 32 32 32 32 32]
 [26 26 26 26 26 32 32 32 32 32]]
</pre>
</div>
</li>
<li><a id="Retrieve a Subcube within a Space-Time Region"></a>Retrieve a Subcube within a Space-Time Region<br>
<div class="outline-text-5" id="text-Retrieve a Subcube within a Space-Time Region">
<div class="org-src-container">
<pre class="src src-python" id="lazy-space-time-cube-get-subcube"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinates</span>
<span class="org-variable-name">band_range</span> <span class="org-operator">=</span> (23,25)
<span class="org-variable-name">row_range</span>  <span class="org-operator">=</span> (95,105)
<span class="org-variable-name">col_range</span>  <span class="org-operator">=</span> (95,105)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.getSubcube(band_range, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.getSubcube(band_range, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.getSubcube(band_range, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.getSubcube(band_range, row_range, col_range))
</pre>
</div>

<pre class="example" id="org0d37a89">
Subcube from Constant Data: Foliar Moisture
[[[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]]

 [[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]]] 

Subcube from Time Series Data: Spread Rate Adjustment
[[[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]]

 [[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]]] 

Subcube from Spatial Data: Elevation
[[[574 369 544 310 517 488 565 549 450 470]
  [443 551 480 476 432 561 578 361 468 480]
  [520 712 396 393 584 292 424 391 494 586]
  [707 534 246 423 521 500 426 340 288 482]
  [542 285 607 555 645 559 461 603 330 452]
  [498 497 664 445 518 564 461 508 600 380]
  [454 500 276 487 447 591 413 378 458 508]
  [573 890 485 501 357 413 356 635 374 618]
  [535 558 491 482 539 572 598 703 463 329]
  [487 555 580 492 462 484 495 396 711 356]]

 [[574 369 544 310 517 488 565 549 450 470]
  [443 551 480 476 432 561 578 361 468 480]
  [520 712 396 393 584 292 424 391 494 586]
  [707 534 246 423 521 500 426 340 288 482]
  [542 285 607 555 645 559 461 603 330 452]
  [498 497 664 445 518 564 461 508 600 380]
  [454 500 276 487 447 591 413 378 458 508]
  [573 890 485 501 357 413 356 635 374 618]
  [535 558 491 482 539 572 598 703 463 329]
  [487 555 580 492 462 484 495 396 711 356]]] 

Subcube from Spatio-Temporal Data: Wind Speed
[[[31 31 31 31 31 31 31 31 31 31]
  [31 31 31 31 31 31 31 31 31 31]
  [31 31 31 31 31 31 31 31 31 31]
  [31 31 31 31 31 31 31 31 31 31]
  [31 31 31 31 31 31 31 31 31 31]
  [26 26 26 26 26 32 32 32 32 32]
  [26 26 26 26 26 32 32 32 32 32]
  [26 26 26 26 26 32 32 32 32 32]
  [26 26 26 26 26 32 32 32 32 32]
  [26 26 26 26 26 32 32 32 32 32]]

 [[30 30 30 30 30 36 36 36 36 36]
  [30 30 30 30 30 36 36 36 36 36]
  [30 30 30 30 30 36 36 36 36 36]
  [30 30 30 30 30 36 36 36 36 36]
  [30 30 30 30 30 36 36 36 36 36]
  [34 34 34 34 34 37 37 37 37 37]
  [34 34 34 34 34 37 37 37 37 37]
  [34 34 34 34 34 37 37 37 37 37]
  [34 34 34 34 34 37 37 37 37 37]
  [34 34 34 34 34 37 37 37 37 37]]]
</pre>
</div>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-[WIP] Fire Behavior Model" class="outline-2">
<h2 id="[WIP] Fire Behavior Model"><span class="section-number-2">4.</span> [WIP] Fire Behavior Model</h2>
<div class="outline-text-2" id="text-[WIP] Fire Behavior Model">
<p>
Pyretechnics implements the following fire behavior formulas from the
fire science literature:
</p>

<ul class="org-ul">
<li>Surface Fire Spread: Rothermel 1972 with FIREMODS adjustments from Albini 1976</li>
<li>Crown Fire Initiation: Van Wagner 1977</li>
<li>Passive/Active Crown Fire Spread: Cruz 2005</li>
<li>Flame Length and Fireline Intensity: Byram 1959</li>
<li>Midflame Wind Adjustment Factor: Albini &amp; Baughman 1979 parameterized as in BehavePlus, FARSITE, FlamMap, FSPro, and FPA according to Andrews 2012</li>
<li>Fire Spread on a Raster Grid: Morais 2001 (method of adaptive timesteps and fractional distances)</li>
<li>Spot Fire: Perryman 2013</li>
</ul>

<p>
The following fuel models are supported:
</p>

<ul class="org-ul">
<li>Anderson 13: no dynamic loading</li>
<li>Scott &amp; Burgan 40: dynamic loading implemented according to Scott &amp; Burgan 2005</li>
</ul>

<p>
As a library, Pyretechnics has the flexibility to implement more than
one such algorithm for the purposes of comparison in both performance
and accuracy. The following sections will introduce the spread
algorithms implemented thus far.
</p>
</div>
</div>
<div id="outline-container-Fuel Model and Moisture Definitions (pyretechnics.fuel_models)" class="outline-2">
<h2 id="Fuel Model and Moisture Definitions (pyretechnics.fuel_models)"><span class="section-number-2">5.</span> Fuel Model and Moisture Definitions (pyretechnics.fuel_models)</h2>
<div class="outline-text-2" id="text-Fuel Model and Moisture Definitions (pyretechnics.fuel_models)">
</div>
<div id="outline-container-For Developers" class="outline-3">
<h3 id="For Developers"><span class="section-number-3">5.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-For Developers">
<p>
The following sections encode various fire behavior fuel models as
Python dictionaries and then provide functions to augment their static
properties with additional information that is dependent upon fuel
moisture. This combination of fuel models and moisture form the basis
of many fire behavior analyses.
</p>
</div>
<div id="outline-container-Fuel Model Properties" class="outline-4">
<h4 id="Fuel Model Properties"><span class="section-number-4">5.1.1.</span> Fuel Model Properties</h4>
<div class="outline-text-4" id="text-Fuel Model Properties">
<p>
All fires ignite and travel through some form of burnable fuel.
Although the effects of wind and slope on the rate of fire spread can
be quite pronounced, its fundamental thermodynamic characteristics are
largely determined by the fuel type in which it is sustained. For
wildfires, these fuels are predominantly herbaceous and woody
vegetation (both alive and dead) as well as decomposing elements of
dead vegetation, such as duff or leaf litter. To estimate the heat
output and rate of spread of a fire burning through any of these
fuels, we must determine those physical properties that affect heat
absorption and release.
</p>

<p>
Of course, measuring these fuel properties for every kind of
vegetation that may be burned in a wildfire is an intractable task. To
cope with this, fuels are classified into categories called "fuel
models" which share similar burning characteristics. Each fuel model
is then assigned a set of representative values for each of the
thermally relevant physical properties shown in Table
<a href="#tab:fuel-model-properties">1</a>.
</p>

<table id="tab:fuel-model-properties">
<caption class="t-above"><span class="table-number">Table 1:</span> Physical properties assigned to each fuel model</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Property</th>
<th scope="col" class="org-left">Description</th>
<th scope="col" class="org-left">Units</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">\(\delta\)</td>
<td class="org-left">fuel depth</td>
<td class="org-left">\(\text{ft}\)</td>
</tr>

<tr>
<td class="org-left">\(w_o\)</td>
<td class="org-left">ovendry fuel loading</td>
<td class="org-left">\(\text{lb}/\text{ft}^2\)</td>
</tr>

<tr>
<td class="org-left">\(\rho_p\)</td>
<td class="org-left">ovendry particle density</td>
<td class="org-left">\(\text{lb}/\text{ft}^3\)</td>
</tr>

<tr>
<td class="org-left">\(\sigma\)</td>
<td class="org-left">fuel particle surface-area-to-volume ratio</td>
<td class="org-left">\(\text{ft}^2/\text{ft}^3\)</td>
</tr>

<tr>
<td class="org-left">\(h\)</td>
<td class="org-left">fuel particle low heat content</td>
<td class="org-left">\(\text{Btu}/\text{lb}\)</td>
</tr>

<tr>
<td class="org-left">\(S_T\)</td>
<td class="org-left">fuel particle total mineral content</td>
<td class="org-left">\(\text{lb minerals}/\text{lb ovendry weight}\)</td>
</tr>

<tr>
<td class="org-left">\(S_e\)</td>
<td class="org-left">fuel particle effective mineral content</td>
<td class="org-left">\(\text{lb silica-free minerals}/\text{lb ovendry weight}\)</td>
</tr>

<tr>
<td class="org-left">\(M_x\)</td>
<td class="org-left">fuel particle moisture of extinction</td>
<td class="org-left">\(\text{lb moisture}/\text{lb ovendry weight}\)</td>
</tr>

<tr>
<td class="org-left">\(M_f\)</td>
<td class="org-left">fuel particle moisture content</td>
<td class="org-left">\(\text{lb moisture}/\text{lb ovendry weight}\)</td>
</tr>
</tbody>
</table>

<p>
While \(M_f\) is not, in fact, directly assigned to any of these fuel
models, their definitions remain incomplete for the purposes of fire
spread modelling (particularly those reliant on the curing formulas of
dynamic fuel loading) until it is provided as a characteristic of
local weather conditions.
</p>

<p>
Although most fuel model properties are static with respect to
environmental conditions, the fuel moisture content can have two
significant impacts on a fuel model's burning potential:
</p>

<ul class="org-ul">
<li>Dynamic fuel loading</li>
<li>Live moisture of extinction</li>
</ul>

<p>
These two topics are discussed in sections <a href="#Dynamic Fuel Loading">5.1.4</a> and
<a href="#Live Moisture of Extinction">5.1.6</a>.
</p>
</div>
</div>
<div id="outline-container-Fuel Model Definitions" class="outline-4">
<h4 id="Fuel Model Definitions"><span class="section-number-4">5.1.2.</span> Fuel Model Definitions</h4>
<div class="outline-text-4" id="text-Fuel Model Definitions">
<p>
The fuel models supported by Pyretechnics include the standard 13 fuel
models of Rothermel, Albini, and Anderson<sup><a id="fnr.5" class="footref" href="#fn.5" role="doc-backlink">5</a></sup> and the
additional 40 fuel models defined by Scott and Burgan<sup><a id="fnr.6" class="footref" href="#fn.6" role="doc-backlink">6</a></sup>.
These are all concisely encoded in an internal data structure, which
may be updated to include additional custom fuel models desired by the
user.
</p>

<div class="org-src-container">
<pre class="src src-python" id="fuel-model-compact-table"><span class="org-comment-delimiter"># </span><span class="org-comment">Lookup table including entries for each of the Anderson 13 and Scott &amp; Burgan 40 fuel models.</span>
<span class="org-comment-delimiter">#</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">The fields have the following meanings:</span>
<span class="org-comment-delimiter">#   </span><span class="org-comment">{fuel-model-number : [name, delta, M_x-dead, h, w_o, sigma]}</span>
<span class="org-comment-delimiter">#</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">where:</span>
<span class="org-comment-delimiter">#   </span><span class="org-comment">w_o   = [  w_o-dead-1hr,   w_o-dead-10hr,   w_o-dead-100hr,   w_o-live-herbaceous,   w_o-live-woody]</span>
<span class="org-comment-delimiter">#   </span><span class="org-comment">sigma = [sigma-dead-1hr, sigma-dead-10hr, sigma-dead-100hr, sigma-live-herbaceous, sigma-live-woody]</span>
<span class="org-variable-name">fuel_model_compact_table</span> <span class="org-operator">=</span> {
    <span class="org-comment-delimiter"># </span><span class="org-comment">Anderson 13:</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Grass and Grass-dominated (short-grass,timber-grass-and-understory,tall-grass)</span>
    1   : [<span class="org-string">"R01"</span>, 1.0, 12, 8, [0.0340, 0.0000, 0.0000, 0.0000, 0.0000], [3500.0,   0.0,  0.0,    0.0,    0.0]],
    2   : [<span class="org-string">"R02"</span>, 1.0, 15, 8, [0.0920, 0.0460, 0.0230, 0.0230, 0.0000], [3000.0, 109.0, 30.0, 1500.0,    0.0]],
    3   : [<span class="org-string">"R03"</span>, 2.5, 25, 8, [0.1380, 0.0000, 0.0000, 0.0000, 0.0000], [1500.0,   0.0,  0.0,    0.0,    0.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Chaparral and Shrubfields (chaparral,brush,dormant-brush-hardwood-slash,southern-rough)</span>
    4   : [<span class="org-string">"R04"</span>, 6.0, 20, 8, [0.2300, 0.1840, 0.0920, 0.2300, 0.0000], [2000.0, 109.0, 30.0, 1500.0,    0.0]],
    5   : [<span class="org-string">"R05"</span>, 2.0, 20, 8, [0.0460, 0.0230, 0.0000, 0.0920, 0.0000], [2000.0, 109.0,  0.0, 1500.0,    0.0]],
    6   : [<span class="org-string">"R06"</span>, 2.5, 25, 8, [0.0690, 0.1150, 0.0920, 0.0000, 0.0000], [1750.0, 109.0, 30.0,    0.0,    0.0]],
    7   : [<span class="org-string">"R07"</span>, 2.5, 40, 8, [0.0520, 0.0860, 0.0690, 0.0170, 0.0000], [1750.0, 109.0, 30.0, 1550.0,    0.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Timber Litter (closed-timber-litter,hardwood-litter,timber-litter-and-understory)</span>
    8   : [<span class="org-string">"R08"</span>, 0.2, 30, 8, [0.0690, 0.0460, 0.1150, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    9   : [<span class="org-string">"R09"</span>, 0.2, 25, 8, [0.1340, 0.0190, 0.0070, 0.0000, 0.0000], [2500.0, 109.0, 30.0,    0.0,    0.0]],
    10  : [<span class="org-string">"R10"</span>, 1.0, 25, 8, [0.1380, 0.0920, 0.2300, 0.0920, 0.0000], [2000.0, 109.0, 30.0, 1500.0,    0.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Logging Slash (light-logging-slash,medium-logging-slash,heavy-logging-slash)</span>
    11  : [<span class="org-string">"R11"</span>, 1.0, 15, 8, [0.0690, 0.2070, 0.2530, 0.0000, 0.0000], [1500.0, 109.0, 30.0,    0.0,    0.0]],
    12  : [<span class="org-string">"R12"</span>, 2.3, 20, 8, [0.1840, 0.6440, 0.7590, 0.0000, 0.0000], [1500.0, 109.0, 30.0,    0.0,    0.0]],
    13  : [<span class="org-string">"R13"</span>, 3.0, 25, 8, [0.3220, 1.0580, 1.2880, 0.0000, 0.0000], [1500.0, 109.0, 30.0,    0.0,    0.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Nonburnable (NB)</span>
    91  : [<span class="org-string">"NB1"</span>, 0.0,  0, 0, [0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [   0.0,   0.0,  0.0,    0.0,    0.0]],
    92  : [<span class="org-string">"NB2"</span>, 0.0,  0, 0, [0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [   0.0,   0.0,  0.0,    0.0,    0.0]],
    93  : [<span class="org-string">"NB3"</span>, 0.0,  0, 0, [0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [   0.0,   0.0,  0.0,    0.0,    0.0]],
    98  : [<span class="org-string">"NB4"</span>, 0.0,  0, 0, [0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [   0.0,   0.0,  0.0,    0.0,    0.0]],
    99  : [<span class="org-string">"NB5"</span>, 0.0,  0, 0, [0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [   0.0,   0.0,  0.0,    0.0,    0.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Scott &amp; Burgan 40:</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Grass (GR)</span>
    101 : [<span class="org-string">"GR1"</span>, 0.4, 15, 8, [0.0046, 0.0000, 0.0000, 0.0138, 0.0000], [2200.0, 109.0, 30.0, 2000.0,    0.0]],
    102 : [<span class="org-string">"GR2"</span>, 1.0, 15, 8, [0.0046, 0.0000, 0.0000, 0.0459, 0.0000], [2000.0, 109.0, 30.0, 1800.0,    0.0]],
    103 : [<span class="org-string">"GR3"</span>, 2.0, 30, 8, [0.0046, 0.0184, 0.0000, 0.0689, 0.0000], [1500.0, 109.0, 30.0, 1300.0,    0.0]],
    104 : [<span class="org-string">"GR4"</span>, 2.0, 15, 8, [0.0115, 0.0000, 0.0000, 0.0872, 0.0000], [2000.0, 109.0, 30.0, 1800.0,    0.0]],
    105 : [<span class="org-string">"GR5"</span>, 1.5, 40, 8, [0.0184, 0.0000, 0.0000, 0.1148, 0.0000], [1800.0, 109.0, 30.0, 1600.0,    0.0]],
    106 : [<span class="org-string">"GR6"</span>, 1.5, 40, 9, [0.0046, 0.0000, 0.0000, 0.1561, 0.0000], [2200.0, 109.0, 30.0, 2000.0,    0.0]],
    107 : [<span class="org-string">"GR7"</span>, 3.0, 15, 8, [0.0459, 0.0000, 0.0000, 0.2479, 0.0000], [2000.0, 109.0, 30.0, 1800.0,    0.0]],
    108 : [<span class="org-string">"GR8"</span>, 4.0, 30, 8, [0.0230, 0.0459, 0.0000, 0.3352, 0.0000], [1500.0, 109.0, 30.0, 1300.0,    0.0]],
    109 : [<span class="org-string">"GR9"</span>, 5.0, 40, 8, [0.0459, 0.0459, 0.0000, 0.4132, 0.0000], [1800.0, 109.0, 30.0, 1600.0,    0.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Grass-Shrub (GS)</span>
    121 : [<span class="org-string">"GS1"</span>, 0.9, 15, 8, [0.0092, 0.0000, 0.0000, 0.0230, 0.0298], [2000.0, 109.0, 30.0, 1800.0, 1800.0]],
    122 : [<span class="org-string">"GS2"</span>, 1.5, 15, 8, [0.0230, 0.0230, 0.0000, 0.0275, 0.0459], [2000.0, 109.0, 30.0, 1800.0, 1800.0]],
    123 : [<span class="org-string">"GS3"</span>, 1.8, 40, 8, [0.0138, 0.0115, 0.0000, 0.0666, 0.0574], [1800.0, 109.0, 30.0, 1600.0, 1600.0]],
    124 : [<span class="org-string">"GS4"</span>, 2.1, 40, 8, [0.0872, 0.0138, 0.0046, 0.1561, 0.3260], [1800.0, 109.0, 30.0, 1600.0, 1600.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Shrub (SH)</span>
    141 : [<span class="org-string">"SH1"</span>, 1.0, 15, 8, [0.0115, 0.0115, 0.0000, 0.0069, 0.0597], [2000.0, 109.0, 30.0, 1800.0, 1600.0]],
    142 : [<span class="org-string">"SH2"</span>, 1.0, 15, 8, [0.0620, 0.1102, 0.0344, 0.0000, 0.1768], [2000.0, 109.0, 30.0,    0.0, 1600.0]],
    143 : [<span class="org-string">"SH3"</span>, 2.4, 40, 8, [0.0207, 0.1377, 0.0000, 0.0000, 0.2847], [1600.0, 109.0, 30.0,    0.0, 1400.0]],
    144 : [<span class="org-string">"SH4"</span>, 3.0, 30, 8, [0.0390, 0.0528, 0.0092, 0.0000, 0.1171], [2000.0, 109.0, 30.0, 1800.0, 1600.0]],
    145 : [<span class="org-string">"SH5"</span>, 6.0, 15, 8, [0.1653, 0.0964, 0.0000, 0.0000, 0.1331], [ 750.0, 109.0, 30.0,    0.0, 1600.0]],
    146 : [<span class="org-string">"SH6"</span>, 2.0, 30, 8, [0.1331, 0.0666, 0.0000, 0.0000, 0.0643], [ 750.0, 109.0, 30.0,    0.0, 1600.0]],
    147 : [<span class="org-string">"SH7"</span>, 6.0, 15, 8, [0.1607, 0.2433, 0.1010, 0.0000, 0.1561], [ 750.0, 109.0, 30.0,    0.0, 1600.0]],
    148 : [<span class="org-string">"SH8"</span>, 3.0, 40, 8, [0.0941, 0.1561, 0.0390, 0.0000, 0.1997], [ 750.0, 109.0, 30.0,    0.0, 1600.0]],
    149 : [<span class="org-string">"SH9"</span>, 4.4, 40, 8, [0.2066, 0.1125, 0.0000, 0.0712, 0.3214], [ 750.0, 109.0, 30.0, 1800.0, 1500.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Timber-Understory (TU)</span>
    161 : [<span class="org-string">"TU1"</span>, 0.6, 20, 8, [0.0092, 0.0413, 0.0689, 0.0092, 0.0413], [2000.0, 109.0, 30.0, 1800.0, 1600.0]],
    162 : [<span class="org-string">"TU2"</span>, 1.0, 30, 8, [0.0436, 0.0826, 0.0574, 0.0000, 0.0092], [2000.0, 109.0, 30.0,    0.0, 1600.0]],
    163 : [<span class="org-string">"TU3"</span>, 1.3, 30, 8, [0.0505, 0.0069, 0.0115, 0.0298, 0.0505], [1800.0, 109.0, 30.0, 1600.0, 1400.0]],
    164 : [<span class="org-string">"TU4"</span>, 0.5, 12, 8, [0.2066, 0.0000, 0.0000, 0.0000, 0.0918], [2300.0, 109.0, 30.0,    0.0, 2000.0]],
    165 : [<span class="org-string">"TU5"</span>, 1.0, 25, 8, [0.1837, 0.1837, 0.1377, 0.0000, 0.1377], [1500.0, 109.0, 30.0,    0.0,  750.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Timber Litter (TL)</span>
    181 : [<span class="org-string">"TL1"</span>, 0.2, 30, 8, [0.0459, 0.1010, 0.1653, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    182 : [<span class="org-string">"TL2"</span>, 0.2, 25, 8, [0.0643, 0.1056, 0.1010, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    183 : [<span class="org-string">"TL3"</span>, 0.3, 20, 8, [0.0230, 0.1010, 0.1286, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    184 : [<span class="org-string">"TL4"</span>, 0.4, 25, 8, [0.0230, 0.0689, 0.1928, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    185 : [<span class="org-string">"TL5"</span>, 0.6, 25, 8, [0.0528, 0.1148, 0.2020, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0, 1600.0]],
    186 : [<span class="org-string">"TL6"</span>, 0.3, 25, 8, [0.1102, 0.0551, 0.0551, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    187 : [<span class="org-string">"TL7"</span>, 0.4, 25, 8, [0.0138, 0.0643, 0.3719, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    188 : [<span class="org-string">"TL8"</span>, 0.3, 35, 8, [0.2663, 0.0643, 0.0505, 0.0000, 0.0000], [1800.0, 109.0, 30.0,    0.0,    0.0]],
    189 : [<span class="org-string">"TL9"</span>, 0.6, 35, 8, [0.3053, 0.1515, 0.1905, 0.0000, 0.0000], [1800.0, 109.0, 30.0,    0.0, 1600.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Slash-Blowdown (SB)</span>
    201 : [<span class="org-string">"SB1"</span>, 1.0, 25, 8, [0.0689, 0.1377, 0.5051, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    202 : [<span class="org-string">"SB2"</span>, 1.0, 25, 8, [0.2066, 0.1951, 0.1837, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    203 : [<span class="org-string">"SB3"</span>, 1.2, 25, 8, [0.2525, 0.1263, 0.1377, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    204 : [<span class="org-string">"SB4"</span>, 2.7, 25, 8, [0.2410, 0.1607, 0.2410, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
}
</pre>
</div>

<p>
Although this compact data structure contains all the properties that
vary by fuel model (i.e., \(\delta\), \(w_o\), \(\sigma\),
\(M_{x-\text{dead}}\), \(h\)), several of their values need to be
multiplied by a coefficient to make their units match those listed in
Table <a href="#tab:fuel-model-properties">1</a>. We also need to add in the missing
\(\rho_p\), \(S_T\), and \(S_e\) values, which are constant across all of
these fuel models, and to expand those properties whose values may
vary by size class into lists with the following encoding:
</p>

<pre class="example" id="orgccf519a">
[dead_1hr dead_10hr dead_100hr dead_herbaceous live_herbaceous live_woody]
</pre>

<p>
As a performance optimization, we set the dead herbaceous values that
don't depend on fuel moisture for the dynamic Scott &amp; Burgan 40 fuel
models. Finally, we add two boolean properties (<code>dynamic</code> and
<code>burnable</code>) to each fuel model for reference in later calculations.
</p>

<div class="org-src-container">
<pre class="src src-python" id="expand-compact-fuel-model-table"><span class="org-keyword">def</span> <span class="org-function-name">expand_compact_fuel_model</span>(fuel_model_number):
    [<span class="org-variable-name">name</span>, <span class="org-variable-name">delta</span>, <span class="org-variable-name">M_x_dead</span>, <span class="org-variable-name">h</span>, <span class="org-variable-name">w_o</span>, <span class="org-variable-name">sigma</span>] <span class="org-operator">=</span> fuel_model_compact_table[fuel_model_number]
    [<span class="org-variable-name">w_o_dead_1hr</span>, <span class="org-variable-name">w_o_dead_10hr</span>, <span class="org-variable-name">w_o_dead_100hr</span>, <span class="org-variable-name">w_o_live_herbaceous</span>, <span class="org-variable-name">w_o_live_woody</span>] <span class="org-operator">=</span> w_o
    [<span class="org-variable-name">sigma_dead_1hr</span>, <span class="org-variable-name">sigma_dead_10hr</span>, <span class="org-variable-name">sigma_dead_100hr</span>, <span class="org-variable-name">sigma_live_herbaceous</span>, <span class="org-variable-name">sigma_live_woody</span>] <span class="org-operator">=</span> sigma
    <span class="org-variable-name">M_x_dead</span> <span class="org-operator">=</span> M_x_dead <span class="org-operator">*</span> 0.01
    <span class="org-variable-name">h</span>        <span class="org-operator">=</span> h <span class="org-operator">*</span> 1000.0
    <span class="org-comment-delimiter"># </span><span class="org-comment">Conditionally set dead_herbaceous values</span>
    <span class="org-variable-name">dynamic</span>               <span class="org-operator">=</span> fuel_model_number <span class="org-operator">&gt;</span> 100 <span class="org-keyword">and</span> w_o_live_herbaceous <span class="org-operator">&gt;</span> 0.0
    <span class="org-variable-name">M_x_dead_herbaceous</span>   <span class="org-operator">=</span> M_x_dead              <span class="org-keyword">if</span> dynamic <span class="org-keyword">else</span> 0.0
    <span class="org-variable-name">sigma_dead_herbaceous</span> <span class="org-operator">=</span> sigma_live_herbaceous <span class="org-keyword">if</span> dynamic <span class="org-keyword">else</span> 0.0
    <span class="org-keyword">return</span> {
        <span class="org-string">"name"</span>    : name,
        <span class="org-string">"number"</span>  : fuel_model_number,
        <span class="org-string">"delta"</span>   : delta,
        <span class="org-string">"M_x"</span>     : [M_x_dead, M_x_dead, M_x_dead, M_x_dead_herbaceous, 0.0, 0.0],
        <span class="org-string">"w_o"</span>     : [w_o_dead_1hr, w_o_dead_10hr, w_o_dead_100hr, 0.0, w_o_live_herbaceous, w_o_live_woody],
        <span class="org-string">"sigma"</span>   : [sigma_dead_1hr, sigma_dead_10hr, sigma_dead_100hr, sigma_dead_herbaceous, sigma_live_herbaceous, sigma_live_woody],
        <span class="org-string">"h"</span>       : 6 <span class="org-operator">*</span> [h],
        <span class="org-string">"rho_p"</span>   : 6 <span class="org-operator">*</span> [32.0],
        <span class="org-string">"S_T"</span>     : 6 <span class="org-operator">*</span> [0.0555],
        <span class="org-string">"S_e"</span>     : 6 <span class="org-operator">*</span> [0.01],
        <span class="org-string">"dynamic"</span> : dynamic,
        <span class="org-string">"burnable"</span>: <span class="org-keyword">not</span> (91 <span class="org-operator">&lt;=</span> fuel_model_number <span class="org-operator">&lt;=</span> 99),
    }


<span class="org-variable-name">fuel_model_table</span> <span class="org-operator">=</span> {k: expand_compact_fuel_model(k) <span class="org-keyword">for</span> k <span class="org-keyword">in</span> fuel_model_compact_table.keys()}
</pre>
</div>
</div>
</div>
<div id="outline-container-Fuel Categories and Size Classes" class="outline-4">
<h4 id="Fuel Categories and Size Classes"><span class="section-number-4">5.1.3.</span> Fuel Categories and Size Classes</h4>
<div class="outline-text-4" id="text-Fuel Categories and Size Classes">
<p>
Each fuel model applies to a collection of burnable material that may
be live or dead and whose constituent elements may vary in size
considerably.
</p>

<p>
The two terms <b>category</b> and <b>size class</b> are used to describe this
heterogeneity within each fuel model.
</p>

<p>
In Pyretechnics, when we refer to a fuel category, we mean one of
these two values:
</p>

<ul class="org-ul">
<li>Dead</li>
<li>Live</li>
</ul>

<p>
When we refer to a fuel size class, we mean one of these six values:
</p>

<ul class="org-ul">
<li>Dead 1 hour (&lt; 1/4" diameter)</li>
<li>Dead 10 hour (1/4"-1" diameter)</li>
<li>Dead 100 hour (1"-3" diameter)</li>
<li>Dead herbaceous (dynamic fuel models only)</li>
<li>Live herbaceous</li>
<li>Live woody</li>
</ul>

<p>
In order to more easily encode mathematical operations over these fuel
categories and size classes, we define a collection of utility
functions that will later be used in both the fuel moisture and
surface fire equations.
</p>

<div class="org-src-container">
<pre class="src src-python" id="fuel-category-and-size-class-functions"><span class="org-keyword">def</span> <span class="org-function-name">map_category</span>(f):
    <span class="org-keyword">return</span> [f(0), f(1)]


<span class="org-keyword">def</span> <span class="org-function-name">map_size_class</span>(f):
    <span class="org-keyword">return</span> [f(0), f(1), f(2), f(3), f(4), f(5)]


<span class="org-keyword">def</span> <span class="org-function-name">category_sum</span>(f):
    <span class="org-keyword">return</span> f(0) <span class="org-operator">+</span> f(1)


<span class="org-keyword">def</span> <span class="org-function-name">size_class_sum</span>(f):
    <span class="org-keyword">return</span> [f(0) <span class="org-operator">+</span> f(1) <span class="org-operator">+</span> f(2) <span class="org-operator">+</span> f(3), f(4) <span class="org-operator">+</span> f(5)]
</pre>
</div>
</div>
</div>
<div id="outline-container-Dynamic Fuel Loading" class="outline-4">
<h4 id="Dynamic Fuel Loading"><span class="section-number-4">5.1.4.</span> Dynamic Fuel Loading</h4>
<div class="outline-text-4" id="text-Dynamic Fuel Loading">
<p>
All of the Scott &amp; Burgan 40 fuel models with a live herbaceous
component are considered dynamic. In these models, a fraction of the
live herbaceous load is transferred to a new dead herbaceous category
as a function of live herbaceous moisture content (see equation
below).<sup><a id="fnr.7" class="footref" href="#fn.7" role="doc-backlink">7</a></sup> The dead herbaceous size class uses the dead 1
hour moisture content, dead moisture of extinction, and live
herbaceous surface-area-to-volume-ratio. In the following formula,
\(M_f^{lh}\) is the live herbaceous moisture content.
</p>

\begin{align}
  \text{FractionGreen} &= \left\{
    \begin{array}{lr}
      0 & M_f^{lh} \le 0.3 \\
      1 & M_f^{lh} \ge 1.2 \\
      M_f^{lh} / 0.9 - 1/3 & \text{else}
    \end{array}
  \right. \\
  \nonumber \\
  \text{FractionCured} &= 1 - \text{FractionGreen}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="add-dynamic-fuel-loading"><span class="org-keyword">def</span> <span class="org-function-name">add_dynamic_fuel_loading</span>(fuel_model, M_f):
    <span class="org-keyword">if</span> fuel_model[<span class="org-string">"dynamic"</span>]:
        <span class="org-comment-delimiter"># </span><span class="org-comment">dynamic fuel model</span>
        <span class="org-variable-name">w_o</span>                       <span class="org-operator">=</span> fuel_model[<span class="org-string">"w_o"</span>]
        <span class="org-variable-name">live_herbaceous_load</span>      <span class="org-operator">=</span> w_o[4]
        <span class="org-variable-name">live_herbaceous_moisture</span>  <span class="org-operator">=</span> M_f[4]
        <span class="org-variable-name">fraction_green</span>            <span class="org-operator">=</span> <span class="org-builtin">max</span>(0.0, <span class="org-builtin">min</span>(1.0, (live_herbaceous_moisture <span class="org-operator">/</span> 0.9) <span class="org-operator">-</span> 0.3333333333333333))
        <span class="org-variable-name">fraction_cured</span>            <span class="org-operator">=</span> 1.0 <span class="org-operator">-</span> fraction_green
        <span class="org-variable-name">dynamic_fuel_model</span>        <span class="org-operator">=</span> fuel_model.copy() <span class="org-comment-delimiter"># </span><span class="org-comment">shallow copy</span>
        <span class="org-variable-name">dynamic_fuel_model</span>[<span class="org-string">"M_f"</span>] <span class="org-operator">=</span> [
            M_f[0],
            M_f[1],
            M_f[2],
            M_f[0], <span class="org-comment-delimiter"># </span><span class="org-comment">set dead_herbaceous to dead_1hr</span>
            M_f[4],
            M_f[5],
        ]
        <span class="org-variable-name">dynamic_fuel_model</span>[<span class="org-string">"w_o"</span>] <span class="org-operator">=</span> [
            w_o[0],
            w_o[1],
            w_o[2],
            live_herbaceous_load <span class="org-operator">*</span> fraction_cured, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_herbaceous</span>
            live_herbaceous_load <span class="org-operator">*</span> fraction_green, <span class="org-comment-delimiter"># </span><span class="org-comment">live_herbaceous</span>
            w_o[5],
        ]
        <span class="org-keyword">return</span> dynamic_fuel_model
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">static fuel model</span>
        <span class="org-variable-name">static_fuel_model</span> <span class="org-operator">=</span> fuel_model.copy() <span class="org-comment-delimiter"># </span><span class="org-comment">shallow copy</span>
        <span class="org-variable-name">static_fuel_model</span>[<span class="org-string">"M_f"</span>] <span class="org-operator">=</span> M_f
        <span class="org-keyword">return</span> static_fuel_model
</pre>
</div>
</div>
</div>
<div id="outline-container-Size Class Weighting Factors" class="outline-4">
<h4 id="Size Class Weighting Factors"><span class="section-number-4">5.1.5.</span> Size Class Weighting Factors</h4>
<div class="outline-text-4" id="text-Size Class Weighting Factors">
<p>
Once the dynamic fuel loading is applied, we can compute the size
class weighting factors expressed in equations 53-57 in Rothermel
1972<sup><a id="fnr.8" class="footref" href="#fn.8" role="doc-backlink">8</a></sup>. For brevity, these formulas are elided from
this text.
</p>

<div class="org-src-container">
<pre class="src src-python" id="add-weighting-factors"><span class="org-keyword">def</span> <span class="org-function-name">add_weighting_factors</span>(fuel_model):
    <span class="org-variable-name">w_o</span>                         <span class="org-operator">=</span> fuel_model[<span class="org-string">"w_o"</span>]
    <span class="org-variable-name">sigma</span>                       <span class="org-operator">=</span> fuel_model[<span class="org-string">"sigma"</span>]
    <span class="org-variable-name">rho_p</span>                       <span class="org-operator">=</span> fuel_model[<span class="org-string">"rho_p"</span>]
    <span class="org-variable-name">A_ij</span>                        <span class="org-operator">=</span> map_size_class(<span class="org-keyword">lambda</span> i: (sigma[i] <span class="org-operator">*</span> w_o[i]) <span class="org-operator">/</span> rho_p[i])
    <span class="org-variable-name">A_i</span>                         <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: A_ij[i])
    <span class="org-variable-name">A_T</span>                         <span class="org-operator">=</span> category_sum(<span class="org-keyword">lambda</span> i: A_i[i])
    <span class="org-variable-name">f_ij</span>                        <span class="org-operator">=</span> map_size_class(<span class="org-keyword">lambda</span> i: (<span class="org-keyword">lambda</span> A: (A_ij[i] <span class="org-operator">/</span> A) <span class="org-keyword">if</span> A <span class="org-operator">&gt;</span> 0.0 <span class="org-keyword">else</span> 0.0)(A_i[i<span class="org-operator">//</span>4]))
    <span class="org-variable-name">f_i</span>                         <span class="org-operator">=</span> map_category(<span class="org-keyword">lambda</span> i: (A_i[i] <span class="org-operator">/</span> A_T) <span class="org-keyword">if</span> A_T <span class="org-operator">&gt;</span> 0.0 <span class="org-keyword">else</span> 0.0)
    <span class="org-variable-name">firemod_size_classes</span>        <span class="org-operator">=</span> map_size_class(<span class="org-keyword">lambda</span> i: (<span class="org-keyword">lambda</span> s:
                                                            1 <span class="org-keyword">if</span> (s <span class="org-operator">&gt;=</span> 1200.0)
                                                            <span class="org-keyword">else</span> 2 <span class="org-keyword">if</span> (s <span class="org-operator">&gt;=</span> 192.0)
                                                            <span class="org-keyword">else</span> 3 <span class="org-keyword">if</span> (s <span class="org-operator">&gt;=</span> 96.0)
                                                            <span class="org-keyword">else</span> 4 <span class="org-keyword">if</span> (s <span class="org-operator">&gt;=</span> 48.0)
                                                            <span class="org-keyword">else</span> 5 <span class="org-keyword">if</span> (s <span class="org-operator">&gt;=</span> 16.0)
                                                            <span class="org-keyword">else</span> 6
                                                            )(sigma[i]))
    <span class="org-variable-name">g_ij</span>                        <span class="org-operator">=</span> map_size_class(<span class="org-keyword">lambda</span> i: (<span class="org-keyword">lambda</span> c:
                                                            ((f_ij[0] <span class="org-keyword">if</span> (c <span class="org-operator">==</span> firemod_size_classes[0]) <span class="org-keyword">else</span> 0.0)
                                                             <span class="org-operator">+</span> (f_ij[1] <span class="org-keyword">if</span> (c <span class="org-operator">==</span> firemod_size_classes[1]) <span class="org-keyword">else</span> 0.0)
                                                             <span class="org-operator">+</span> (f_ij[2] <span class="org-keyword">if</span> (c <span class="org-operator">==</span> firemod_size_classes[2]) <span class="org-keyword">else</span> 0.0)
                                                             <span class="org-operator">+</span> (f_ij[3] <span class="org-keyword">if</span> (c <span class="org-operator">==</span> firemod_size_classes[3]) <span class="org-keyword">else</span> 0.0))
                                                            <span class="org-keyword">if</span> (i <span class="org-operator">&lt;</span> 4) <span class="org-keyword">else</span>
                                                            ((f_ij[4] <span class="org-keyword">if</span> (c <span class="org-operator">==</span> firemod_size_classes[4]) <span class="org-keyword">else</span> 0.0)
                                                             <span class="org-operator">+</span> (f_ij[5] <span class="org-keyword">if</span> (c <span class="org-operator">==</span> firemod_size_classes[5]) <span class="org-keyword">else</span> 0.0))
                                                            )(firemod_size_classes[i]))
    <span class="org-variable-name">weighted_fuel_model</span>         <span class="org-operator">=</span> fuel_model.copy() <span class="org-comment-delimiter"># </span><span class="org-comment">shallow copy</span>
    <span class="org-variable-name">weighted_fuel_model</span>[<span class="org-string">"f_ij"</span>] <span class="org-operator">=</span> f_ij
    <span class="org-variable-name">weighted_fuel_model</span>[<span class="org-string">"f_i"</span>]  <span class="org-operator">=</span> f_i
    <span class="org-variable-name">weighted_fuel_model</span>[<span class="org-string">"g_ij"</span>] <span class="org-operator">=</span> g_ij
    <span class="org-keyword">return</span> weighted_fuel_model
</pre>
</div>
</div>
</div>
<div id="outline-container-Live Moisture of Extinction" class="outline-4">
<h4 id="Live Moisture of Extinction"><span class="section-number-4">5.1.6.</span> Live Moisture of Extinction</h4>
<div class="outline-text-4" id="text-Live Moisture of Extinction">
<p>
The live moisture of extinction for each fuel model is determined from
the dead fuel moisture content, the dead moisture of extinction, and
the ratio of dead fuel loading to live fuel loading using Equation 88
from Rothermel 1972, adjusted according to Albini 1976 Appendix III to
match the behavior of Albini's original FIREMODS
library.<sup><a id="fnr.9" class="footref" href="#fn.9" role="doc-backlink">9</a></sup><sup>, </sup><sup><a id="fnr.10" class="footref" href="#fn.10" role="doc-backlink">10</a></sup> Whenever the fuel moisture
content becomes greater than or equal to the moisture of extinction, a
fire will no longer spread through that fuel. Here are the formulas
referenced above:
</p>

\begin{align}
  M_x^l &= \max(M_x^d, 2.9 \, W' \, (1 - M_f^d / M_x^d) - 0.226) \\
  \nonumber \\
  W' &= \frac{\sum_{c \in D}{w_o^c \> e^{-138/\sigma^c}}}{\sum_{c \in L}{w_o^c \> e^{-500/\sigma^c}}} \\
  \nonumber \\
  M_f^d &= \frac{\sum_{c \in D}{w_o^c \> M_f^c \> e^{-138/\sigma^c}}}{\sum_{c \in D}{w_o^c \> e^{-138/\sigma^c}}}
\end{align}

<p>
where \(M_{x}^{l}\) is the live moisture of extinction, \(M_{x}^{d}\) is
the dead moisture of extinction, \(D\) is the set of dead fuel size
classes (1hr, 10hr, 100hr, herbaceous), \(L\) is the set of live fuel
size classes (herbaceous, woody), \(w_{o}^{c}\) is the dry weight
loading of size class \(c\), \(\sigma^{c}\) is the surface area to volume
ratio of size class \(c\), and \(M_{f}^{c}\) is the moisture content of
size class \(c\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="add-live-moisture-of-extinction"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> exp

<span class="org-keyword">def</span> <span class="org-function-name">add_live_moisture_of_extinction</span>(fuel_model):
    <span class="org-doc">"""</span>
<span class="org-doc">    Equation 88 from Rothermel 1972 adjusted by Albini 1976 Appendix III.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">w_o</span>                       <span class="org-operator">=</span> fuel_model[<span class="org-string">"w_o"</span>]
    <span class="org-variable-name">sigma</span>                     <span class="org-operator">=</span> fuel_model[<span class="org-string">"sigma"</span>]
    <span class="org-variable-name">M_f</span>                       <span class="org-operator">=</span> fuel_model[<span class="org-string">"M_f"</span>]
    <span class="org-variable-name">M_x</span>                       <span class="org-operator">=</span> fuel_model[<span class="org-string">"M_x"</span>]
    <span class="org-variable-name">loading_factors</span>           <span class="org-operator">=</span> map_size_class(<span class="org-keyword">lambda</span> i:
                                               (<span class="org-keyword">lambda</span> sigma_ij, A:
                                                w_o[i] <span class="org-operator">*</span> exp(A <span class="org-operator">/</span> sigma_ij) <span class="org-keyword">if</span> (sigma_ij <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 0.0
                                                )(sigma[i], <span class="org-operator">-</span>138.0 <span class="org-keyword">if</span> (i <span class="org-operator">&lt;</span> 4) <span class="org-keyword">else</span> <span class="org-operator">-</span>500.0))
    [dead_loading_factor,
     live_loading_factor]     <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: loading_factors[i])
    [<span class="org-variable-name">dead_moisture_factor</span>, <span class="org-variable-name">_</span>] <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: M_f[i] <span class="org-operator">*</span> loading_factors[i])
    <span class="org-variable-name">dead_to_live_ratio</span>        <span class="org-operator">=</span> (dead_loading_factor <span class="org-operator">/</span> live_loading_factor) <span class="org-keyword">if</span> (live_loading_factor <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> <span class="org-constant">None</span>
    <span class="org-variable-name">dead_fuel_moisture</span>        <span class="org-operator">=</span> (dead_moisture_factor <span class="org-operator">/</span> dead_loading_factor) <span class="org-keyword">if</span> (dead_loading_factor <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 0.0
    <span class="org-variable-name">M_x_dead</span>                  <span class="org-operator">=</span> M_x[0]
    <span class="org-variable-name">M_x_live</span>                  <span class="org-operator">=</span> <span class="org-builtin">max</span>(M_x_dead,
                                    (2.9 <span class="org-operator">*</span> dead_to_live_ratio <span class="org-operator">*</span> (1.0 <span class="org-operator">-</span> (dead_fuel_moisture <span class="org-operator">/</span> M_x_dead))) <span class="org-operator">-</span> 0.226
                                    ) <span class="org-keyword">if</span> (live_loading_factor <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> M_x_dead
    <span class="org-variable-name">moisturized_fuel_model</span>    <span class="org-operator">=</span> fuel_model.copy() <span class="org-comment-delimiter"># </span><span class="org-comment">shallow copy</span>
    <span class="org-variable-name">moisturized_fuel_model</span>[<span class="org-string">"M_x"</span>] <span class="org-operator">=</span> [
        M_x[0],
        M_x[1],
        M_x[2],
        M_x[3],
        M_x_live,
        M_x_live,
    ]
    <span class="org-keyword">return</span> moisturized_fuel_model
</pre>
</div>
</div>
</div>
<div id="outline-container-Applying Fuel Moisture to a Fuel Model" class="outline-4">
<h4 id="Applying Fuel Moisture to a Fuel Model"><span class="section-number-4">5.1.7.</span> Applying Fuel Moisture to a Fuel Model</h4>
<div class="outline-text-4" id="text-Applying Fuel Moisture to a Fuel Model">
<p>
The preceding sections augmented the baseline fuel models by adding
dynamic fuel loading (section <a href="#Dynamic Fuel Loading">5.1.4</a>), size class
weighting factors (section <a href="#Size Class Weighting Factors">5.1.5</a>), and live
moisture of extinction (section <a href="#Live Moisture of Extinction">5.1.6</a>). In
typical usage, we will want to carry out all three of these steps when
applying fuel moisture to a fuel model. To simplify this task,
Pyretechnics provides the <code>moisturize</code> utility function.
</p>

<div class="org-src-container">
<pre class="src src-python" id="moisturize"><span class="org-comment-delimiter"># </span><span class="org-comment">TODO: If these functions aren't called anywhere else, create a copy</span>
<span class="org-comment-delimiter">#       </span><span class="org-comment">of the fuel model here and mutate it in the called functions.</span>
<span class="org-keyword">def</span> <span class="org-function-name">moisturize</span>(fuel_model, fuel_moisture):
    <span class="org-variable-name">dynamic_fuel_model</span>     <span class="org-operator">=</span> add_dynamic_fuel_loading(fuel_model, fuel_moisture)
    <span class="org-variable-name">weighted_fuel_model</span>    <span class="org-operator">=</span> add_weighting_factors(dynamic_fuel_model)
    <span class="org-variable-name">moisturized_fuel_model</span> <span class="org-operator">=</span> add_live_moisture_of_extinction(weighted_fuel_model)
    <span class="org-keyword">return</span> moisturized_fuel_model
</pre>
</div>

<p>
This concludes our coverage of fuel models and fuel moisture.
</p>
</div>
</div>
</div>
<div id="outline-container-For Users" class="outline-3">
<h3 id="For Users"><span class="section-number-3">5.2.</span> For Users</h3>
<div class="outline-text-3" id="text-For Users">
<p>
In the following sections, we will demonstrate how to access fuel
model properties by fuel model number both alone and combined with
fuel moisture.
</p>
</div>
<div id="outline-container-How to Look Up a Fuel Model's Properties" class="outline-4">
<h4 id="How to Look Up a Fuel Model's Properties"><span class="section-number-4">5.2.1.</span> How to Look Up a Fuel Model's Properties</h4>
<div class="outline-text-4" id="text-How to Look Up a Fuel Model's Properties">
<div class="org-src-container">
<pre class="src src-python" id="look-up-fuel-model-properties"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">from</span> pyretechnics.fuel_models <span class="org-keyword">import</span> fuel_model_table

<span class="org-variable-name">static_fuel_model_number</span>  <span class="org-operator">=</span> 1   <span class="org-comment-delimiter"># </span><span class="org-comment">R01</span>
<span class="org-variable-name">dynamic_fuel_model_number</span> <span class="org-operator">=</span> 101 <span class="org-comment-delimiter"># </span><span class="org-comment">GR1</span>

<span class="org-variable-name">static_fuel_model</span>  <span class="org-operator">=</span> fuel_model_table.get(static_fuel_model_number)
<span class="org-variable-name">dynamic_fuel_model</span> <span class="org-operator">=</span> fuel_model_table.get(dynamic_fuel_model_number)

<span class="org-builtin">print</span>(<span class="org-string">"Static Fuel Model: R01"</span>)
pprint(static_fuel_model)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Dynamic Fuel Model: GR1"</span>)
pprint(dynamic_fuel_model)
</pre>
</div>

<pre class="example" id="org73d1b97">
Static Fuel Model: R01
{'M_x': [0.12, 0.12, 0.12, 0.0, 0.0, 0.0],
 'S_T': [0.0555, 0.0555, 0.0555, 0.0555, 0.0555, 0.0555],
 'S_e': [0.01, 0.01, 0.01, 0.01, 0.01, 0.01],
 'burnable': True,
 'delta': 1.0,
 'dynamic': False,
 'h': [8000.0, 8000.0, 8000.0, 8000.0, 8000.0, 8000.0],
 'name': 'R01',
 'number': 1,
 'rho_p': [32.0, 32.0, 32.0, 32.0, 32.0, 32.0],
 'sigma': [3500.0, 0.0, 0.0, 0.0, 0.0, 0.0],
 'w_o': [0.034, 0.0, 0.0, 0.0, 0.0, 0.0]}

Dynamic Fuel Model: GR1
{'M_x': [0.15, 0.15, 0.15, 0.15, 0.0, 0.0],
 'S_T': [0.0555, 0.0555, 0.0555, 0.0555, 0.0555, 0.0555],
 'S_e': [0.01, 0.01, 0.01, 0.01, 0.01, 0.01],
 'burnable': True,
 'delta': 0.4,
 'dynamic': True,
 'h': [8000.0, 8000.0, 8000.0, 8000.0, 8000.0, 8000.0],
 'name': 'GR1',
 'number': 101,
 'rho_p': [32.0, 32.0, 32.0, 32.0, 32.0, 32.0],
 'sigma': [2200.0, 109.0, 30.0, 2000.0, 2000.0, 0.0],
 'w_o': [0.0046, 0.0, 0.0, 0.0, 0.0138, 0.0]}
</pre>
</div>
</div>
<div id="outline-container-How to Apply Fuel Moisture to a Fuel Model" class="outline-4">
<h4 id="How to Apply Fuel Moisture to a Fuel Model"><span class="section-number-4">5.2.2.</span> How to Apply Fuel Moisture to a Fuel Model</h4>
<div class="outline-text-4" id="text-How to Apply Fuel Moisture to a Fuel Model">
<div class="org-src-container">
<pre class="src src-python" id="moisturize-fuel-model"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">from</span> pyretechnics.fuel_models <span class="org-keyword">import</span> fuel_model_table, moisturize

<span class="org-variable-name">static_fuel_model_number</span>  <span class="org-operator">=</span> 1   <span class="org-comment-delimiter"># </span><span class="org-comment">R01</span>
<span class="org-variable-name">dynamic_fuel_model_number</span> <span class="org-operator">=</span> 101 <span class="org-comment-delimiter"># </span><span class="org-comment">GR1</span>

<span class="org-variable-name">static_fuel_model</span>  <span class="org-operator">=</span> fuel_model_table.get(static_fuel_model_number)
<span class="org-variable-name">dynamic_fuel_model</span> <span class="org-operator">=</span> fuel_model_table.get(dynamic_fuel_model_number)

<span class="org-variable-name">fuel_moisture</span> <span class="org-operator">=</span> [
    0.05, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_1hr</span>
    0.10, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_10hr</span>
    0.15, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_100hr</span>
    0.00, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_herbaceous (will be set by moisturize for dynamic fuel models)</span>
    0.30, <span class="org-comment-delimiter"># </span><span class="org-comment">live_herbaceous</span>
    0.50, <span class="org-comment-delimiter"># </span><span class="org-comment">live_woody</span>
]

<span class="org-builtin">print</span>(<span class="org-string">"Moisturized Static Fuel Model: R01"</span>)
pprint(moisturize(static_fuel_model, fuel_moisture))

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Moisturized Dynamic Fuel Model: GR1"</span>)
pprint(moisturize(dynamic_fuel_model, fuel_moisture))
</pre>
</div>

<pre class="example" id="orgef7bd00">
Moisturized Static Fuel Model: R01
{'M_f': [0.05, 0.1, 0.15, 0.0, 0.3, 0.5],
 'M_x': [0.12, 0.12, 0.12, 0.0, 0.12, 0.12],
 'S_T': [0.0555, 0.0555, 0.0555, 0.0555, 0.0555, 0.0555],
 'S_e': [0.01, 0.01, 0.01, 0.01, 0.01, 0.01],
 'burnable': True,
 'delta': 1.0,
 'dynamic': False,
 'f_i': [1.0, 0.0],
 'f_ij': [1.0, 0.0, 0.0, 0.0, 0.0, 0.0],
 'g_ij': [1.0, 0.0, 0.0, 0.0, 0.0, 0.0],
 'h': [8000.0, 8000.0, 8000.0, 8000.0, 8000.0, 8000.0],
 'name': 'R01',
 'number': 1,
 'rho_p': [32.0, 32.0, 32.0, 32.0, 32.0, 32.0],
 'sigma': [3500.0, 0.0, 0.0, 0.0, 0.0, 0.0],
 'w_o': [0.034, 0.0, 0.0, 0.0, 0.0, 0.0]}

Moisturized Dynamic Fuel Model: GR1
{'M_f': [0.05, 0.1, 0.15, 0.05, 0.3, 0.5],
 'M_x': [0.15, 0.15, 0.15, 0.15, 0.15, 0.15],
 'S_T': [0.0555, 0.0555, 0.0555, 0.0555, 0.0555, 0.0555],
 'S_e': [0.01, 0.01, 0.01, 0.01, 0.01, 0.01],
 'burnable': True,
 'delta': 0.4,
 'dynamic': True,
 'f_i': [1.0, 0.0],
 'f_ij': [0.26829268292682923, 0.0, 0.0, 0.7317073170731707, 0.0, 0.0],
 'g_ij': [1.0, 0.0, 0.0, 1.0, 0.0, 0.0],
 'h': [8000.0, 8000.0, 8000.0, 8000.0, 8000.0, 8000.0],
 'name': 'GR1',
 'number': 101,
 'rho_p': [32.0, 32.0, 32.0, 32.0, 32.0, 32.0],
 'sigma': [2200.0, 109.0, 30.0, 2000.0, 2000.0, 0.0],
 'w_o': [0.0046, 0.0, 0.0, 0.0138, 0.0, 0.0]}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-Surface Fire Equations (pyretechnics.surface_fire)" class="outline-2">
<h2 id="Surface Fire Equations (pyretechnics.surface_fire)"><span class="section-number-2">6.</span> Surface Fire Equations (pyretechnics.surface_fire)</h2>
<div class="outline-text-2" id="text-Surface Fire Equations (pyretechnics.surface_fire)">
</div>
<div id="outline-container-For Developers" class="outline-3">
<h3 id="For Developers"><span class="section-number-3">6.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-For Developers">
<p>
The following sections define functions that calculate the spread rate
and intensity of a fire burning through surface fuels. These functions
combine fuel models and fuel moisture values (as defined in section
<a href="#Fuel Model and Moisture Definitions (pyretechnics.fuel_models)">5</a>) with
wind and topography inputs to determine the maximum spread rate and
direction of a surface fire as well as its fireline intensity and
flame length.
</p>
</div>
<div id="outline-container-Rothermel's Surface Fire Rate of Spread Equation" class="outline-4">
<h4 id="Rothermel's Surface Fire Rate of Spread Equation"><span class="section-number-4">6.1.1.</span> Rothermel's Surface Fire Rate of Spread Equation</h4>
<div class="outline-text-4" id="text-Rothermel's Surface Fire Rate of Spread Equation">
<p>
To simulate fire behavior in as similar a way as possible to the US
government-sponsored fire models (e.g., FARSITE, FlamMap, FPA,
BehavePlus), Pyretechnics adopts the surface fire spread and reaction
intensity formulas from Rothermel's 1972 publication "A Mathematical
Model for Predicting Fire Spread in Wildland Fuels", adjusted
according to Albini 1976 Appendix III to match the behavior of
Albini's original FIREMODS library.<sup><a id="fnr.11" class="footref" href="#fn.11" role="doc-backlink">11</a></sup><sup>, </sup><sup><a id="fnr.12" class="footref" href="#fn.12" role="doc-backlink">12</a></sup>
This should align with the updated description provided in Patricia
Andrews' 2018 publication "The Rothermel Surface Fire Spread Model and
Associated Developments: A Comprehensive
Explanation".<sup><a id="fnr.13" class="footref" href="#fn.13" role="doc-backlink">13</a></sup>
</p>

<p>
Very briefly, the surface rate of spread of a fire's leading edge \(R\)
is described by the following formula:
</p>

\begin{align}
  R = \frac{I_R \, \xi \, (1 + \phi_W + \phi_S)}{\rho_b \, \epsilon \, Q_{ig}}
\end{align}

<p>
where these terms have the meanings shown in Table
<a href="#tab:fire-spread-inputs">2</a>.
</p>

<table id="tab:fire-spread-inputs">
<caption class="t-above"><span class="table-number">Table 2:</span> Inputs to Rothermel's surface fire rate of spread equation</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Term</th>
<th scope="col" class="org-left">Description</th>
<th scope="col" class="org-left">Units</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">\(R\)</td>
<td class="org-left">surface fire spread rate</td>
<td class="org-left">\(\text{ft}/\min\)</td>
</tr>

<tr>
<td class="org-left">\(I_R\)</td>
<td class="org-left">reaction intensity</td>
<td class="org-left">\(\text{Btu}/\text{ft}^2/\min\)</td>
</tr>

<tr>
<td class="org-left">\(\xi\)</td>
<td class="org-left">propagating flux ratio</td>
<td class="org-left">\(\text{unitless}\)</td>
</tr>

<tr>
<td class="org-left">\(\phi_W\)</td>
<td class="org-left">wind factor</td>
<td class="org-left">\(\text{unitless}\)</td>
</tr>

<tr>
<td class="org-left">\(\phi_S\)</td>
<td class="org-left">slope factor</td>
<td class="org-left">\(\text{unitless}\)</td>
</tr>

<tr>
<td class="org-left">\(\rho_b\)</td>
<td class="org-left">oven-dry fuel bed bulk density</td>
<td class="org-left">\(\text{lb}/\text{ft}^3\)</td>
</tr>

<tr>
<td class="org-left">\(\epsilon\)</td>
<td class="org-left">effective heating number</td>
<td class="org-left">\(\text{unitless}\)</td>
</tr>

<tr>
<td class="org-left">\(Q_{ig}\)</td>
<td class="org-left">heat of preignition</td>
<td class="org-left">\(\text{Btu}/\text{lb}\)</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-Surface Fire Spread Rate Functions (No Wind No Slope)" class="outline-4">
<h4 id="Surface Fire Spread Rate Functions (No Wind No Slope)"><span class="section-number-4">6.1.2.</span> Surface Fire Spread Rate Functions (No Wind No Slope)</h4>
<div class="outline-text-4" id="text-Surface Fire Spread Rate Functions (No Wind No Slope)">
<p>
In this section, Rothermel's surface fire spread rate equation will be
computed without introducing the effects of wind or slope (i.e.,
\(\phi_W = \phi_S = 0\)). In this case, the only necessary input is a
moisturized fuel model (as created in section <a href="#Applying Fuel Moisture to a Fuel Model">5.1.7</a>). Thus, the functions below will focus on the
no-wind-no-slope term \(R_0\) defined as follows:
</p>

\begin{align}
  R_0 &= \frac{I_R \, \xi}{\rho_b \, \epsilon \, Q_{ig}} \\
  \nonumber \\
  R &= R_0 \, (1 + \phi_W + \phi_S)
\end{align}

<p>
Each term will be defined in its own section, and finally they will be
combined together in a single function that computes \(R_0\).
</p>
</div>
<ol class="org-ol">
<li><a id="Module Imports"></a>Module Imports<br>
<div class="outline-text-5" id="text-Module Imports">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-imports"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> exp
<span class="org-keyword">from</span> pyretechnics.fuel_models <span class="org-keyword">import</span> map_category, map_size_class, category_sum, size_class_sum
</pre>
</div>
</div>
</li>
<li><a id="Common Intermediate Calculations: $\sigma', \beta, \beta_{op}$"></a>Common Intermediate Calculations: \(\sigma', \beta, \beta_{op}\)<br>
<div class="outline-text-5" id="text-Common Intermediate Calculations: $\sigma', \beta, \beta_{op}$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-common-intermediate-calculations"><span class="org-keyword">def</span> <span class="org-function-name">calc_surface_area_to_volume_ratio</span>(f_i, f_ij, sigma):
    <span class="org-variable-name">sigma_prime_i</span> <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: f_ij[i] <span class="org-operator">*</span> sigma[i])
    <span class="org-keyword">return</span> category_sum(<span class="org-keyword">lambda</span> i: f_i[i] <span class="org-operator">*</span> sigma_prime_i[i])


<span class="org-keyword">def</span> <span class="org-function-name">calc_packing_ratio</span>(w_o, rho_p, delta):
    <span class="org-keyword">if</span> (delta <span class="org-operator">&gt;</span> 0.0):
        <span class="org-variable-name">beta_i</span> <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: w_o[i] <span class="org-operator">/</span> rho_p[i])
        <span class="org-keyword">return</span> category_sum(<span class="org-keyword">lambda</span> i: beta_i[i]) <span class="org-operator">/</span> delta
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> 0.0


<span class="org-keyword">def</span> <span class="org-function-name">calc_optimum_packing_ratio</span>(sigma_prime):
    <span class="org-keyword">return</span> (3.348 <span class="org-operator">/</span> sigma_prime <span class="org-operator">**</span> 0.8189) <span class="org-keyword">if</span> (sigma_prime <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 1.0
</pre>
</div>
</div>
</li>
<li><a id="Reaction Intensity: $I_R$"></a>Reaction Intensity: \(I_R\)<br>
<div class="outline-text-5" id="text-Reaction Intensity: $I_R$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-reaction-intensity"><span class="org-keyword">def</span> <span class="org-function-name">calc_mineral_damping_coefficients</span>(f_ij, S_e):
    <span class="org-variable-name">S_e_i</span> <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: f_ij[i] <span class="org-operator">*</span> S_e[i])
    <span class="org-keyword">return</span> map_category(<span class="org-keyword">lambda</span> i:
                        (<span class="org-keyword">lambda</span> S_e_i:
                         0.174 <span class="org-operator">/</span> (S_e_i <span class="org-operator">**</span> 0.19) <span class="org-keyword">if</span> (S_e_i <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 1.0
                         )(S_e_i[i]))


<span class="org-keyword">def</span> <span class="org-function-name">calc_moisture_damping_coefficients</span>(f_ij, M_f, M_x):
    <span class="org-variable-name">M_f_i</span> <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: f_ij[i] <span class="org-operator">*</span> M_f[i])
    <span class="org-variable-name">M_x_i</span> <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: f_ij[i] <span class="org-operator">*</span> M_x[i])
    <span class="org-keyword">return</span> map_category(<span class="org-keyword">lambda</span> i:
                        (<span class="org-keyword">lambda</span> M_f, M_x:
                         (<span class="org-keyword">lambda</span> r_M:
                          1.0 <span class="org-operator">-</span> 2.59 <span class="org-operator">*</span> r_M <span class="org-operator">+</span> 5.11 <span class="org-operator">*</span> r_M <span class="org-operator">**</span> 2.0 <span class="org-operator">-</span> 3.52 <span class="org-operator">*</span> r_M <span class="org-operator">**</span> 3.0
                          )(<span class="org-builtin">min</span>(1.0, M_f <span class="org-operator">/</span> M_x) <span class="org-keyword">if</span> (M_x <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 1.0)
                         )(M_f_i[i], M_x_i[i]))


<span class="org-keyword">def</span> <span class="org-function-name">calc_low_heat_content</span>(f_ij, h):
    <span class="org-keyword">return</span> size_class_sum(<span class="org-keyword">lambda</span> i: f_ij[i] <span class="org-operator">*</span> h[i])


<span class="org-keyword">def</span> <span class="org-function-name">calc_net_fuel_loading</span>(g_ij, w_o, S_T):
    <span class="org-keyword">return</span> size_class_sum(<span class="org-keyword">lambda</span> i:
                          (<span class="org-keyword">lambda</span> g_ij, w_o, S_T:
                           g_ij <span class="org-operator">*</span> w_o <span class="org-operator">*</span> (1.0 <span class="org-operator">-</span> S_T)
                           )(g_ij[i], w_o[i], S_T[i]))


<span class="org-keyword">def</span> <span class="org-function-name">calc_heat_per_unit_area</span>(eta_S_i, eta_M_i, h_i, W_n_i):
    <span class="org-keyword">return</span> category_sum(<span class="org-keyword">lambda</span> i: W_n_i[i] <span class="org-operator">*</span> h_i[i] <span class="org-operator">*</span> eta_M_i[i] <span class="org-operator">*</span> eta_S_i[i])


<span class="org-keyword">def</span> <span class="org-function-name">calc_optimum_reaction_velocity</span>(sigma_prime, beta, beta_op):
    <span class="org-comment-delimiter"># </span><span class="org-comment">Albini 1976 replaces 1 / (4.774 * (sigma_prime ** 0.1) - 7.27)</span>
    <span class="org-variable-name">A</span>               <span class="org-operator">=</span> (133.0 <span class="org-operator">/</span> sigma_prime <span class="org-operator">**</span> 0.7913) <span class="org-keyword">if</span> (sigma_prime <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 0.0
    <span class="org-variable-name">B</span>               <span class="org-operator">=</span> sigma_prime <span class="org-operator">**</span> 1.5
    <span class="org-variable-name">C</span>               <span class="org-operator">=</span> beta <span class="org-operator">/</span> beta_op
    <span class="org-comment-delimiter"># </span><span class="org-comment">Maximum reaction velocity (1/min)</span>
    <span class="org-variable-name">Gamma_prime_max</span> <span class="org-operator">=</span> B <span class="org-operator">/</span> (495.0 <span class="org-operator">+</span> 0.0594 <span class="org-operator">*</span> B)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Optimum reaction velocity (1/min)</span>
    <span class="org-keyword">return</span> Gamma_prime_max <span class="org-operator">*</span> (C <span class="org-operator">**</span> A) <span class="org-operator">*</span> exp(A <span class="org-operator">*</span> (1.0 <span class="org-operator">-</span> C))


<span class="org-keyword">def</span> <span class="org-function-name">calc_reaction_intensity</span>(moisturized_fuel_model, sigma_prime, beta, beta_op):
    <span class="org-variable-name">w_o</span>         <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"w_o"</span>]
    <span class="org-variable-name">h</span>           <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"h"</span>]
    <span class="org-variable-name">S_T</span>         <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"S_T"</span>]
    <span class="org-variable-name">S_e</span>         <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"S_e"</span>]
    <span class="org-variable-name">M_x</span>         <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"M_x"</span>]
    <span class="org-variable-name">M_f</span>         <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"M_f"</span>]
    <span class="org-variable-name">f_ij</span>        <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"f_ij"</span>]
    <span class="org-variable-name">g_ij</span>        <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"g_ij"</span>]
    <span class="org-variable-name">eta_S_i</span>     <span class="org-operator">=</span> calc_mineral_damping_coefficients(f_ij, S_e)
    <span class="org-variable-name">eta_M_i</span>     <span class="org-operator">=</span> calc_moisture_damping_coefficients(f_ij, M_f, M_x)
    <span class="org-variable-name">h_i</span>         <span class="org-operator">=</span> calc_low_heat_content(f_ij, h)                             <span class="org-comment-delimiter"># </span><span class="org-comment">(Btu/lb)</span>
    <span class="org-variable-name">W_n_i</span>       <span class="org-operator">=</span> calc_net_fuel_loading(g_ij, w_o, S_T)                      <span class="org-comment-delimiter"># </span><span class="org-comment">(lb/ft^2)</span>
    <span class="org-variable-name">Btus</span>        <span class="org-operator">=</span> calc_heat_per_unit_area(eta_S_i, eta_M_i, h_i, W_n_i)      <span class="org-comment-delimiter"># </span><span class="org-comment">(Btu/ft^2)</span>
    <span class="org-variable-name">Gamma_prime</span> <span class="org-operator">=</span> calc_optimum_reaction_velocity(sigma_prime, beta, beta_op) <span class="org-comment-delimiter"># </span><span class="org-comment">(1/min)</span>
    <span class="org-keyword">return</span> Btus <span class="org-operator">*</span> Gamma_prime                                                <span class="org-comment-delimiter"># </span><span class="org-comment">(Btu/ft^2/min)</span>
</pre>
</div>
</div>
</li>
<li><a id="Propagating Flux Ratio: $\xi$"></a>Propagating Flux Ratio: \(\xi\)<br>
<div class="outline-text-5" id="text-Propagating Flux Ratio: $\xi$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-propagating-flux-ratio"><span class="org-keyword">def</span> <span class="org-function-name">calc_propagating_flux_ratio</span>(sigma_prime, beta):
    <span class="org-keyword">return</span> exp((0.792 <span class="org-operator">+</span> 0.681 <span class="org-operator">*</span> (sigma_prime <span class="org-operator">**</span> 0.5)) <span class="org-operator">*</span> (beta <span class="org-operator">+</span> 0.1)) <span class="org-operator">/</span> (192.0 <span class="org-operator">+</span> 0.2595 <span class="org-operator">*</span> sigma_prime)
</pre>
</div>
</div>
</li>
<li><a id="Heat Source (No Wind No Slope): $I_R \, \xi$"></a>Heat Source (No Wind No Slope): \(I_R \, \xi\)<br>
<div class="outline-text-5" id="text-Heat Source (No Wind No Slope): $I_R \, \xi$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-heat-source-no-wind-no-slope"><span class="org-keyword">def</span> <span class="org-function-name">calc_heat_source</span>(I_R, xi):
    <span class="org-keyword">return</span> I_R <span class="org-operator">*</span> xi
</pre>
</div>
</div>
</li>
<li><a id="Oven-Dry Fuel Bed Bulk Density: $\rho_b$"></a>Oven-Dry Fuel Bed Bulk Density: \(\rho_b\)<br>
<div class="outline-text-5" id="text-Oven-Dry Fuel Bed Bulk Density: $\rho_b$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-oven-dry-fuel-bed-bulk-density"><span class="org-keyword">def</span> <span class="org-function-name">calc_ovendry_bulk_density</span>(w_o, delta):
    <span class="org-keyword">if</span> (delta <span class="org-operator">&gt;</span> 0.0):
        <span class="org-variable-name">rho_b_i</span> <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: w_o[i])
        <span class="org-keyword">return</span> category_sum(<span class="org-keyword">lambda</span> i: rho_b_i[i]) <span class="org-operator">/</span> delta
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> 0.0
</pre>
</div>
</div>
</li>
<li><a id="Effective Heating Number Distribution: $\epsilon_{ij}$"></a>Effective Heating Number Distribution: \(\epsilon_{ij}\)<br>
<div class="outline-text-5" id="text-Effective Heating Number Distribution: $\epsilon_{ij}$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-effective-heating-number-distribution"><span class="org-keyword">def</span> <span class="org-function-name">calc_effective_heating_number_distribution</span>(sigma):
    <span class="org-keyword">return</span> map_size_class(<span class="org-keyword">lambda</span> i:
                          (<span class="org-keyword">lambda</span> sigma:
                           exp(<span class="org-operator">-</span>138.0 <span class="org-operator">/</span> sigma) <span class="org-keyword">if</span> (sigma <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 0.0
                           )(sigma[i]))
</pre>
</div>
</div>
</li>
<li><a id="Heat of Preignition Distribution: $(Q_{ig})_{ij}$"></a>Heat of Preignition Distribution: \((Q_{ig})_{ij}\)<br>
<div class="outline-text-5" id="text-Heat of Preignition Distribution: $(Q_{ig})_{ij}$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-heat-of-preignition-distribution"><span class="org-keyword">def</span> <span class="org-function-name">calc_heat_of_preignition_distribution</span>(M_f):
    <span class="org-keyword">return</span> map_size_class(<span class="org-keyword">lambda</span> i: 250.0 <span class="org-operator">+</span> 1116.0 <span class="org-operator">*</span> M_f[i])
</pre>
</div>
</div>
</li>
<li><a id="Heat Sink: $\rho_b \, \epsilon \, Q_{ig}$"></a>Heat Sink: \(\rho_b \, \epsilon \, Q_{ig}\)<br>
<div class="outline-text-5" id="text-Heat Sink: $\rho_b \, \epsilon \, Q_{ig}$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-heat-sink"><span class="org-keyword">def</span> <span class="org-function-name">calc_heat_sink</span>(f_i, f_ij, rho_b, epsilon_ij, Q_ig_ij):
    <span class="org-variable-name">effective_heat_of_preignition_i</span> <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: f_ij[i] <span class="org-operator">*</span> epsilon_ij[i] <span class="org-operator">*</span> Q_ig_ij[i])
    <span class="org-variable-name">effective_heat_of_preignition</span>   <span class="org-operator">=</span> category_sum(<span class="org-keyword">lambda</span> i: f_i[i] <span class="org-operator">*</span> effective_heat_of_preignition_i[i])
    <span class="org-keyword">return</span> rho_b <span class="org-operator">*</span> effective_heat_of_preignition
</pre>
</div>
</div>
</li>
<li><a id="Spread Rate (No Wind No Slope): $R_0$"></a>Spread Rate (No Wind No Slope): \(R_0\)<br>
<div class="outline-text-5" id="text-Spread Rate (No Wind No Slope): $R_0$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-spread-rate-no-wind-no-slope"><span class="org-keyword">def</span> <span class="org-function-name">calc_spread_rate</span>(heat_source, heat_sink):
    <span class="org-keyword">return</span> heat_source <span class="org-operator">/</span> heat_sink <span class="org-keyword">if</span> (heat_sink <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 0.0
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-Surface Fire Intensity Functions" class="outline-4">
<h4 id="Surface Fire Intensity Functions"><span class="section-number-4">6.1.3.</span> Surface Fire Intensity Functions</h4>
<div class="outline-text-4" id="text-Surface Fire Intensity Functions">
<p>
Using these surface fire spread rate and reaction intensity values, we
can now calculate surface fire intensity values by applying Anderson's
flame depth formula and Byram's fireline intensity and flame length
equations as described below.<sup><a id="fnr.14" class="footref" href="#fn.14" role="doc-backlink">14</a></sup><sup>, </sup><sup><a id="fnr.15" class="footref" href="#fn.15" role="doc-backlink">15</a></sup>
</p>

\begin{align}
  t_{\text{res}} &= \frac{384}{\sigma'} \\
  \nonumber \\
  D_A &= R \, t_{\text{res}} \\
  \nonumber \\
  I_s &= \frac{I_R \, D_A}{60} \\
  \nonumber \\
  L_s &= 0.45(I_s)^{0.46}
\end{align}

<p>
where \(\sigma'\) is the weighted sum by size class of the fuel model's
surface area to volume ratio in \(\text{ft}^2/\text{ft}^3\),
\(t_{\text{res}}\) is the residence time in \(\text{minutes}\), \(R\) is the
surface fire spread rate in \(\text{ft}/\min\), \(D_A\) is the flame depth
in \(\text{ft}\), \(I_R\) is the reaction intensity in
\(\text{Btu}/\text{ft}^2/\min\), \(I_s\) is the fireline intensity in
\(\text{Btu}/\text{ft}/\text{s}\), and \(L_s\) is the flame length in
\(\text{ft}\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="surface-fire-intensity-functions"><span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv


<span class="org-keyword">def</span> <span class="org-function-name">calc_residence_time</span>(sigma_prime):
    <span class="org-keyword">return</span> 384.0 <span class="org-operator">/</span> sigma_prime


<span class="org-keyword">def</span> <span class="org-function-name">calc_flame_depth</span>(spread_rate, residence_time):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the depth, or front-to-back distance, of the actively flaming zone</span>
<span class="org-doc">    of a free-spreading fire in ft given:</span>
<span class="org-doc">    - spread_rate (ft/min) orthogonal to the fireline.</span>
<span class="org-doc">    - residence_time (min)</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> spread_rate <span class="org-operator">*</span> residence_time


<span class="org-keyword">def</span> <span class="org-function-name">calc_fireline_intensity</span>(reaction_intensity, flame_depth):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the rate of heat release per unit of fire edge in Btu/ft/s given:</span>
<span class="org-doc">    - reaction_intensity (Btu/ft^2/min)</span>
<span class="org-doc">    - flame_depth (ft)</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> (reaction_intensity <span class="org-operator">*</span> flame_depth) <span class="org-operator">/</span> 60.0


<span class="org-keyword">def</span> <span class="org-function-name">calc_flame_length</span>(fireline_intensity):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the average flame length (m) given:</span>
<span class="org-doc">    - fireline_intensity :: kW/m</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> conv.ft_to_m(0.45 <span class="org-operator">*</span> (conv.kW_m_to_Btu_ft_s(fireline_intensity) <span class="org-operator">**</span> 0.46))
</pre>
</div>

<p>
Because of the linear relationship between spread rate, flame depth,
and fireline intensity, once we have calculated the no wind, no slope
fireline intensity, we can simply multiply it by the same combined
wind and slope factor that is applied to the no wind, no slope spread
rate in order to derive the maximum fireline intensity.
</p>

<p>
Since flame length's relationship to fireline intensity is non-linear,
we will need to wait until after any transformations are applied to
fireline intensity before calculating the associated flame length.
</p>
</div>
</div>
<div id="outline-container-Wind and Slope Factor Functions" class="outline-4">
<h4 id="Wind and Slope Factor Functions"><span class="section-number-4">6.1.4.</span> Wind and Slope Factor Functions</h4>
<div class="outline-text-4" id="text-Wind and Slope Factor Functions">
<p>
In order to compute the maximum spread rate, direction, and intensity
of the surface fire front, we will need to incorporate the effects of
wind and slope on the fire. However, we can precompute several
intermediate values and functions needed for this step based solely on
the fuel bed characteristics already available to us with just a
moisturized fuel model (see section <a href="#Applying Fuel Moisture to a Fuel Model">5.1.7</a>).
</p>
</div>
<ol class="org-ol">
<li><a id="Max Effective Wind Speed: $U_{\text{eff}}^{\max}$"></a>Max Effective Wind Speed: \(U_{\text{eff}}^{\max}\)<br>
<div class="outline-text-5" id="text-Max Effective Wind Speed: $U_{\text{eff}}^{\max}$">
<p>
The midflame wind speed that would be required to produce the combined
spread rate in a no-slope scenario is termed the effective windspeed
\(U_{\text{eff}}\). Following the recommendations given in Appendix III
of Albini 1976, these midflame wind speeds are all limited by the
reaction intensity \(I_R\) as follows:<sup><a id="fnr.16" class="footref" href="#fn.16" role="doc-backlink">16</a></sup>
</p>

\begin{align}
  U_{\text{eff}}^{\max} = 0.9 \, I_R
\end{align}

<p>
where \(I_R\) is the reaction intensity in \(\text{Btu}/\text{ft}^2/\min\)
and \(U_{\text{eff}}^{\max}\) is the maximum effective wind speed in
\(\text{ft}/\min\)
</p>

<div class="org-src-container">
<pre class="src src-python" id="surface-fire-max-effective-wind-speed"><span class="org-keyword">def</span> <span class="org-function-name">calc_max_effective_wind_speed</span>(reaction_intensity):
    <span class="org-keyword">return</span> 0.9 <span class="org-operator">*</span> reaction_intensity
</pre>
</div>
</div>
</li>
<li><a id="Slope Factor Function: $\tan(\theta_S) \mapsto \phi_S$"></a>Slope Factor Function: \(\tan(\theta_S) \mapsto \phi_S\)<br>
<div class="outline-text-5" id="text-Slope Factor Function: $\tan(\theta_S) \mapsto \phi_S$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-slope-factor-function"><span class="org-keyword">def</span> <span class="org-function-name">get_phi_S_fn</span>(beta):
    <span class="org-keyword">if</span> (beta <span class="org-operator">&gt;</span> 0.0):
        <span class="org-variable-name">G</span> <span class="org-operator">=</span> 5.275 <span class="org-operator">*</span> beta <span class="org-operator">**</span> <span class="org-operator">-</span>0.3
        <span class="org-keyword">return</span> <span class="org-keyword">lambda</span> slope: (slope <span class="org-operator">**</span> 2.0) <span class="org-operator">*</span> G
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> <span class="org-keyword">lambda</span> _: 0.0
</pre>
</div>
</div>
</li>
<li><a id="Wind Factor Function: $U_{\text{mid}} \mapsto \phi_W$"></a>Wind Factor Function: \(U_{\text{mid}} \mapsto \phi_W\)<br>
<div class="outline-text-5" id="text-Wind Factor Function: $U_{\text{mid}} \mapsto \phi_W$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-wind-factor-function"><span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv


<span class="org-keyword">def</span> <span class="org-function-name">get_phi_W_fn</span>(beta, B, C, F):
    <span class="org-keyword">if</span> (beta <span class="org-operator">&gt;</span> 0.0):
        <span class="org-variable-name">C_over_F</span> <span class="org-operator">=</span> C <span class="org-operator">/</span> F
        <span class="org-keyword">return</span> <span class="org-keyword">lambda</span> midflame_wind_speed: (conv.m_to_ft(midflame_wind_speed) <span class="org-operator">**</span> B) <span class="org-operator">*</span> C_over_F
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> <span class="org-keyword">lambda</span> _: 0.0
</pre>
</div>
</div>
</li>
<li><a id="Wind Speed Function: $\phi_W \mapsto U_{\text{mid}}$"></a>Wind Speed Function: \(\phi_W \mapsto U_{\text{mid}}\)<br>
<div class="outline-text-5" id="text-Wind Speed Function: $\phi_W \mapsto U_{\text{mid}}$">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-wind-speed-function"><span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv


<span class="org-keyword">def</span> <span class="org-function-name">get_wind_speed_fn</span>(B, C, F):
    <span class="org-variable-name">F_over_C</span>  <span class="org-operator">=</span> F <span class="org-operator">/</span> C
    <span class="org-variable-name">B_inverse</span> <span class="org-operator">=</span> 1.0 <span class="org-operator">/</span> B
    <span class="org-keyword">return</span> <span class="org-keyword">lambda</span> phi_W: conv.ft_to_m((phi_W <span class="org-operator">*</span> F_over_C) <span class="org-operator">**</span> B_inverse)
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-Surface Fire Behavior Functions (No Wind No Slope)" class="outline-4">
<h4 id="Surface Fire Behavior Functions (No Wind No Slope)"><span class="section-number-4">6.1.5.</span> Surface Fire Behavior Functions (No Wind No Slope)</h4>
<div class="outline-text-4" id="text-Surface Fire Behavior Functions (No Wind No Slope)">
<div class="org-src-container">
<pre class="src src-python" id="surface-fire-behavior-no-wind-no-slope"><span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv


<span class="org-keyword">def</span> <span class="org-function-name">calc_surface_fire_behavior_no_wind_no_slope</span>(moisturized_fuel_model, spread_rate_adjustment<span class="org-operator">=</span>1.0):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - moisturized_fuel_model :: dictionary of fuel model and fuel moisture properties</span>
<span class="org-doc">      - delta :: ft                                        (fuel depth)</span>
<span class="org-doc">      - w_o   :: lb/ft^2                                   (ovendry fuel loading)</span>
<span class="org-doc">      - rho_p :: lb/ft^3                                   (ovendry particle density)</span>
<span class="org-doc">      - sigma :: ft^2/ft^3                                 (fuel particle surface-area-to-volume ratio)</span>
<span class="org-doc">      - h     :: Btu/lb                                    (fuel particle low heat content)</span>
<span class="org-doc">      - S_T   :: lb minerals/lb ovendry weight             (fuel particle total mineral content)</span>
<span class="org-doc">      - S_e   :: lb silica-free minerals/lb ovendry weight (fuel particle effective mineral content)</span>
<span class="org-doc">      - M_x   :: lb moisture/lb ovendry weight             (fuel particle moisture of extinction)</span>
<span class="org-doc">      - M_f   :: lb moisture/lb ovendry weight             (fuel particle moisture content)</span>
<span class="org-doc">      - f_ij  :: %                                         (percent load per size class)</span>
<span class="org-doc">      - f_i   :: %                                         (percent load per category)</span>
<span class="org-doc">      - g_ij  :: %                                         (percent load per size class - Albini_1976_FIREMOD, page 20)</span>
<span class="org-doc">    - spread_rate_adjustment :: unitless float (1.0 for no adjustment)</span>

<span class="org-doc">    return a dictionary containing these keys:</span>
<span class="org-doc">    - base_spread_rate         :: m/min</span>
<span class="org-doc">    - base_fireline_intensity  :: kW/m</span>
<span class="org-doc">    - max_effective_wind_speed :: m/min</span>
<span class="org-doc">    - get_phi_S                :: lambda: slope (rise/run) =&gt; phi_S (unitless)</span>
<span class="org-doc">    - get_phi_W                :: lambda: midflame_wind_speed (m/min) =&gt; phi_W (unitless)</span>
<span class="org-doc">    - get_wind_speed           :: lambda: phi_W (unitless) =&gt; midflame_wind_speed (m/min)</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack fuel model values</span>
    <span class="org-variable-name">delta</span>          <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"delta"</span>]
    <span class="org-variable-name">w_o</span>            <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"w_o"</span>]
    <span class="org-variable-name">rho_p</span>          <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"rho_p"</span>]
    <span class="org-variable-name">sigma</span>          <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"sigma"</span>]
    <span class="org-variable-name">M_f</span>            <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"M_f"</span>]
    <span class="org-variable-name">f_ij</span>           <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"f_ij"</span>]
    <span class="org-variable-name">f_i</span>            <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"f_i"</span>]
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate base spread rate (no wind, no slope)</span>
    <span class="org-variable-name">sigma_prime</span>    <span class="org-operator">=</span> calc_surface_area_to_volume_ratio(f_i, f_ij, sigma)
    <span class="org-variable-name">beta</span>           <span class="org-operator">=</span> calc_packing_ratio(w_o, rho_p, delta)
    <span class="org-variable-name">beta_op</span>        <span class="org-operator">=</span> calc_optimum_packing_ratio(sigma_prime)
    <span class="org-variable-name">I_R</span>            <span class="org-operator">=</span> calc_reaction_intensity(moisturized_fuel_model, sigma_prime, beta, beta_op) <span class="org-comment-delimiter"># </span><span class="org-comment">Btu/ft^2/min</span>
    <span class="org-variable-name">xi</span>             <span class="org-operator">=</span> calc_propagating_flux_ratio(sigma_prime, beta)
    <span class="org-variable-name">heat_source</span>    <span class="org-operator">=</span> calc_heat_source(I_R, xi)                                  <span class="org-comment-delimiter"># </span><span class="org-comment">Btu/ft^2/min</span>
    <span class="org-variable-name">rho_b</span>          <span class="org-operator">=</span> calc_ovendry_bulk_density(w_o, delta)                      <span class="org-comment-delimiter"># </span><span class="org-comment">lb/ft^3</span>
    <span class="org-variable-name">epsilon_ij</span>     <span class="org-operator">=</span> calc_effective_heating_number_distribution(sigma)
    <span class="org-variable-name">Q_ig_ij</span>        <span class="org-operator">=</span> calc_heat_of_preignition_distribution(M_f)                 <span class="org-comment-delimiter"># </span><span class="org-comment">Btu/lb</span>
    <span class="org-variable-name">heat_sink</span>      <span class="org-operator">=</span> calc_heat_sink(f_i, f_ij, rho_b, epsilon_ij, Q_ig_ij)      <span class="org-comment-delimiter"># </span><span class="org-comment">Btu/ft^3</span>
    <span class="org-variable-name">R0</span>             <span class="org-operator">=</span> calc_spread_rate(heat_source, heat_sink)                   <span class="org-comment-delimiter"># </span><span class="org-comment">ft/min</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate base fireline intensity (no wind, no slope)</span>
    <span class="org-variable-name">t_res</span>          <span class="org-operator">=</span> calc_residence_time(sigma_prime)                           <span class="org-comment-delimiter"># </span><span class="org-comment">min</span>
    <span class="org-variable-name">D_A</span>            <span class="org-operator">=</span> calc_flame_depth(R0, t_res)                                <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
    <span class="org-variable-name">I_s</span>            <span class="org-operator">=</span> calc_fireline_intensity(I_R, D_A)                          <span class="org-comment-delimiter"># </span><span class="org-comment">Btu/ft/s</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Pre-compute values related to wind and slope</span>
    <span class="org-variable-name">U_eff_max</span>      <span class="org-operator">=</span> calc_max_effective_wind_speed(I_R)                         <span class="org-comment-delimiter"># </span><span class="org-comment">ft/min</span>
    <span class="org-variable-name">B</span>              <span class="org-operator">=</span> 0.02526 <span class="org-operator">*</span> (sigma_prime <span class="org-operator">**</span> 0.54)
    <span class="org-variable-name">C</span>              <span class="org-operator">=</span> 7.47 <span class="org-operator">*</span> exp(<span class="org-operator">-</span>0.133 <span class="org-operator">*</span> (sigma_prime <span class="org-operator">**</span> 0.55))
    <span class="org-variable-name">E</span>              <span class="org-operator">=</span> 0.715 <span class="org-operator">*</span> exp(<span class="org-operator">-</span>3.59 <span class="org-operator">*</span> (sigma_prime <span class="org-operator">/</span> 10000.0))
    <span class="org-variable-name">F</span>              <span class="org-operator">=</span> (beta <span class="org-operator">/</span> beta_op) <span class="org-operator">**</span> E
    <span class="org-variable-name">get_phi_S</span>      <span class="org-operator">=</span> get_phi_S_fn(beta)
    <span class="org-variable-name">get_phi_W</span>      <span class="org-operator">=</span> get_phi_W_fn(beta, B, C, F)
    <span class="org-variable-name">get_wind_speed</span> <span class="org-operator">=</span> get_wind_speed_fn(B, C, F)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Return no-wind-no-slope surface fire behavior values</span>
    <span class="org-keyword">return</span> {
        <span class="org-string">"base_spread_rate"</span>        : conv.ft_to_m(R0 <span class="org-operator">*</span> spread_rate_adjustment),
        <span class="org-string">"base_fireline_intensity"</span> : conv.Btu_ft_s_to_kW_m(I_s <span class="org-operator">*</span> spread_rate_adjustment),
        <span class="org-string">"max_effective_wind_speed"</span>: conv.ft_to_m(U_eff_max),
        <span class="org-string">"get_phi_S"</span>               : get_phi_S,
        <span class="org-string">"get_phi_W"</span>               : get_phi_W,
        <span class="org-string">"get_wind_speed"</span>          : get_wind_speed,
    }
</pre>
</div>
</div>
</div>
<div id="outline-container-Midflame Wind Speed" class="outline-4">
<h4 id="Midflame Wind Speed"><span class="section-number-4">6.1.6.</span> Midflame Wind Speed</h4>
<div class="outline-text-4" id="text-Midflame Wind Speed">
<p>
Rothermel's formulas all expect a measure of midflame wind speed
\(U_{\text{mid}}\). However, wind speed data is often collected at a
height 20 feet (or 10 meters) above either unsheltered ground or a
tree canopy layer if present. To convert this 20-ft wind speed
\(U_{20}\) to the required midflame wind speed value, Pyretechnics uses
the wind adjustment factor formula from Albini &amp; Baughman 1979,
parameterized as in BehavePlus, FARSITE, FlamMap, FSPro, and FPA
according to Andrews 2012<sup><a id="fnr.17" class="footref" href="#fn.17" role="doc-backlink">17</a></sup><sup>, </sup><sup><a id="fnr.18" class="footref" href="#fn.18" role="doc-backlink">18</a></sup>.
</p>

\begin{align}
  \text{WAF} &= \left\{
    \begin{array}{lr}
      1.83 \ln(\frac{20.0 + 0.36 \text{FBD}}{0.13 \text{FBD}})^{-1} & CC = 0 \\
      0.555 [\sqrt{\text{CH} (\text{CC}/3.0)} \ln(\frac{20 + 0.36 \text{CH}}{0.13 \text{CH}})]^{-1} & CC > 0
    \end{array}
  \right. \\
  \nonumber \\
  U_{\text{mid}} &= U_{20} \, \text{WAF}
\end{align}

<p>
where \(\text{WAF}\) is the unitless wind adjustment factor,
\(\text{FBD}\) is the fuel bed depth in \(\text{ft}\), \(\text{CH}\) is the
canopy height in \(\text{ft}\), and \(\text{CC}\) is the canopy cover
fraction \((0-1)\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="midflame-wind-speed"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> log, sqrt


<span class="org-keyword">def</span> <span class="org-function-name">calc_wind_adjustment_factor</span>(fuel_bed_depth, canopy_height, canopy_cover):
    <span class="org-doc">"""</span>
<span class="org-doc">    Return the wind adjustment factor (unitless) given these inputs:</span>
<span class="org-doc">    - fuel_bed_depth :: ft</span>
<span class="org-doc">    - canopy_height  :: ft</span>
<span class="org-doc">    - canopy_cover   :: 0-1</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">if</span> (canopy_cover <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">and</span> (canopy_height <span class="org-operator">&gt;</span> 0.0):
        <span class="org-comment-delimiter"># </span><span class="org-comment">sheltered: equation 2 based on CC and CH, CR=1 (Andrews 2012)</span>
        <span class="org-variable-name">A</span> <span class="org-operator">=</span> sqrt((canopy_cover <span class="org-operator">/</span> 3.0) <span class="org-operator">*</span> canopy_height)
        <span class="org-variable-name">B</span> <span class="org-operator">=</span> log((20.0 <span class="org-operator">+</span> 0.36 <span class="org-operator">*</span> canopy_height) <span class="org-operator">/</span> (0.13 <span class="org-operator">*</span> canopy_height))
        <span class="org-keyword">return</span> 0.555 <span class="org-operator">/</span> (A <span class="org-operator">*</span> B)
    <span class="org-keyword">elif</span> (fuel_bed_depth <span class="org-operator">&gt;</span> 0.0):
        <span class="org-comment-delimiter"># </span><span class="org-comment">unsheltered: equation 6 H_F = H (Andrews 2012)</span>
        <span class="org-variable-name">A</span> <span class="org-operator">=</span> log((20.0 <span class="org-operator">+</span> 0.36 <span class="org-operator">*</span> fuel_bed_depth) <span class="org-operator">/</span> (0.13 <span class="org-operator">*</span> fuel_bed_depth))
        <span class="org-keyword">return</span> 1.83 <span class="org-operator">/</span> A <span class="org-comment-delimiter"># </span><span class="org-comment">1.83 truncated from 1.8328795184533409</span>
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">non-burnable fuel model</span>
        <span class="org-keyword">return</span> 0.0


<span class="org-keyword">def</span> <span class="org-function-name">calc_midflame_wind_speed</span>(wind_speed_20ft, fuel_bed_depth, canopy_height, canopy_cover):
    <span class="org-doc">"""</span>
<span class="org-doc">    Return the midflame wind speed (S) given these inputs:</span>
<span class="org-doc">    - wind_speed_20ft :: S</span>
<span class="org-doc">    - fuel_bed_depth  :: ft</span>
<span class="org-doc">    - canopy_height   :: ft</span>
<span class="org-doc">    - canopy_cover    :: 0-1</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">wind_adj_factor</span> <span class="org-operator">=</span> calc_wind_adjustment_factor(fuel_bed_depth, canopy_height, canopy_cover)
    <span class="org-keyword">return</span> wind_speed_20ft <span class="org-operator">*</span> wind_adj_factor
</pre>
</div>
</div>
</div>
<div id="outline-container-Combining Wind and Slope Vectors" class="outline-4">
<h4 id="Combining Wind and Slope Vectors"><span class="section-number-4">6.1.7.</span> Combining Wind and Slope Vectors</h4>
<div class="outline-text-4" id="text-Combining Wind and Slope Vectors">
<p>
On flat terrain and in the absence of wind, an idealized surface fire
will spread outward in a circle through homogeneous fuels. On sloped
terrain, a fire will spread more quickly upslope than downslope, and
when wind is present, a fire will spread more quickly in the direction
that the wind is blowing rather than against it. In the presence of
both sloped terrain and wind, the two forces combine to create a new
maximum spread rate and direction for the fire. Together, wind and
slope effects elongate otherwise circular fire perimeters into
ellipses, with the fastest moving edge known as the head fire.
</p>

<p>
Since Rothermel's original equations for computing the head fire
spread rate assume that the wind direction and upslope direction are
aligned, the effects of cross-slope winds must be taken into effect.
To accomplish this, Pyretechnics implements the vector addition
procedure defined in Rothermel 1983 that combines the wind and slope
vectors to calculate the maximum fire spread direction and
magnitude.<sup><a id="fnr.19" class="footref" href="#fn.19" role="doc-backlink">19</a></sup>
</p>

<p>
In order to address potential errors related to projecting the
horizontal wind and slope azimuth vectors to and from the
slope-tangential plane, upon which the equations from Rothermel 1983
are defined, we incorporate the three-dimensional vector combination
procedure provided by Waeselynck 2024.<sup><a id="fnr.20" class="footref" href="#fn.20" role="doc-backlink">20</a></sup>
</p>

<div class="org-src-container">
<pre class="src src-python" id="surface-fire-combine-wind-and-slope-vectors"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pyretechnics.conversion <span class="org-keyword">import</span> azimuthal_to_cartesian
<span class="org-keyword">from</span> pyretechnics.vector_utils <span class="org-keyword">import</span> vector_magnitude, as_unit_vector, to_slope_plane


<span class="org-keyword">def</span> <span class="org-function-name">project_wind_and_slope_vectors_3d</span>(wind_speed, downwind_direction, slope, upslope_direction):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - wind_speed         :: S</span>
<span class="org-doc">    - downwind_direction :: degrees clockwise from North</span>
<span class="org-doc">    - slope              :: rise/run</span>
<span class="org-doc">    - upslope_direction  :: degrees clockwise from North</span>

<span class="org-doc">    return a dictionary containing these keys:</span>
<span class="org-doc">    - wind_vector_3d  :: (x: S, y: S, z: S)</span>
<span class="org-doc">    - slope_vector_3d :: (x, y, z)</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Convert wind and slope vectors from azimuthal to cartesian coordinates</span>
    <span class="org-variable-name">wind_vector_2d</span>  <span class="org-operator">=</span> azimuthal_to_cartesian(wind_speed, downwind_direction)
    <span class="org-variable-name">slope_vector_2d</span> <span class="org-operator">=</span> azimuthal_to_cartesian(slope, upslope_direction)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Project wind and slope vectors onto the slope-tangential plane</span>
    <span class="org-variable-name">wind_vector_3d</span>  <span class="org-operator">=</span> to_slope_plane(wind_vector_2d, slope_vector_2d)
    <span class="org-variable-name">slope_vector_3d</span> <span class="org-operator">=</span> to_slope_plane(slope_vector_2d, slope_vector_2d)
    <span class="org-keyword">return</span> {
        <span class="org-string">"wind_vector_3d"</span> : wind_vector_3d,
        <span class="org-string">"slope_vector_3d"</span>: slope_vector_3d,
    }


<span class="org-keyword">def</span> <span class="org-function-name">get_phi_E</span>(wind_vector_3d, slope_vector_3d, phi_W, phi_S):
    <span class="org-comment-delimiter"># </span><span class="org-comment">Convert wind and slope vectors to unit vectors on the slope-tangential plane</span>
    <span class="org-variable-name">w_S</span> <span class="org-operator">=</span> as_unit_vector(wind_vector_3d)  <span class="org-keyword">if</span> phi_W <span class="org-operator">&gt;</span> 0.0 <span class="org-keyword">else</span> wind_vector_3d
    <span class="org-variable-name">u_S</span> <span class="org-operator">=</span> as_unit_vector(slope_vector_3d) <span class="org-keyword">if</span> phi_S <span class="org-operator">&gt;</span> 0.0 <span class="org-keyword">else</span> slope_vector_3d
    <span class="org-comment-delimiter"># </span><span class="org-comment">Create the 3D slope-tangential phi_W, phi_S, and phi_E vectors</span>
    <span class="org-variable-name">phi_W_3d</span> <span class="org-operator">=</span> phi_W <span class="org-operator">*</span> w_S
    <span class="org-variable-name">phi_S_3d</span> <span class="org-operator">=</span> phi_S <span class="org-operator">*</span> u_S
    <span class="org-variable-name">phi_E_3d</span> <span class="org-operator">=</span> phi_W_3d <span class="org-operator">+</span> phi_S_3d
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate phi_E</span>
    <span class="org-variable-name">phi_E</span> <span class="org-operator">=</span> vector_magnitude(phi_E_3d)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Determine max spread direction and return results</span>
    <span class="org-keyword">if</span> phi_E <span class="org-operator">&gt;</span> 0.0:
        <span class="org-keyword">return</span> {
            <span class="org-string">"phi_E"</span>               : phi_E,
            <span class="org-string">"max_spread_direction"</span>: phi_E_3d <span class="org-operator">/</span> phi_E,
        }
    <span class="org-keyword">elif</span> phi_S <span class="org-operator">&gt;</span> 0.0:
        <span class="org-keyword">return</span> {
            <span class="org-string">"phi_E"</span>               : phi_E,
            <span class="org-string">"max_spread_direction"</span>: u_S,
        }
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> {
            <span class="org-string">"phi_E"</span>               : phi_E,
            <span class="org-string">"max_spread_direction"</span>: np.asarray((0,1,0)), <span class="org-comment-delimiter"># </span><span class="org-comment">default: North</span>
        }
</pre>
</div>
</div>
</div>
<div id="outline-container-Elliptical Eccentricity" class="outline-4">
<h4 id="Elliptical Eccentricity"><span class="section-number-4">6.1.8.</span> Elliptical Eccentricity</h4>
<div class="outline-text-4" id="text-Elliptical Eccentricity">
<p>
The effective wind speed \(U_{\text{eff}}\) is the wind speed that would
be required to produce the same spread rate in flat terrain as that
given by the combination of wind and sloped terrain as described in
section <a href="#Combining Wind and Slope Vectors">6.1.7</a>.
</p>

<p>
In order to project the one-dimensional surface fire spread rate
values calculated in earlier sections onto a two-dimensional plane,
\(U_{\text{eff}}\) is used to compute the length to width ratio
\(\frac{L}{W}\) of an ellipse that approximates the surface fire front.
This length to width ratio is then converted into an eccentricity
measure \(E\) of the ellipse using equation 8 from Albini and Chase
1980.<sup><a id="fnr.21" class="footref" href="#fn.21" role="doc-backlink">21</a></sup>
</p>

\begin{align}
  E = \frac{\sqrt{(\frac{L}{W})^2 - 1}}{\frac{L}{W}}
\end{align}

<p>
Currently Pyretechnics supports two different methods for computing
the length to width ratio \(\frac{L}{W}\):
</p>

<ol class="org-ol">
<li>Using equation 9 from Rothermel 1991.<sup><a id="fnr.22" class="footref" href="#fn.22" role="doc-backlink">22</a></sup></li>
</ol>

\begin{align}
  \frac{L}{W} = 1 + 0.25 \, U_{\text{eff}}
\end{align}

<p>
where \(U_{\text{eff}}\) is the effective wind speed in \(\text{mph}\).
</p>

<ol class="org-ol">
<li>Using the formula implemented in the Missoula Fire Lab's <code>behave</code> C++ library<sup><a id="fnr.23" class="footref" href="#fn.23" role="doc-backlink">23</a></sup></li>
</ol>

\begin{align}
  \frac{L}{W} = \min(8.0, 0.936 e^{(0.1147 U_{\text{eff}})} + 0.461 e^{(-0.0692 U_{\text{eff}})} - 0.397)
\end{align}

<p>
where \(U_{\text{eff}}\) is the effective wind speed in \(\text{mph}\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="surface-fire-eccentricity"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> exp, sqrt
<span class="org-keyword">from</span> pyretechnics.conversion <span class="org-keyword">import</span> m_min_to_mph


<span class="org-keyword">def</span> <span class="org-function-name">surface_length_to_width_ratio</span>(effective_wind_speed, model<span class="org-operator">=</span><span class="org-string">"rothermel"</span>):
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the length_to_width_ratio of the surface fire front given:</span>
<span class="org-doc">    - effective_wind_speed :: m/min (aligned with the slope-tangential plane)</span>
<span class="org-doc">    - model                :: "rothermel" or "behave" (Optional)</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">effective_wind_speed_mph</span> <span class="org-operator">=</span> m_min_to_mph(effective_wind_speed)
    <span class="org-keyword">match</span> model:
        <span class="org-keyword">case</span> <span class="org-string">"rothermel"</span>:
            <span class="org-keyword">return</span> 1.0 <span class="org-operator">+</span> 0.25 <span class="org-operator">*</span> effective_wind_speed_mph

        <span class="org-keyword">case</span> <span class="org-string">"behave"</span>:
            <span class="org-keyword">return</span> <span class="org-builtin">min</span>(8.0,
                       0.936 <span class="org-operator">*</span> exp(0.1147 <span class="org-operator">*</span> effective_wind_speed_mph)
                       <span class="org-operator">+</span>
                       0.461 <span class="org-operator">*</span> exp(<span class="org-operator">-</span>0.0692 <span class="org-operator">*</span> effective_wind_speed_mph)
                       <span class="org-operator">-</span>
                       0.397)

        <span class="org-keyword">case</span> _:
            <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"Invalid input: model must be 'rothermel' or 'behave'."</span>)


<span class="org-keyword">def</span> <span class="org-function-name">surface_fire_eccentricity</span>(length_to_width_ratio):
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the eccentricity (E) of the surface fire front using eq. 8 from</span>
<span class="org-doc">    Albini and Chase 1980 given:</span>
<span class="org-doc">    - L/W :: (1: circular spread, &gt; 1: elliptical spread)</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> sqrt(length_to_width_ratio <span class="org-operator">**</span> 2.0 <span class="org-operator">-</span> 1.0) <span class="org-operator">/</span> length_to_width_ratio
</pre>
</div>
</div>
</div>
<div id="outline-container-Surface Fire Behavior in the Direction of Maximum Spread" class="outline-4">
<h4 id="Surface Fire Behavior in the Direction of Maximum Spread"><span class="section-number-4">6.1.9.</span> Surface Fire Behavior in the Direction of Maximum Spread</h4>
<div class="outline-text-4" id="text-Surface Fire Behavior in the Direction of Maximum Spread">
<p>
This section introduces a function that applies the effects of wind
and slope to the no-wind-no-slope surface fire behavior values
produced in section <a href="#Surface Fire Behavior Functions (No Wind No Slope)">6.1.5</a>, in order to compute the maximum surface fire behavior values
associated with a head fire.
</p>

<p>
A noteworthy decision for users is whether or not to limit the
effective wind speed \(U_{\text{eff}}\) in these calculations.
</p>

<p>
Rothermel 1972 defines a maximum effective wind speed, above which the
predicted spread rate and intensity remains constant. However, a 2013
publication by Andrews et al recommends instead that this wind speed
limit not be imposed, in order to avoid possible spread rate
underprediction.<sup><a id="fnr.24" class="footref" href="#fn.24" role="doc-backlink">24</a></sup><sup>, </sup><sup><a id="fnr.25" class="footref" href="#fn.25" role="doc-backlink">25</a></sup>
</p>

<p>
In order to support both use cases, the
<code>calc_surface_fire_behavior_max</code> function includes an optional
<code>use_wind_limit</code> argument that can be used to toggle this limit on or
off.
</p>

<div class="org-src-container">
<pre class="src src-python" id="surface-fire-behavior-max"><span class="org-keyword">from</span> pyretechnics.conversion <span class="org-keyword">import</span> opposite_direction
<span class="org-keyword">from</span> pyretechnics.vector_utils <span class="org-keyword">import</span> vector_magnitude


<span class="org-keyword">def</span> <span class="org-function-name">maybe_limit_wind_speed</span>(use_wind_limit, max_wind_speed, get_phi_W, get_wind_speed, phi_E_magnitude):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - use_wind_limit  :: boolean</span>
<span class="org-doc">    - max_wind_speed  :: m/min</span>
<span class="org-doc">    - get_phi_W       :: lambda: midflame_wind_speed (m/min) =&gt; phi_W (unitless)</span>
<span class="org-doc">    - get_wind_speed  :: lambda: phi_W (unitless) =&gt; midflame_wind_speed (m/min)</span>
<span class="org-doc">    - phi_E_magnitude :: unitless</span>

<span class="org-doc">    return a tuple with these fields:</span>
<span class="org-doc">    - limited_wind_speed :: m/min</span>
<span class="org-doc">    - limited_phi_E      :: unitless</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">effective_wind_speed</span> <span class="org-operator">=</span> get_wind_speed(phi_E_magnitude)
    <span class="org-keyword">if</span> (use_wind_limit <span class="org-keyword">and</span> effective_wind_speed <span class="org-operator">&gt;</span> max_wind_speed):
        <span class="org-keyword">return</span> (
            max_wind_speed,
            get_phi_W(max_wind_speed),
        )
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> (
            effective_wind_speed,
            phi_E_magnitude,
        )


<span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: No longer takes ellipse_adjustment_factor parameter</span>
<span class="org-keyword">def</span> <span class="org-function-name">calc_surface_fire_behavior_max</span>(surface_fire_min, midflame_wind_speed, upwind_direction,
                                   slope, aspect, use_wind_limit<span class="org-operator">=</span><span class="org-constant">True</span>):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - surface_fire_min       :: dictionary of no-wind-no-slope surface fire behavior values</span>
<span class="org-doc">      - base_spread_rate         :: m/min</span>
<span class="org-doc">      - base_fireline_intensity  :: kW/m</span>
<span class="org-doc">      - max_effective_wind_speed :: m/min</span>
<span class="org-doc">      - get_phi_S                :: lambda: slope (rise/run) =&gt; phi_S (unitless)</span>
<span class="org-doc">      - get_phi_W                :: lambda: midflame_wind_speed (m/min) =&gt; phi_W (unitless)</span>
<span class="org-doc">      - get_wind_speed           :: lambda: phi_W (unitless) =&gt; midflame_wind_speed (m/min)</span>
<span class="org-doc">    - midflame_wind_speed    :: m/min</span>
<span class="org-doc">    - upwind_direction       :: degrees clockwise from North</span>
<span class="org-doc">    - slope                  :: rise/run</span>
<span class="org-doc">    - aspect                 :: degrees clockwise from North</span>
<span class="org-doc">    - use_wind_limit         :: boolean (Optional)</span>

<span class="org-doc">    return a dictionary containing these keys:</span>
<span class="org-doc">    - max_spread_rate        :: m/min</span>
<span class="org-doc">    - max_spread_direction   :: (x, y, z) unit vector</span>
<span class="org-doc">    - max_fireline_intensity :: kW/m</span>
<span class="org-doc">    - max_flame_length       :: m</span>
<span class="org-doc">    - length_to_width_ratio  :: unitless (1: circular spread, &gt; 1: elliptical spread)</span>
<span class="org-doc">    - eccentricity           :: unitless (0: circular spread, &gt; 0: elliptical spread)</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack no-wind-no-slope surface fire behavior values</span>
    <span class="org-variable-name">spread_rate</span>        <span class="org-operator">=</span> surface_fire_min[<span class="org-string">"base_spread_rate"</span>]
    <span class="org-variable-name">fireline_intensity</span> <span class="org-operator">=</span> surface_fire_min[<span class="org-string">"base_fireline_intensity"</span>]
    <span class="org-variable-name">max_wind_speed</span>     <span class="org-operator">=</span> surface_fire_min[<span class="org-string">"max_effective_wind_speed"</span>]
    <span class="org-variable-name">get_phi_W</span>          <span class="org-operator">=</span> surface_fire_min[<span class="org-string">"get_phi_W"</span>]
    <span class="org-variable-name">get_phi_S</span>          <span class="org-operator">=</span> surface_fire_min[<span class="org-string">"get_phi_S"</span>]
    <span class="org-variable-name">get_wind_speed</span>     <span class="org-operator">=</span> surface_fire_min[<span class="org-string">"get_wind_speed"</span>]
    <span class="org-comment-delimiter"># </span><span class="org-comment">Reverse the provided wind and slope directions</span>
    <span class="org-variable-name">downwind_direction</span> <span class="org-operator">=</span> opposite_direction(upwind_direction)
    <span class="org-variable-name">upslope_direction</span>  <span class="org-operator">=</span> opposite_direction(aspect)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Project wind and slope vectors onto the slope-tangential plane</span>
    <span class="org-variable-name">vectors</span> <span class="org-operator">=</span> project_wind_and_slope_vectors_3d(midflame_wind_speed, downwind_direction, slope, upslope_direction)
    <span class="org-variable-name">wind_vector_3d</span>  <span class="org-operator">=</span> vectors[<span class="org-string">"wind_vector_3d"</span>]  <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
    <span class="org-variable-name">slope_vector_3d</span> <span class="org-operator">=</span> vectors[<span class="org-string">"slope_vector_3d"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate phi_W and phi_S</span>
    <span class="org-variable-name">phi_W</span> <span class="org-operator">=</span> get_phi_W(vector_magnitude(wind_vector_3d)) <span class="org-comment-delimiter"># </span><span class="org-comment">|wind_vector_3d| = slope-aligned midflame wind speed</span>
    <span class="org-variable-name">phi_S</span> <span class="org-operator">=</span> get_phi_S(slope)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate phi_E and the max_spread_direction</span>
    <span class="org-variable-name">result</span>               <span class="org-operator">=</span> get_phi_E(wind_vector_3d, slope_vector_3d, phi_W, phi_S)
    <span class="org-variable-name">phi_E</span>                <span class="org-operator">=</span> result[<span class="org-string">"phi_E"</span>]
    <span class="org-variable-name">max_spread_direction</span> <span class="org-operator">=</span> result[<span class="org-string">"max_spread_direction"</span>]
    <span class="org-comment-delimiter"># </span><span class="org-comment">Limit effective wind speed to max wind speed if use_wind_limit == True</span>
    (<span class="org-variable-name">limited_wind_speed</span>, <span class="org-variable-name">limited_phi_E</span>) <span class="org-operator">=</span> maybe_limit_wind_speed(use_wind_limit, max_wind_speed,
                                                                 get_phi_W, get_wind_speed, phi_E)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate and return max surface fire behavior values</span>
    <span class="org-variable-name">max_spread_rate</span>        <span class="org-operator">=</span> spread_rate <span class="org-operator">*</span> (1.0 <span class="org-operator">+</span> limited_phi_E)
    <span class="org-variable-name">max_fireline_intensity</span> <span class="org-operator">=</span> fireline_intensity <span class="org-operator">*</span> (1.0 <span class="org-operator">+</span> limited_phi_E)
    <span class="org-variable-name">length_to_width_ratio</span>  <span class="org-operator">=</span> surface_length_to_width_ratio(limited_wind_speed)
    <span class="org-keyword">return</span> {
        <span class="org-string">"max_spread_rate"</span>       : max_spread_rate,
        <span class="org-string">"max_spread_direction"</span>  : max_spread_direction, <span class="org-comment-delimiter"># </span><span class="org-comment">unit vector</span>
        <span class="org-string">"max_fireline_intensity"</span>: max_fireline_intensity,
        <span class="org-string">"max_flame_length"</span>      : calc_flame_length(max_fireline_intensity),
        <span class="org-string">"length_to_width_ratio"</span> : length_to_width_ratio,
        <span class="org-string">"eccentricity"</span>          : surface_fire_eccentricity(length_to_width_ratio),
    }
</pre>
</div>
</div>
</div>
<div id="outline-container-Surface Fire Behavior in Any Direction" class="outline-4">
<h4 id="Surface Fire Behavior in Any Direction"><span class="section-number-4">6.1.10.</span> Surface Fire Behavior in Any Direction</h4>
<div class="outline-text-4" id="text-Surface Fire Behavior in Any Direction">
<p>
Once we have calculated the maximum surface fire behavior values
associated with a head fire, we can use the elliptical eccentricity
\(E\) to project the maximum spread rate \(R_s\) and maximum fireline
intensity \(I_s\) to any point along the fire front as follows:
</p>

\begin{align}
  \eta &= \frac{1-E}{1-E\cos\omega} \\
  \nonumber \\
  R_s(\omega) &= R_s \, \eta \\
  \nonumber \\
  I_s(\omega) &= I_s \, \eta
\end{align}

<p>
where \(\omega\) is the angular offset from the direction of maximum
fire spread and \(R_s(\omega)\) and \(I_s(\omega)\) are the spread rate
and fireline intensity in this direction respectively.
</p>

<p>
Since the surface fire ellipse is defined on the slope-tangential
plane, we must represent spread directions with three dimensional unit
vectors aligned with this plane rather than with angles. Fortunately,
we can use the relationship between the dot product of two vectors and
the cosine of the angle between them to rewrite the \(\eta\) function
above as follows:
</p>

\begin{align}
  \eta = \frac{1-E}{1-E(\vec{u_{\max}} \cdot \vec{u_{\omega}})}
\end{align}

<p>
where \(\vec{u_{\max}}\) is the slope-tangential unit vector in the
direction of maximum spread and \(\vec{u_{\omega}}\) is the
slope-tangential unit vector rotated \(\omega\) degrees clockwise along
this plane from \(\vec{u_{\max}}\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="surface-fire-behavior-in-direction"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np


<span class="org-keyword">def</span> <span class="org-function-name">calc_surface_fire_behavior_in_direction</span>(surface_fire_max, spread_direction):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - surface_fire_max     :: dictionary of max surface fire behavior values</span>
<span class="org-doc">      - max_spread_rate        :: m/min</span>
<span class="org-doc">      - max_spread_direction   :: (x, y, z) unit vector</span>
<span class="org-doc">      - max_fireline_intensity :: kW/m</span>
<span class="org-doc">      - max_flame_length       :: m</span>
<span class="org-doc">      - length_to_width_ratio  :: unitless (1: circular spread, &gt; 1: elliptical spread)</span>
<span class="org-doc">      - eccentricity           :: unitless (0: circular spread, &gt; 0: elliptical spread)</span>
<span class="org-doc">    - spread_direction     :: 3D unit vector on the slope-tangential plane</span>

<span class="org-doc">    return a dictionary containing these keys:</span>
<span class="org-doc">    - fire_type          :: "surface"</span>
<span class="org-doc">    - spread_rate        :: m/min</span>
<span class="org-doc">    - spread_direction   :: (x, y, z) unit vector</span>
<span class="org-doc">    - fireline_intensity :: kW/m</span>
<span class="org-doc">    - flame_length       :: m</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack max surface fire behavior values</span>
    <span class="org-variable-name">max_spread_rate</span>        <span class="org-operator">=</span> surface_fire_max[<span class="org-string">"max_spread_rate"</span>]
    <span class="org-variable-name">max_spread_direction</span>   <span class="org-operator">=</span> surface_fire_max[<span class="org-string">"max_spread_direction"</span>]
    <span class="org-variable-name">max_fireline_intensity</span> <span class="org-operator">=</span> surface_fire_max[<span class="org-string">"max_fireline_intensity"</span>]
    <span class="org-variable-name">eccentricity</span>           <span class="org-operator">=</span> surface_fire_max[<span class="org-string">"eccentricity"</span>]
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate cos(w), where w is the offset angle between these unit vectors on the slope-tangential plane</span>
    <span class="org-variable-name">cos_w</span> <span class="org-operator">=</span> np.dot(max_spread_direction, np.asarray(spread_direction))
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate adjustment due to the offset angle from the max spread direction</span>
    <span class="org-variable-name">adjustment</span> <span class="org-operator">=</span> (1.0 <span class="org-operator">-</span> eccentricity) <span class="org-operator">/</span> (1.0 <span class="org-operator">-</span> eccentricity <span class="org-operator">*</span> cos_w)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Update surface fire behavior values by the adjustment value</span>
    <span class="org-variable-name">fireline_intensity</span> <span class="org-operator">=</span> max_fireline_intensity <span class="org-operator">*</span> adjustment
    <span class="org-keyword">return</span> {
        <span class="org-string">"fire_type"</span>         : <span class="org-string">"surface"</span>,
        <span class="org-string">"spread_rate"</span>       : max_spread_rate <span class="org-operator">*</span> adjustment,
        <span class="org-string">"spread_direction"</span>  : spread_direction,
        <span class="org-string">"fireline_intensity"</span>: fireline_intensity,
        <span class="org-string">"flame_length"</span>      : calc_flame_length(fireline_intensity),
    }
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-For Users" class="outline-3">
<h3 id="For Users"><span class="section-number-3">6.2.</span> For Users</h3>
<div class="outline-text-3" id="text-For Users">
<p>
In the following sections, we will demonstrate how to calculate the
surface fire behavior values given a fuel model and measurements of
fuel moisture, wind speed, wind direction, slope, and aspect. This
will be done first for the no-wind-no-slope case, followed by the max
spread direction case, and finally in any direction on the sloped
surface using both offset angles from the heading fire direction and
3D vectors specifying absolute directions.
</p>

<p>
Because wind speed and direction will often be provided from
measurements taken 10m or 20ft above the canopy and may be given in
either cartesion <code>(x,y)</code> or azimuthal <code>(r,azimuth)</code> coordinates, we
also demonstrate how to convert from cartesian to azimuthal
coordinates, from 10m to 20ft wind speeds, and from 20ft to midflame
wind speeds, given a fuel model and measurements of canopy height and
canopy cover.
</p>

<p>
See Appendix <a href="#Units Conversion Functions (pyretechnics.conversion)">15.1</a> for
the full list of available units conversion functions.
</p>

<p>
See Appendix <a href="#Vector Utility Functions (pyretechnics.vector_utils)">15.2</a> for
the full list of available vector manipulation functions.
</p>
</div>
<div id="outline-container-How to Calculate the No-Wind-No-Slope Surface Fire Behavior" class="outline-4">
<h4 id="How to Calculate the No-Wind-No-Slope Surface Fire Behavior"><span class="section-number-4">6.2.1.</span> How to Calculate the No-Wind-No-Slope Surface Fire Behavior</h4>
<div class="outline-text-4" id="text-How to Calculate the No-Wind-No-Slope Surface Fire Behavior">
<div class="org-src-container">
<pre class="src src-python" id="compute-surface-fire-behavior-min"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.fuel_models <span class="org-keyword">as</span> fm
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf

<span class="org-comment-delimiter"># </span><span class="org-comment">Set input parameters</span>
<span class="org-variable-name">fuel_model</span>    <span class="org-operator">=</span> fm.fuel_model_table[101] <span class="org-comment-delimiter"># </span><span class="org-comment">GR1</span>
<span class="org-variable-name">fuel_moisture</span> <span class="org-operator">=</span> [
    0.05, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_1hr</span>
    0.10, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_10hr</span>
    0.15, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_100hr</span>
    0.00, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_herbaceous (will be set by moisturize for dynamic fuel models)</span>
    0.90, <span class="org-comment-delimiter"># </span><span class="org-comment">live_herbaceous</span>
    0.60, <span class="org-comment-delimiter"># </span><span class="org-comment">live_woody</span>
]

<span class="org-comment-delimiter"># </span><span class="org-comment">Apply fuel moisture to fuel model</span>
<span class="org-variable-name">moisturized_fuel_model</span> <span class="org-operator">=</span> fm.moisturize(fuel_model, fuel_moisture)

<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate no-wind-no-slope surface fire behavior</span>
<span class="org-variable-name">surface_fire_min</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model)

<span class="org-comment-delimiter"># </span><span class="org-comment">View results</span>
<span class="org-builtin">print</span>(<span class="org-string">"No-Wind-No-Slope Surface Fire Behavior for Fuel Model GR1 with Fuel Moisture = "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(moisturized_fuel_model[<span class="org-string">"M_f"</span>]))
pprint({k: surface_fire_min[k] <span class="org-keyword">for</span> k <span class="org-keyword">in</span> [<span class="org-string">"base_spread_rate"</span>, <span class="org-string">"base_fireline_intensity"</span>, <span class="org-string">"max_effective_wind_speed"</span>]})
</pre>
</div>

<pre class="example">
No-Wind-No-Slope Surface Fire Behavior for Fuel Model GR1 with Fuel Moisture = [0.05, 0.1, 0.15, 0.05, 0.9, 0.6]
{'base_fireline_intensity': 1.789997884491001,
 'base_spread_rate': 0.12637238760906658,
 'max_effective_wind_speed': 109.77292783706747}
</pre>
</div>
</div>
<div id="outline-container-How to Translate the 10m Wind Speed Vector into the Midflame Wind Speed Vector" class="outline-4">
<h4 id="How to Translate the 10m Wind Speed Vector into the Midflame Wind Speed Vector"><span class="section-number-4">6.2.2.</span> How to Translate the 10m Wind Speed Vector into the Midflame Wind Speed Vector</h4>
<div class="outline-text-4" id="text-How to Translate the 10m Wind Speed Vector into the Midflame Wind Speed Vector">
<div class="org-src-container">
<pre class="src src-python" id="translate-10m-wind-to-midflame-wind"><span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv
<span class="org-keyword">import</span> pyretechnics.fuel_models <span class="org-keyword">as</span> fm
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf

<span class="org-comment-delimiter"># </span><span class="org-comment">Set input parameters</span>
<span class="org-variable-name">fuel_model</span>       <span class="org-operator">=</span> fm.fuel_model_table[101] <span class="org-comment-delimiter"># </span><span class="org-comment">GR1</span>
<span class="org-variable-name">canopy_height</span>    <span class="org-operator">=</span> 20                       <span class="org-comment-delimiter"># </span><span class="org-comment">meters</span>
<span class="org-variable-name">canopy_cover</span>     <span class="org-operator">=</span> 0.6                      <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
<span class="org-variable-name">wind_speed_10m</span>   <span class="org-operator">=</span> 20                       <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
<span class="org-variable-name">upwind_direction</span> <span class="org-operator">=</span> 45.0                     <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 10m wind speed to 20ft wind speed</span>
<span class="org-variable-name">wind_speed_20ft</span> <span class="org-operator">=</span> conv.wind_speed_10m_to_wind_speed_20ft(wind_speed_10m) <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 20ft wind speed to midflame wind speed in m/min</span>
<span class="org-variable-name">midflame_wind_speed</span> <span class="org-operator">=</span> sf.calc_midflame_wind_speed(conv.km_hr_to_m_min(wind_speed_20ft), <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
                                                  fuel_model[<span class="org-string">"delta"</span>],                  <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                  conv.m_to_ft(canopy_height),          <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                  canopy_cover)                         <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">View results</span>
<span class="org-builtin">print</span>(<span class="org-string">"Midflame Wind Speed and Direction for 10m Wind Speed = 20 km/hr, Upwind Direction = 45.0</span><span class="org-constant">\n</span><span class="org-string">"</span>
      <span class="org-operator">+</span> <span class="org-string">" with Fuel Model GR1, Canopy Height = 20m, and Canopy Cover = 60%</span><span class="org-constant">\n</span><span class="org-string">"</span>
      <span class="org-operator">+</span> <span class="org-string">"- Speed: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(midflame_wind_speed) <span class="org-operator">+</span> <span class="org-string">" (m/min)</span><span class="org-constant">\n</span><span class="org-string">"</span>
      <span class="org-operator">+</span> <span class="org-string">"- Downwind Direction: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(conv.opposite_direction(upwind_direction)) <span class="org-operator">+</span> <span class="org-string">" (degrees clockwise from North)"</span>)
</pre>
</div>

<pre class="example">
Midflame Wind Speed and Direction for 10m Wind Speed = 20 km/hr, Upwind Direction = 45.0
 with Fuel Model GR1, Canopy Height = 20m, and Canopy Cover = 60%
- Speed: 27.224285989299275 (m/min)
- Downwind Direction: 225.0 (degrees clockwise from North)
</pre>
</div>
</div>
<div id="outline-container-How to Calculate the Surface Fire Behavior in the Direction of Maximum Spread" class="outline-4">
<h4 id="How to Calculate the Surface Fire Behavior in the Direction of Maximum Spread"><span class="section-number-4">6.2.3.</span> How to Calculate the Surface Fire Behavior in the Direction of Maximum Spread</h4>
<div class="outline-text-4" id="text-How to Calculate the Surface Fire Behavior in the Direction of Maximum Spread">
<div class="org-src-container">
<pre class="src src-python" id="compute-surface-fire-behavior-max"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.fuel_models <span class="org-keyword">as</span> fm
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf

<span class="org-comment-delimiter"># </span><span class="org-comment">Set input parameters</span>
<span class="org-variable-name">fuel_model</span>    <span class="org-operator">=</span> fm.fuel_model_table[101] <span class="org-comment-delimiter"># </span><span class="org-comment">GR1</span>
<span class="org-variable-name">fuel_moisture</span> <span class="org-operator">=</span> [
    0.05, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_1hr</span>
    0.10, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_10hr</span>
    0.15, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_100hr</span>
    0.00, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_herbaceous (will be set by moisturize for dynamic fuel models)</span>
    0.90, <span class="org-comment-delimiter"># </span><span class="org-comment">live_herbaceous</span>
    0.60, <span class="org-comment-delimiter"># </span><span class="org-comment">live_woody</span>
]
<span class="org-variable-name">midflame_wind_speed</span> <span class="org-operator">=</span> 500.0 <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
<span class="org-variable-name">upwind_direction</span>    <span class="org-operator">=</span> 215.0 <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
<span class="org-variable-name">slope</span>               <span class="org-operator">=</span> 0.2   <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
<span class="org-variable-name">aspect</span>              <span class="org-operator">=</span> 270.0 <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Apply fuel moisture to fuel model</span>
<span class="org-variable-name">moisturized_fuel_model</span> <span class="org-operator">=</span> fm.moisturize(fuel_model, fuel_moisture)

<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate no-wind-no-slope surface fire behavior</span>
<span class="org-variable-name">surface_fire_min</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model)

<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread with effective wind speed limit</span>
<span class="org-variable-name">surface_fire_max</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_max(surface_fire_min,
                                                     midflame_wind_speed,
                                                     upwind_direction,
                                                     slope,
                                                     aspect)

<span class="org-comment-delimiter"># </span><span class="org-comment">View results</span>
<span class="org-builtin">print</span>(<span class="org-string">"Surface Fire Behavior Max (Limited) for Fuel Model GR1 with Fuel Moisture = "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(moisturized_fuel_model[<span class="org-string">"M_f"</span>]))
pprint(surface_fire_max)

<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread without effective wind speed limit</span>
<span class="org-variable-name">surface_fire_max_unlimited</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_max(surface_fire_min,
                                                               midflame_wind_speed,
                                                               upwind_direction,
                                                               slope,
                                                               aspect,
                                                               use_wind_limit<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-comment-delimiter"># </span><span class="org-comment">View results</span>
<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Surface Fire Behavior Max (Unlimited) for Fuel Model GR1 with Fuel Moisture = "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(moisturized_fuel_model[<span class="org-string">"M_f"</span>]))
pprint(surface_fire_max_unlimited)
</pre>
</div>

<pre class="example" id="org0640c8a">
Surface Fire Behavior Max (Limited) for Fuel Model GR1 with Fuel Moisture = [0.05, 0.1, 0.15, 0.05, 0.9, 0.6]
{'eccentricity': 0.8693098652160369,
 'length_to_width_ratio': 2.0231959552088243,
 'max_fireline_intensity': 32.52824122084378,
 'max_flame_length': 0.3843932850124078,
 'max_spread_direction': array([0.57514211, 0.80992593, 0.11502842]),
 'max_spread_rate': 2.2964672435747526}

Surface Fire Behavior Max (Unlimited) for Fuel Model GR1 with Fuel Moisture = [0.05, 0.1, 0.15, 0.05, 0.9, 0.6]
{'eccentricity': 0.9845208632281957,
 'length_to_width_ratio': 5.705566830080509,
 'max_fireline_intensity': 330.523270465988,
 'max_flame_length': 1.1167831782666553,
 'max_spread_direction': array([0.57514211, 0.80992593, 0.11502842]),
 'max_spread_rate': 23.334672745170035}
</pre>
</div>
</div>
<div id="outline-container-How to Calculate the Surface Fire Behavior in Any Direction" class="outline-4">
<h4 id="How to Calculate the Surface Fire Behavior in Any Direction"><span class="section-number-4">6.2.4.</span> How to Calculate the Surface Fire Behavior in Any Direction</h4>
<div class="outline-text-4" id="text-How to Calculate the Surface Fire Behavior in Any Direction">
<div class="org-src-container">
<pre class="src src-python" id="compute-surface-fire-behavior-in-direction"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.fuel_models <span class="org-keyword">as</span> fm
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf
<span class="org-keyword">import</span> pyretechnics.vector_utils <span class="org-keyword">as</span> vu

<span class="org-comment-delimiter"># </span><span class="org-comment">Set input parameters</span>
<span class="org-variable-name">fuel_model</span>    <span class="org-operator">=</span> fm.fuel_model_table[101] <span class="org-comment-delimiter"># </span><span class="org-comment">GR1</span>
<span class="org-variable-name">fuel_moisture</span> <span class="org-operator">=</span> [
    0.05, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_1hr</span>
    0.10, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_10hr</span>
    0.15, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_100hr</span>
    0.00, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_herbaceous (will be set by moisturize for dynamic fuel models)</span>
    0.90, <span class="org-comment-delimiter"># </span><span class="org-comment">live_herbaceous</span>
    0.60, <span class="org-comment-delimiter"># </span><span class="org-comment">live_woody</span>
]
<span class="org-variable-name">midflame_wind_speed</span> <span class="org-operator">=</span> 500.0 <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
<span class="org-variable-name">upwind_direction</span>    <span class="org-operator">=</span> 215.0 <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
<span class="org-variable-name">slope</span>               <span class="org-operator">=</span> 0.2   <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
<span class="org-variable-name">aspect</span>              <span class="org-operator">=</span> 270.0 <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Apply fuel moisture to fuel model</span>
<span class="org-variable-name">moisturized_fuel_model</span> <span class="org-operator">=</span> fm.moisturize(fuel_model, fuel_moisture)

<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate no-wind-no-slope surface fire behavior</span>
<span class="org-variable-name">surface_fire_min</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model)

<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread with effective wind speed limit</span>
<span class="org-variable-name">surface_fire_max</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_max(surface_fire_min,
                                                     midflame_wind_speed,
                                                     upwind_direction,
                                                     slope,
                                                     aspect)

<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior for the heading, flanking, and backing fires</span>
<span class="org-variable-name">heading_fire_direction</span>  <span class="org-operator">=</span> surface_fire_max[<span class="org-string">"max_spread_direction"</span>]
<span class="org-variable-name">flanking_fire_direction</span> <span class="org-operator">=</span> vu.rotate_on_sloped_plane(heading_fire_direction, 90, slope, aspect)
<span class="org-variable-name">backing_fire_direction</span>  <span class="org-operator">=</span> <span class="org-operator">-</span>heading_fire_direction

<span class="org-variable-name">heading_fire_behavior</span>  <span class="org-operator">=</span> sf.calc_surface_fire_behavior_in_direction(surface_fire_max, heading_fire_direction)
<span class="org-variable-name">flanking_fire_behavior</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_in_direction(surface_fire_max, flanking_fire_direction)
<span class="org-variable-name">backing_fire_behavior</span>  <span class="org-operator">=</span> sf.calc_surface_fire_behavior_in_direction(surface_fire_max, backing_fire_direction)

<span class="org-comment-delimiter"># </span><span class="org-comment">View heading fire results</span>
<span class="org-builtin">print</span>(<span class="org-string">"Heading Fire Behavior for Fuel Model GR1 with Fuel Moisture = "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(moisturized_fuel_model[<span class="org-string">"M_f"</span>]))
pprint(heading_fire_behavior)

<span class="org-comment-delimiter"># </span><span class="org-comment">View flanking fire results</span>
<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Flanking Fire Behavior for Fuel Model GR1 with Fuel Moisture = "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(moisturized_fuel_model[<span class="org-string">"M_f"</span>]))
pprint(flanking_fire_behavior)

<span class="org-comment-delimiter"># </span><span class="org-comment">View backing fire results</span>
<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Backing Fire Behavior for Fuel Model GR1 with Fuel Moisture = "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(moisturized_fuel_model[<span class="org-string">"M_f"</span>]))
pprint(backing_fire_behavior)
</pre>
</div>

<pre class="example" id="orgbe6eea3">
Heading Fire Behavior for Fuel Model GR1 with Fuel Moisture = [0.05, 0.1, 0.15, 0.05, 0.9, 0.6]
{'fire_type': 'surface',
 'fireline_intensity': 32.528241220843725,
 'flame_length': 0.38439328501240755,
 'spread_direction': array([0.57514211, 0.80992593, 0.11502842]),
 'spread_rate': 2.2964672435747486}

Flanking Fire Behavior for Fuel Model GR1 with Fuel Moisture = [0.05, 0.1, 0.15, 0.05, 0.9, 0.6]
{'fire_type': 'surface',
 'fireline_intensity': 4.251120229437338,
 'flame_length': 0.15074658520504813,
 'spread_direction': array([ 0.79419771, -0.58653217,  0.15883954]),
 'spread_rate': 0.3001256135897406}

Backing Fire Behavior for Fuel Model GR1 with Fuel Moisture = [0.05, 0.1, 0.15, 0.05, 0.9, 0.6]
{'fire_type': 'surface',
 'fireline_intensity': 2.2741656204473273,
 'flame_length': 0.11305091610423659,
 'spread_direction': array([-0.57514211, -0.80992593, -0.11502842]),
 'spread_rate': 0.160554234038162}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-Crown Fire Equations (pyretechnics.crown_fire)" class="outline-2">
<h2 id="Crown Fire Equations (pyretechnics.crown_fire)"><span class="section-number-2">7.</span> Crown Fire Equations (pyretechnics.crown_fire)</h2>
<div class="outline-text-2" id="text-Crown Fire Equations (pyretechnics.crown_fire)">
</div>
<div id="outline-container-For Developers" class="outline-3">
<h3 id="For Developers"><span class="section-number-3">7.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-For Developers">
<p>
The following sections define functions that calculate the spread rate
and intensity of a fire burning through tree canopy fuels. These
functions combine the surface fire behavior values calculated in
section <a href="#Surface Fire Equations (pyretechnics.surface_fire)">6</a> with
measurements of foliar moisture, dead 1 hour fuel moisture, canopy
cover, canopy height, canopy base height, and canopy bulk density to
determine whether a surface fire will spread into either a passive or
active crown fire. If so, they can then calculate the maximum spread
rate and direction of this crown fire as well as its fireline
intensity and flame length.
</p>
</div>
<div id="outline-container-Crown Fire Initiation" class="outline-4">
<h4 id="Crown Fire Initiation"><span class="section-number-4">7.1.1.</span> Crown Fire Initiation</h4>
<div class="outline-text-4" id="text-Crown Fire Initiation">
<p>
In order to incorporate the effects of crown fire behavior,
Pyretechnics includes the crown fire initiation routine from Van
Wagner 1977.<sup><a id="fnr.26" class="footref" href="#fn.26" role="doc-backlink">26</a></sup> According to this approach, we begin
by calculating the <i>critical fireline intensity</i> as follows:
</p>

\begin{align}
  H &= 460 + 2600 M^f \\
  \nonumber \\
  I_s^* &= (0.01 \, Z_b \, H)^{1.5}
\end{align}

<p>
where \(H\) is the heat of ignition for the herbaceous material in the
canopy in \(\text{kJ/kg}\), \(M^f\) is the foliar moisture content in
\(\text{kg moisture/kg ovendry weight}\), \(Z_b\) is the canopy base
height in meters, and \(I_s^*\) is the critical fireline intensity in
\(\text{kW/m}\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="van-wagner-critical-fireline-intensity"><span class="org-keyword">def</span> <span class="org-function-name">van_wagner_critical_fireline_intensity</span>(canopy_base_height, foliar_moisture):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the critical fireline intensity (kW/m) given:</span>
<span class="org-doc">    - canopy_base_height :: m</span>
<span class="org-doc">    - foliar_moisture    :: kg moisture/kg ovendry weight</span>

<span class="org-doc">    Constants used:</span>
<span class="org-doc">    460.0 = heat-of-ignition :: kJ/kg</span>
<span class="org-doc">    0.01 = empirical estimate for C in Van Wagner 1977 (eq. 4)</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">H</span> <span class="org-operator">=</span> 460.0 <span class="org-operator">+</span> 2600.0 <span class="org-operator">*</span> foliar_moisture
    <span class="org-keyword">return</span> (0.01 <span class="org-operator">*</span> canopy_base_height <span class="org-operator">*</span> H) <span class="org-operator">**</span> 1.5
</pre>
</div>

<p>
If a surface fire is present, the canopy cover is greater than 40%,
and the surface fireline intensity \(I_s\) is greater than or equal to
the critical fireline intensity \(I_s^*\), then the surface fire
transitions to a crown fire.
</p>

<div class="org-src-container">
<pre class="src src-python" id="van-wagner-crown-fire-initiation"><span class="org-keyword">def</span> <span class="org-function-name">van_wagner_crown_fire_initiation</span>(surface_fireline_intensity, canopy_cover, canopy_base_height, foliar_moisture):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns True if the surface fire transitions to a crown fire or False otherwise given:</span>
<span class="org-doc">    - surface_fireline_intensity :: kW/m</span>
<span class="org-doc">    - canopy_cover               :: 0-1</span>
<span class="org-doc">    - canopy_base_height         :: m</span>
<span class="org-doc">    - foliar_moisture            :: kg moisture/kg ovendry weight</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> (
        surface_fireline_intensity <span class="org-operator">&gt;</span> 0.0
        <span class="org-keyword">and</span>
        canopy_cover <span class="org-operator">&gt;</span> 0.4
        <span class="org-keyword">and</span>
        surface_fireline_intensity <span class="org-operator">&gt;=</span> van_wagner_critical_fireline_intensity(canopy_base_height, foliar_moisture)
    )
</pre>
</div>
</div>
</div>
<div id="outline-container-Passive and Active Crown Fire Spread Rate Functions" class="outline-4">
<h4 id="Passive and Active Crown Fire Spread Rate Functions"><span class="section-number-4">7.1.2.</span> Passive and Active Crown Fire Spread Rate Functions</h4>
<div class="outline-text-4" id="text-Passive and Active Crown Fire Spread Rate Functions">
<p>
If crowning occurs, then the active crown fire spread rate is
calculated from the following formula given in Cruz
2005:<sup><a id="fnr.27" class="footref" href="#fn.27" role="doc-backlink">27</a></sup>
</p>

\begin{align}
  \text{CROS}_A = 11.02 \, U_{10\text{m}}^{0.90} \, B_m^{0.19} \, e^{-17 \, \text{EFFM}} \\
\end{align}

<p>
where \(\text{CROS}_A\) is the active crown fire spread rate in
\(\text{m}/\min\), \(U_{10\text{m}}\) is the 10 meter windspeed in
\(\text{km/hr}\), \(B_m\) is the canopy bulk density in \(\text{kg/m}^3\),
and \(\text{EFFM}\) is the estimated fine fuel moisture in \(\text{kg moisture/kg ovendry weight}\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="cruz-active-crown-fire-spread-rate"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> exp


<span class="org-keyword">def</span> <span class="org-function-name">cruz_active_crown_fire_spread_rate</span>(wind_speed_10m, canopy_bulk_density, estimated_fine_fuel_moisture):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the active crown fire spread rate (m/min) given:</span>
<span class="org-doc">    - wind_speed_10m                                   :: km/hr</span>
<span class="org-doc">    - canopy_bulk_density                              :: kg/m^3</span>
<span class="org-doc">    - estimated_fine_fuel_moisture (M_f[0] "dead-1hr") :: kg moisture/kg ovendry weight</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> (11.02
            <span class="org-operator">*</span> wind_speed_10m <span class="org-operator">**</span> 0.90
            <span class="org-operator">*</span> canopy_bulk_density <span class="org-operator">**</span> 0.19
            <span class="org-operator">*</span> exp(<span class="org-operator">-</span>17.0 <span class="org-operator">*</span> estimated_fine_fuel_moisture))
</pre>
</div>

<p>
Next, we need to calculate the <i>critical spread rate</i> from Van Wagner
1977<sup><a id="fnr.28" class="footref" href="#fn.28" role="doc-backlink">28</a></sup> as follows:
</p>

\begin{align}
  R^* = \frac{3.0}{B_m}
\end{align}

<p>
where \(R^*\) is the critical spread rate in \(\text{m}/\min\) and \(B_m\)
is the canopy bulk density in \(\text{kg/m}^3\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="van-wagner-critical-spread-rate"><span class="org-keyword">def</span> <span class="org-function-name">van_wagner_critical_spread_rate</span>(canopy_bulk_density):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the critical spread rate (m/min) given:</span>
<span class="org-doc">    - canopy_bulk_density :: kg/m^3</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> 3.0 <span class="org-operator">/</span> canopy_bulk_density
</pre>
</div>

<p>
If the active crown fire spread rate \(\text{CROS}_A\) is greater than
the critical spread rate \(R^*\), then the crown fire will be active,
otherwise passive. In the event of a passive crown fire, its spread
rate is calculated using the following formula from Cruz
2005:<sup><a id="fnr.29" class="footref" href="#fn.29" role="doc-backlink">29</a></sup>
</p>

\begin{align}
  \text{CROS}_P = \text{CROS}_A \, e^{-\text{CROS}_A / R^*}
\end{align}

<p>
where \(\text{CROS}_P\) is the passive crown fire spread rate in
\(\text{m}/\min\), \(\text{CROS}_A\) is the active crown fire spread rate
in \(\text{m}/\min\), and \(R^*\) is the critical spread rate in
\(\text{m}/\min\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="cruz-passive-crown-fire-spread-rate"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> exp


<span class="org-keyword">def</span> <span class="org-function-name">cruz_passive_crown_fire_spread_rate</span>(active_spread_rate, critical_spread_rate):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the passive crown fire spread rate (m/min) given:</span>
<span class="org-doc">    - active_spread_rate   :: m/min</span>
<span class="org-doc">    - critical_spread_rate :: m/min</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> active_spread_rate <span class="org-operator">*</span> exp(<span class="org-operator">-</span>active_spread_rate <span class="org-operator">/</span> critical_spread_rate)
</pre>
</div>

<p>
Putting it all together, the following function calculates the
critical spread rate, whether a crown fire will become passive or
active, and its associated passive or active spread rate.
</p>

<div class="org-src-container">
<pre class="src src-python" id="cruz-crown-fire-spread-info"><span class="org-keyword">def</span> <span class="org-function-name">cruz_crown_fire_spread_info</span>(wind_speed_10m, canopy_bulk_density, estimated_fine_fuel_moisture):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - wind_speed_10m                                   :: km/hr</span>
<span class="org-doc">    - canopy_bulk_density                              :: kg/m^3</span>
<span class="org-doc">    - estimated_fine_fuel_moisture (M_f[0] "dead-1hr") :: kg moisture/kg ovendry weight</span>

<span class="org-doc">    return a dictionary containing these keys:</span>
<span class="org-doc">    - fire_type            :: "passive_crown" or "active_crown"</span>
<span class="org-doc">    - spread_rate          :: m/min</span>
<span class="org-doc">    - critical_spread_rate :: m/min</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">active_spread_rate</span>   <span class="org-operator">=</span> cruz_active_crown_fire_spread_rate(wind_speed_10m,
                                                              canopy_bulk_density,
                                                              estimated_fine_fuel_moisture) <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
    <span class="org-variable-name">critical_spread_rate</span> <span class="org-operator">=</span> van_wagner_critical_spread_rate(canopy_bulk_density) <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
    <span class="org-keyword">if</span> (active_spread_rate <span class="org-operator">&gt;</span> critical_spread_rate):
        <span class="org-keyword">return</span> {
            <span class="org-string">"fire_type"</span>           : <span class="org-string">"active_crown"</span>,
            <span class="org-string">"spread_rate"</span>         : active_spread_rate,
            <span class="org-string">"critical_spread_rate"</span>: critical_spread_rate,
        }
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> {
            <span class="org-string">"fire_type"</span>           : <span class="org-string">"passive_crown"</span>,
            <span class="org-string">"spread_rate"</span>         : cruz_passive_crown_fire_spread_rate(active_spread_rate, critical_spread_rate),
            <span class="org-string">"critical_spread_rate"</span>: critical_spread_rate,
        }
</pre>
</div>
</div>
</div>
<div id="outline-container-Crown Fire Intensity Functions" class="outline-4">
<h4 id="Crown Fire Intensity Functions"><span class="section-number-4">7.1.3.</span> Crown Fire Intensity Functions</h4>
<div class="outline-text-4" id="text-Crown Fire Intensity Functions">
<p>
Once the crown fire spread rate is determined, the crown fireline
intensity and flame length may be calculated using the following
formulas:
</p>

\begin{align}
  I_c &= \frac{R_c \, B \, (Z - Z_b) \, h}{60} \\
  \nonumber \\
  L_c &= 0.45(I_s + I_c)^{0.46}
\end{align}

<p>
where \(I_c\) is the crown fireline intensity in \(\text{Btu/ft/s}\),
\(R_c\) is the crown fire spread rate (either \(\text{CROS}_A\) or
\(\text{CROS}_P\)) in \(\text{ft}/\min\), \(B\) is the canopy bulk density
in \(\text{lb/ft}^3\), \(Z\) is the canopy height in \(\text{ft}\), \(Z_b\) is
the canopy base height in \(\text{ft}\), \(h\) is the fuel model heat of
combustion (generally 8000 \(\text{Btu/lb}\)), \(L_c\) is the crown fire
flame length in \(\text{ft}\), and \(I_s\) is the surface fireline
intensity in \(\text{Btu/ft/s}\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="crown-fireline-intensity"><span class="org-keyword">from</span> pyretechnics.surface_fire <span class="org-keyword">import</span> calc_flame_length


<span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: heat_of_combustion is h from the fuel models (generally 8000 Btu/lb)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: ELMFIRE hard-codes heat_of_combustion to 18000 kJ/kg = 7738.6 Btu/lb</span>
<span class="org-keyword">def</span> <span class="org-function-name">calc_crown_fireline_intensity</span>(crown_spread_rate, canopy_bulk_density, canopy_height,
                                  canopy_base_height, heat_of_combustion):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the crown fireline intensity (Btu/ft/s OR kW/m) given:</span>
<span class="org-doc">    - crown_spread_rate                                             :: ft/min  OR m/min</span>
<span class="org-doc">    - canopy_bulk_density                                           :: lb/ft^3 OR kg/m^3</span>
<span class="org-doc">    - canopy_height                                                 :: ft      OR m</span>
<span class="org-doc">    - canopy_base_height                                            :: ft      OR m</span>
<span class="org-doc">    - heat_of_combustion                                            :: Btu/lb  OR kJ/kg</span>

<span class="org-doc">    (ft/min * lb/ft^3 * ft * Btu/lb)/60 = (Btu/ft/min)/60 = Btu/ft/s</span>
<span class="org-doc">    OR</span>
<span class="org-doc">    (m/min * kg/m^3 * m * kJ/kg)/60 = (kJ/m*min)/60 = kJ/m*s = kW/m</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">canopy_height_difference</span> <span class="org-operator">=</span> canopy_height <span class="org-operator">-</span> canopy_base_height
    <span class="org-keyword">return</span> (crown_spread_rate <span class="org-operator">*</span> canopy_bulk_density <span class="org-operator">*</span> canopy_height_difference <span class="org-operator">*</span> heat_of_combustion) <span class="org-operator">/</span> 60.0


<span class="org-keyword">def</span> <span class="org-function-name">calc_crown_fire_flame_length</span>(surface_fireline_intensity, crown_fireline_intensity):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the crown fire flame length (m) given:</span>
<span class="org-doc">    - surface_fireline_intensity :: kW/m</span>
<span class="org-doc">    - crown_fireline_intensity   :: kW/m</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> calc_flame_length(surface_fireline_intensity <span class="org-operator">+</span> crown_fireline_intensity) <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-Elliptical Eccentricity" class="outline-4">
<h4 id="Elliptical Eccentricity"><span class="section-number-4">7.1.4.</span> Elliptical Eccentricity</h4>
<div class="outline-text-4" id="text-Elliptical Eccentricity">
<p>
As with surface fire spread, the wind speed (this time the 20-ft wind
speed \(U_{20}\)) is used to compute the length to width ratio
\(\frac{L}{W}\) of an ellipse that approximates the crown fire front
using equation 10 from Rothermel 1991.<sup><a id="fnr.30" class="footref" href="#fn.30" role="doc-backlink">30</a></sup> This length
to width ratio is then converted into an eccentricity measure of the
ellipse using equation 8 from Albini and Chase 1980.<sup><a id="fnr.31" class="footref" href="#fn.31" role="doc-backlink">31</a></sup>
Here are the formulas used:
</p>

\begin{align}
  \frac{L}{W} &= 1 + 0.125 \, U_{20} \\
  \nonumber \\
  E &= \frac{\sqrt{(\frac{L}{W})^2 - 1}}{\frac{L}{W}}
\end{align}

<p>
where \(U_{20}\) is the 20-ft wind speed in \(\text{mph}\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="crown-fire-eccentricity"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> sqrt
<span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv


<span class="org-keyword">def</span> <span class="org-function-name">crown_length_to_width_ratio</span>(wind_speed_10m, max_length_to_width_ratio<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the length_to_width_ratio of the crown fire front using eq. 9 from</span>
<span class="org-doc">    Rothermel 1991 given:</span>
<span class="org-doc">    - wind_speed_10m            :: km/hr (aligned with the slope-tangential plane)</span>
<span class="org-doc">    - max_length_to_width_ratio :: float &gt; 0.0 (Optional)</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">wind_speed_20ft_mph</span>   <span class="org-operator">=</span> conv.km_hr_to_mph(conv.wind_speed_10m_to_wind_speed_20ft(wind_speed_10m)) <span class="org-comment-delimiter"># </span><span class="org-comment">mph</span>
    <span class="org-variable-name">length_to_width_ratio</span> <span class="org-operator">=</span> 1.0 <span class="org-operator">+</span> 0.125 <span class="org-operator">*</span> wind_speed_20ft_mph
    <span class="org-keyword">if</span> max_length_to_width_ratio:
        <span class="org-keyword">return</span> <span class="org-builtin">min</span>(length_to_width_ratio, max_length_to_width_ratio)
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> length_to_width_ratio


<span class="org-keyword">def</span> <span class="org-function-name">crown_fire_eccentricity</span>(length_to_width_ratio):
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the eccentricity (E) of the crown fire front using eq. 8 from</span>
<span class="org-doc">    Albini and Chase 1980 given:</span>
<span class="org-doc">    - L/W :: (1: circular spread, &gt; 1: elliptical spread)</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> sqrt(length_to_width_ratio <span class="org-operator">**</span> 2.0 <span class="org-operator">-</span> 1.0) <span class="org-operator">/</span> length_to_width_ratio
</pre>
</div>
</div>
</div>
<div id="outline-container-Crown Fire Behavior in the Direction of Maximum Spread" class="outline-4">
<h4 id="Crown Fire Behavior in the Direction of Maximum Spread"><span class="section-number-4">7.1.5.</span> Crown Fire Behavior in the Direction of Maximum Spread</h4>
<div class="outline-text-4" id="text-Crown Fire Behavior in the Direction of Maximum Spread">
<p>
This section introduces a function that computes all of the crown fire
behavior values described in the previous sections. In order to
accurately compare the crown fire behavior values from this section
with the surface fire behavior values from section <a href="#Surface Fire Behavior in the Direction of Maximum Spread">6.1.9</a>, the 10 meter wind vector
must be projected onto the slope-tangential plane (using Waeselynck
2024<sup><a id="fnr.32" class="footref" href="#fn.32" role="doc-backlink">32</a></sup>) before the crown fire's maximum spread rate
and associated elliptical parameters are calculated. This ensures that
both the surface fire and crown fire ellipses are aligned with the
slope-tangential plane for later comparison in section <a href="#Combining Surface and Crown Fire Behavior">7.1.7</a>.
</p>

<div class="org-src-container">
<pre class="src src-python" id="crown-fire-behavior-max"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf
<span class="org-keyword">import</span> pyretechnics.vector_utils <span class="org-keyword">as</span> vu


<span class="org-keyword">def</span> <span class="org-function-name">calc_crown_fire_behavior_max</span>(canopy_height, canopy_base_height, canopy_bulk_density, heat_of_combustion,
                                 estimated_fine_fuel_moisture, wind_speed_10m, upwind_direction,
                                 slope, aspect, max_length_to_width_ratio<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - canopy_height                                    :: m</span>
<span class="org-doc">    - canopy_base_height                               :: m</span>
<span class="org-doc">    - canopy_bulk_density                              :: kg/m^3</span>
<span class="org-doc">    - heat_of_combustion                               :: kJ/kg</span>
<span class="org-doc">    - estimated_fine_fuel_moisture (M_f[0] "dead-1hr") :: kg moisture/kg ovendry weight</span>
<span class="org-doc">    - wind_speed_10m                                   :: km/hr</span>
<span class="org-doc">    - upwind_direction                                 :: degrees clockwise from North</span>
<span class="org-doc">    - slope                                            :: rise/run</span>
<span class="org-doc">    - aspect                                           :: degrees clockwise from North</span>
<span class="org-doc">    - max_length_to_width_ratio                        :: float &gt; 0.0 (Optional)</span>

<span class="org-doc">    return a dictionary containing these keys:</span>
<span class="org-doc">    - max_fire_type          :: "passive_crown" or "active_crown"</span>
<span class="org-doc">    - max_spread_rate        :: m/min</span>
<span class="org-doc">    - max_spread_direction   :: (x, y, z) unit vector</span>
<span class="org-doc">    - max_fireline_intensity :: kW/m</span>
<span class="org-doc">    - length_to_width_ratio  :: unitless (1: circular spread, &gt; 1: elliptical spread)</span>
<span class="org-doc">    - eccentricity           :: unitless (0: circular spread, &gt; 0: elliptical spread)</span>
<span class="org-doc">    - critical_spread_rate   :: m/min</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Reverse the provided wind and slope directions</span>
    <span class="org-variable-name">downwind_direction</span> <span class="org-operator">=</span> conv.opposite_direction(upwind_direction)
    <span class="org-variable-name">upslope_direction</span>  <span class="org-operator">=</span> conv.opposite_direction(aspect)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Project wind and slope vectors onto the slope-tangential plane</span>
    <span class="org-variable-name">vectors</span> <span class="org-operator">=</span> sf.project_wind_and_slope_vectors_3d(wind_speed_10m, downwind_direction, slope, upslope_direction)
    <span class="org-variable-name">wind_vector_3d</span>  <span class="org-operator">=</span> vectors[<span class="org-string">"wind_vector_3d"</span>]  <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-variable-name">slope_vector_3d</span> <span class="org-operator">=</span> vectors[<span class="org-string">"slope_vector_3d"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Determine the max spread direction</span>
    <span class="org-variable-name">wind_speed_10m_3d</span>    <span class="org-operator">=</span> vu.vector_magnitude(wind_vector_3d)      <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-variable-name">max_spread_direction</span> <span class="org-operator">=</span> (wind_vector_3d <span class="org-operator">/</span> wind_speed_10m_3d      <span class="org-comment-delimiter"># </span><span class="org-comment">unit vector in the 3D downwind direction</span>
                            <span class="org-keyword">if</span> wind_speed_10m_3d <span class="org-operator">&gt;</span> 0.0
                            <span class="org-keyword">else</span> vu.as_unit_vector(slope_vector_3d) <span class="org-comment-delimiter"># </span><span class="org-comment">unit vector in the 3D upslope direction</span>
                            <span class="org-keyword">if</span> slope <span class="org-operator">&gt;</span> 0.0
                            <span class="org-keyword">else</span> np.asarray((0,1,0)))               <span class="org-comment-delimiter"># </span><span class="org-comment">default: North</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the crown fire behavior in the max spread direction</span>
    <span class="org-variable-name">spread_info</span>           <span class="org-operator">=</span> cruz_crown_fire_spread_info(wind_speed_10m_3d, canopy_bulk_density,
                                                        estimated_fine_fuel_moisture)
    <span class="org-variable-name">spread_rate</span>           <span class="org-operator">=</span> spread_info[<span class="org-string">"spread_rate"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
    <span class="org-variable-name">fireline_intensity</span>    <span class="org-operator">=</span> calc_crown_fireline_intensity(spread_rate, canopy_bulk_density, canopy_height,
                                                          canopy_base_height, heat_of_combustion) <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
    <span class="org-variable-name">length_to_width_ratio</span> <span class="org-operator">=</span> crown_length_to_width_ratio(wind_speed_10m_3d, max_length_to_width_ratio) <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
    <span class="org-variable-name">eccentricity</span>          <span class="org-operator">=</span> crown_fire_eccentricity(length_to_width_ratio) <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
    <span class="org-keyword">return</span> {
        <span class="org-string">"max_fire_type"</span>         : spread_info[<span class="org-string">"fire_type"</span>],
        <span class="org-string">"max_spread_rate"</span>       : spread_rate,
        <span class="org-string">"max_spread_direction"</span>  : max_spread_direction, <span class="org-comment-delimiter"># </span><span class="org-comment">unit vector</span>
        <span class="org-string">"max_fireline_intensity"</span>: fireline_intensity,
        <span class="org-string">"length_to_width_ratio"</span> : length_to_width_ratio,
        <span class="org-string">"eccentricity"</span>          : eccentricity,
        <span class="org-string">"critical_spread_rate"</span>  : spread_info[<span class="org-string">"critical_spread_rate"</span>],
    }
</pre>
</div>
</div>
</div>
<div id="outline-container-Crown Fire Behavior in Any Direction" class="outline-4">
<h4 id="Crown Fire Behavior in Any Direction"><span class="section-number-4">7.1.6.</span> Crown Fire Behavior in Any Direction</h4>
<div class="outline-text-4" id="text-Crown Fire Behavior in Any Direction">
<p>
Once we have calculated the maximum crown fire behavior values
associated with a head fire, we can use the elliptical eccentricity
\(E\) to project the maximum spread rate \(R_c\) and maximum fireline
intensity \(I_c\) to any point along the fire front as follows:
</p>

\begin{align}
  \eta &= \frac{1-E}{1-E\cos\omega} \\
  \nonumber \\
  R_c(\omega) &= R_c \, \eta \\
  \nonumber \\
  I_c(\omega) &= I_c \, \eta
\end{align}

<p>
where \(\omega\) is the angular offset from the direction of maximum
fire spread and \(R_c(\omega)\) and \(I_c(\omega)\) are the spread rate
and fireline intensity in this direction respectively.
</p>

<p>
Since the crown fire ellipse is defined on the slope-tangential plane,
we must represent spread directions with three dimensional unit
vectors aligned with this plane rather than with angles. Fortunately,
we can use the relationship between the dot product of two vectors and
the cosine of the angle between them to rewrite the \(\eta\) function
above as follows:
</p>

\begin{align}
  \eta = \frac{1-E}{1-E(\vec{u_{\max}} \cdot \vec{u_{\omega}})}
\end{align}

<p>
where \(\vec{u_{\max}}\) is the slope-tangential unit vector in the
direction of maximum spread and \(\vec{u_{\omega}}\) is the
slope-tangential unit vector rotated \(\omega\) degrees clockwise along
this plane from \(\vec{u_{\max}}\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="crown-fire-behavior-in-direction"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np


<span class="org-keyword">def</span> <span class="org-function-name">calc_crown_fire_behavior_in_direction</span>(crown_fire_max, spread_direction):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - crown_fire_max     :: dictionary of max crown fire behavior values</span>
<span class="org-doc">      - max_fire_type          :: "passive_crown" or "active_crown"</span>
<span class="org-doc">      - max_spread_rate        :: m/min</span>
<span class="org-doc">      - max_spread_direction   :: (x, y, z) unit vector</span>
<span class="org-doc">      - max_fireline_intensity :: kW/m</span>
<span class="org-doc">      - length_to_width_ratio  :: unitless (1: circular spread, &gt; 1: elliptical spread)</span>
<span class="org-doc">      - eccentricity           :: unitless (0: circular spread, &gt; 0: elliptical spread)</span>
<span class="org-doc">      - critical_spread_rate   :: m/min</span>
<span class="org-doc">    - spread_direction   :: 3D unit vector on the slope-tangential plane</span>

<span class="org-doc">    return a dictionary containing these keys:</span>
<span class="org-doc">    - fire_type          :: "passive_crown" or "active_crown"</span>
<span class="org-doc">    - spread_rate        :: m/min</span>
<span class="org-doc">    - spread_direction   :: (x, y, z) unit vector</span>
<span class="org-doc">    - fireline_intensity :: kW/m</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack max crown fire behavior values</span>
    <span class="org-variable-name">max_fire_type</span>          <span class="org-operator">=</span> crown_fire_max[<span class="org-string">"max_fire_type"</span>]
    <span class="org-variable-name">max_spread_rate</span>        <span class="org-operator">=</span> crown_fire_max[<span class="org-string">"max_spread_rate"</span>]
    <span class="org-variable-name">max_spread_direction</span>   <span class="org-operator">=</span> crown_fire_max[<span class="org-string">"max_spread_direction"</span>]
    <span class="org-variable-name">max_fireline_intensity</span> <span class="org-operator">=</span> crown_fire_max[<span class="org-string">"max_fireline_intensity"</span>]
    <span class="org-variable-name">eccentricity</span>           <span class="org-operator">=</span> crown_fire_max[<span class="org-string">"eccentricity"</span>]
    <span class="org-variable-name">critical_spread_rate</span>   <span class="org-operator">=</span> crown_fire_max[<span class="org-string">"critical_spread_rate"</span>]
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate cos(w), where w is the offset angle between these unit vectors on the slope-tangential plane</span>
    <span class="org-variable-name">cos_w</span> <span class="org-operator">=</span> np.dot(max_spread_direction, np.asarray(spread_direction))
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate adjustment due to the offset angle from the max spread direction</span>
    <span class="org-variable-name">adjustment</span> <span class="org-operator">=</span> (1.0 <span class="org-operator">-</span> eccentricity) <span class="org-operator">/</span> (1.0 <span class="org-operator">-</span> eccentricity <span class="org-operator">*</span> cos_w)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Adjust the spread rate (possibly switching from an active to passive crown fire)</span>
    <span class="org-variable-name">spread_rate</span> <span class="org-operator">=</span> max_spread_rate <span class="org-operator">*</span> adjustment
    <span class="org-keyword">if</span> spread_rate <span class="org-operator">&gt;</span> critical_spread_rate:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Max spread rate was active and directional spread rate remains active</span>
        <span class="org-keyword">return</span> {
            <span class="org-string">"fire_type"</span>         : <span class="org-string">"active_crown"</span>,
            <span class="org-string">"spread_rate"</span>       : spread_rate,
            <span class="org-string">"spread_direction"</span>  : spread_direction,
            <span class="org-string">"fireline_intensity"</span>: max_fireline_intensity <span class="org-operator">*</span> adjustment,
        }
    <span class="org-keyword">elif</span> max_fire_type <span class="org-operator">==</span> <span class="org-string">"passive_crown"</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Max spread rate was passive and directional spread rate remains passive</span>
        <span class="org-keyword">return</span> {
            <span class="org-string">"fire_type"</span>         : <span class="org-string">"passive_crown"</span>,
            <span class="org-string">"spread_rate"</span>       : spread_rate,
            <span class="org-string">"spread_direction"</span>  : spread_direction,
            <span class="org-string">"fireline_intensity"</span>: max_fireline_intensity <span class="org-operator">*</span> adjustment,
        }
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Max spread rate was active and directional spread rate has become passive</span>
        <span class="org-keyword">return</span> {
            <span class="org-string">"fire_type"</span>         : <span class="org-string">"passive_crown"</span>,
            <span class="org-string">"spread_rate"</span>       : cruz_passive_crown_fire_spread_rate(spread_rate, critical_spread_rate),
            <span class="org-string">"spread_direction"</span>  : spread_direction,
            <span class="org-string">"fireline_intensity"</span>: max_fireline_intensity <span class="org-operator">*</span> adjustment,
        }
</pre>
</div>
</div>
</div>
<div id="outline-container-Combining Surface and Crown Fire Behavior" class="outline-4">
<h4 id="Combining Surface and Crown Fire Behavior"><span class="section-number-4">7.1.7.</span> Combining Surface and Crown Fire Behavior</h4>
<div class="outline-text-4" id="text-Combining Surface and Crown Fire Behavior">
<p>
When both surface fire and crown fire are present in the same
location, their combined behavior determines the spread rate and
intensity values associated with this location. Specifically, their
combined spread rate is the maximum of the two spread rates and their
combined fireline intensity is the sum of their two fireline
intensities. Their combined flame length is the flame length of their
combined fireline intensities. The fire type associated with this
combined fire will be the crown fire type.
</p>

<p>
<b>Note:</b> Since the surface fire and crown fire each define separate
fire spread ellipses with potentially different maximum spread
directions, their relative spread rates and intensities should only be
compared in a given absolute direction in the slope-tangential plane.
</p>

<div class="org-src-container">
<pre class="src src-python" id="combined-fire-behavior"><span class="org-keyword">def</span> <span class="org-function-name">calc_combined_fire_behavior</span>(surface_fire_behavior, crown_fire_behavior):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - surface_fire_behavior :: dictionary of surface fire behavior values</span>
<span class="org-doc">      - fire_type              :: "surface"</span>
<span class="org-doc">      - spread_rate            :: m/min</span>
<span class="org-doc">      - spread_direction       :: (x, y, z) unit vector</span>
<span class="org-doc">      - fireline_intensity     :: kW/m</span>
<span class="org-doc">      - flame_length           :: m</span>
<span class="org-doc">    - crown_fire_behavior   :: dictionary of crown fire behavior values</span>
<span class="org-doc">      - fire_type              :: "passive_crown" or "active_crown"</span>
<span class="org-doc">      - spread_rate            :: m/min</span>
<span class="org-doc">      - spread_direction       :: (x, y, z) unit vector</span>
<span class="org-doc">      - fireline_intensity     :: kW/m</span>

<span class="org-doc">    return a dictionary containing these keys:</span>
<span class="org-doc">    - fire_type          :: "surface", "passive_crown", or "active_crown"</span>
<span class="org-doc">    - spread_rate        :: m/min</span>
<span class="org-doc">    - spread_direction   :: (x, y, z) unit vector</span>
<span class="org-doc">    - fireline_intensity :: kW/m</span>
<span class="org-doc">    - flame_length       :: m</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack the surface fire behavior values</span>
    <span class="org-variable-name">surface_spread_rate</span>        <span class="org-operator">=</span> surface_fire_behavior[<span class="org-string">"spread_rate"</span>]        <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
    <span class="org-variable-name">surface_spread_direction</span>   <span class="org-operator">=</span> surface_fire_behavior[<span class="org-string">"spread_direction"</span>]   <span class="org-comment-delimiter"># </span><span class="org-comment">(x, y, z) unit vector</span>
    <span class="org-variable-name">surface_fireline_intensity</span> <span class="org-operator">=</span> surface_fire_behavior[<span class="org-string">"fireline_intensity"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack the crown fire behavior values</span>
    <span class="org-variable-name">crown_fire_type</span>          <span class="org-operator">=</span> crown_fire_behavior[<span class="org-string">"fire_type"</span>]          <span class="org-comment-delimiter"># </span><span class="org-comment">"passive_crown" or "active_crown"</span>
    <span class="org-variable-name">crown_spread_rate</span>        <span class="org-operator">=</span> crown_fire_behavior[<span class="org-string">"spread_rate"</span>]        <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
    <span class="org-variable-name">crown_spread_direction</span>   <span class="org-operator">=</span> crown_fire_behavior[<span class="org-string">"spread_direction"</span>]   <span class="org-comment-delimiter"># </span><span class="org-comment">(x, y, z) unit vector</span>
    <span class="org-variable-name">crown_fireline_intensity</span> <span class="org-operator">=</span> crown_fire_behavior[<span class="org-string">"fireline_intensity"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Determine whether the surface or crown fire has the fastest spread rate</span>
    <span class="org-keyword">if</span> surface_spread_rate <span class="org-operator">&gt;</span> crown_spread_rate:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Surface fire spreads faster</span>
        <span class="org-keyword">return</span> {
            <span class="org-string">"fire_type"</span>         : crown_fire_type,
            <span class="org-string">"spread_rate"</span>       : surface_spread_rate,
            <span class="org-string">"spread_direction"</span>  : surface_spread_direction,
            <span class="org-string">"fireline_intensity"</span>: surface_fireline_intensity <span class="org-operator">+</span> crown_fireline_intensity,
            <span class="org-string">"flame_length"</span>      : calc_crown_fire_flame_length(surface_fireline_intensity, crown_fireline_intensity),
        }
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Crown fire spreads faster</span>
        <span class="org-keyword">return</span> {
            <span class="org-string">"fire_type"</span>         : crown_fire_type,
            <span class="org-string">"spread_rate"</span>       : crown_spread_rate,
            <span class="org-string">"spread_direction"</span>  : crown_spread_direction,
            <span class="org-string">"fireline_intensity"</span>: surface_fireline_intensity <span class="org-operator">+</span> crown_fireline_intensity,
            <span class="org-string">"flame_length"</span>      : calc_crown_fire_flame_length(surface_fireline_intensity, crown_fireline_intensity),
        }
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-For Users" class="outline-3">
<h3 id="For Users"><span class="section-number-3">7.2.</span> For Users</h3>
<div class="outline-text-3" id="text-For Users">
<p>
In the following sections, we will demonstrate how to calculate the
crown fire behavior values given a surface fire line intensity and
measurements of foliar moisture, fine fuel moisture, tree canopy
characteristics, wind speed, wind direction, slope, and aspect. This
will be done first for the max spread direction case and then in any
direction on the sloped surface using 3D vectors to specify absolute
directions.
</p>

<p>
Because wind speed and direction will often be provided from
measurements taken 10m or 20ft above the canopy and may be given in
either cartesion <code>(x,y)</code> or azimuthal <code>(r,azimuth)</code> coordinates, we
also demonstrate how to convert from cartesian to azimuthal
coordinates and from 10m to 20ft wind speeds.
</p>

<p>
See Appendix <a href="#Units Conversion Functions (pyretechnics.conversion)">15.1</a> for
the full list of available units conversion functions.
</p>

<p>
See Appendix <a href="#Vector Utility Functions (pyretechnics.vector_utils)">15.2</a> for
the full list of available vector manipulation functions.
</p>
</div>
<div id="outline-container-How to Determine Whether a Surface Fire Transitions to a Crown Fire" class="outline-4">
<h4 id="How to Determine Whether a Surface Fire Transitions to a Crown Fire"><span class="section-number-4">7.2.1.</span> How to Determine Whether a Surface Fire Transitions to a Crown Fire</h4>
<div class="outline-text-4" id="text-How to Determine Whether a Surface Fire Transitions to a Crown Fire">
<div class="org-src-container">
<pre class="src src-python" id="check-crown-fire-initiation"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.crown_fire <span class="org-keyword">as</span> cf

<span class="org-comment-delimiter"># </span><span class="org-comment">Set tree canopy characteristics</span>
<span class="org-variable-name">canopy_cover_low</span>   <span class="org-operator">=</span> 0.3 <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
<span class="org-variable-name">canopy_cover_high</span>  <span class="org-operator">=</span> 0.8 <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
<span class="org-variable-name">canopy_base_height</span> <span class="org-operator">=</span> 3.0 <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
<span class="org-variable-name">foliar_moisture</span>    <span class="org-operator">=</span> 1.0 <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Specify some surface fireline intensity values to check</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">These would normally be calculated by the functions in pyretechnics.surface_fire</span>
<span class="org-variable-name">surface_fireline_intensity_low</span>  <span class="org-operator">=</span> 500.0  <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
<span class="org-variable-name">surface_fireline_intensity_high</span> <span class="org-operator">=</span> 5000.0 <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">=================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Check for crown fire with canopy_cover_low and surface_fireline_intensity_low</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"Low Canopy Cover and Low Surface Fireline Intensity</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)

<span class="org-keyword">if</span> cf.van_wagner_crown_fire_initiation(surface_fireline_intensity_low,
                                       canopy_cover_low,
                                       canopy_base_height,
                                       foliar_moisture):
    <span class="org-comment-delimiter"># </span><span class="org-comment">Crown Fire</span>
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">A crown fire occurs with these input parameters:"</span>)
    pprint({
        <span class="org-string">"surface_fireline_intensity"</span>: surface_fireline_intensity_low,
        <span class="org-string">"canopy_cover"</span>              : canopy_cover_low,
        <span class="org-string">"canopy_base_height"</span>        : canopy_base_height,
        <span class="org-string">"foliar_moisture"</span>           : foliar_moisture,
    })
<span class="org-keyword">else</span>:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Surface Fire</span>
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">A surface fire occurs with these input parameters:"</span>)
    pprint({
        <span class="org-string">"surface_fireline_intensity"</span>: surface_fireline_intensity_low,
        <span class="org-string">"canopy_cover"</span>              : canopy_cover_low,
        <span class="org-string">"canopy_base_height"</span>        : canopy_base_height,
        <span class="org-string">"foliar_moisture"</span>           : foliar_moisture,
    })

<span class="org-comment-delimiter">#</span><span class="org-comment">=================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Check for crown fire with canopy_cover_low and surface_fireline_intensity_high</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Low Canopy Cover and High Surface Fireline Intensity</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)

<span class="org-keyword">if</span> cf.van_wagner_crown_fire_initiation(surface_fireline_intensity_high,
                                       canopy_cover_low,
                                       canopy_base_height,
                                       foliar_moisture):
    <span class="org-comment-delimiter"># </span><span class="org-comment">Crown Fire</span>
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">A crown fire occurs with these input parameters:"</span>)
    pprint({
        <span class="org-string">"surface_fireline_intensity"</span>: surface_fireline_intensity_high,
        <span class="org-string">"canopy_cover"</span>              : canopy_cover_low,
        <span class="org-string">"canopy_base_height"</span>        : canopy_base_height,
        <span class="org-string">"foliar_moisture"</span>           : foliar_moisture,
    })
<span class="org-keyword">else</span>:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Surface Fire</span>
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">A surface fire occurs with these input parameters:"</span>)
    pprint({
        <span class="org-string">"surface_fireline_intensity"</span>: surface_fireline_intensity_high,
        <span class="org-string">"canopy_cover"</span>              : canopy_cover_low,
        <span class="org-string">"canopy_base_height"</span>        : canopy_base_height,
        <span class="org-string">"foliar_moisture"</span>           : foliar_moisture,
    })

<span class="org-comment-delimiter">#</span><span class="org-comment">=================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Check for crown fire with canopy_cover_high and surface_fireline_intensity_low</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">High Canopy Cover and Low Surface Fireline Intensity</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)

<span class="org-keyword">if</span> cf.van_wagner_crown_fire_initiation(surface_fireline_intensity_low,
                                       canopy_cover_high,
                                       canopy_base_height,
                                       foliar_moisture):
    <span class="org-comment-delimiter"># </span><span class="org-comment">Crown Fire</span>
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">A crown fire occurs with these input parameters:"</span>)
    pprint({
        <span class="org-string">"surface_fireline_intensity"</span>: surface_fireline_intensity_low,
        <span class="org-string">"canopy_cover"</span>              : canopy_cover_high,
        <span class="org-string">"canopy_base_height"</span>        : canopy_base_height,
        <span class="org-string">"foliar_moisture"</span>           : foliar_moisture,
    })
<span class="org-keyword">else</span>:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Surface Fire</span>
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">A surface fire occurs with these input parameters:"</span>)
    pprint({
        <span class="org-string">"surface_fireline_intensity"</span>: surface_fireline_intensity_low,
        <span class="org-string">"canopy_cover"</span>              : canopy_cover_high,
        <span class="org-string">"canopy_base_height"</span>        : canopy_base_height,
        <span class="org-string">"foliar_moisture"</span>           : foliar_moisture,
    })

<span class="org-comment-delimiter">#</span><span class="org-comment">=================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Check for crown fire with canopy_cover_high and surface_fireline_intensity_high</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">High Canopy Cover and High Surface Fireline Intensity</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)

<span class="org-keyword">if</span> cf.van_wagner_crown_fire_initiation(surface_fireline_intensity_high,
                                       canopy_cover_high,
                                       canopy_base_height,
                                       foliar_moisture):
    <span class="org-comment-delimiter"># </span><span class="org-comment">Crown Fire</span>
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">A crown fire occurs with these input parameters:"</span>)
    pprint({
        <span class="org-string">"surface_fireline_intensity"</span>: surface_fireline_intensity_high,
        <span class="org-string">"canopy_cover"</span>              : canopy_cover_high,
        <span class="org-string">"canopy_base_height"</span>        : canopy_base_height,
        <span class="org-string">"foliar_moisture"</span>           : foliar_moisture,
    })
<span class="org-keyword">else</span>:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Surface Fire</span>
    <span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">A surface fire occurs with these input parameters:"</span>)
    pprint({
        <span class="org-string">"surface_fireline_intensity"</span>: surface_fireline_intensity_high,
        <span class="org-string">"canopy_cover"</span>              : canopy_cover_high,
        <span class="org-string">"canopy_base_height"</span>        : canopy_base_height,
        <span class="org-string">"foliar_moisture"</span>           : foliar_moisture,
    })
</pre>
</div>

<pre class="example" id="org6a4192d">
Low Canopy Cover and Low Surface Fireline Intensity
============================================================

A surface fire occurs with these input parameters:
{'canopy_base_height': 3.0,
 'canopy_cover': 0.3,
 'foliar_moisture': 1.0,
 'surface_fireline_intensity': 500.0}

Low Canopy Cover and High Surface Fireline Intensity
============================================================

A surface fire occurs with these input parameters:
{'canopy_base_height': 3.0,
 'canopy_cover': 0.3,
 'foliar_moisture': 1.0,
 'surface_fireline_intensity': 5000.0}

High Canopy Cover and Low Surface Fireline Intensity
============================================================

A surface fire occurs with these input parameters:
{'canopy_base_height': 3.0,
 'canopy_cover': 0.8,
 'foliar_moisture': 1.0,
 'surface_fireline_intensity': 500.0}

High Canopy Cover and High Surface Fireline Intensity
============================================================

A crown fire occurs with these input parameters:
{'canopy_base_height': 3.0,
 'canopy_cover': 0.8,
 'foliar_moisture': 1.0,
 'surface_fireline_intensity': 5000.0}
</pre>
</div>
</div>
<div id="outline-container-How to Calculate the Crown Fire Behavior in the Direction of Maximum Spread" class="outline-4">
<h4 id="How to Calculate the Crown Fire Behavior in the Direction of Maximum Spread"><span class="section-number-4">7.2.2.</span> How to Calculate the Crown Fire Behavior in the Direction of Maximum Spread</h4>
<div class="outline-text-4" id="text-How to Calculate the Crown Fire Behavior in the Direction of Maximum Spread">
<div class="org-src-container">
<pre class="src src-python" id="compute-crown-fire-behavior-max"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.crown_fire <span class="org-keyword">as</span> cf

<span class="org-comment-delimiter"># </span><span class="org-comment">Set input parameters</span>
<span class="org-variable-name">canopy_height</span>                <span class="org-operator">=</span> 30.0    <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
<span class="org-variable-name">canopy_base_height</span>           <span class="org-operator">=</span> 3.0     <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
<span class="org-variable-name">canopy_bulk_density</span>          <span class="org-operator">=</span> 0.3     <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>
<span class="org-variable-name">heat_of_combustion</span>           <span class="org-operator">=</span> 18608.0 <span class="org-comment-delimiter"># </span><span class="org-comment">kJ/kg</span>
<span class="org-variable-name">estimated_fine_fuel_moisture</span> <span class="org-operator">=</span> 0.05    <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
<span class="org-variable-name">wind_speed_10m</span>               <span class="org-operator">=</span> 10.0    <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
<span class="org-variable-name">upwind_direction</span>             <span class="org-operator">=</span> 180.0   <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
<span class="org-variable-name">slope</span>                        <span class="org-operator">=</span> 0.5     <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
<span class="org-variable-name">aspect_parallel_to_wind</span>      <span class="org-operator">=</span> 180.0   <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
<span class="org-variable-name">aspect_perpendicular_to_wind</span> <span class="org-operator">=</span> 270.0   <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction of maximum spread with slope and wind aligned</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">====================================================================================================</span>

<span class="org-variable-name">crown_fire_max_aligned</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_max(canopy_height, canopy_base_height,
                                                         canopy_bulk_density, heat_of_combustion,
                                                         estimated_fine_fuel_moisture,
                                                         wind_speed_10m, upwind_direction,
                                                         slope, aspect_parallel_to_wind)

<span class="org-comment-delimiter"># </span><span class="org-comment">View results</span>
<span class="org-builtin">print</span>(<span class="org-string">"Crown Fire Behavior Max with Wind and Slope Aligned</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Inputs:"</span>)
pprint({
    <span class="org-string">"canopy_height"</span>               : canopy_height,
    <span class="org-string">"canopy_base_height"</span>          : canopy_base_height,
    <span class="org-string">"canopy_bulk_density"</span>         : canopy_bulk_density,
    <span class="org-string">"heat_of_combustion"</span>          : heat_of_combustion,
    <span class="org-string">"estimated_fine_fuel_moisture"</span>: estimated_fine_fuel_moisture,
    <span class="org-string">"wind_speed_10m"</span>              : wind_speed_10m,
    <span class="org-string">"upwind_direction"</span>            : upwind_direction,
    <span class="org-string">"slope"</span>                       : slope,
    <span class="org-string">"aspect"</span>                      : aspect_parallel_to_wind,
})

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Outputs:"</span>)
pprint(crown_fire_max_aligned)

<span class="org-comment-delimiter">#</span><span class="org-comment">====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction of maximum spread with slope and wind perpendicular</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">====================================================================================================</span>

<span class="org-variable-name">crown_fire_max_perpendicular</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_max(canopy_height, canopy_base_height,
                                                               canopy_bulk_density, heat_of_combustion,
                                                               estimated_fine_fuel_moisture,
                                                               wind_speed_10m, upwind_direction,
                                                               slope, aspect_perpendicular_to_wind)

<span class="org-comment-delimiter"># </span><span class="org-comment">View results</span>
<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Crown Fire Behavior Max with Wind and Slope Perpendicular</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Inputs:"</span>)
pprint({
    <span class="org-string">"canopy_height"</span>               : canopy_height,
    <span class="org-string">"canopy_base_height"</span>          : canopy_base_height,
    <span class="org-string">"canopy_bulk_density"</span>         : canopy_bulk_density,
    <span class="org-string">"heat_of_combustion"</span>          : heat_of_combustion,
    <span class="org-string">"estimated_fine_fuel_moisture"</span>: estimated_fine_fuel_moisture,
    <span class="org-string">"wind_speed_10m"</span>              : wind_speed_10m,
    <span class="org-string">"upwind_direction"</span>            : upwind_direction,
    <span class="org-string">"slope"</span>                       : slope,
    <span class="org-string">"aspect"</span>                      : aspect_perpendicular_to_wind,
})

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Outputs:"</span>)
pprint(crown_fire_max_perpendicular)
</pre>
</div>

<pre class="example" id="org680d9d2">
Crown Fire Behavior Max with Wind and Slope Aligned
============================================================

Inputs:
{'aspect': 180.0,
 'canopy_base_height': 3.0,
 'canopy_bulk_density': 0.3,
 'canopy_height': 30.0,
 'estimated_fine_fuel_moisture': 0.05,
 'heat_of_combustion': 18608.0,
 'slope': 0.5,
 'upwind_direction': 180.0,
 'wind_speed_10m': 10.0}

Outputs:
{'critical_spread_rate': 10.0,
 'eccentricity': 0.8218958698260199,
 'length_to_width_ratio': 1.7555015973996304,
 'max_fire_type': 'active_crown',
 'max_fireline_intensity': 82666.07067724908,
 'max_spread_direction': array([0.        , 0.89442719, 0.4472136 ]),
 'max_spread_rate': 32.907419619299176}

Crown Fire Behavior Max with Wind and Slope Perpendicular
============================================================

Inputs:
{'aspect': 270.0,
 'canopy_base_height': 3.0,
 'canopy_bulk_density': 0.3,
 'canopy_height': 30.0,
 'estimated_fine_fuel_moisture': 0.05,
 'heat_of_combustion': 18608.0,
 'slope': 0.5,
 'upwind_direction': 180.0,
 'wind_speed_10m': 10.0}

Outputs:
{'critical_spread_rate': 10.0,
 'eccentricity': 0.8024265702196313,
 'length_to_width_ratio': 1.6757411715581005,
 'max_fire_type': 'active_crown',
 'max_fireline_intensity': 74768.3487091958,
 'max_spread_direction': array([0.000000e+00, 1.000000e+00, 3.061617e-17]),
 'max_spread_rate': 29.763522144675242}
</pre>
</div>
</div>
<div id="outline-container-How to Calculate the Crown Fire Behavior in Any Direction" class="outline-4">
<h4 id="How to Calculate the Crown Fire Behavior in Any Direction"><span class="section-number-4">7.2.3.</span> How to Calculate the Crown Fire Behavior in Any Direction</h4>
<div class="outline-text-4" id="text-How to Calculate the Crown Fire Behavior in Any Direction">
<div class="org-src-container">
<pre class="src src-python" id="compute-crown-fire-behavior-in-direction"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.crown_fire <span class="org-keyword">as</span> cf
<span class="org-keyword">import</span> pyretechnics.vector_utils <span class="org-keyword">as</span> vu

<span class="org-comment-delimiter"># </span><span class="org-comment">Set input parameters</span>
<span class="org-variable-name">canopy_height</span>                <span class="org-operator">=</span> 30.0    <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
<span class="org-variable-name">canopy_base_height</span>           <span class="org-operator">=</span> 3.0     <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
<span class="org-variable-name">canopy_bulk_density</span>          <span class="org-operator">=</span> 0.3     <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>
<span class="org-variable-name">heat_of_combustion</span>           <span class="org-operator">=</span> 18608.0 <span class="org-comment-delimiter"># </span><span class="org-comment">kJ/kg</span>
<span class="org-variable-name">estimated_fine_fuel_moisture</span> <span class="org-operator">=</span> 0.05    <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
<span class="org-variable-name">wind_speed_10m</span>               <span class="org-operator">=</span> 10.0    <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
<span class="org-variable-name">upwind_direction</span>             <span class="org-operator">=</span> 180.0   <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
<span class="org-variable-name">slope</span>                        <span class="org-operator">=</span> 0.5     <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
<span class="org-variable-name">aspect</span>                       <span class="org-operator">=</span> 225.0   <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction of maximum spread</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

<span class="org-variable-name">crown_fire_max</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_max(canopy_height, canopy_base_height,
                                                 canopy_bulk_density, heat_of_combustion,
                                                 estimated_fine_fuel_moisture,
                                                 wind_speed_10m, upwind_direction,
                                                 slope, aspect)

<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior for the heading, flanking, and backing fires</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

<span class="org-variable-name">heading_fire_direction</span>  <span class="org-operator">=</span> crown_fire_max[<span class="org-string">"max_spread_direction"</span>]
<span class="org-variable-name">flanking_fire_direction</span> <span class="org-operator">=</span> vu.rotate_on_sloped_plane(heading_fire_direction, 90, slope, aspect)
<span class="org-variable-name">backing_fire_direction</span>  <span class="org-operator">=</span> <span class="org-operator">-</span>heading_fire_direction

<span class="org-variable-name">heading_fire_behavior</span>  <span class="org-operator">=</span> cf.calc_crown_fire_behavior_in_direction(crown_fire_max, heading_fire_direction)
<span class="org-variable-name">flanking_fire_behavior</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_in_direction(crown_fire_max, flanking_fire_direction)
<span class="org-variable-name">backing_fire_behavior</span>  <span class="org-operator">=</span> cf.calc_crown_fire_behavior_in_direction(crown_fire_max, backing_fire_direction)

<span class="org-comment-delimiter"># </span><span class="org-comment">View heading fire results</span>
<span class="org-builtin">print</span>(<span class="org-string">"Heading Fire Behavior</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)
pprint(heading_fire_behavior)

<span class="org-comment-delimiter"># </span><span class="org-comment">View flanking fire results</span>
<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Flanking Fire Behavior</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)
pprint(flanking_fire_behavior)

<span class="org-comment-delimiter"># </span><span class="org-comment">View backing fire results</span>
<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Backing Fire Behavior</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)
pprint(backing_fire_behavior)
</pre>
</div>

<pre class="example" id="orgdae2614">
Heading Fire Behavior
============================================================
{'fire_type': 'active_crown',
 'fireline_intensity': 78838.1499300167,
 'spread_direction': array([0.        , 0.94280904, 0.33333333]),
 'spread_rate': 31.38361434747966}

Flanking Fire Behavior
============================================================
{'fire_type': 'passive_crown',
 'fireline_intensity': 14756.204837586314,
 'spread_direction': array([ 0.9486833 , -0.10540926,  0.2981424 ]),
 'spread_rate': 3.264617932843692}

Backing Fire Behavior
============================================================
{'fire_type': 'passive_crown',
 'fireline_intensity': 8139.876265831974,
 'spread_direction': array([-0.        , -0.94280904, -0.33333333]),
 'spread_rate': 2.3434742325850952}
</pre>
</div>
</div>
<div id="outline-container-How to Calculate the Combined Surface and Crown Fire Behavior in Any Direction" class="outline-4">
<h4 id="How to Calculate the Combined Surface and Crown Fire Behavior in Any Direction"><span class="section-number-4">7.2.4.</span> How to Calculate the Combined Surface and Crown Fire Behavior in Any Direction</h4>
<div class="outline-text-4" id="text-How to Calculate the Combined Surface and Crown Fire Behavior in Any Direction">
<div class="org-src-container">
<pre class="src src-python" id="compute-combined-fire-behavior-in-direction"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv
<span class="org-keyword">import</span> pyretechnics.crown_fire <span class="org-keyword">as</span> cf
<span class="org-keyword">import</span> pyretechnics.fuel_models <span class="org-keyword">as</span> fm
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf
<span class="org-keyword">import</span> pyretechnics.vector_utils <span class="org-keyword">as</span> vu

<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Set input parameters</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Landscape</span>
<span class="org-variable-name">fuel_model</span>          <span class="org-operator">=</span> fm.fuel_model_table[101] <span class="org-comment-delimiter"># </span><span class="org-comment">GR1</span>
<span class="org-variable-name">canopy_cover</span>        <span class="org-operator">=</span> 0.6                      <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
<span class="org-variable-name">canopy_height</span>       <span class="org-operator">=</span> 30.0                     <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
<span class="org-variable-name">canopy_base_height</span>  <span class="org-operator">=</span> 3.0                      <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
<span class="org-variable-name">canopy_bulk_density</span> <span class="org-operator">=</span> 0.3                      <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>
<span class="org-variable-name">slope</span>               <span class="org-operator">=</span> 0.8                      <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
<span class="org-variable-name">aspect</span>              <span class="org-operator">=</span> 225.0                    <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Weather</span>
<span class="org-variable-name">fuel_moisture</span>    <span class="org-operator">=</span> [
    0.05, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_1hr</span>
    0.10, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_10hr</span>
    0.15, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_100hr</span>
    0.00, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_herbaceous (will be set by moisturize for dynamic fuel models)</span>
    0.90, <span class="org-comment-delimiter"># </span><span class="org-comment">live_herbaceous</span>
    0.60, <span class="org-comment-delimiter"># </span><span class="org-comment">live_woody</span>
]                        <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
<span class="org-variable-name">foliar_moisture</span>  <span class="org-operator">=</span> 0.9   <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
<span class="org-variable-name">wind_speed_10m</span>   <span class="org-operator">=</span> 30.0  <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
<span class="org-variable-name">upwind_direction</span> <span class="org-operator">=</span> 180.0 <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Derived Parameters</span>
<span class="org-variable-name">fuel_bed_depth</span>               <span class="org-operator">=</span> fuel_model[<span class="org-string">"delta"</span>]                      <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
<span class="org-variable-name">heat_of_combustion</span>           <span class="org-operator">=</span> conv.Btu_lb_to_kJ_kg(fuel_model[<span class="org-string">"h"</span>][0]) <span class="org-comment-delimiter"># </span><span class="org-comment">kJ/kg</span>
<span class="org-variable-name">estimated_fine_fuel_moisture</span> <span class="org-operator">=</span> fuel_moisture[0]                         <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Fire Perimeter Normal Vector</span>
<span class="org-variable-name">fire_perimeter_normal_vector_2d</span> <span class="org-operator">=</span> (1.0, 0.0) <span class="org-comment-delimiter"># </span><span class="org-comment">(x,y) unit vector pointing East</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Project the 2D fire perimeter normal vector onto the slope-tangential plane</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

<span class="org-variable-name">upslope_direction</span>               <span class="org-operator">=</span> conv.opposite_direction(aspect)
<span class="org-variable-name">slope_vector_2d</span>                 <span class="org-operator">=</span> conv.azimuthal_to_cartesian(slope, upslope_direction)
<span class="org-variable-name">fire_perimeter_normal_vector_3d</span> <span class="org-operator">=</span> vu.as_unit_vector(vu.to_slope_plane(fire_perimeter_normal_vector_2d, slope_vector_2d))

<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate midflame wind speed</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 10m wind speed to 20ft wind speed</span>
<span class="org-variable-name">wind_speed_20ft</span> <span class="org-operator">=</span> conv.wind_speed_10m_to_wind_speed_20ft(wind_speed_10m) <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Convert 20ft wind speed from km/hr to m/min</span>
<span class="org-variable-name">wind_speed_20ft_m_min</span> <span class="org-operator">=</span> conv.km_hr_to_m_min(wind_speed_20ft) <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 20ft wind speed to midflame wind speed in m/min</span>
<span class="org-variable-name">midflame_wind_speed</span> <span class="org-operator">=</span> sf.calc_midflame_wind_speed(wind_speed_20ft_m_min,       <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
                                                  fuel_bed_depth,              <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                  conv.m_to_ft(canopy_height), <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                  canopy_cover)                <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Apply fuel moisture to fuel model</span>
<span class="org-variable-name">moisturized_fuel_model</span> <span class="org-operator">=</span> fm.moisturize(fuel_model, fuel_moisture)

<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate no-wind-no-slope surface fire behavior</span>
<span class="org-variable-name">surface_fire_min</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model)

<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread with effective wind speed limit</span>
<span class="org-variable-name">surface_fire_max</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_max(surface_fire_min,
                                                     midflame_wind_speed,
                                                     upwind_direction,
                                                     slope,
                                                     aspect)

<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction normal to the fire perimeter</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

<span class="org-variable-name">surface_fire_normal</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_in_direction(surface_fire_max, fire_perimeter_normal_vector_3d)

<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Determine whether the surface fire transitions to a crown fire</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

<span class="org-keyword">if</span> cf.van_wagner_crown_fire_initiation(surface_fire_normal[<span class="org-string">"fireline_intensity"</span>],
                                       canopy_cover,
                                       canopy_base_height,
                                       foliar_moisture):

    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction of maximum spread</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

    <span class="org-variable-name">crown_fire_max</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_max(canopy_height, canopy_base_height,
                                                     canopy_bulk_density, heat_of_combustion,
                                                     estimated_fine_fuel_moisture,
                                                     wind_speed_10m, upwind_direction,
                                                     slope, aspect)

    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction normal to the fire perimeter</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

    <span class="org-variable-name">crown_fire_normal</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_in_direction(crown_fire_max, fire_perimeter_normal_vector_3d)

    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate combined fire behavior in the direction normal to the fire perimeter</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

    <span class="org-variable-name">combined_fire_normal</span> <span class="org-operator">=</span> cf.calc_combined_fire_behavior(surface_fire_normal, crown_fire_normal)

    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Display the combined fire behavior normal to the fire perimeter</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

    <span class="org-builtin">print</span>(<span class="org-string">"Fire Behavior from Combined Surface and Crown Fire</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)
    pprint(combined_fire_normal)

<span class="org-keyword">else</span>:

    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Display the surface fire behavior normal to the fire perimeter</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

    <span class="org-builtin">print</span>(<span class="org-string">"Fire Behavior from Surface Fire (No Crown Fire Occurred)</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 60)
    pprint(surface_fire_normal)
</pre>
</div>

<pre class="example">
Fire Behavior from Surface Fire (No Crown Fire Occurred)
============================================================
{'fire_type': 'surface',
 'fireline_intensity': 11.637272000784206,
 'flame_length': 0.23956726229329667,
 'spread_direction': array([0.87038828, 0.        , 0.49236596]),
 'spread_rate': 0.8215818916531423}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-Burning Cells on a Grid (pyretechnics.burn_cells)" class="outline-2">
<h2 id="Burning Cells on a Grid (pyretechnics.burn_cells)"><span class="section-number-2">8.</span> Burning Cells on a Grid (pyretechnics.burn_cells)</h2>
<div class="outline-text-2" id="text-Burning Cells on a Grid (pyretechnics.burn_cells)">
</div>
<div id="outline-container-For Developers" class="outline-3">
<h3 id="For Developers"><span class="section-number-3">8.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-For Developers">
<p>
This module provides convenience functions that apply the fuel model
and moisture definitions from section <a href="#Fuel Model and Moisture Definitions (pyretechnics.fuel_models)">5</a>, surface fire equations from
section <a href="#Surface Fire Equations (pyretechnics.surface_fire)">6</a>, and crown
fire equations from section <a href="#Crown Fire Equations (pyretechnics.crown_fire)">7</a> to cells within a space-time cube, returning
their combined surface and crown fire behavior.
</p>
</div>
<div id="outline-container-Burn Cell as a Head Fire" class="outline-4">
<h4 id="Burn Cell as a Head Fire"><span class="section-number-4">8.1.1.</span> Burn Cell as a Head Fire</h4>
<div class="outline-text-4" id="text-Burn Cell as a Head Fire">
<p>
Sometimes the goal of a fire behavior analysis is to determine the
most extreme behavior to be expected, given static measurements of
surface fuels, tree canopy characteristics, topography, wind, and
moisture. The following function computes the maximum surface fire
behavior and checks to see whether its maximum surface fireline
intensity causes a crown fire. If so, the maximum crown fire behavior
is computed and combined with the maximum surface fire behavior as per
section <a href="#Combining Surface and Crown Fire Behavior">7.1.7</a>. If not, the maximum
surface fire behavior is returned.
</p>

<div class="org-src-container">
<pre class="src src-python" id="burn-cell-as-head-fire"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv
<span class="org-keyword">import</span> pyretechnics.crown_fire <span class="org-keyword">as</span> cf
<span class="org-keyword">import</span> pyretechnics.fuel_models <span class="org-keyword">as</span> fm
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf
<span class="org-keyword">import</span> pyretechnics.vector_utils <span class="org-keyword">as</span> vu


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Create a version of this function that runs efficiently over a space_time_region</span>
<span class="org-keyword">def</span> <span class="org-function-name">burn_cell_as_head_fire</span>(space_time_cubes, space_time_coordinate,
                           use_wind_limit<span class="org-operator">=</span><span class="org-constant">True</span>, max_length_to_width_ratio<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - space_time_cubes          :: dictionary of (Lazy)SpaceTimeCube objects with these cell types</span>
<span class="org-doc">      - slope                         :: rise/run</span>
<span class="org-doc">      - aspect                        :: degrees clockwise from North</span>
<span class="org-doc">      - fuel_model                    :: integer index in fm.fuel_model_table</span>
<span class="org-doc">      - canopy_cover                  :: 0-1</span>
<span class="org-doc">      - canopy_height                 :: m</span>
<span class="org-doc">      - canopy_base_height            :: m</span>
<span class="org-doc">      - canopy_bulk_density           :: kg/m^3</span>
<span class="org-doc">      - wind_speed_10m                :: km/hr</span>
<span class="org-doc">      - upwind_direction              :: degrees clockwise from North</span>
<span class="org-doc">      - fuel_moisture_dead_1hr        :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_dead_10hr       :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_dead_100hr      :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_live_herbaceous :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_live_woody      :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - foliar_moisture               :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_spread_adjustment        :: float &gt;= 0.0 (Optional: defaults to 1.0)</span>
<span class="org-doc">      - weather_spread_adjustment     :: float &gt;= 0.0 (Optional: defaults to 1.0)</span>
<span class="org-doc">    - space_time_coordinate     :: (t,y,x)</span>
<span class="org-doc">    - use_wind_limit            :: boolean (Optional)</span>
<span class="org-doc">    - max_length_to_width_ratio :: float &gt; 0.0 (Optional)</span>

<span class="org-doc">    return a dictionary with these fire behavior values for the space-time coordinate (t,y,x):</span>
<span class="org-doc">    - fire_type          :: "unburned", "surface", "passive_crown", or "active_crown"</span>
<span class="org-doc">    - spread_rate        :: m/min</span>
<span class="org-doc">    - spread_direction   :: (x, y, z) unit vector on the slope-tangential plane</span>
<span class="org-doc">    - fireline_intensity :: kW/m</span>
<span class="org-doc">    - flame_length       :: m</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the space_time_coordinate</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    (<span class="org-variable-name">t</span>, <span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>) <span class="org-operator">=</span> space_time_coordinate

    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack the space_time_cubes dictionary</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Topography, Fuel Model, and Vegetation</span>
    <span class="org-variable-name">slope</span>               <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"slope"</span>].get(t,y,x)               <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-variable-name">aspect</span>              <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"aspect"</span>].get(t,y,x)              <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-variable-name">fuel_model_number</span>   <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_model"</span>].get(t,y,x)          <span class="org-comment-delimiter"># </span><span class="org-comment">integer index in fm.fuel_model_table</span>
    <span class="org-variable-name">canopy_cover</span>        <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"canopy_cover"</span>].get(t,y,x)        <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
    <span class="org-variable-name">canopy_height</span>       <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"canopy_height"</span>].get(t,y,x)       <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-variable-name">canopy_base_height</span>  <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"canopy_base_height"</span>].get(t,y,x)  <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-variable-name">canopy_bulk_density</span> <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"canopy_bulk_density"</span>].get(t,y,x) <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Wind, Surface Moisture, and Foliar Moisture</span>
    <span class="org-variable-name">wind_speed_10m</span>                <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"wind_speed_10m"</span>].get(t,y,x)                <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-variable-name">upwind_direction</span>              <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"upwind_direction"</span>].get(t,y,x)              <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-variable-name">fuel_moisture_dead_1hr</span>        <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_dead_1hr"</span>].get(t,y,x)        <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_dead_10hr</span>       <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_dead_10hr"</span>].get(t,y,x)       <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_dead_100hr</span>      <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_dead_100hr"</span>].get(t,y,x)      <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_live_herbaceous</span> <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_live_herbaceous"</span>].get(t,y,x) <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_live_woody</span>      <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_live_woody"</span>].get(t,y,x)      <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">foliar_moisture</span>               <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"foliar_moisture"</span>].get(t,y,x)               <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Spread Rate Adjustments (Optional)</span>
    <span class="org-variable-name">fuel_spread_adjustment</span>    <span class="org-operator">=</span> (space_time_cubes[<span class="org-string">"fuel_spread_adjustment"</span>].get(t,y,x)
                                 <span class="org-keyword">if</span> <span class="org-string">"fuel_spread_adjustment"</span> <span class="org-keyword">in</span> space_time_cubes
                                 <span class="org-keyword">else</span> 1.0)                                         <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>
    <span class="org-variable-name">weather_spread_adjustment</span> <span class="org-operator">=</span> (space_time_cubes[<span class="org-string">"weather_spread_adjustment"</span>].get(t,y,x)
                                 <span class="org-keyword">if</span> <span class="org-string">"weather_spread_adjustment"</span> <span class="org-keyword">in</span> space_time_cubes
                                 <span class="org-keyword">else</span> 1.0)                                         <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>
    <span class="org-variable-name">spread_rate_adjustment</span>    <span class="org-operator">=</span> fuel_spread_adjustment <span class="org-operator">*</span> weather_spread_adjustment <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>

    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Check whether cell is burnable</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    <span class="org-variable-name">fuel_model</span> <span class="org-operator">=</span> fm.fuel_model_table.get(fuel_model_number)

    <span class="org-keyword">if</span> <span class="org-keyword">not</span> (fuel_model <span class="org-keyword">and</span> fuel_model[<span class="org-string">"burnable"</span>]):
        <span class="org-comment-delimiter"># </span><span class="org-comment">Encountered unknown or non-burnable fuel model</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Create a 3D unit vector pointing upslope on the slope-tangential plane</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

        <span class="org-variable-name">upslope_direction</span> <span class="org-operator">=</span> conv.opposite_direction(aspect)
        <span class="org-variable-name">slope_vector_2d</span>   <span class="org-operator">=</span> conv.azimuthal_to_cartesian(slope, upslope_direction)
        <span class="org-variable-name">slope_vector_3d</span>   <span class="org-operator">=</span> vu.to_slope_plane(slope_vector_2d, slope_vector_2d)
        <span class="org-variable-name">spread_direction</span>  <span class="org-operator">=</span> vu.as_unit_vector(slope_vector_3d) <span class="org-keyword">if</span> slope <span class="org-operator">&gt;</span> 0.0 <span class="org-keyword">else</span> np.asarray((0,1,0)) <span class="org-comment-delimiter"># </span><span class="org-comment">default: North</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Return zero surface fire behavior</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-keyword">return</span> {
            <span class="org-string">"fire_type"</span>         : <span class="org-string">"unburned"</span>,
            <span class="org-string">"spread_rate"</span>       : 0.0,
            <span class="org-string">"spread_direction"</span>  : spread_direction,
            <span class="org-string">"fireline_intensity"</span>: 0.0,
            <span class="org-string">"flame_length"</span>      : 0.0,
        }

    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Encountered burnable fuel model</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Compute derived parameters</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-variable-name">fuel_moisture</span>                <span class="org-operator">=</span> [fuel_moisture_dead_1hr,
                                        fuel_moisture_dead_10hr,
                                        fuel_moisture_dead_100hr,
                                        0.0, <span class="org-comment-delimiter"># </span><span class="org-comment">fuel_moisture_dead_herbaceous</span>
                                        fuel_moisture_live_herbaceous,
                                        fuel_moisture_live_woody]               <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
        <span class="org-variable-name">fuel_bed_depth</span>               <span class="org-operator">=</span> fuel_model[<span class="org-string">"delta"</span>]                      <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
        <span class="org-variable-name">heat_of_combustion</span>           <span class="org-operator">=</span> conv.Btu_lb_to_kJ_kg(fuel_model[<span class="org-string">"h"</span>][0]) <span class="org-comment-delimiter"># </span><span class="org-comment">kJ/kg</span>
        <span class="org-variable-name">estimated_fine_fuel_moisture</span> <span class="org-operator">=</span> fuel_moisture_dead_1hr                   <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate midflame wind speed</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 10m wind speed to 20ft wind speed</span>
        <span class="org-variable-name">wind_speed_20ft</span> <span class="org-operator">=</span> conv.wind_speed_10m_to_wind_speed_20ft(wind_speed_10m) <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Convert 20ft wind speed from km/hr to m/min</span>
        <span class="org-variable-name">wind_speed_20ft_m_min</span> <span class="org-operator">=</span> conv.km_hr_to_m_min(wind_speed_20ft) <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 20ft wind speed to midflame wind speed in m/min</span>
        <span class="org-variable-name">midflame_wind_speed</span> <span class="org-operator">=</span> sf.calc_midflame_wind_speed(wind_speed_20ft_m_min,       <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
                                                          fuel_bed_depth,              <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                          conv.m_to_ft(canopy_height), <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                          canopy_cover)                <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Apply fuel moisture to fuel model</span>
        <span class="org-variable-name">moisturized_fuel_model</span> <span class="org-operator">=</span> fm.moisturize(fuel_model, fuel_moisture)

        <span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Memoize calc_surface_fire_behavior_no_wind_no_slope</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate no-wind-no-slope surface fire behavior</span>
        <span class="org-variable-name">surface_fire_min</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model,
                                                                          spread_rate_adjustment)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread</span>
        <span class="org-variable-name">surface_fire_max</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_max(surface_fire_min,
                                                             midflame_wind_speed,
                                                             upwind_direction,
                                                             slope,
                                                             aspect,
                                                             use_wind_limit)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Simplify the surface fire behavior fields for future comparison/combination with the crown fire behavior values</span>
        <span class="org-variable-name">surface_fire_max_simple</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_in_direction(surface_fire_max,
                                                                             surface_fire_max[<span class="org-string">"max_spread_direction"</span>])

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Determine whether the surface fire transitions to a crown fire</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-keyword">if</span> cf.van_wagner_crown_fire_initiation(surface_fire_max_simple[<span class="org-string">"fireline_intensity"</span>],
                                               canopy_cover,
                                               canopy_base_height,
                                               foliar_moisture):

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction of maximum spread</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction of maximum spread</span>
            <span class="org-variable-name">crown_fire_max</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_max(canopy_height, canopy_base_height,
                                                             canopy_bulk_density, heat_of_combustion,
                                                             estimated_fine_fuel_moisture,
                                                             wind_speed_10m, upwind_direction,
                                                             slope, aspect, max_length_to_width_ratio)

            <span class="org-comment-delimiter"># </span><span class="org-comment">Simplify the crown fire behavior fields for future comparison/combination with the surface fire behavior values</span>
            <span class="org-variable-name">crown_fire_max_simple</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_in_direction(crown_fire_max,
                                                                             crown_fire_max[<span class="org-string">"max_spread_direction"</span>])

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate combined fire behavior in the direction of maximum spread</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-variable-name">combined_fire_max</span> <span class="org-operator">=</span> cf.calc_combined_fire_behavior(surface_fire_max_simple, crown_fire_max_simple)

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Return the combined fire behavior in the direction of maximum spread</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-keyword">return</span> combined_fire_max

        <span class="org-keyword">else</span>:

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Return the surface fire behavior in the direction of maximum spread</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-keyword">return</span> surface_fire_max_simple
</pre>
</div>
</div>
</div>
<div id="outline-container-Burn Cell in Any Direction" class="outline-4">
<h4 id="Burn Cell in Any Direction"><span class="section-number-4">8.1.2.</span> Burn Cell in Any Direction</h4>
<div class="outline-text-4" id="text-Burn Cell in Any Direction">
<p>
When the goal of a fire behavior analysis is to evolve a burn scar
from its point of ignition into a generally conical shape in
space-time, then it is necessary to evaluate the combined surface and
crown fire behavior in the direction normal to the fire front. In
order to facilitate this calculation, the following function takes an
azimuth (degrees clockwise from North), meant to represent the spatial
direction in which the fire front is spreading from a given grid cell.
It first projects this 2D direction onto the local slope-tangential
plane and computes the surface fire behavior in this direction. If a
crown fire occurs, the crown fire behavior is also calculated in the
azimuth direction, and the combined surface and crown fire behavior
(as per section <a href="#Combining Surface and Crown Fire Behavior">7.1.7</a>) is
returned. If no crown fire occurs, the surface fire behavior in the
azimuth direction is returned.
</p>

<div class="org-src-container">
<pre class="src src-python" id="burn-cell-toward-azimuth"><span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv
<span class="org-keyword">import</span> pyretechnics.crown_fire <span class="org-keyword">as</span> cf
<span class="org-keyword">import</span> pyretechnics.fuel_models <span class="org-keyword">as</span> fm
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf
<span class="org-keyword">import</span> pyretechnics.vector_utils <span class="org-keyword">as</span> vu


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Create a version of this function that runs efficiently over a space_time_region</span>
<span class="org-keyword">def</span> <span class="org-function-name">burn_cell_toward_azimuth</span>(space_time_cubes, space_time_coordinate, azimuth,
                             use_wind_limit<span class="org-operator">=</span><span class="org-constant">True</span>, max_length_to_width_ratio<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - space_time_cubes          :: dictionary of (Lazy)SpaceTimeCube objects with these cell types</span>
<span class="org-doc">      - slope                         :: rise/run</span>
<span class="org-doc">      - aspect                        :: degrees clockwise from North</span>
<span class="org-doc">      - fuel_model                    :: integer index in fm.fuel_model_table</span>
<span class="org-doc">      - canopy_cover                  :: 0-1</span>
<span class="org-doc">      - canopy_height                 :: m</span>
<span class="org-doc">      - canopy_base_height            :: m</span>
<span class="org-doc">      - canopy_bulk_density           :: kg/m^3</span>
<span class="org-doc">      - wind_speed_10m                :: km/hr</span>
<span class="org-doc">      - upwind_direction              :: degrees clockwise from North</span>
<span class="org-doc">      - fuel_moisture_dead_1hr        :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_dead_10hr       :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_dead_100hr      :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_live_herbaceous :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_live_woody      :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - foliar_moisture               :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_spread_adjustment        :: float &gt;= 0.0 (Optional: defaults to 1.0)</span>
<span class="org-doc">      - weather_spread_adjustment     :: float &gt;= 0.0 (Optional: defaults to 1.0)</span>
<span class="org-doc">    - space_time_coordinate     :: (t,y,x)</span>
<span class="org-doc">    - azimuth                   :: degrees clockwise from North on the horizontal plane</span>
<span class="org-doc">    - use_wind_limit            :: boolean (Optional)</span>
<span class="org-doc">    - max_length_to_width_ratio :: float &gt; 0.0 (Optional)</span>

<span class="org-doc">    return a dictionary with these fire behavior values for the space-time coordinate (t,y,x):</span>
<span class="org-doc">    - fire_type          :: "unburned", "surface", "passive_crown", or "active_crown"</span>
<span class="org-doc">    - spread_rate        :: m/min</span>
<span class="org-doc">    - spread_direction   :: (x, y, z) unit vector on the slope-tangential plane</span>
<span class="org-doc">    - fireline_intensity :: kW/m</span>
<span class="org-doc">    - flame_length       :: m</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the space_time_coordinate</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    (<span class="org-variable-name">t</span>, <span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>) <span class="org-operator">=</span> space_time_coordinate

    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack the space_time_cubes dictionary</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Topography, Fuel Model, and Vegetation</span>
    <span class="org-variable-name">slope</span>               <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"slope"</span>].get(t,y,x)               <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-variable-name">aspect</span>              <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"aspect"</span>].get(t,y,x)              <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-variable-name">fuel_model_number</span>   <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_model"</span>].get(t,y,x)          <span class="org-comment-delimiter"># </span><span class="org-comment">integer index in fm.fuel_model_table</span>
    <span class="org-variable-name">canopy_cover</span>        <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"canopy_cover"</span>].get(t,y,x)        <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
    <span class="org-variable-name">canopy_height</span>       <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"canopy_height"</span>].get(t,y,x)       <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-variable-name">canopy_base_height</span>  <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"canopy_base_height"</span>].get(t,y,x)  <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-variable-name">canopy_bulk_density</span> <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"canopy_bulk_density"</span>].get(t,y,x) <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Wind, Surface Moisture, and Foliar Moisture</span>
    <span class="org-variable-name">wind_speed_10m</span>                <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"wind_speed_10m"</span>].get(t,y,x)                <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-variable-name">upwind_direction</span>              <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"upwind_direction"</span>].get(t,y,x)              <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-variable-name">fuel_moisture_dead_1hr</span>        <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_dead_1hr"</span>].get(t,y,x)        <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_dead_10hr</span>       <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_dead_10hr"</span>].get(t,y,x)       <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_dead_100hr</span>      <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_dead_100hr"</span>].get(t,y,x)      <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_live_herbaceous</span> <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_live_herbaceous"</span>].get(t,y,x) <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_live_woody</span>      <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_live_woody"</span>].get(t,y,x)      <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">foliar_moisture</span>               <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"foliar_moisture"</span>].get(t,y,x)               <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Spread Rate Adjustments (Optional)</span>
    <span class="org-variable-name">fuel_spread_adjustment</span>    <span class="org-operator">=</span> (space_time_cubes[<span class="org-string">"fuel_spread_adjustment"</span>].get(t,y,x)
                                 <span class="org-keyword">if</span> <span class="org-string">"fuel_spread_adjustment"</span> <span class="org-keyword">in</span> space_time_cubes
                                 <span class="org-keyword">else</span> 1.0)                                         <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>
    <span class="org-variable-name">weather_spread_adjustment</span> <span class="org-operator">=</span> (space_time_cubes[<span class="org-string">"weather_spread_adjustment"</span>].get(t,y,x)
                                 <span class="org-keyword">if</span> <span class="org-string">"weather_spread_adjustment"</span> <span class="org-keyword">in</span> space_time_cubes
                                 <span class="org-keyword">else</span> 1.0)                                         <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>
    <span class="org-variable-name">spread_rate_adjustment</span>    <span class="org-operator">=</span> fuel_spread_adjustment <span class="org-operator">*</span> weather_spread_adjustment <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>

    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Project a 2D unit vector pointing toward the azimuth onto the slope-tangential plane</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    <span class="org-variable-name">upslope_direction</span> <span class="org-operator">=</span> conv.opposite_direction(aspect)
    <span class="org-variable-name">slope_vector_2d</span>   <span class="org-operator">=</span> conv.azimuthal_to_cartesian(slope, upslope_direction)
    <span class="org-variable-name">azimuth_vector_2d</span> <span class="org-operator">=</span> conv.azimuthal_to_cartesian(1.0, azimuth)
    <span class="org-variable-name">spread_direction</span>  <span class="org-operator">=</span> vu.as_unit_vector(vu.to_slope_plane(azimuth_vector_2d, slope_vector_2d))

    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Check whether cell is burnable</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    <span class="org-variable-name">fuel_model</span> <span class="org-operator">=</span> fm.fuel_model_table.get(fuel_model_number)

    <span class="org-keyword">if</span> <span class="org-keyword">not</span> (fuel_model <span class="org-keyword">and</span> fuel_model[<span class="org-string">"burnable"</span>]):
        <span class="org-comment-delimiter"># </span><span class="org-comment">Encountered unknown or non-burnable fuel model</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Return zero surface fire behavior in the direction of the azimuth vector</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-keyword">return</span> {
            <span class="org-string">"fire_type"</span>         : <span class="org-string">"unburned"</span>,
            <span class="org-string">"spread_rate"</span>       : 0.0,
            <span class="org-string">"spread_direction"</span>  : spread_direction,
            <span class="org-string">"fireline_intensity"</span>: 0.0,
            <span class="org-string">"flame_length"</span>      : 0.0,
        }

    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Encountered burnable fuel model</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Compute derived parameters</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-variable-name">fuel_moisture</span>                <span class="org-operator">=</span> [fuel_moisture_dead_1hr,
                                        fuel_moisture_dead_10hr,
                                        fuel_moisture_dead_100hr,
                                        0.0, <span class="org-comment-delimiter"># </span><span class="org-comment">fuel_moisture_dead_herbaceous</span>
                                        fuel_moisture_live_herbaceous,
                                        fuel_moisture_live_woody]               <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
        <span class="org-variable-name">fuel_bed_depth</span>               <span class="org-operator">=</span> fuel_model[<span class="org-string">"delta"</span>]                      <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
        <span class="org-variable-name">heat_of_combustion</span>           <span class="org-operator">=</span> conv.Btu_lb_to_kJ_kg(fuel_model[<span class="org-string">"h"</span>][0]) <span class="org-comment-delimiter"># </span><span class="org-comment">kJ/kg</span>
        <span class="org-variable-name">estimated_fine_fuel_moisture</span> <span class="org-operator">=</span> fuel_moisture_dead_1hr                   <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate midflame wind speed</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 10m wind speed to 20ft wind speed</span>
        <span class="org-variable-name">wind_speed_20ft</span> <span class="org-operator">=</span> conv.wind_speed_10m_to_wind_speed_20ft(wind_speed_10m) <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Convert 20ft wind speed from km/hr to m/min</span>
        <span class="org-variable-name">wind_speed_20ft_m_min</span> <span class="org-operator">=</span> conv.km_hr_to_m_min(wind_speed_20ft) <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 20ft wind speed to midflame wind speed in m/min</span>
        <span class="org-variable-name">midflame_wind_speed</span> <span class="org-operator">=</span> sf.calc_midflame_wind_speed(wind_speed_20ft_m_min,       <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
                                                          fuel_bed_depth,              <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                          conv.m_to_ft(canopy_height), <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                          canopy_cover)                <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Apply fuel moisture to fuel model</span>
        <span class="org-variable-name">moisturized_fuel_model</span> <span class="org-operator">=</span> fm.moisturize(fuel_model, fuel_moisture)

        <span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Memoize calc_surface_fire_behavior_no_wind_no_slope</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate no-wind-no-slope surface fire behavior</span>
        <span class="org-variable-name">surface_fire_min</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model,
                                                                          spread_rate_adjustment)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread</span>
        <span class="org-variable-name">surface_fire_max</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_max(surface_fire_min,
                                                             midflame_wind_speed,
                                                             upwind_direction,
                                                             slope,
                                                             aspect,
                                                             use_wind_limit)

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of the azimuth vector</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-variable-name">surface_fire_azimuth</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_in_direction(surface_fire_max, spread_direction)

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Determine whether the surface fire transitions to a crown fire</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-keyword">if</span> cf.van_wagner_crown_fire_initiation(surface_fire_azimuth[<span class="org-string">"fireline_intensity"</span>],
                                               canopy_cover,
                                               canopy_base_height,
                                               foliar_moisture):

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction of maximum spread</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-variable-name">crown_fire_max</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_max(canopy_height, canopy_base_height,
                                                             canopy_bulk_density, heat_of_combustion,
                                                             estimated_fine_fuel_moisture,
                                                             wind_speed_10m, upwind_direction,
                                                             slope, aspect, max_length_to_width_ratio)

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction of the azimuth vector</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-variable-name">crown_fire_azimuth</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_in_direction(crown_fire_max, spread_direction)

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate combined fire behavior in the direction of the azimuth vector</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-variable-name">combined_fire_azimuth</span> <span class="org-operator">=</span> cf.calc_combined_fire_behavior(surface_fire_azimuth, crown_fire_azimuth)

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Return the combined fire behavior in the direction of the azimuth vector</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-keyword">return</span> combined_fire_azimuth

        <span class="org-keyword">else</span>:

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Return the surface fire behavior in the direction of the azimuth vector</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-keyword">return</span> surface_fire_azimuth
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-For Users" class="outline-3">
<h3 id="For Users"><span class="section-number-3">8.2.</span> For Users</h3>
<div class="outline-text-3" id="text-For Users">
<p>
In the following sections, we will demonstrate how to calculate the
combined surface and crown fire behavior first in the direction of
maximum spread and then in any direction.
</p>
</div>
<div id="outline-container-How to Burn a Cell as a Head Fire" class="outline-4">
<h4 id="How to Burn a Cell as a Head Fire"><span class="section-number-4">8.2.1.</span> How to Burn a Cell as a Head Fire</h4>
<div class="outline-text-4" id="text-How to Burn a Cell as a Head Fire">
<div class="org-src-container">
<pre class="src src-python" id="run-burn-cell-as-head-fire"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.burn_cells <span class="org-keyword">as</span> bc
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (
    240,  <span class="org-comment-delimiter"># </span><span class="org-comment">bands: 10 days @ 1 hour/band</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">rows:  30 km @ 30 meters/row</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">cols:  30 km @ 30 meters/col</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Create an input dictionary of SpaceTimeCubes (using constant data for this example)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">space_time_cubes</span> <span class="org-operator">=</span> {
    <span class="org-string">"slope"</span>                        : SpaceTimeCube(cube_shape, 0.8),   <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-string">"aspect"</span>                       : SpaceTimeCube(cube_shape, 225.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_model"</span>                   : SpaceTimeCube(cube_shape, 101),   <span class="org-comment-delimiter"># </span><span class="org-comment">integer index in fm.fuel_model_table</span>
    <span class="org-string">"canopy_cover"</span>                 : SpaceTimeCube(cube_shape, 0.6),   <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
    <span class="org-string">"canopy_height"</span>                : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_base_height"</span>           : SpaceTimeCube(cube_shape, 3.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_bulk_density"</span>          : SpaceTimeCube(cube_shape, 0.3),   <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>
    <span class="org-string">"wind_speed_10m"</span>               : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-string">"upwind_direction"</span>             : SpaceTimeCube(cube_shape, 180.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_moisture_dead_1hr"</span>       : SpaceTimeCube(cube_shape, 0.05),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_10hr"</span>      : SpaceTimeCube(cube_shape, 0.10),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_100hr"</span>     : SpaceTimeCube(cube_shape, 0.15),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_herbaceous"</span>: SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_woody"</span>     : SpaceTimeCube(cube_shape, 0.60),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"foliar_moisture"</span>              : SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_spread_adjustment"</span>       : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
    <span class="org-string">"weather_spread_adjustment"</span>    : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
}

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify a space-time coordinate (t,y,x) within the extent of the SpaceTimeCube dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">space_time_coordinate</span> <span class="org-operator">=</span> (24, 100, 100)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate combined fire behavior in the direction of maximum spread (with wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">combined_behavior_limited</span> <span class="org-operator">=</span> bc.burn_cell_as_head_fire(space_time_cubes, space_time_coordinate)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate combined fire behavior in the direction of maximum spread (without wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">combined_behavior_unlimited</span> <span class="org-operator">=</span> bc.burn_cell_as_head_fire(space_time_cubes, space_time_coordinate,
                                                        use_wind_limit<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Display combined fire behavior in the direction of maximum spread (with wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"Fire Behavior from Combined Surface and Crown Fire (with Wind Limit) at Coordinate "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(space_time_coordinate) <span class="org-operator">+</span> <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 100)
pprint(combined_behavior_limited)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Display combined fire behavior in the direction of maximum spread (without wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Fire Behavior from Combined Surface and Crown Fire (without Wind Limit) at Coordinate "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(space_time_coordinate) <span class="org-operator">+</span> <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 100)
pprint(combined_behavior_unlimited)
</pre>
</div>

<pre class="example" id="orga0f74d3">
Fire Behavior from Combined Surface and Crown Fire (with Wind Limit) at Coordinate (24, 100, 100)
====================================================================================================
{'fire_type': 'surface',
 'fireline_intensity': 32.52824122084378,
 'flame_length': 0.3843932850124078,
 'spread_direction': array([0.48686888, 0.61304249, 0.62220383]),
 'spread_rate': 2.2964672435747526}

Fire Behavior from Combined Surface and Crown Fire (without Wind Limit) at Coordinate (24, 100, 100)
====================================================================================================
{'fire_type': 'surface',
 'fireline_intensity': 50.61290793356301,
 'flame_length': 0.47108157472046464,
 'spread_direction': array([0.48686888, 0.61304249, 0.62220383]),
 'spread_rate': 3.573229932180057}
</pre>
</div>
</div>
<div id="outline-container-How to Burn a Cell in Any Direction" class="outline-4">
<h4 id="How to Burn a Cell in Any Direction"><span class="section-number-4">8.2.2.</span> How to Burn a Cell in Any Direction</h4>
<div class="outline-text-4" id="text-How to Burn a Cell in Any Direction">
<div class="org-src-container">
<pre class="src src-python" id="run-burn-cell-toward-azimuth"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.burn_cells <span class="org-keyword">as</span> bc
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (
    240,  <span class="org-comment-delimiter"># </span><span class="org-comment">bands: 10 days @ 1 hour/band</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">rows:  30 km @ 30 meters/row</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">cols:  30 km @ 30 meters/col</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Create an input dictionary of SpaceTimeCubes (using constant data for this example)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">space_time_cubes</span> <span class="org-operator">=</span> {
    <span class="org-string">"slope"</span>                        : SpaceTimeCube(cube_shape, 0.8),   <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-string">"aspect"</span>                       : SpaceTimeCube(cube_shape, 225.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_model"</span>                   : SpaceTimeCube(cube_shape, 101),   <span class="org-comment-delimiter"># </span><span class="org-comment">integer index in fm.fuel_model_table</span>
    <span class="org-string">"canopy_cover"</span>                 : SpaceTimeCube(cube_shape, 0.6),   <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
    <span class="org-string">"canopy_height"</span>                : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_base_height"</span>           : SpaceTimeCube(cube_shape, 3.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_bulk_density"</span>          : SpaceTimeCube(cube_shape, 0.3),   <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>
    <span class="org-string">"wind_speed_10m"</span>               : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-string">"upwind_direction"</span>             : SpaceTimeCube(cube_shape, 180.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_moisture_dead_1hr"</span>       : SpaceTimeCube(cube_shape, 0.05),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_10hr"</span>      : SpaceTimeCube(cube_shape, 0.10),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_100hr"</span>     : SpaceTimeCube(cube_shape, 0.15),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_herbaceous"</span>: SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_woody"</span>     : SpaceTimeCube(cube_shape, 0.60),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"foliar_moisture"</span>              : SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_spread_adjustment"</span>       : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
    <span class="org-string">"weather_spread_adjustment"</span>    : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
}

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify a space-time coordinate (t,y,x) within the extent of the SpaceTimeCube dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">space_time_coordinate</span> <span class="org-operator">=</span> (24, 100, 100)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify an azimuth to spread the fire towards</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">spread_azimuth</span> <span class="org-operator">=</span> 90.0 <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North on the horizontal plane</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate combined fire behavior in the direction of the azimuth (with wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">combined_behavior_limited</span> <span class="org-operator">=</span> bc.burn_cell_toward_azimuth(space_time_cubes, space_time_coordinate, spread_azimuth)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Calculate combined fire behavior in the direction of the azimuth (without wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">combined_behavior_unlimited</span> <span class="org-operator">=</span> bc.burn_cell_toward_azimuth(space_time_cubes, space_time_coordinate, spread_azimuth,
                                                          use_wind_limit<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Display combined fire behavior in the direction of the azimuth (with wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"Fire Behavior from Combined Surface and Crown Fire (with Wind Limit) at Coordinate "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(space_time_coordinate) <span class="org-operator">+</span> <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 100)
pprint(combined_behavior_limited)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Display combined fire behavior in the direction of the azimuth (without wind limit)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Fire Behavior from Combined Surface and Crown Fire (without Wind Limit) at Coordinate "</span>
      <span class="org-operator">+</span> <span class="org-builtin">str</span>(space_time_coordinate) <span class="org-operator">+</span> <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 100)
pprint(combined_behavior_unlimited)
</pre>
</div>

<pre class="example" id="org880fa3e">
Fire Behavior from Combined Surface and Crown Fire (with Wind Limit) at Coordinate (24, 100, 100)
====================================================================================================
{'fire_type': 'surface',
 'fireline_intensity': 11.637272000784206,
 'flame_length': 0.23956726229329667,
 'spread_direction': array([8.70388280e-01, 5.32959110e-17, 4.92365964e-01]),
 'spread_rate': 0.8215818916531423}

Fire Behavior from Combined Surface and Crown Fire (without Wind Limit) at Coordinate (24, 100, 100)
====================================================================================================
{'fire_type': 'surface',
 'fireline_intensity': 13.898200796816093,
 'flame_length': 0.2599542202128164,
 'spread_direction': array([8.70388280e-01, 5.32959110e-17, 4.92365964e-01]),
 'spread_rate': 0.9812016167065538}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-[WIP] Fire Spread Algorithm: Eulerian Level Set Method (pyretechnics.eulerian_level_set)" class="outline-2">
<h2 id="[WIP] Fire Spread Algorithm: Eulerian Level Set Method (pyretechnics.eulerian_level_set)"><span class="section-number-2">9.</span> [WIP] Fire Spread Algorithm: Eulerian Level Set Method (pyretechnics.eulerian_level_set)</h2>
<div class="outline-text-2" id="text-[WIP] Fire Spread Algorithm: Eulerian Level Set Method (pyretechnics.eulerian_level_set)">
</div>
<div id="outline-container-For Developers" class="outline-3">
<h3 id="For Developers"><span class="section-number-3">9.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-For Developers">
<p>
In order to simulate the spread of a fire from a starting point or
perimeter, we will need to implement a model that projects the
one-dimensional spread and intensity equations presented in sections
<a href="#Surface Fire Equations (pyretechnics.surface_fire)">6</a> and <a href="#Crown Fire Equations (pyretechnics.crown_fire)">7</a> into the three-dimensional
space-time cube introduced in section <a href="#Data Model">2</a>.
</p>

<p>
This section introduces the equations used in the Eulerian level set
method of fire spread, operationalized in Chris Lautenberger's ELMFIRE
model<sup><a id="fnr.33" class="footref" href="#fn.33" role="doc-backlink">33</a></sup>.
</p>
</div>
<div id="outline-container-The $\phi$ Field" class="outline-4">
<h4 id="The $\phi$ Field"><span class="section-number-4">9.1.1.</span> The \(\phi\) Field</h4>
<div class="outline-text-4" id="text-The $\phi$ Field">
<p>
In this model, a continuous field called \(\phi\) fills the simulation
space and is used to track the progression of the fire front through
space and time. Within Pyretechnics, the \(\phi\) field is discretized
into grid cells and initialized with the following values:
</p>

<ul class="org-ul">
<li>-1 for cells that have already been burned and are inside the fire perimeter</li>
<li>1 for cells that have not been burned and are outside the fire perimeter</li>
</ul>

<p>
If a fire is being simulated starting from an actively burning
perimeter, the \(\phi\) grid cells indicate the initially burning region.
If a point fire is being simulated, then a single \(\phi\) cell will be
set to -1 and the remaining cells will have the value 1.
</p>
</div>
</div>
<div id="outline-container-Fire Front Normal Vector" class="outline-4">
<h4 id="Fire Front Normal Vector"><span class="section-number-4">9.1.2.</span> Fire Front Normal Vector</h4>
<div class="outline-text-4" id="text-Fire Front Normal Vector">
<p>
In this fire spread algorithm, the fire front only propagates normal
to itself. Given a \(\phi\) raster, we can calculate the normal vector to
the \(\phi\) field by using the following formula:
</p>

\begin{align}
  \hat{n} &= n_x\hat{i} + n_y\hat{j} = \frac{1}{|\nabla\phi|}\left(\frac{\partial \phi}{\partial x}\hat{i} + \frac{\partial \phi}{\partial y}\hat{j}\right) \\
  \nonumber \\
  |\nabla\phi| &= \sqrt{\left(\frac{\partial \phi}{\partial x}\right)^2 + \left(\frac{\partial \phi}{\partial y}\right)^2}
\end{align}

<p>
We begin by approximating the spatial gradients of the \(\phi\) field with
node-centered central differences, represented by the values in the
\(\phi\) raster's grid cells.
</p>

\begin{align}
  \left(\frac{\partial \phi}{\partial x}\right)_{i,j} &\approx \frac{\phi_{i+1,j} - \phi_{i-1,j}}{2 \Delta x} \\
  \nonumber \\
  \left(\frac{\partial \phi}{\partial y}\right)_{i,j} &\approx \frac{\phi_{i,j+1} - \phi_{i,j-1}}{2 \Delta y}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="phi-field-spatial-gradients-approx"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np


<span class="org-keyword">def</span> <span class="org-function-name">calc_dphi_dx_approx</span>(phi, dx, x, y, cols):
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the spatial gradient of the phi raster in the x (west-&gt;east)</span>
<span class="org-doc">    direction at grid cell (x,y) given the cell width dx.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">east_x</span> <span class="org-operator">=</span> x <span class="org-operator">+</span> 1
    <span class="org-variable-name">west_x</span> <span class="org-operator">=</span> x <span class="org-operator">-</span> 1
    <span class="org-keyword">if</span> east_x <span class="org-operator">&lt;</span> cols:
        <span class="org-keyword">if</span> west_x <span class="org-operator">&gt;=</span> 0:
            <span class="org-keyword">return</span> (phi[y][east_x] <span class="org-operator">-</span> phi[y][west_x]) <span class="org-operator">/</span> (2.0 <span class="org-operator">*</span> dx)
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> (phi[y][east_x] <span class="org-operator">-</span> phi[y][x]) <span class="org-operator">/</span> dx
    <span class="org-keyword">else</span>:
        <span class="org-keyword">if</span> west_x <span class="org-operator">&gt;=</span> 0:
            <span class="org-keyword">return</span> (phi[y][x] <span class="org-operator">-</span> phi[y][west_x]) <span class="org-operator">/</span> dx
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> 0.0


<span class="org-keyword">def</span> <span class="org-function-name">calc_dphi_dy_approx</span>(phi, dy, x, y, rows):
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the spatial gradient of the phi raster in the y (south-&gt;north)</span>
<span class="org-doc">    direction at grid cell (x,y) given the cell height dy.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">north_y</span> <span class="org-operator">=</span> y <span class="org-operator">+</span> 1
    <span class="org-variable-name">south_y</span> <span class="org-operator">=</span> y <span class="org-operator">-</span> 1
    <span class="org-keyword">if</span> north_y <span class="org-operator">&lt;</span> rows:
        <span class="org-keyword">if</span> south_y <span class="org-operator">&gt;=</span> 0:
            <span class="org-keyword">return</span> (phi[north_y][x] <span class="org-operator">-</span> phi[south_y][x]) <span class="org-operator">/</span> (2.0 <span class="org-operator">*</span> dy)
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> (phi[north_y][x] <span class="org-operator">-</span> phi[y][x]) <span class="org-operator">/</span> dy
    <span class="org-keyword">else</span>:
        <span class="org-keyword">if</span> south_y <span class="org-operator">&gt;=</span> 0:
            <span class="org-keyword">return</span> (phi[y][x] <span class="org-operator">-</span> phi[south_y][x]) <span class="org-operator">/</span> dy
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> 0.0


<span class="org-keyword">def</span> <span class="org-function-name">calc_phi_gradient_approx</span>(phi, dx, dy, x, y):
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the spatial gradient of the phi raster at grid cell (x,y)</span>
<span class="org-doc">    given the cell width dx and the cell height dy.</span>
<span class="org-doc">    """</span>
    (<span class="org-variable-name">rows</span>, <span class="org-variable-name">cols</span>) <span class="org-operator">=</span> phi.shape
    <span class="org-variable-name">dphi_dx</span>      <span class="org-operator">=</span> calc_dphi_dx_approx(phi, dx, x, y, cols)
    <span class="org-variable-name">dphi_dy</span>      <span class="org-operator">=</span> calc_dphi_dy_approx(phi, dy, x, y, rows)
    <span class="org-keyword">return</span> np.asarray((dphi_dx, dphi_dy))
</pre>
</div>

<p>
We can now combine these spatial gradients with the magnitude of the
gradient of the \(\phi\) field at any location on the grid to compute
the fire front normal vector as follows:
</p>

<div class="org-src-container">
<pre class="src src-python" id="phi-field-normal-vector"><span class="org-keyword">import</span> pyretechnics.vector_utils <span class="org-keyword">as</span> vu


<span class="org-keyword">def</span> <span class="org-function-name">calc_phi_normal_vector</span>(phi, dx, dy, x, y):
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the phi field normal vector in the x and y dimensions.</span>

<span class="org-doc">    - n_x: eastward component of the unit normal vector</span>
<span class="org-doc">    - n_y: northward component of the unit normal vector</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">phi_gradient</span> <span class="org-operator">=</span> calc_phi_gradient_approx(phi, dx, dy, x, y)
    <span class="org-keyword">if</span> phi_gradient[0] <span class="org-operator">==</span> 0.0 <span class="org-keyword">and</span> phi_gradient[1] <span class="org-operator">==</span> 0.0:
        <span class="org-keyword">return</span> phi_gradient <span class="org-comment-delimiter"># </span><span class="org-comment">(n_x, n_y)</span>
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> vu.as_unit_vector(phi_gradient) <span class="org-comment-delimiter"># </span><span class="org-comment">(n_x, n_y)</span>
</pre>
</div>

<p>
Next, we can use the following geometrical relations to calculate the
angle \(\theta_n\) (measured clockwise from North) to which the normal
vector points:
</p>

\begin{equation}
  \theta_n =
  \begin{cases}
    \frac{1}{2}\pi - \tan^{-1}(\frac{n_y}{n_x}) & \text{for}\ n_x > 0 & \text{and}\ n_y \geq 0 \\
    \frac{1}{2}\pi + \tan^{-1}(\frac{|n_y|}{n_x}) & \text{for}\ n_x > 0 & \text{and}\ n_y < 0 \\
    \frac{3}{2}\pi + \tan^{-1}(\frac{n_y}{|n_x|}) & \text{for}\ n_x < 0 & \text{and}\ n_y \geq 0 \\
    \frac{3}{2}\pi - \tan^{-1}(\frac{n_y}{n_x}) & \text{for}\ n_x < 0 & \text{and}\ n_y < 0 \\
    0 & \text{for}\ n_x = 0 & \text{and}\ n_y \geq 0 \\
    \pi & \text{for}\ n_x = 0 & \text{and}\ n_y < 0
  \end{cases}
\end{equation}

<div class="org-src-container">
<pre class="src src-python" id="phi-field-normal-vector-angle"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> atan, pi, degrees


<span class="org-keyword">def</span> <span class="org-function-name">calc_phi_normal_azimuth</span>(phi_normal_vector):
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the angle (measured in degrees clockwise from North)</span>
<span class="org-doc">    to which the phi field's normal vector points.</span>
<span class="org-doc">    """</span>
    (<span class="org-variable-name">n_x</span>, <span class="org-variable-name">n_y</span>) <span class="org-operator">=</span> phi_normal_vector
    <span class="org-keyword">if</span> n_x <span class="org-operator">&gt;</span> 0:
        <span class="org-keyword">if</span> n_y <span class="org-operator">&gt;=</span> 0:
            <span class="org-variable-name">angle</span> <span class="org-operator">=</span> 1<span class="org-operator">/</span>2 <span class="org-operator">*</span> pi <span class="org-operator">-</span> atan(n_y <span class="org-operator">/</span> n_x)
        <span class="org-keyword">elif</span> n_y <span class="org-operator">&lt;</span> 0:
            <span class="org-variable-name">angle</span> <span class="org-operator">=</span> 1<span class="org-operator">/</span>2 <span class="org-operator">*</span> pi <span class="org-operator">+</span> atan(<span class="org-builtin">abs</span>(n_y) <span class="org-operator">/</span> n_x)
    <span class="org-keyword">elif</span> n_x <span class="org-operator">&lt;</span> 0:
        <span class="org-keyword">if</span> n_y <span class="org-operator">&gt;=</span> 0:
            <span class="org-variable-name">angle</span> <span class="org-operator">=</span> 3<span class="org-operator">/</span>2 <span class="org-operator">*</span> pi <span class="org-operator">+</span> atan(n_y <span class="org-operator">/</span> <span class="org-builtin">abs</span>(n_x))
        <span class="org-keyword">elif</span> n_y <span class="org-operator">&lt;</span> 0:
            <span class="org-variable-name">angle</span> <span class="org-operator">=</span> 3<span class="org-operator">/</span>2 <span class="org-operator">*</span> pi <span class="org-operator">-</span> atan(n_y <span class="org-operator">/</span> n_x)
    <span class="org-keyword">else</span>:
        <span class="org-keyword">if</span> n_y <span class="org-operator">&gt;=</span> 0:
            <span class="org-variable-name">angle</span> <span class="org-operator">=</span> 0.0
        <span class="org-keyword">elif</span> n_y <span class="org-operator">&lt;</span> 0:
            <span class="org-variable-name">angle</span> <span class="org-operator">=</span> pi
    <span class="org-keyword">return</span> degrees(angle)
</pre>
</div>

<p>
Now that we can compute the fire front normal vector, we can find the
spread rate in this direction by combining this vector with the
maximum spread rate vector and elliptical eccentricity values
calculated for each grid cell, using the approaches described in
sections <a href="#Surface Fire Equations (pyretechnics.surface_fire)">6</a> and <a href="#Crown Fire Equations (pyretechnics.crown_fire)">7</a>.
</p>

<p>
We will refer to the spread rate vector normal to the fire front in
the following sections as \(U\) with spatial components \(U_x\) and \(U_y\).
</p>
</div>
</div>
<div id="outline-container-Numerical Solution of the $\phi$ Field Equation" class="outline-4">
<h4 id="Numerical Solution of the $\phi$ Field Equation"><span class="section-number-4">9.1.3.</span> Numerical Solution of the \(\phi\) Field Equation</h4>
<div class="outline-text-4" id="text-Numerical Solution of the $\phi$ Field Equation">
<p>
In order to evolve the \(\phi\) field through time and space, we must
solve the following hyperbolic differential equation for the scalar
variable \(\phi\).
</p>

\begin{align}
  \frac{\partial \phi}{\partial t} + U_x \frac{\partial \phi}{\partial x} + U_y \frac{\partial \phi}{\partial y} = 0
\end{align}

<p>
This is accomplished after applying a flux limiter to the convective
terms, in order to ensure solution monotonicity and prevent spurious
oscillations that can be induced in its absence.
</p>

<p>
First, we define the parameter \(r\) and the Superbee flux limiter
\(B(r)\) as follows:
</p>

\begin{align}
  r &= \frac{\delta\phi_{\text{up}}}{\delta\phi_{\text{loc}}} \\
  \nonumber \\
  B(r) &= \max(0, \min(2r, 1), \min(r, 2))
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="superbee-flux-limiter"><span class="org-keyword">def</span> <span class="org-function-name">calc_superbee_flux_limiter</span>(dphi_up, dphi_loc):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">if</span> dphi_loc <span class="org-operator">==</span> 0.0:
        <span class="org-keyword">return</span> 0.0
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">r</span> <span class="org-operator">=</span> dphi_up <span class="org-operator">/</span> dphi_loc
        <span class="org-keyword">return</span> <span class="org-builtin">max</span>(0,
                   <span class="org-builtin">min</span>(2 <span class="org-operator">*</span> r, 1),
                   <span class="org-builtin">min</span>(r, 2))
</pre>
</div>

<p>
To compute the inputs to this function, we build up the partial
derivatives of the \(\phi\) field in terms of "east", "west", "north",
and "south" values as follows:
</p>

\begin{align}
  \frac{\partial \phi}{\partial x} &\approx \frac{\phi_{\text{east}} - \phi_{\text{west}}}{\Delta x} \\
  \nonumber \\
  \frac{\partial \phi}{\partial y} &\approx \frac{\phi_{\text{north}} - \phi_{\text{south}}}{\Delta y}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="phi-field-spatial-gradients"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np


<span class="org-keyword">def</span> <span class="org-function-name">calc_dphi_dx</span>(phi, u_x, dx, x, y, cols):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">phi_east</span> <span class="org-operator">=</span> calc_phi_east(phi, u_x, x, y, cols)
    <span class="org-variable-name">phi_west</span> <span class="org-operator">=</span> calc_phi_west(phi, u_x, x, y, cols)
    <span class="org-keyword">return</span> (phi_east <span class="org-operator">-</span> phi_west) <span class="org-operator">/</span> dx


<span class="org-keyword">def</span> <span class="org-function-name">calc_dphi_dy</span>(phi, u_y, dy, x, y, rows):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">phi_north</span> <span class="org-operator">=</span> calc_phi_north(phi, u_y, x, y, rows)
    <span class="org-variable-name">phi_south</span> <span class="org-operator">=</span> calc_phi_south(phi, u_y, x, y, rows)
    <span class="org-keyword">return</span> (phi_north <span class="org-operator">-</span> phi_south) <span class="org-operator">/</span> dy


<span class="org-keyword">def</span> <span class="org-function-name">calc_phi_gradient</span>(phi, u_x, u_y, dx, dy, x, y):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    (<span class="org-variable-name">rows</span>, <span class="org-variable-name">cols</span>) <span class="org-operator">=</span> phi.shape
    <span class="org-variable-name">dphi_dx</span>      <span class="org-operator">=</span> calc_dphi_dx(phi, u_x, dx, x, y, cols)
    <span class="org-variable-name">dphi_dy</span>      <span class="org-operator">=</span> calc_dphi_dy(phi, u_y, dy, x, y, rows)
    <span class="org-keyword">return</span> np.asarray((dphi_dx, dphi_dy))
</pre>
</div>

<p>
For the east face:
</p>

\begin{align}
  \delta\phi_{\text{loc}} &= \phi_{i+1,j} - \phi{i,j} \\
  \nonumber \\
  \delta\phi_{\text{up}} &= \begin{cases}
                              \phi_{i,j} - \phi_{i-1,j} & \text{for}\ u_{x,i,j} \ge 0 \\
                              \phi_{i+2,j} - \phi_{i+1,j} & \text{for}\ u_{x,i,j} < 0
                            \end{cases} \\
  \nonumber \\
  \phi_{\text{east}} &= \begin{cases}
                          \phi_{i,j} + \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{x,i,j} \ge 0 \\
                          \phi_{i+1,j} - \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{x,i,j} < 0
                        \end{cases}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="phi-east"><span class="org-keyword">def</span> <span class="org-function-name">calc_phi_east</span>(phi, u_x, x, y, cols):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">very_east_x</span> <span class="org-operator">=</span> <span class="org-builtin">min</span>(x<span class="org-operator">+</span>2, cols<span class="org-operator">-</span>1)
    <span class="org-variable-name">east_x</span>      <span class="org-operator">=</span> <span class="org-builtin">min</span>(x<span class="org-operator">+</span>1, cols<span class="org-operator">-</span>1)
    <span class="org-variable-name">west_x</span>      <span class="org-operator">=</span> <span class="org-builtin">max</span>(x<span class="org-operator">-</span>1, 0)

    <span class="org-variable-name">dphi_loc</span> <span class="org-operator">=</span> phi[y][east_x] <span class="org-operator">-</span> phi[y][x]
    <span class="org-keyword">if</span> u_x <span class="org-operator">&gt;=</span> 0:
        <span class="org-variable-name">dphi_up</span> <span class="org-operator">=</span> phi[y][x] <span class="org-operator">-</span> phi[y][west_x]
        <span class="org-variable-name">B</span> <span class="org-operator">=</span> calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span class="org-keyword">return</span> phi[y][x] <span class="org-operator">+</span> 0.5 <span class="org-operator">*</span> B <span class="org-operator">*</span> dphi_loc
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">dphi_up</span> <span class="org-operator">=</span> phi[y][very_east_x] <span class="org-operator">-</span> phi[y][east_x]
        <span class="org-variable-name">B</span> <span class="org-operator">=</span> calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span class="org-keyword">return</span> phi[y][east_x] <span class="org-operator">-</span> 0.5 <span class="org-operator">*</span> B <span class="org-operator">*</span> dphi_loc
</pre>
</div>

<p>
For the west face:
</p>

\begin{align}
  \delta\phi_{\text{loc}} &= \phi_{i-1,j} - \phi{i,j} \\
  \nonumber \\
  \delta\phi_{\text{up}} &= \begin{cases}
                              \phi_{i-2,j} - \phi_{i-1,j} & \text{for}\ u_{x,i,j} \ge 0 \\
                              \phi_{i,j} - \phi_{i+1,j} & \text{for}\ u_{x,i,j} < 0
                            \end{cases} \\
  \nonumber \\
  \phi_{\text{west}} &= \begin{cases}
                          \phi_{i-1,j} - \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{x,i,j} \ge 0 \\
                          \phi_{i,j} + \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{x,i,j} < 0
                        \end{cases}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="phi-west"><span class="org-keyword">def</span> <span class="org-function-name">calc_phi_west</span>(phi, u_x, x, y, cols):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">east_x</span>      <span class="org-operator">=</span> <span class="org-builtin">min</span>(x<span class="org-operator">+</span>1, cols<span class="org-operator">-</span>1)
    <span class="org-variable-name">west_x</span>      <span class="org-operator">=</span> <span class="org-builtin">max</span>(x<span class="org-operator">-</span>1, 0)
    <span class="org-variable-name">very_west_x</span> <span class="org-operator">=</span> <span class="org-builtin">max</span>(x<span class="org-operator">-</span>2, 0)

    <span class="org-variable-name">dphi_loc</span> <span class="org-operator">=</span> phi[y][west_x] <span class="org-operator">-</span> phi[y][x]
    <span class="org-keyword">if</span> u_x <span class="org-operator">&gt;=</span> 0:
        <span class="org-variable-name">dphi_up</span> <span class="org-operator">=</span> phi[y][very_west_x] <span class="org-operator">-</span> phi[y][west_x]
        <span class="org-variable-name">B</span> <span class="org-operator">=</span> calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span class="org-keyword">return</span> phi[y][west_x] <span class="org-operator">-</span> 0.5 <span class="org-operator">*</span> B <span class="org-operator">*</span> dphi_loc
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">dphi_up</span> <span class="org-operator">=</span> phi[y][x] <span class="org-operator">-</span> phi[y][east_x]
        <span class="org-variable-name">B</span> <span class="org-operator">=</span> calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span class="org-keyword">return</span> phi[y][x] <span class="org-operator">+</span> 0.5 <span class="org-operator">*</span> B <span class="org-operator">*</span> dphi_loc
</pre>
</div>

<p>
For the north face:
</p>

\begin{align}
  \delta\phi_{\text{loc}} &= \phi_{i,j+1} - \phi{i,j} \\
  \nonumber \\
  \delta\phi_{\text{up}} &= \begin{cases}
                              \phi_{i,j} - \phi_{i,j-1} & \text{for}\ u_{y,i,j} \ge 0 \\
                              \phi_{i,j+2} - \phi_{i,j+1} & \text{for}\ u_{y,i,j} < 0
                            \end{cases} \\
  \nonumber \\
  \phi_{\text{north}} &= \begin{cases}
                           \phi_{i,j} + \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{y,i,j} \ge 0 \\
                           \phi_{i,j+1} - \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{y,i,j} < 0
                         \end{cases}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="phi-north"><span class="org-keyword">def</span> <span class="org-function-name">calc_phi_north</span>(phi, u_y, x, y, rows):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">very_north_y</span> <span class="org-operator">=</span> <span class="org-builtin">min</span>(y<span class="org-operator">+</span>2, rows<span class="org-operator">-</span>1)
    <span class="org-variable-name">north_y</span>      <span class="org-operator">=</span> <span class="org-builtin">min</span>(y<span class="org-operator">+</span>1, rows<span class="org-operator">-</span>1)
    <span class="org-variable-name">south_y</span>      <span class="org-operator">=</span> <span class="org-builtin">max</span>(y<span class="org-operator">-</span>1, 0)

    <span class="org-variable-name">dphi_loc</span> <span class="org-operator">=</span> phi[north_y][x] <span class="org-operator">-</span> phi[y][x]
    <span class="org-keyword">if</span> u_y <span class="org-operator">&gt;=</span> 0:
        <span class="org-variable-name">dphi_up</span> <span class="org-operator">=</span> phi[y][x] <span class="org-operator">-</span> phi[south_y][x]
        <span class="org-variable-name">B</span> <span class="org-operator">=</span> calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span class="org-keyword">return</span> phi[y][x] <span class="org-operator">+</span> 0.5 <span class="org-operator">*</span> B <span class="org-operator">*</span> dphi_loc
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">dphi_up</span> <span class="org-operator">=</span> phi[very_north_y][x] <span class="org-operator">-</span> phi[north_y][x]
        <span class="org-variable-name">B</span> <span class="org-operator">=</span> calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span class="org-keyword">return</span> phi[north_y][x] <span class="org-operator">-</span> 0.5 <span class="org-operator">*</span> B <span class="org-operator">*</span> dphi_loc
</pre>
</div>

<p>
For the south face:
</p>

\begin{align}
  \delta\phi_{\text{loc}} &= \phi_{i,j-1} - \phi{i,j} \\
  \nonumber \\
  \delta\phi_{\text{up}} &= \begin{cases}
                              \phi_{i,j-2} - \phi_{i,j-1} & \text{for}\ u_{y,i,j} \ge 0 \\
                              \phi_{i,j} - \phi_{i,j+1} & \text{for}\ u_{y,i,j} < 0
                            \end{cases} \\
  \nonumber \\
  \phi_{\text{south}} &= \begin{cases}
                           \phi_{i,j-1} - \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{y,i,j} \ge 0 \\
                           \phi_{i,j} + \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{y,i,j} < 0
                         \end{cases}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="phi-south"><span class="org-keyword">def</span> <span class="org-function-name">calc_phi_south</span>(phi, u_y, x, y, rows):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">north_y</span>      <span class="org-operator">=</span> <span class="org-builtin">min</span>(y<span class="org-operator">+</span>1, rows<span class="org-operator">-</span>1)
    <span class="org-variable-name">south_y</span>      <span class="org-operator">=</span> <span class="org-builtin">max</span>(y<span class="org-operator">-</span>1, 0)
    <span class="org-variable-name">very_south_y</span> <span class="org-operator">=</span> <span class="org-builtin">max</span>(y<span class="org-operator">-</span>2, 0)

    <span class="org-variable-name">dphi_loc</span> <span class="org-operator">=</span> phi[south_y][x] <span class="org-operator">-</span> phi[y][x]
    <span class="org-keyword">if</span> u_y <span class="org-operator">&gt;=</span> 0:
        <span class="org-variable-name">dphi_up</span> <span class="org-operator">=</span> phi[very_south_y][x] <span class="org-operator">-</span> phi[south_y][x]
        <span class="org-variable-name">B</span> <span class="org-operator">=</span> calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span class="org-keyword">return</span> phi[south_y][x] <span class="org-operator">-</span> 0.5 <span class="org-operator">*</span> B <span class="org-operator">*</span> dphi_loc
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">dphi_up</span> <span class="org-operator">=</span> phi[y][x] <span class="org-operator">-</span> phi[north_y][x]
        <span class="org-variable-name">B</span> <span class="org-operator">=</span> calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span class="org-keyword">return</span> phi[y][x] <span class="org-operator">+</span> 0.5 <span class="org-operator">*</span> B <span class="org-operator">*</span> dphi_loc
</pre>
</div>

<p>
Once the various spatial partial derivatives have been calculated, we
can march the \(\phi\) field solution forward in time using a second
order Runge Kutta method as follows:
</p>

\begin{align}
  \phi^* &= \phi^t - \Delta t \left(U_x \frac{\phi^t_{\text{east}} - \phi^t_{\text{west}}}{\Delta x} + U_y \frac{\phi^t_{\text{north}} - \phi^t_{\text{south}}}{\Delta y} \right) \\
  \nonumber \\
  \phi^{t + \Delta t} &= \frac{1}{2}\phi^t + \frac{1}{2} \left( \phi^* - \Delta t \left(U_x \frac{\phi^*_{\text{east}} - \phi^*_{\text{west}}}{\Delta x} + U_y \frac{\phi^*_{\text{north}} - \phi^*_{\text{south}}}{\Delta y} \right) \right)
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="phi-time"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pyretechnics.burn_cells <span class="org-keyword">import</span> burn_cell_toward_azimuth


<span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: stub</span>
<span class="org-keyword">def</span> <span class="org-function-name">identify_perimeter_cells</span>(phi):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> [[0,0]]


<span class="org-keyword">def</span> <span class="org-function-name">calc_phi_star</span>(phi, u_x, u_y, dx, dy, dt, x, y):
    <span class="org-doc">"""</span>
<span class="org-doc">    Return an estimate for phi[y][x] at time (t + dt) given these inputs:</span>
<span class="org-doc">    - phi :: 2D float array of values in [-1,1]</span>
<span class="org-doc">    - u_x :: m/min</span>
<span class="org-doc">    - u_y :: m/min</span>
<span class="org-doc">    - dx  :: meters</span>
<span class="org-doc">    - dy  :: meters</span>
<span class="org-doc">    - dt  :: minutes</span>
<span class="org-doc">    - x   :: integer column index in phi</span>
<span class="org-doc">    - y   :: integer row index in phi</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">spread_vector</span>   <span class="org-operator">=</span> np.asarray((u_x, u_y))
    <span class="org-variable-name">gradient_vector</span> <span class="org-operator">=</span> calc_phi_gradient(phi, u_x, u_y, dx, dy, x, y)
    <span class="org-variable-name">dphi_dt</span>         <span class="org-operator">=</span> np.dot(spread_vector, gradient_vector)
    <span class="org-keyword">return</span> phi[y][x] <span class="org-operator">-</span> dphi_dt <span class="org-operator">*</span> dt


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Add exit conditions for a max_duration or no perimeter cells found and that should be the spread algorithm!</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Store the fire behavior values computed in the first perimeter_cells loop in output arrays.</span>
<span class="org-keyword">def</span> <span class="org-function-name">calc_phi_next_timestep</span>(space_time_cubes, phi, dx, dy, dt, t):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    NOTE:</span>
<span class="org-doc">    - space_time_cubes and phi must have the same spatial resolution.</span>
<span class="org-doc">    - space_time_cubes must support temporal lookups in minutes.</span>
<span class="org-doc">    - dx is the cell width in meters.</span>
<span class="org-doc">    - dy is the cell height in meters.</span>
<span class="org-doc">    - dt is the timestep in minutes.</span>
<span class="org-doc">    - t is the start time in minutes.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">perimeter_cells</span> <span class="org-operator">=</span> identify_perimeter_cells(phi)

    <span class="org-variable-name">phi_star</span> <span class="org-operator">=</span> np.copy(phi)
    <span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Make this into a ufunc and apply directly to the array</span>
    <span class="org-keyword">for</span> [y, x] <span class="org-keyword">in</span> perimeter_cells:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the spread vector normal to the fire front on the slope-tangential plane</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: This only gives the wavelet spread rate, not the fire front spread rate. Use Val's functions instead.</span>
        <span class="org-variable-name">space_time_coordinate</span> <span class="org-operator">=</span> (t, y, x)
        <span class="org-variable-name">normal_vector</span>         <span class="org-operator">=</span> calc_phi_normal_vector(phi, dx, dy, x, y)
        <span class="org-variable-name">normal_azimuth</span>        <span class="org-operator">=</span> calc_phi_normal_azimuth(normal_vector)
        <span class="org-variable-name">fire_behavior</span>         <span class="org-operator">=</span> burn_cell_toward_azimuth(space_time_cubes, space_time_coordinate, normal_azimuth)
        (<span class="org-variable-name">u_x</span>, <span class="org-variable-name">u_y</span>, <span class="org-variable-name">u_z</span>)       <span class="org-operator">=</span> fire_behavior[<span class="org-string">"spread_rate"</span>] <span class="org-operator">*</span> fire_behavior[<span class="org-string">"spread_direction"</span>]

        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the gradient of phi given this spread vector projected onto the horizontal plane</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Update phi_star based on the dot product of the spread vector and the gradient vector</span>
        phi_star[y][x] <span class="org-operator">=</span> calc_phi_star(phi, u_x, u_y, dx, dy, dt, x, y)

    <span class="org-variable-name">perimeter_cells_star</span> <span class="org-operator">=</span> identify_perimeter_cells(phi_star)

    <span class="org-variable-name">phi_star_star</span> <span class="org-operator">=</span> np.copy(phi_star)
    <span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Make this into a ufunc and apply directly to the array</span>
    <span class="org-keyword">for</span> [y, x] <span class="org-keyword">in</span> perimeter_cells_star:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the spread vector normal to the fire front on the slope-tangential plane</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: This only gives the wavelet spread rate, not the fire front spread rate. Use Val's functions instead.</span>
        <span class="org-variable-name">space_time_coordinate</span> <span class="org-operator">=</span> (t <span class="org-operator">+</span> dt, y, x)
        <span class="org-variable-name">normal_vector</span>         <span class="org-operator">=</span> calc_phi_normal_vector(phi_star, dx, dy, x, y)
        <span class="org-variable-name">normal_azimuth</span>        <span class="org-operator">=</span> calc_phi_normal_azimuth(normal_vector)
        <span class="org-variable-name">fire_behavior</span>         <span class="org-operator">=</span> burn_cell_toward_azimuth(space_time_cubes, space_time_coordinate, normal_azimuth)
        (<span class="org-variable-name">u_x</span>, <span class="org-variable-name">u_y</span>, <span class="org-variable-name">u_z</span>)       <span class="org-operator">=</span> fire_behavior[<span class="org-string">"spread_rate"</span>] <span class="org-operator">*</span> fire_behavior[<span class="org-string">"spread_direction"</span>]

        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the gradient of phi_star given this spread vector projected onto the horizontal plane</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Update phi_star_star based on the dot product of the spread vector and the gradient vector</span>
        phi_star_star[y][x] <span class="org-operator">=</span> calc_phi_star(phi_star, u_x, u_y, dx, dy, dt, x, y)

    <span class="org-keyword">return</span> (phi <span class="org-operator">+</span> phi_star_star) <span class="org-operator">/</span> 2.0
</pre>
</div>

<p>
In the above equations, timestep (\(\Delta t\)) is constrained by the
Courant-Friedrichs-Lewy (CFL) condition. The location of the fire
perimeter is determined by interpolation of the \(\phi\) field as the
level set corresponding to \(\phi = 0\).
</p>
</div>
</div>
<div id="outline-container-Calculate the Surface/Crown Fireline Normal Behavior" class="outline-4">
<h4 id="Calculate the Surface/Crown Fireline Normal Behavior"><span class="section-number-4">9.1.4.</span> Calculate the Surface/Crown Fireline Normal Behavior</h4>
<div class="outline-text-4" id="text-Calculate the Surface/Crown Fireline Normal Behavior">
<div class="org-src-container">
<pre class="src src-python" id="calc-fireline-normal-behavior"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> sqrt
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf
<span class="org-keyword">import</span> pyretechnics.vector_utils <span class="org-keyword">as</span> vu


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Move this to pyretechnics.vector_utils and use throughout the literate program</span>
<span class="org-keyword">def</span> <span class="org-function-name">calc_elevation_gradient</span>(slope, aspect):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the elevation gradient (dz_dx: rise/run, dz_dy: rise/run) given:</span>
<span class="org-doc">    - slope  :: rise/run</span>
<span class="org-doc">    - aspect :: degrees clockwise from North</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> conv.azimuthal_to_cartesian(slope, conv.opposite_direction(aspect))


<span class="org-keyword">def</span> <span class="org-function-name">calc_phi_gradient_on_slope</span>(phi_gradient_xy, elevation_gradient):
    <span class="org-doc">"""</span>
<span class="org-doc">    Return the gradient of phi projected onto the slope-tangential plane as a 3D (x,y,z) vector (in phi/m) given:</span>
<span class="org-doc">    - phi_gradient_xy    :: (dphi_dx: phi/m, dphi_dy: phi/m) 2D vector on the horizontal plane</span>
<span class="org-doc">    - elevation_gradient :: (dz_dx: m/m, dz_dy: m/m)</span>
<span class="org-doc">    """</span>
    (<span class="org-variable-name">dphi_dx</span>, <span class="org-variable-name">dphi_dy</span>) <span class="org-operator">=</span> phi_gradient_xy
    <span class="org-variable-name">phi_gradient_xyz</span>   <span class="org-operator">=</span> np.asarray((dphi_dx, dphi_dy, 0.0))
    <span class="org-keyword">if</span> vu.vector_magnitude(elevation_gradient) <span class="org-operator">==</span> 0.0:
        <span class="org-keyword">return</span> phi_gradient_xyz
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">slope_normal_vector</span> <span class="org-operator">=</span> vu.get_slope_normal_vector(elevation_gradient) <span class="org-comment-delimiter"># </span><span class="org-comment">(x,y,z) unit vector</span>
        <span class="org-keyword">return</span> phi_gradient_xyz <span class="org-operator">-</span> np.dot(phi_gradient_xyz, slope_normal_vector) <span class="org-operator">*</span> slope_normal_vector


<span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Do I switch to cruz_passive_crown_fire_spread_rate() if the normal_spread_rate &lt; critical_spread_rate?</span>
<span class="org-comment-delimiter">#        </span><span class="org-comment">Did I do this correctly in calc_crown_fire_behavior_in_direction?</span>
<span class="org-keyword">def</span> <span class="org-function-name">calc_fireline_normal_behavior</span>(fire_behavior_max, phi_gradient):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - fire_behavior_max  :: dictionary of max surface or crown fire behavior values</span>
<span class="org-doc">      - max_fire_type          :: "passive_crown" or "active_crown" (Required for crown fires only)</span>
<span class="org-doc">      - max_spread_rate        :: m/min</span>
<span class="org-doc">      - max_spread_direction   :: (x, y, z) unit vector</span>
<span class="org-doc">      - max_fireline_intensity :: kW/m</span>
<span class="org-doc">      - max_flame_length       :: m</span>
<span class="org-doc">      - length_to_width_ratio  :: unitless (1: circular spread, &gt; 1: elliptical spread)</span>
<span class="org-doc">      - eccentricity           :: unitless (0: circular spread, &gt; 0: elliptical spread)</span>
<span class="org-doc">      - critical_spread_rate   :: m/min (Required for crown fires only)</span>
<span class="org-doc">    - phi_gradient       :: (dphi_dx: phi/m, dphi_dy: phi/m, dphi_dz: phi/m) 3D vector on the slope-tangential plane</span>

<span class="org-doc">    return a dictionary containing these keys:</span>
<span class="org-doc">    - dphi_dt            :: phi/min (on the slope-tangential plane)</span>
<span class="org-doc">    - fire_type          :: "unburned", "surface", "passive_crown", or "active_crown"</span>
<span class="org-doc">    - spread_rate        :: m/min</span>
<span class="org-doc">    - spread_direction   :: (x, y, z) unit vector</span>
<span class="org-doc">    - fireline_intensity :: kW/m</span>
<span class="org-doc">    - flame_length       :: m</span>

<span class="org-doc">    Note: This function should work for surface or crown fires interchangeably.</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the magnitude of the phi gradient</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    <span class="org-variable-name">phi_magnitude</span> <span class="org-operator">=</span> vu.vector_magnitude(phi_gradient) <span class="org-comment-delimiter"># </span><span class="org-comment">phi/m</span>

    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Check whether cell is on the fire perimeter and burning</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    <span class="org-keyword">if</span> (phi_magnitude <span class="org-operator">==</span> 0.0 <span class="org-keyword">or</span> fire_behavior_max[<span class="org-string">"max_spread_rate"</span>] <span class="org-operator">==</span> 0.0):
        <span class="org-comment-delimiter"># </span><span class="org-comment">This location is not on the fire perimeter and/or is not burning</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Set the spread direction to the phi gradient direction, max spread direction, upslope, or North</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

        <span class="org-variable-name">spread_direction</span> <span class="org-operator">=</span> (np.asarray(phi_gradient) <span class="org-operator">/</span> phi_magnitude <span class="org-keyword">if</span> phi_magnitude <span class="org-operator">&gt;</span> 0.0
                            <span class="org-keyword">else</span> fire_behavior_max[<span class="org-string">"max_spread_direction"</span>])

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Return zero surface/crown fire behavior</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-keyword">return</span> {
            <span class="org-string">"dphi_dt"</span>           : 0.0,
            <span class="org-string">"fire_type"</span>         : <span class="org-string">"unburned"</span>,
            <span class="org-string">"spread_rate"</span>       : 0.0,
            <span class="org-string">"spread_direction"</span>  : spread_direction,
            <span class="org-string">"fireline_intensity"</span>: 0.0,
            <span class="org-string">"flame_length"</span>      : 0.0,
        }

    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">This location is on the fire perimeter and is burning</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack the fire_behavior_max dictionary</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-variable-name">heading_fire_type</span>          <span class="org-operator">=</span> fire_behavior_max.get(<span class="org-string">"max_fire_type"</span>, <span class="org-string">"surface"</span>)
        <span class="org-variable-name">heading_spread_rate</span>        <span class="org-operator">=</span> fire_behavior_max[<span class="org-string">"max_spread_rate"</span>]               <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
        <span class="org-variable-name">heading_spread_direction</span>   <span class="org-operator">=</span> fire_behavior_max[<span class="org-string">"max_spread_direction"</span>]          <span class="org-comment-delimiter"># </span><span class="org-comment">(x,y,z) unit vector</span>
        <span class="org-variable-name">heading_spread_vector</span>      <span class="org-operator">=</span> heading_spread_rate <span class="org-operator">*</span> heading_spread_direction     <span class="org-comment-delimiter"># </span><span class="org-comment">(x,y,z) m/min vector</span>
        <span class="org-variable-name">heading_fireline_intensity</span> <span class="org-operator">=</span> fire_behavior_max[<span class="org-string">"max_fireline_intensity"</span>]        <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
        <span class="org-variable-name">length_to_width_ratio</span>      <span class="org-operator">=</span> fire_behavior_max[<span class="org-string">"length_to_width_ratio"</span>]         <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
        <span class="org-variable-name">eccentricity</span>               <span class="org-operator">=</span> fire_behavior_max[<span class="org-string">"eccentricity"</span>]                  <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
        <span class="org-variable-name">critical_spread_rate</span>       <span class="org-operator">=</span> fire_behavior_max.get(<span class="org-string">"critical_spread_rate"</span>, 0.0) <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the backing and flanking fire spread rates</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-variable-name">backing_adjustment</span>   <span class="org-operator">=</span> (1.0 <span class="org-operator">-</span> eccentricity) <span class="org-operator">/</span> (1.0 <span class="org-operator">+</span> eccentricity)                                 <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
        <span class="org-variable-name">backing_spread_rate</span>  <span class="org-operator">=</span> heading_spread_rate <span class="org-operator">*</span> backing_adjustment                                    <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
        <span class="org-variable-name">flanking_spread_rate</span> <span class="org-operator">=</span> (heading_spread_rate <span class="org-operator">+</span> backing_spread_rate) <span class="org-operator">/</span> (2.0 <span class="org-operator">*</span> length_to_width_ratio) <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate dphi/dt</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-variable-name">A</span>       <span class="org-operator">=</span> (heading_spread_rate <span class="org-operator">-</span> backing_spread_rate) <span class="org-operator">/</span> (2 <span class="org-operator">*</span> heading_spread_rate) <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
        <span class="org-variable-name">B</span>       <span class="org-operator">=</span> np.dot(heading_spread_vector, phi_gradient)                             <span class="org-comment-delimiter"># </span><span class="org-comment">phi/min</span>
        <span class="org-variable-name">C</span>       <span class="org-operator">=</span> flanking_spread_rate <span class="org-operator">/</span> heading_spread_rate                              <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
        <span class="org-variable-name">D</span>       <span class="org-operator">=</span> (heading_spread_rate <span class="org-operator">*</span> phi_magnitude) <span class="org-operator">**</span> 2.0                            <span class="org-comment-delimiter"># </span><span class="org-comment">(phi/min)^2</span>
        <span class="org-variable-name">E</span>       <span class="org-operator">=</span> (length_to_width_ratio <span class="org-operator">**</span> 2.0 <span class="org-operator">-</span> 1.0) <span class="org-operator">*</span> (B <span class="org-operator">**</span> 2.0)                       <span class="org-comment-delimiter"># </span><span class="org-comment">(phi/min)^2</span>
        <span class="org-variable-name">dphi_dt</span> <span class="org-operator">=</span> <span class="org-operator">-</span>(A <span class="org-operator">*</span> B <span class="org-operator">+</span> C <span class="org-operator">*</span> sqrt(D <span class="org-operator">+</span> E))                                              <span class="org-comment-delimiter"># </span><span class="org-comment">phi/min</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate fire behavior normal to the fire perimeter</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-variable-name">normal_spread_rate</span>        <span class="org-operator">=</span> <span class="org-operator">-</span>dphi_dt <span class="org-operator">/</span> phi_magnitude                        <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
        <span class="org-variable-name">normal_direction</span>          <span class="org-operator">=</span> np.asarray(phi_gradient) <span class="org-operator">/</span> phi_magnitude        <span class="org-comment-delimiter"># </span><span class="org-comment">(x,y,z) unit vector</span>
        <span class="org-variable-name">normal_adjustment</span>         <span class="org-operator">=</span> normal_spread_rate <span class="org-operator">/</span> heading_spread_rate        <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
        <span class="org-variable-name">normal_fireline_intensity</span> <span class="org-operator">=</span> heading_fireline_intensity <span class="org-operator">*</span> normal_adjustment  <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
        <span class="org-variable-name">normal_flame_length</span>       <span class="org-operator">=</span> sf.calc_flame_length(normal_fireline_intensity) <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
        <span class="org-variable-name">normal_fire_type</span>          <span class="org-operator">=</span> (<span class="org-string">"surface"</span> <span class="org-keyword">if</span> heading_fire_type <span class="org-operator">==</span> <span class="org-string">"surface"</span>
                                     <span class="org-keyword">else</span> <span class="org-string">"active_crown"</span> <span class="org-keyword">if</span> normal_spread_rate <span class="org-operator">&gt;</span> critical_spread_rate
                                     <span class="org-keyword">else</span> <span class="org-string">"passive_crown"</span>)

        <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Return the surface/crown fire behavior normal to the fire perimeter</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

        <span class="org-keyword">return</span> {
            <span class="org-string">"dphi_dt"</span>           : dphi_dt,                   <span class="org-comment-delimiter"># </span><span class="org-comment">phi/min</span>
            <span class="org-string">"fire_type"</span>         : normal_fire_type,          <span class="org-comment-delimiter"># </span><span class="org-comment">surface, passive_crown, or active_crown</span>
            <span class="org-string">"spread_rate"</span>       : normal_spread_rate,        <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
            <span class="org-string">"spread_direction"</span>  : normal_direction,          <span class="org-comment-delimiter"># </span><span class="org-comment">(x,y,z) unit vector</span>
            <span class="org-string">"fireline_intensity"</span>: normal_fireline_intensity, <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
            <span class="org-string">"flame_length"</span>      : normal_flame_length,       <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
        }
</pre>
</div>
</div>
</div>
<div id="outline-container-Burn Cell Normal to the Fire Perimeter" class="outline-4">
<h4 id="Burn Cell Normal to the Fire Perimeter"><span class="section-number-4">9.1.5.</span> Burn Cell Normal to the Fire Perimeter</h4>
<div class="outline-text-4" id="text-Burn Cell Normal to the Fire Perimeter">
<p>
When the goal of a fire behavior analysis is to evolve a burn scar
from its point of ignition into a generally conical shape in
space-time, then it is necessary to evaluate the combined surface and
crown fire behavior in the direction normal to the fire front. In
order to facilitate this calculation, the following function takes an
azimuth (degrees clockwise from North), meant to represent the spatial
direction in which the fire front is spreading from a given grid cell.
It first projects this 2D direction onto the local slope-tangential
plane and computes the surface fire behavior in this direction. If a
crown fire occurs, the crown fire behavior is also calculated in the
azimuth direction, and the combined surface and crown fire behavior
(as per section <a href="#Combining Surface and Crown Fire Behavior">7.1.7</a>) is
returned. If no crown fire occurs, the surface fire behavior in the
azimuth direction is returned.
</p>

<div class="org-src-container">
<pre class="src src-python" id="burn-cell-toward-phi-gradient"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv
<span class="org-keyword">import</span> pyretechnics.crown_fire <span class="org-keyword">as</span> cf
<span class="org-keyword">import</span> pyretechnics.fuel_models <span class="org-keyword">as</span> fm
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf
<span class="org-keyword">import</span> pyretechnics.vector_utils <span class="org-keyword">as</span> vu


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Create a version of this function that runs efficiently over a space_time_region</span>
<span class="org-keyword">def</span> <span class="org-function-name">burn_cell_toward_phi_gradient</span>(space_time_cubes, space_time_coordinate, phi_gradient_xy,
                                  use_wind_limit<span class="org-operator">=</span><span class="org-constant">True</span>, max_length_to_width_ratio<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - space_time_cubes          :: dictionary of (Lazy)SpaceTimeCube objects with these cell types</span>
<span class="org-doc">      - slope                         :: rise/run</span>
<span class="org-doc">      - aspect                        :: degrees clockwise from North</span>
<span class="org-doc">      - fuel_model                    :: integer index in fm.fuel_model_table</span>
<span class="org-doc">      - canopy_cover                  :: 0-1</span>
<span class="org-doc">      - canopy_height                 :: m</span>
<span class="org-doc">      - canopy_base_height            :: m</span>
<span class="org-doc">      - canopy_bulk_density           :: kg/m^3</span>
<span class="org-doc">      - wind_speed_10m                :: km/hr</span>
<span class="org-doc">      - upwind_direction              :: degrees clockwise from North</span>
<span class="org-doc">      - fuel_moisture_dead_1hr        :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_dead_10hr       :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_dead_100hr      :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_live_herbaceous :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_live_woody      :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - foliar_moisture               :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_spread_adjustment        :: float &gt;= 0.0 (Optional: defaults to 1.0)</span>
<span class="org-doc">      - weather_spread_adjustment     :: float &gt;= 0.0 (Optional: defaults to 1.0)</span>
<span class="org-doc">    - space_time_coordinate     :: (t,y,x)</span>
<span class="org-doc">    - phi_gradient_xy           :: (dphi_dx: phi/m, dphi_dy: phi/m) 2D vector on the horizontal plane</span>
<span class="org-doc">    - use_wind_limit            :: boolean (Optional)</span>
<span class="org-doc">    - max_length_to_width_ratio :: float &gt; 0.0 (Optional)</span>

<span class="org-doc">    return a dictionary with these fire behavior values for the space-time coordinate (t,y,x):</span>
<span class="org-doc">    - dphi_dt            :: phi/min (on the slope-tangential plane)</span>
<span class="org-doc">    - fire_type          :: "unburned", "surface", "passive_crown", or "active_crown"</span>
<span class="org-doc">    - spread_rate        :: m/min</span>
<span class="org-doc">    - spread_direction   :: (x, y, z) unit vector on the slope-tangential plane</span>
<span class="org-doc">    - fireline_intensity :: kW/m</span>
<span class="org-doc">    - flame_length       :: m</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the space_time_coordinate</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    (<span class="org-variable-name">t</span>, <span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>) <span class="org-operator">=</span> space_time_coordinate

    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack the space_time_cubes dictionary</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Topography, Fuel Model, and Vegetation</span>
    <span class="org-variable-name">slope</span>               <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"slope"</span>].get(t,y,x)               <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-variable-name">aspect</span>              <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"aspect"</span>].get(t,y,x)              <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-variable-name">fuel_model_number</span>   <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_model"</span>].get(t,y,x)          <span class="org-comment-delimiter"># </span><span class="org-comment">integer index in fm.fuel_model_table</span>
    <span class="org-variable-name">canopy_cover</span>        <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"canopy_cover"</span>].get(t,y,x)        <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
    <span class="org-variable-name">canopy_height</span>       <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"canopy_height"</span>].get(t,y,x)       <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-variable-name">canopy_base_height</span>  <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"canopy_base_height"</span>].get(t,y,x)  <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-variable-name">canopy_bulk_density</span> <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"canopy_bulk_density"</span>].get(t,y,x) <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Wind, Surface Moisture, and Foliar Moisture</span>
    <span class="org-variable-name">wind_speed_10m</span>                <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"wind_speed_10m"</span>].get(t,y,x)                <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-variable-name">upwind_direction</span>              <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"upwind_direction"</span>].get(t,y,x)              <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-variable-name">fuel_moisture_dead_1hr</span>        <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_dead_1hr"</span>].get(t,y,x)        <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_dead_10hr</span>       <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_dead_10hr"</span>].get(t,y,x)       <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_dead_100hr</span>      <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_dead_100hr"</span>].get(t,y,x)      <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_live_herbaceous</span> <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_live_herbaceous"</span>].get(t,y,x) <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">fuel_moisture_live_woody</span>      <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"fuel_moisture_live_woody"</span>].get(t,y,x)      <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-variable-name">foliar_moisture</span>               <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"foliar_moisture"</span>].get(t,y,x)               <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Spread Rate Adjustments (Optional)</span>
    <span class="org-variable-name">fuel_spread_adjustment</span>    <span class="org-operator">=</span> (space_time_cubes[<span class="org-string">"fuel_spread_adjustment"</span>].get(t,y,x)
                                 <span class="org-keyword">if</span> <span class="org-string">"fuel_spread_adjustment"</span> <span class="org-keyword">in</span> space_time_cubes
                                 <span class="org-keyword">else</span> 1.0)                                         <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>
    <span class="org-variable-name">weather_spread_adjustment</span> <span class="org-operator">=</span> (space_time_cubes[<span class="org-string">"weather_spread_adjustment"</span>].get(t,y,x)
                                 <span class="org-keyword">if</span> <span class="org-string">"weather_spread_adjustment"</span> <span class="org-keyword">in</span> space_time_cubes
                                 <span class="org-keyword">else</span> 1.0)                                         <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>
    <span class="org-variable-name">spread_rate_adjustment</span>    <span class="org-operator">=</span> fuel_spread_adjustment <span class="org-operator">*</span> weather_spread_adjustment <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0</span>

    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the elevation gradient</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    <span class="org-variable-name">elevation_gradient</span> <span class="org-operator">=</span> calc_elevation_gradient(slope, aspect)

    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Project the horizontal phi gradient onto the slope-tangential plane</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

    <span class="org-variable-name">phi_gradient</span> <span class="org-operator">=</span> calc_phi_gradient_on_slope(phi_gradient_xy, elevation_gradient)

    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the magnitude of the phi gradient</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    <span class="org-variable-name">phi_magnitude</span> <span class="org-operator">=</span> vu.vector_magnitude(phi_gradient) <span class="org-comment-delimiter"># </span><span class="org-comment">phi/m</span>

    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Check whether cell is on the fire perimeter and burnable</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

    <span class="org-variable-name">fuel_model</span> <span class="org-operator">=</span> fm.fuel_model_table.get(fuel_model_number)

    <span class="org-keyword">if</span> <span class="org-keyword">not</span> (phi_magnitude <span class="org-operator">&gt;</span> 0.0 <span class="org-keyword">and</span> fuel_model <span class="org-keyword">and</span> fuel_model[<span class="org-string">"burnable"</span>]):
        <span class="org-comment-delimiter"># </span><span class="org-comment">Cell is not on the fire perimeter and/or contains an unknown or non-burnable fuel model</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Set the spread direction to the phi gradient direction, upslope, or North</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">================================================================================================</span>

        <span class="org-keyword">if</span> phi_magnitude <span class="org-operator">&gt;</span> 0.0:
            <span class="org-variable-name">spread_direction</span> <span class="org-operator">=</span> np.asarray(phi_gradient) <span class="org-operator">/</span> phi_magnitude
        <span class="org-keyword">elif</span> slope <span class="org-operator">&gt;</span> 0.0:
            <span class="org-variable-name">slope_vector_3d</span>  <span class="org-operator">=</span> vu.to_slope_plane(elevation_gradient, elevation_gradient)
            <span class="org-variable-name">spread_direction</span> <span class="org-operator">=</span> vu.as_unit_vector(slope_vector_3d)
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">spread_direction</span> <span class="org-operator">=</span> np.asarray((0,1,0)) <span class="org-comment-delimiter"># </span><span class="org-comment">default: North</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Return zero surface fire behavior</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-keyword">return</span> {
            <span class="org-string">"dphi_dt"</span>           : 0.0,
            <span class="org-string">"fire_type"</span>         : <span class="org-string">"unburned"</span>,
            <span class="org-string">"spread_rate"</span>       : 0.0,
            <span class="org-string">"spread_direction"</span>  : spread_direction,
            <span class="org-string">"fireline_intensity"</span>: 0.0,
            <span class="org-string">"flame_length"</span>      : 0.0,
        }

    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Cell is on the fire perimeter and contains a burnable fuel model</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Compute derived parameters</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-variable-name">fuel_moisture</span>                <span class="org-operator">=</span> [fuel_moisture_dead_1hr,
                                        fuel_moisture_dead_10hr,
                                        fuel_moisture_dead_100hr,
                                        0.0, <span class="org-comment-delimiter"># </span><span class="org-comment">fuel_moisture_dead_herbaceous</span>
                                        fuel_moisture_live_herbaceous,
                                        fuel_moisture_live_woody]               <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
        <span class="org-variable-name">fuel_bed_depth</span>               <span class="org-operator">=</span> fuel_model[<span class="org-string">"delta"</span>]                      <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
        <span class="org-variable-name">heat_of_combustion</span>           <span class="org-operator">=</span> conv.Btu_lb_to_kJ_kg(fuel_model[<span class="org-string">"h"</span>][0]) <span class="org-comment-delimiter"># </span><span class="org-comment">kJ/kg</span>
        <span class="org-variable-name">estimated_fine_fuel_moisture</span> <span class="org-operator">=</span> fuel_moisture_dead_1hr                   <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate midflame wind speed</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 10m wind speed to 20ft wind speed</span>
        <span class="org-variable-name">wind_speed_20ft</span> <span class="org-operator">=</span> conv.wind_speed_10m_to_wind_speed_20ft(wind_speed_10m) <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Convert 20ft wind speed from km/hr to m/min</span>
        <span class="org-variable-name">wind_speed_20ft_m_min</span> <span class="org-operator">=</span> conv.km_hr_to_m_min(wind_speed_20ft) <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Convert from 20ft wind speed to midflame wind speed in m/min</span>
        <span class="org-variable-name">midflame_wind_speed</span> <span class="org-operator">=</span> sf.calc_midflame_wind_speed(wind_speed_20ft_m_min,       <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
                                                          fuel_bed_depth,              <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                          conv.m_to_ft(canopy_height), <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
                                                          canopy_cover)                <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Apply fuel moisture to fuel model</span>
        <span class="org-variable-name">moisturized_fuel_model</span> <span class="org-operator">=</span> fm.moisturize(fuel_model, fuel_moisture)

        <span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Memoize calc_surface_fire_behavior_no_wind_no_slope</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate no-wind-no-slope surface fire behavior</span>
        <span class="org-variable-name">surface_fire_min</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_no_wind_no_slope(moisturized_fuel_model,
                                                                          spread_rate_adjustment)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior in the direction of maximum spread</span>
        <span class="org-variable-name">surface_fire_max</span> <span class="org-operator">=</span> sf.calc_surface_fire_behavior_max(surface_fire_min,
                                                             midflame_wind_speed,
                                                             upwind_direction,
                                                             slope,
                                                             aspect,
                                                             use_wind_limit)

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate surface fire behavior normal to the fire perimeter</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-variable-name">surface_fire_normal</span> <span class="org-operator">=</span> calc_fireline_normal_behavior(surface_fire_max, phi_gradient)

        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Determine whether the surface fire transitions to a crown fire</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

        <span class="org-keyword">if</span> cf.van_wagner_crown_fire_initiation(surface_fire_normal[<span class="org-string">"fireline_intensity"</span>],
                                               canopy_cover,
                                               canopy_base_height,
                                               foliar_moisture):

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior in the direction of maximum spread</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-variable-name">crown_fire_max</span> <span class="org-operator">=</span> cf.calc_crown_fire_behavior_max(canopy_height, canopy_base_height,
                                                             canopy_bulk_density, heat_of_combustion,
                                                             estimated_fine_fuel_moisture,
                                                             wind_speed_10m, upwind_direction,
                                                             slope, aspect, max_length_to_width_ratio)

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate crown fire behavior normal to the fire perimeter</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-variable-name">crown_fire_normal</span> <span class="org-operator">=</span> calc_fireline_normal_behavior(crown_fire_max, phi_gradient)

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate combined fire behavior normal to the fire perimeter</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-variable-name">combined_fire_normal</span> <span class="org-operator">=</span> cf.calc_combined_fire_behavior(surface_fire_normal, crown_fire_normal)
            <span class="org-variable-name">surface_dphi_dt</span>      <span class="org-operator">=</span> surface_fire_normal[<span class="org-string">"dphi_dt"</span>]
            <span class="org-variable-name">crown_dphi_dt</span>        <span class="org-operator">=</span> crown_fire_normal[<span class="org-string">"dphi_dt"</span>]
            <span class="org-variable-name">combined_dphi_dt</span>     <span class="org-operator">=</span> surface_dphi_dt <span class="org-keyword">if</span> <span class="org-builtin">abs</span>(surface_dphi_dt) <span class="org-operator">&gt;</span> <span class="org-builtin">abs</span>(crown_dphi_dt) <span class="org-keyword">else</span> crown_dphi_dt
            <span class="org-variable-name">combined_fire_normal</span>[<span class="org-string">"dphi_dt"</span>] <span class="org-operator">=</span> combined_dphi_dt

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Return the combined fire behavior normal to the fire perimeter</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-keyword">return</span> combined_fire_normal

        <span class="org-keyword">else</span>:

            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Return the surface fire behavior normal to the fire perimeter</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">========================================================================================</span>

            <span class="org-keyword">return</span> surface_fire_normal
</pre>
</div>
</div>
</div>
<div id="outline-container-Identify Cells Near the Fire Perimeter ($\phi = 0$)" class="outline-4">
<h4 id="Identify Cells Near the Fire Perimeter ($\phi = 0$)"><span class="section-number-4">9.1.6.</span> Identify Cells Near the Fire Perimeter (\(\phi = 0\))</h4>
<div class="outline-text-4" id="text-Identify Cells Near the Fire Perimeter ($\phi = 0$)">
</div>
<ol class="org-ol">
<li><a id="A proposed algorithm for narrow band tracking"></a>A proposed algorithm for narrow band tracking<br>
<div class="outline-text-5" id="text-A proposed algorithm for narrow band tracking">
</div>
<ol class="org-ol">
<li><a id="Problem statement"></a>Problem statement<br>
<div class="outline-text-6" id="text-Problem statement">
<p>
To make the level-set method efficient, an important optimization
consists of updating only those cells in a narrow band around the fire
front (e.g., within a width of 3 cells). This way fire behavior gets
computed (and \(\phi\) gets updated) only on a sparse subset of the
landscape at each timestep.
</p>
</div>
</li>
<li><a id="Definitions"></a>Definitions<br>
<div class="outline-text-6" id="text-Definitions">
<p>
At a given time step:
</p>

<ol class="org-ol">
<li>a <span class="underline">frontier</span> cell is a cell that has a neighbor of opposite \(\phi\)
sign.</li>

<li>a <span class="underline">tracked</span> cell is a cell for which we will compute the fire
behavior and update the \(\phi\) field.</li>
</ol>
</div>
</li>
<li><a id="Suggested algorithm"></a>Suggested algorithm<br>
<div class="outline-text-6" id="text-Suggested algorithm">
<dl class="org-dl">
<dt>Detecting Frontier Cells</dt><dd>iterate through cell pairs (N/S, E/W),
computing the products of their \(\phi\) values and match when these
are negative.</dd>

<dt>Invariant</dt><dd>at each time step, the set of tracked cells is the set
of cells within 3 cells of a frontier cell using the Chebyshev
distance.</dd>

<dt>State</dt><dd>we maintain a "reference counting" map, mapping each
tracked cell to the number of frontier cells to which it is near
(<span class="underline">near</span> means "within 3 cells" using the Chebyshev distance). In
particular, the keyset of this map is the set of tracked cells.</dd>

<dt>Iteration</dt><dd>at the end of timestep \(t\), we know the values of
\(\phi(t)\) and \(\phi(t+\Delta t)\) for all tracked cells. We now must
compute the new set of tracked cells, which involves updating the
reference-counting map. We do so by taking the following steps:

<ol class="org-ol">
<li>Scan the set of tracked cells, and compute two subsets of them:
(A) those that have become frontier cells and (B) those that are
no longer frontier cells.</li>

<li>For each cell in A (new frontier cell), list the cells near it,
and increment their tracking counter by 1.</li>

<li>For each cell in B (no longer a frontier cell), list the cells
near it, and decrement their tracking counter by 1. Upon reaching
0, remove the map entry.</li>
</ol></dd>
</dl>

<div class="org-src-container">
<pre class="src src-python" id="phi-field-perimeter-tracking"><span class="org-keyword">def</span> <span class="org-function-name">opposite_phi_signs</span>(phi_matrix, y1, x1, y2, x2):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> phi_matrix[y1, x1] <span class="org-operator">*</span> phi_matrix[y2, x2] <span class="org-operator">&lt;</span> 0.0


<span class="org-keyword">def</span> <span class="org-function-name">identify_frontier_cells</span>(phi_matrix, tracked_cells<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    (<span class="org-variable-name">rows</span>, <span class="org-variable-name">cols</span>)   <span class="org-operator">=</span> phi_matrix.shape
    <span class="org-variable-name">frontier_cells</span> <span class="org-operator">=</span> <span class="org-builtin">set</span>()
    <span class="org-keyword">if</span> tracked_cells:
        <span class="org-keyword">for</span> (y, x) <span class="org-keyword">in</span> tracked_cells:
            <span class="org-comment-delimiter"># </span><span class="org-comment">Compare (north, south) and (east, west) neighboring cell pairs for opposite phi signs</span>
            <span class="org-variable-name">north_y</span> <span class="org-operator">=</span> <span class="org-builtin">min</span>(y<span class="org-operator">+</span>1, rows<span class="org-operator">-</span>1)
            <span class="org-variable-name">south_y</span> <span class="org-operator">=</span> <span class="org-builtin">max</span>(y<span class="org-operator">-</span>1, 0)
            <span class="org-variable-name">east_x</span>  <span class="org-operator">=</span> <span class="org-builtin">min</span>(x<span class="org-operator">+</span>1, cols<span class="org-operator">-</span>1)
            <span class="org-variable-name">west_x</span>  <span class="org-operator">=</span> <span class="org-builtin">max</span>(x<span class="org-operator">-</span>1, 0)
            <span class="org-keyword">if</span> (opposite_phi_signs(phi_matrix, north_y, x, south_y, x) <span class="org-keyword">or</span>
                opposite_phi_signs(phi_matrix, y, east_x, y, west_x)):
                frontier_cells.add((y, x))
    <span class="org-keyword">else</span>:
        <span class="org-keyword">for</span> y <span class="org-keyword">in</span> <span class="org-builtin">range</span>(rows):
            <span class="org-keyword">for</span> x <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cols):
                <span class="org-comment-delimiter"># </span><span class="org-comment">Compare (north, south) and (east, west) neighboring cell pairs for opposite phi signs</span>
                <span class="org-variable-name">north_y</span> <span class="org-operator">=</span> <span class="org-builtin">min</span>(y<span class="org-operator">+</span>1, rows<span class="org-operator">-</span>1)
                <span class="org-variable-name">south_y</span> <span class="org-operator">=</span> <span class="org-builtin">max</span>(y<span class="org-operator">-</span>1, 0)
                <span class="org-variable-name">east_x</span>  <span class="org-operator">=</span> <span class="org-builtin">min</span>(x<span class="org-operator">+</span>1, cols<span class="org-operator">-</span>1)
                <span class="org-variable-name">west_x</span>  <span class="org-operator">=</span> <span class="org-builtin">max</span>(x<span class="org-operator">-</span>1, 0)
                <span class="org-keyword">if</span> (opposite_phi_signs(phi_matrix, north_y, x, south_y, x) <span class="org-keyword">or</span>
                    opposite_phi_signs(phi_matrix, y, east_x, y, west_x)):
                    frontier_cells.add((y, x))
    <span class="org-keyword">return</span> frontier_cells


<span class="org-keyword">def</span> <span class="org-function-name">project_buffer</span>(cell, buffer_width, rows, cols):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    (<span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>)         <span class="org-operator">=</span> cell
    <span class="org-variable-name">buffer_range_y</span> <span class="org-operator">=</span> <span class="org-builtin">range</span>(<span class="org-builtin">max</span>(0, y <span class="org-operator">-</span> buffer_width), <span class="org-builtin">min</span>(rows, y <span class="org-operator">+</span> buffer_width <span class="org-operator">+</span> 1))
    <span class="org-variable-name">buffer_range_x</span> <span class="org-operator">=</span> <span class="org-builtin">range</span>(<span class="org-builtin">max</span>(0, x <span class="org-operator">-</span> buffer_width), <span class="org-builtin">min</span>(cols, x <span class="org-operator">+</span> buffer_width <span class="org-operator">+</span> 1))
    <span class="org-keyword">return</span> [(y_, x_)
            <span class="org-keyword">for</span> y_ <span class="org-keyword">in</span> buffer_range_y
            <span class="org-keyword">for</span> x_ <span class="org-keyword">in</span> buffer_range_x]


<span class="org-keyword">def</span> <span class="org-function-name">identify_tracked_cells</span>(frontier_cells, buffer_width, matrix_shape):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    (<span class="org-variable-name">rows</span>, <span class="org-variable-name">cols</span>)  <span class="org-operator">=</span> matrix_shape
    <span class="org-variable-name">tracked_cells</span> <span class="org-operator">=</span> {}
    <span class="org-keyword">for</span> cell <span class="org-keyword">in</span> frontier_cells:
        <span class="org-keyword">for</span> buffer_cell <span class="org-keyword">in</span> project_buffer(cell, buffer_width, rows, cols):
            <span class="org-variable-name">tracked_cells</span>[buffer_cell] <span class="org-operator">=</span> tracked_cells.get(buffer_cell, 0) <span class="org-operator">+</span> 1
    <span class="org-keyword">return</span> tracked_cells


<span class="org-keyword">def</span> <span class="org-function-name">update_tracked_cells</span>(tracked_cells, frontier_cells_old, frontier_cells_new, buffer_width, matrix_shape):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Determine which frontier cells have been added or dropped</span>
    (<span class="org-variable-name">rows</span>, <span class="org-variable-name">cols</span>)           <span class="org-operator">=</span> matrix_shape
    <span class="org-variable-name">frontier_cells_added</span>   <span class="org-operator">=</span> frontier_cells_new.difference(frontier_cells_old)
    <span class="org-variable-name">frontier_cells_dropped</span> <span class="org-operator">=</span> frontier_cells_old.difference(frontier_cells_new)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Increment reference counters for all cells within buffer_width of the added frontier cells</span>
    <span class="org-keyword">for</span> cell <span class="org-keyword">in</span> frontier_cells_added:
        <span class="org-keyword">for</span> buffer_cell <span class="org-keyword">in</span> project_buffer(cell, buffer_width, rows, cols):
            <span class="org-variable-name">tracked_cells</span>[buffer_cell] <span class="org-operator">=</span> tracked_cells.get(buffer_cell, 0) <span class="org-operator">+</span> 1
    <span class="org-comment-delimiter"># </span><span class="org-comment">Decrement reference counters for all cells within buffer_width of the dropped frontier cells</span>
    <span class="org-keyword">for</span> cell <span class="org-keyword">in</span> frontier_cells_dropped:
        <span class="org-keyword">for</span> buffer_cell <span class="org-keyword">in</span> project_buffer(cell, buffer_width, rows, cols):
            <span class="org-variable-name">tracked_cells</span>[buffer_cell] <span class="org-operator">-=</span> 1
            <span class="org-keyword">if</span> tracked_cells[buffer_cell] <span class="org-operator">==</span> 0:
                tracked_cells.pop(buffer_cell)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Return updated tracked cells</span>
    <span class="org-keyword">return</span> tracked_cells
</pre>
</div>
</div>
</li>
</ol>
</li>
</ol>
</div>
<div id="outline-container-Spread Phi Field" class="outline-4">
<h4 id="Spread Phi Field"><span class="section-number-4">9.1.7.</span> Spread Phi Field</h4>
<div class="outline-text-4" id="text-Spread Phi Field">
<p>
\(\hat{\nabla} \varphi \cdot U = (\hat{\nabla} \varphi \cdot \frac{\ddot{\nabla} \varphi}{|\ddot{\nabla} \varphi|}) (\frac{\ddot{\nabla} \varphi}{|\ddot{\nabla} \varphi|}\cdot U) = (\hat{\nabla} \varphi \cdot \frac{\ddot{\nabla} \varphi}{|\ddot{\nabla} \varphi|^2}) (\ddot{\nabla} \varphi \cdot U)\)
</p>

<p>
Compute dt at each timestep using the Courant-Friedrichs Lewy condition simplified to the one-dimensional case by computing `UMAX`:
<a href="https://en.wikipedia.org/wiki/Courant%E2%80%93Friedrichs%E2%80%93Lewy_condition">https://en.wikipedia.org/wiki/Courant%E2%80%93Friedrichs%E2%80%93Lewy_condition</a>
</p>

<p>
Here's how to do the correct computation for the \(U_x\) and \(U_y\) horizontal spread rates used in the CFL calculation.
</p>

<p>
Denote \(\bar{U} := (\bar{U}_x, \bar{U}_y)\) the horizontal vector that we need for the CFL. This vector is defined as being front-normal in the horizontal plane, with magnitude \(|\bar{U}| = - \frac{d \varphi}{dt}/|\nabla \varphi|\). It follows that its coordinates can be obtained as:
</p>

<p>
$ \bar{U}_x = - \frac{d \varphi}{dt} \frac{1}{|\nabla \varphi|^2}  \frac{\partial \varphi}{\partial x}$
</p>

<p>
&#x2026; and similarly for \(\bar{U}_y\). The spatial gradient is not flux-limited.
</p>

<div class="org-src-container">
<pre class="src src-python" id="spread-phi-field"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv
<span class="org-keyword">import</span> pyretechnics.vector_utils <span class="org-keyword">as</span> vu


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Move to pyretechnics.conversion</span>
<span class="org-variable-name">fire_type_codes</span> <span class="org-operator">=</span> {
    <span class="org-string">"unburned"</span>      : 0,
    <span class="org-string">"surface"</span>       : 1,
    <span class="org-string">"passive_crown"</span> : 2,
    <span class="org-string">"active_crown"</span>  : 3,
}


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Move to pyretechnics.vector_utils</span>
<span class="org-keyword">def</span> <span class="org-function-name">spread_direction_vector_to_angle</span>(vector_3d):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    (<span class="org-variable-name">x</span>, <span class="org-variable-name">y</span>)       <span class="org-operator">=</span> vu.to_horizontal_plane(vector_3d)
    (<span class="org-variable-name">r</span>, <span class="org-variable-name">azimuth</span>) <span class="org-operator">=</span> conv.cartesian_to_azimuthal(x, y)
    <span class="org-keyword">return</span> azimuth


<span class="org-keyword">def</span> <span class="org-function-name">spread_fire_one_timestep</span>(space_time_cubes, output_matrices, frontier_cells, tracked_cells,
                             cube_resolution, start_time, max_timestep, use_wind_limit<span class="org-operator">=</span><span class="org-constant">True</span>,
                             max_length_to_width_ratio<span class="org-operator">=</span><span class="org-constant">None</span>, max_cells_per_timestep<span class="org-operator">=</span>0.4, buffer_width<span class="org-operator">=</span>3):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    NOTE:</span>
<span class="org-doc">    - space_time_cubes and phi must have the same spatial resolution and extent.</span>
<span class="org-doc">    - space_time_cubes must support temporal lookups in minutes.</span>
<span class="org-doc">    - cell_width is in meters.</span>
<span class="org-doc">    - cell_height is in meters.</span>
<span class="org-doc">    - dt is the timestep in minutes.</span>
<span class="org-doc">    - start_time is the start time in minutes.</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Extract simulation dimensions</span>
    (<span class="org-variable-name">band_duration</span>, <span class="org-variable-name">cell_height</span>, <span class="org-variable-name">cell_width</span>) <span class="org-operator">=</span> cube_resolution

    <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack output matrices</span>
    <span class="org-variable-name">phi_matrix</span>                <span class="org-operator">=</span> output_matrices[<span class="org-string">"phi"</span>]
    <span class="org-variable-name">phi_star_matrix</span>           <span class="org-operator">=</span> output_matrices[<span class="org-string">"phi_star"</span>]
    <span class="org-variable-name">fire_type_matrix</span>          <span class="org-operator">=</span> output_matrices[<span class="org-string">"fire_type"</span>]
    <span class="org-variable-name">spread_rate_matrix</span>        <span class="org-operator">=</span> output_matrices[<span class="org-string">"spread_rate"</span>]
    <span class="org-variable-name">spread_direction_matrix</span>   <span class="org-operator">=</span> output_matrices[<span class="org-string">"spread_direction"</span>]
    <span class="org-variable-name">fireline_intensity_matrix</span> <span class="org-operator">=</span> output_matrices[<span class="org-string">"fireline_intensity"</span>]
    <span class="org-variable-name">flame_length_matrix</span>       <span class="org-operator">=</span> output_matrices[<span class="org-string">"flame_length"</span>]
    <span class="org-variable-name">time_of_arrival_matrix</span>    <span class="org-operator">=</span> output_matrices[<span class="org-string">"time_of_arrival"</span>]

    <span class="org-comment-delimiter"># </span><span class="org-comment">Initialize max spread rates in the x and y dimensions to 0.0</span>
    <span class="org-variable-name">max_spread_rate_x</span> <span class="org-operator">=</span> 0.0
    <span class="org-variable-name">max_spread_rate_y</span> <span class="org-operator">=</span> 0.0

    <span class="org-comment-delimiter"># </span><span class="org-comment">Create an empty dictionary to store intermediate fire behavior values per cell</span>
    <span class="org-variable-name">fire_behavior_dict</span> <span class="org-operator">=</span> {}

    <span class="org-comment-delimiter"># </span><span class="org-comment">Compute fire behavior values at time (start_time) and identify the max spread rates in the x and y dimensions</span>
    <span class="org-variable-name">t0</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>(start_time <span class="org-operator">//</span> band_duration)
    <span class="org-keyword">for</span> cell_index <span class="org-keyword">in</span> tracked_cells:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack cell_index</span>
        (<span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>) <span class="org-operator">=</span> cell_index

        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate phi gradient on the horizontal plane</span>
        <span class="org-variable-name">phi_gradient_xy</span>  <span class="org-operator">=</span> calc_phi_gradient_approx(phi_matrix, cell_width, cell_height, x, y)
        <span class="org-variable-name">phi_magnitude_xy</span> <span class="org-operator">=</span> vu.vector_magnitude(phi_gradient_xy)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the fire behavior normal to the fire front on the slope-tangential plane</span>
        <span class="org-variable-name">fire_behavior</span> <span class="org-operator">=</span> burn_cell_toward_phi_gradient(space_time_cubes, (t0, y, x),
                                                      phi_gradient_xy, use_wind_limit,
                                                      max_length_to_width_ratio)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Check whether cell has a positive phi magnitude</span>
        <span class="org-keyword">if</span> phi_magnitude_xy <span class="org-operator">&gt;</span> 0.0:
            <span class="org-comment-delimiter"># </span><span class="org-comment">Keep a running tally of the max horizontal spread rates in the x and y dimensions for unburned cells</span>
            (<span class="org-variable-name">dphi_dx</span>, <span class="org-variable-name">dphi_dy</span>) <span class="org-operator">=</span> phi_gradient_xy
            <span class="org-variable-name">phi_magnitude_xy_2</span> <span class="org-operator">=</span> phi_magnitude_xy <span class="org-operator">**</span> 2.0
            <span class="org-keyword">if</span> phi_matrix[y,x] <span class="org-operator">&gt;</span> 0.0:
                <span class="org-variable-name">dphi_dt</span>            <span class="org-operator">=</span> fire_behavior[<span class="org-string">"dphi_dt"</span>]
                <span class="org-variable-name">spread_rate_x</span>      <span class="org-operator">=</span> <span class="org-operator">-</span>dphi_dt <span class="org-operator">*</span> dphi_dx <span class="org-operator">/</span> phi_magnitude_xy_2
                <span class="org-variable-name">spread_rate_y</span>      <span class="org-operator">=</span> <span class="org-operator">-</span>dphi_dt <span class="org-operator">*</span> dphi_dy <span class="org-operator">/</span> phi_magnitude_xy_2
                <span class="org-variable-name">max_spread_rate_x</span>  <span class="org-operator">=</span> <span class="org-builtin">max</span>(max_spread_rate_x, <span class="org-builtin">abs</span>(spread_rate_x))
                <span class="org-variable-name">max_spread_rate_y</span>  <span class="org-operator">=</span> <span class="org-builtin">max</span>(max_spread_rate_y, <span class="org-builtin">abs</span>(spread_rate_y))

            <span class="org-comment-delimiter"># </span><span class="org-comment">Integrate the Superbee flux limited phi gradient to make dphi_dt numerically stable</span>
            <span class="org-variable-name">phi_gradient_xy_limited</span> <span class="org-operator">=</span> calc_phi_gradient(phi_matrix, dphi_dx, dphi_dy, cell_width, cell_height, x, y)
            <span class="org-variable-name">fire_behavior</span>[<span class="org-string">"dphi_dt"</span>] <span class="org-operator">*=</span> np.dot(phi_gradient_xy, phi_gradient_xy_limited) <span class="org-operator">/</span> phi_magnitude_xy_2

        <span class="org-comment-delimiter"># </span><span class="org-comment">Store fire behavior values for later use</span>
        <span class="org-variable-name">fire_behavior_dict</span>[cell_index] <span class="org-operator">=</span> fire_behavior

    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate timestep using the CFL condition</span>
    <span class="org-keyword">if</span> max_spread_rate_x <span class="org-operator">==</span> 0.0:
        <span class="org-keyword">if</span> max_spread_rate_y <span class="org-operator">==</span> 0.0:
            <span class="org-variable-name">dt</span> <span class="org-operator">=</span> max_timestep  <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME:  Don't set stop_time to start_time + dt when no cells are burning</span>
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">dt</span> <span class="org-operator">=</span> <span class="org-builtin">min</span>(max_timestep, max_cells_per_timestep <span class="org-operator">*</span> cell_height <span class="org-operator">/</span> max_spread_rate_y)
    <span class="org-keyword">else</span>:
        <span class="org-keyword">if</span> max_spread_rate_y <span class="org-operator">==</span> 0.0:
            <span class="org-variable-name">dt</span> <span class="org-operator">=</span> <span class="org-builtin">min</span>(max_timestep, max_cells_per_timestep <span class="org-operator">*</span> cell_width <span class="org-operator">/</span> max_spread_rate_x)
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">dt</span> <span class="org-operator">=</span> <span class="org-builtin">min</span>(max_timestep, max_cells_per_timestep <span class="org-operator">*</span> <span class="org-builtin">min</span>(cell_width <span class="org-operator">/</span> max_spread_rate_x,
                                                                cell_height <span class="org-operator">/</span> max_spread_rate_y))

    <span class="org-comment-delimiter"># </span><span class="org-comment">Update the tracked cell values in phi_star_matrix</span>
    <span class="org-keyword">for</span> cell_index <span class="org-keyword">in</span> tracked_cells:
        (<span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>)  <span class="org-operator">=</span> cell_index
        <span class="org-variable-name">dphi_dt</span> <span class="org-operator">=</span> fire_behavior_dict[cell_index][<span class="org-string">"dphi_dt"</span>]
        <span class="org-keyword">if</span> dphi_dt <span class="org-operator">!=</span> 0.0:
            <span class="org-variable-name">phi_star_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>] <span class="org-operator">+=</span> dphi_dt <span class="org-operator">*</span> dt

    <span class="org-comment-delimiter"># </span><span class="org-comment">Compute fire behavior values at time (start_time + dt) and update the output matrices</span>
    <span class="org-variable-name">t1</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>((start_time <span class="org-operator">+</span> dt) <span class="org-operator">//</span> band_duration)
    <span class="org-keyword">for</span> cell_index <span class="org-keyword">in</span> tracked_cells:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Unpack cell_index</span>
        (<span class="org-variable-name">y</span>, <span class="org-variable-name">x</span>) <span class="org-operator">=</span> cell_index

        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate phi gradient on the horizontal plane</span>
        <span class="org-variable-name">phi_gradient_xy_star</span>  <span class="org-operator">=</span> calc_phi_gradient_approx(phi_star_matrix, cell_width, cell_height, x, y)
        <span class="org-variable-name">phi_magnitude_xy_star</span> <span class="org-operator">=</span> vu.vector_magnitude(phi_gradient_xy_star)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the fire behavior normal to the fire front on the slope-tangential plane</span>
        <span class="org-variable-name">fire_behavior_star</span> <span class="org-operator">=</span> burn_cell_toward_phi_gradient(space_time_cubes, (t1, y, x),
                                                           phi_gradient_xy_star, use_wind_limit,
                                                           max_length_to_width_ratio)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Check whether cell has a positive phi magnitude</span>
        <span class="org-keyword">if</span> phi_magnitude_xy_star <span class="org-operator">&gt;</span> 0.0:
            <span class="org-comment-delimiter"># </span><span class="org-comment">Integrate the Superbee flux limited phi gradient to make dphi_dt numerically stable</span>
            <span class="org-variable-name">phi_gradient_xy_star_limited</span> <span class="org-operator">=</span> calc_phi_gradient(phi_star_matrix, <span class="org-operator">*</span>phi_gradient_xy_star,
                                                             cell_width, cell_height, x, y)
            <span class="org-variable-name">fire_behavior_star</span>[<span class="org-string">"dphi_dt"</span>] <span class="org-operator">*=</span> (np.dot(phi_gradient_xy_star, phi_gradient_xy_star_limited) <span class="org-operator">/</span>
                                              (phi_magnitude_xy_star <span class="org-operator">**</span> 2.0))

        <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the new phi value at time (start_time + dt) as phi_next</span>
        <span class="org-variable-name">fire_behavior</span>     <span class="org-operator">=</span> fire_behavior_dict[cell_index]
        <span class="org-variable-name">dphi_dt_estimate1</span> <span class="org-operator">=</span> fire_behavior[<span class="org-string">"dphi_dt"</span>]
        <span class="org-variable-name">dphi_dt_estimate2</span> <span class="org-operator">=</span> fire_behavior_star[<span class="org-string">"dphi_dt"</span>]
        <span class="org-variable-name">dphi_dt_average</span>   <span class="org-operator">=</span> (dphi_dt_estimate1 <span class="org-operator">+</span> dphi_dt_estimate2) <span class="org-operator">/</span> 2.0
        <span class="org-keyword">if</span> dphi_dt_average <span class="org-operator">!=</span> 0.0:
            <span class="org-variable-name">phi</span>      <span class="org-operator">=</span> phi_matrix[y,x]
            <span class="org-variable-name">phi_next</span> <span class="org-operator">=</span> phi <span class="org-operator">+</span> dphi_dt_average <span class="org-operator">*</span> dt

            <span class="org-comment-delimiter"># </span><span class="org-comment">Update the tracked cell values in phi_matrix</span>
            <span class="org-variable-name">phi_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>] <span class="org-operator">=</span> phi_next

            <span class="org-comment-delimiter"># </span><span class="org-comment">Record fire behavior values in the output matrices for cells that are burned in this timestep</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: This records the fire behavior values at time (start_time) and not at the time of arrival.</span>
            <span class="org-keyword">if</span> phi <span class="org-operator">&gt;</span> 0.0 <span class="org-keyword">and</span> phi_next <span class="org-operator">&lt;=</span> 0.0:
                <span class="org-variable-name">fire_type_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]          <span class="org-operator">=</span> fire_type_codes[fire_behavior[<span class="org-string">"fire_type"</span>]]
                <span class="org-variable-name">spread_rate_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]        <span class="org-operator">=</span> fire_behavior[<span class="org-string">"spread_rate"</span>]
                <span class="org-variable-name">spread_direction_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]   <span class="org-operator">=</span> spread_direction_vector_to_angle(fire_behavior[<span class="org-string">"spread_direction"</span>])
                <span class="org-variable-name">fireline_intensity_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>] <span class="org-operator">=</span> fire_behavior[<span class="org-string">"fireline_intensity"</span>]
                <span class="org-variable-name">flame_length_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]       <span class="org-operator">=</span> fire_behavior[<span class="org-string">"flame_length"</span>]
                <span class="org-variable-name">time_of_arrival_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]    <span class="org-operator">=</span> start_time <span class="org-operator">+</span> dt <span class="org-operator">*</span> phi <span class="org-operator">/</span> (phi <span class="org-operator">-</span> phi_next)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Save the new phi_matrix values in phi_star_matrix</span>
    <span class="org-keyword">for</span> (y,x) <span class="org-keyword">in</span> tracked_cells:
        <span class="org-variable-name">phi_star_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>] <span class="org-operator">=</span> phi_matrix[y,x]

    <span class="org-comment-delimiter"># </span><span class="org-comment">Update the sets of frontier cells and tracked cells based on the updated phi matrix</span>
    <span class="org-variable-name">frontier_cells_new</span> <span class="org-operator">=</span> identify_frontier_cells(phi_matrix, tracked_cells)
    <span class="org-variable-name">tracked_cells_new</span>  <span class="org-operator">=</span> update_tracked_cells(tracked_cells, frontier_cells, frontier_cells_new,
                                              buffer_width, phi_matrix.shape)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Return the updated world state</span>
    <span class="org-keyword">return</span> {
        <span class="org-string">"simulation_time"</span>: start_time <span class="org-operator">+</span> dt,
        <span class="org-string">"output_matrices"</span>: output_matrices,
        <span class="org-string">"frontier_cells"</span> : frontier_cells_new,
        <span class="org-string">"tracked_cells"</span>  : tracked_cells_new,
    }


<span class="org-keyword">def</span> <span class="org-function-name">spread_fire_with_phi_field</span>(space_time_cubes, output_matrices, cube_resolution, start_time,
                               max_duration<span class="org-operator">=</span><span class="org-constant">None</span>, use_wind_limit<span class="org-operator">=</span><span class="org-constant">True</span>, max_length_to_width_ratio<span class="org-operator">=</span><span class="org-constant">None</span>,
                               max_cells_per_timestep<span class="org-operator">=</span>0.4, buffer_width<span class="org-operator">=</span>3):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given these inputs:</span>
<span class="org-doc">    - space_time_cubes          :: dictionary of (Lazy)SpaceTimeCube objects with these cell types</span>
<span class="org-doc">      - slope                         :: rise/run</span>
<span class="org-doc">      - aspect                        :: degrees clockwise from North</span>
<span class="org-doc">      - fuel_model                    :: integer index in fm.fuel_model_table</span>
<span class="org-doc">      - canopy_cover                  :: 0-1</span>
<span class="org-doc">      - canopy_height                 :: m</span>
<span class="org-doc">      - canopy_base_height            :: m</span>
<span class="org-doc">      - canopy_bulk_density           :: kg/m^3</span>
<span class="org-doc">      - wind_speed_10m                :: km/hr</span>
<span class="org-doc">      - upwind_direction              :: degrees clockwise from North</span>
<span class="org-doc">      - fuel_moisture_dead_1hr        :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_dead_10hr       :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_dead_100hr      :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_live_herbaceous :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_moisture_live_woody      :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - foliar_moisture               :: kg moisture/kg ovendry weight</span>
<span class="org-doc">      - fuel_spread_adjustment        :: float &gt;= 0.0 (Optional: defaults to 1.0)</span>
<span class="org-doc">      - weather_spread_adjustment     :: float &gt;= 0.0 (Optional: defaults to 1.0)</span>
<span class="org-doc">    - output_matrices           :: dictionary of 2D Numpy arrays whose spatial dimensions match the space_time_cubes</span>
<span class="org-doc">      - phi                           :: 2D float array of values in [-1,1]</span>
<span class="org-doc">      - fire_type                     :: 2D byte array (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)</span>
<span class="org-doc">      - spread_rate                   :: 2D float array (m/min)</span>
<span class="org-doc">      - spread_direction              :: 2D float array (degrees clockwise from North)</span>
<span class="org-doc">      - fireline_intensity            :: 2D float array (kW/m)</span>
<span class="org-doc">      - flame_length                  :: 2D float array (m)</span>
<span class="org-doc">      - time_of_arrival               :: 2D float array (min)</span>
<span class="org-doc">    - cube_resolution           :: tuple with these fields:</span>
<span class="org-doc">      - band_duration                 :: minutes</span>
<span class="org-doc">      - cell_height                   :: meters</span>
<span class="org-doc">      - cell_width                    :: meters</span>
<span class="org-doc">    - start_time                :: minutes (from the start of the space_time_cube's temporal origin)</span>
<span class="org-doc">    - max_duration              :: minutes (Optional)</span>
<span class="org-doc">    - use_wind_limit            :: boolean (Optional)</span>
<span class="org-doc">    - max_length_to_width_ratio :: float &gt; 0.0 (Optional)</span>
<span class="org-doc">    - max_cells_per_timestep    :: max number of cells the fire front can travel in one timestep (Optional)</span>
<span class="org-doc">    - buffer_width              :: Chebyshev distance from frontier cells to include in tracked cells (Optional)</span>

<span class="org-doc">    return a dictionary with these keys:</span>
<span class="org-doc">    - stop_time            :: minutes</span>
<span class="org-doc">    - stop_condition       :: "max duration reached" or "no burnable cells"</span>
<span class="org-doc">    - output_matrices      :: dictionary of 2D Numpy arrays whose spatial dimensions match the space_time_cubes</span>
<span class="org-doc">      - phi                   :: 2D float array of values in [-1,1]</span>
<span class="org-doc">      - fire_type             :: 2D byte array (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)</span>
<span class="org-doc">      - spread_rate           :: 2D float array (m/min)</span>
<span class="org-doc">      - spread_direction      :: 2D float array (degrees clockwise from North)</span>
<span class="org-doc">      - fireline_intensity    :: 2D float array (kW/m)</span>
<span class="org-doc">      - flame_length          :: 2D float array (m)</span>
<span class="org-doc">      - time_of_arrival       :: 2D float array (min)</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Extract simulation dimensions</span>
    (<span class="org-variable-name">bands</span>, <span class="org-variable-name">rows</span>, <span class="org-variable-name">cols</span>) <span class="org-operator">=</span> space_time_cubes[<span class="org-string">"slope"</span>].shape
    <span class="org-variable-name">band_duration</span>       <span class="org-operator">=</span> cube_resolution[0]
    <span class="org-variable-name">cube_duration</span>       <span class="org-operator">=</span> bands <span class="org-operator">*</span> band_duration

    <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that space_time_cubes and output_matrices have the same spatial resolution</span>
    <span class="org-keyword">for</span> layer <span class="org-keyword">in</span> output_matrices:
        <span class="org-keyword">if</span> output_matrices[layer].shape <span class="org-operator">!=</span> (rows, cols):
            <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The space_time_cubes and output_matrices must share the same spatial resolution."</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the max stop time</span>
    <span class="org-variable-name">max_stop_time</span> <span class="org-operator">=</span> start_time <span class="org-operator">+</span> max_duration <span class="org-keyword">if</span> max_duration <span class="org-keyword">else</span> cube_duration

    <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that start_time does not exceed the cube_duration</span>
    <span class="org-keyword">if</span> start_time <span class="org-operator">&gt;</span> cube_duration:
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The start_time exceeds the temporal limit of the space_time_cubes."</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that the max_stop_time does not exceed the cube_duration</span>
    <span class="org-keyword">if</span> max_stop_time <span class="org-operator">&gt;</span> cube_duration:
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The start_time + max_duration exceeds the temporal limit of the space_time_cubes."</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Identify the sets of frontier cells and tracked cells based on the phi matrix</span>
    <span class="org-variable-name">phi_matrix</span>     <span class="org-operator">=</span> output_matrices[<span class="org-string">"phi"</span>]
    <span class="org-variable-name">frontier_cells</span> <span class="org-operator">=</span> identify_frontier_cells(phi_matrix)
    <span class="org-variable-name">tracked_cells</span>  <span class="org-operator">=</span> identify_tracked_cells(frontier_cells, buffer_width, (rows, cols))

    <span class="org-comment-delimiter"># </span><span class="org-comment">Make a copy of the phi matrix to use for intermediate calculations in each timestep</span>
    <span class="org-variable-name">output_matrices</span>[<span class="org-string">"phi_star"</span>] <span class="org-operator">=</span> np.copy(phi_matrix)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Spread the fire until an exit condition is reached</span>
    <span class="org-variable-name">simulation_time</span> <span class="org-operator">=</span> start_time
    <span class="org-keyword">while</span>(simulation_time <span class="org-operator">&lt;</span> max_stop_time <span class="org-keyword">and</span> <span class="org-builtin">len</span>(tracked_cells) <span class="org-operator">&gt;</span> 0):
        <span class="org-comment-delimiter"># </span><span class="org-comment">Compute max_timestep based on the remaining time in the simulation</span>
        <span class="org-variable-name">max_timestep</span> <span class="org-operator">=</span> max_stop_time <span class="org-operator">-</span> simulation_time

        <span class="org-comment-delimiter"># </span><span class="org-comment">Spread fire one timestep</span>
        <span class="org-variable-name">results</span> <span class="org-operator">=</span> spread_fire_one_timestep(space_time_cubes, output_matrices, frontier_cells, tracked_cells,
                                           cube_resolution, simulation_time, max_timestep, use_wind_limit,
                                           max_length_to_width_ratio, max_cells_per_timestep, buffer_width)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Reset spread inputs</span>
        <span class="org-variable-name">simulation_time</span> <span class="org-operator">=</span> results[<span class="org-string">"simulation_time"</span>]
        <span class="org-variable-name">output_matrices</span> <span class="org-operator">=</span> results[<span class="org-string">"output_matrices"</span>]
        <span class="org-variable-name">frontier_cells</span>  <span class="org-operator">=</span> results[<span class="org-string">"frontier_cells"</span>]
        <span class="org-variable-name">tracked_cells</span>   <span class="org-operator">=</span> results[<span class="org-string">"tracked_cells"</span>]

    <span class="org-comment-delimiter"># </span><span class="org-comment">Remove the temporary copy of the phi matrix from output_matrices</span>
    output_matrices.pop(<span class="org-string">"phi_star"</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Return the final simulation results</span>
    <span class="org-keyword">return</span> {
        <span class="org-string">"stop_time"</span>      : simulation_time,
        <span class="org-string">"stop_condition"</span> : <span class="org-string">"max duration reached"</span> <span class="org-keyword">if</span> <span class="org-builtin">len</span>(tracked_cells) <span class="org-operator">&gt;</span> 0 <span class="org-keyword">else</span> <span class="org-string">"no burnable cells"</span>,
        <span class="org-string">"output_matrices"</span>: output_matrices,
    }
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-For Users" class="outline-3">
<h3 id="For Users"><span class="section-number-3">9.2.</span> For Users</h3>
<div class="outline-text-3" id="text-For Users">
</div>
<div id="outline-container-How to Spread a Fire from a Point Ignition" class="outline-4">
<h4 id="How to Spread a Fire from a Point Ignition"><span class="section-number-4">9.2.1.</span> How to Spread a Fire from a Point Ignition</h4>
<div class="outline-text-4" id="text-How to Spread a Fire from a Point Ignition">
<div class="org-src-container">
<pre class="src src-python" id="run-spread-fire-with-phi-field"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">import</span> pyretechnics.eulerian_level_set <span class="org-keyword">as</span> els
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (
    240, <span class="org-comment-delimiter"># </span><span class="org-comment">bands: 10 days @ 1 hour/band</span>
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">rows:  3 km @ 30 meters/row</span>
    100, <span class="org-comment-delimiter"># </span><span class="org-comment">cols:  3 km @ 30 meters/col</span>
)

<span class="org-variable-name">grid_shape</span> <span class="org-operator">=</span> cube_shape[1:]

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube resolution</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">cube_resolution</span> <span class="org-operator">=</span> (
    60, <span class="org-comment-delimiter"># </span><span class="org-comment">band_duration: minutes</span>
    30, <span class="org-comment-delimiter"># </span><span class="org-comment">cell_height:   meters</span>
    30, <span class="org-comment-delimiter"># </span><span class="org-comment">cell_width:    meters</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Create an input dictionary of SpaceTimeCubes (using constant data for this example)</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">space_time_cubes</span> <span class="org-operator">=</span> {
    <span class="org-string">"slope"</span>                        : SpaceTimeCube(cube_shape, 0.8),   <span class="org-comment-delimiter"># </span><span class="org-comment">rise/run</span>
    <span class="org-string">"aspect"</span>                       : SpaceTimeCube(cube_shape, 225.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_model"</span>                   : SpaceTimeCube(cube_shape, 101),   <span class="org-comment-delimiter"># </span><span class="org-comment">integer index in fm.fuel_model_table</span>
    <span class="org-string">"canopy_cover"</span>                 : SpaceTimeCube(cube_shape, 0.6),   <span class="org-comment-delimiter"># </span><span class="org-comment">0-1</span>
    <span class="org-string">"canopy_height"</span>                : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_base_height"</span>           : SpaceTimeCube(cube_shape, 3.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
    <span class="org-string">"canopy_bulk_density"</span>          : SpaceTimeCube(cube_shape, 0.3),   <span class="org-comment-delimiter"># </span><span class="org-comment">kg/m^3</span>
    <span class="org-string">"wind_speed_10m"</span>               : SpaceTimeCube(cube_shape, 30.0),  <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-string">"upwind_direction"</span>             : SpaceTimeCube(cube_shape, 180.0), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_moisture_dead_1hr"</span>       : SpaceTimeCube(cube_shape, 0.05),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_10hr"</span>      : SpaceTimeCube(cube_shape, 0.10),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_100hr"</span>     : SpaceTimeCube(cube_shape, 0.15),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_herbaceous"</span>: SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_woody"</span>     : SpaceTimeCube(cube_shape, 0.60),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"foliar_moisture"</span>              : SpaceTimeCube(cube_shape, 0.90),  <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_spread_adjustment"</span>       : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
    <span class="org-string">"weather_spread_adjustment"</span>    : SpaceTimeCube(cube_shape, 1.0),   <span class="org-comment-delimiter"># </span><span class="org-comment">float &gt;= 0.0 (Optional: defaults to 1.0)</span>
}

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Create an output dictionary of 2D Numpy arrays</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">output_matrices</span> <span class="org-operator">=</span> {
    <span class="org-string">"phi"</span>               : np.ones(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>),       <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array of values in [-1,1]</span>
    <span class="org-string">"fire_type"</span>         : np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"uint8"</span>),        <span class="org-comment-delimiter"># </span><span class="org-comment">2D byte array (0-3)</span>
    <span class="org-string">"spread_rate"</span>       : np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>),      <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array (m/min)</span>
    <span class="org-string">"spread_direction"</span>  : np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>),      <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array (degrees clockwise from North)</span>
    <span class="org-string">"fireline_intensity"</span>: np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>),      <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array (kW/m)</span>
    <span class="org-string">"flame_length"</span>      : np.zeros(grid_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>),      <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array (m)</span>
    <span class="org-string">"time_of_arrival"</span>   : np.full(grid_shape, <span class="org-operator">-</span>1.0, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>), <span class="org-comment-delimiter"># </span><span class="org-comment">2D float array (min)</span>
}

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Set the start time, max duration, and initially ignited cell</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Day 2 @ 10:30am</span>
<span class="org-variable-name">start_time</span> <span class="org-operator">=</span> 2070  <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">8 hours</span>
<span class="org-variable-name">max_duration</span> <span class="org-operator">=</span> 480 <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Burn initially ignited cell into the phi matrix by setting it to -1.0</span>
output_matrices[<span class="org-string">"phi"</span>][50,50] <span class="org-operator">=</span> <span class="org-operator">-</span>1.0

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Spread fire from the start time for the max duration</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-variable-name">fire_spread_results</span> <span class="org-operator">=</span> els.spread_fire_with_phi_field(space_time_cubes, output_matrices,
                                                     cube_resolution, start_time, max_duration)

<span class="org-variable-name">stop_time</span>       <span class="org-operator">=</span> fire_spread_results[<span class="org-string">"stop_time"</span>]       <span class="org-comment-delimiter"># </span><span class="org-comment">minutes</span>
<span class="org-variable-name">stop_condition</span>  <span class="org-operator">=</span> fire_spread_results[<span class="org-string">"stop_condition"</span>]  <span class="org-comment-delimiter"># </span><span class="org-comment">"max duration reached" or "no burnable cells"</span>
<span class="org-variable-name">output_matrices</span> <span class="org-operator">=</span> fire_spread_results[<span class="org-string">"output_matrices"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">updated 2D arrays (mutated from inputs)</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Display summary statistics of our fire spread results</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">============================================================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Used as a filter in get_array_stats below</span>
<span class="org-variable-name">burned_cells</span> <span class="org-operator">=</span> output_matrices[<span class="org-string">"fire_type"</span>] <span class="org-operator">&gt;</span> 0

<span class="org-keyword">def</span> <span class="org-function-name">get_array_stats</span>(array):
    <span class="org-variable-name">array_values_in_burn_scar</span> <span class="org-operator">=</span> array[burned_cells]
    <span class="org-keyword">return</span> {
        <span class="org-string">"Min"</span>  : np.<span class="org-builtin">min</span>(array_values_in_burn_scar),
        <span class="org-string">"Max"</span>  : np.<span class="org-builtin">max</span>(array_values_in_burn_scar),
        <span class="org-string">"Mean"</span> : np.mean(array_values_in_burn_scar),
        <span class="org-string">"Stdev"</span>: np.std(array_values_in_burn_scar),
    }

<span class="org-builtin">print</span>(<span class="org-string">"Fire Behavior from Day 2 @ 10:30am - Day 2 @ 6:30pm Spreading from Coordinate (50,50)</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-operator">+</span> <span class="org-string">"="</span> <span class="org-operator">*</span> 100)

<span class="org-builtin">print</span>(<span class="org-string">"Stop Time: "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(stop_time) <span class="org-operator">+</span> <span class="org-string">" (minutes)"</span>)
<span class="org-builtin">print</span>(<span class="org-string">"Stop Condition: "</span> <span class="org-operator">+</span> stop_condition)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Phi (phi &lt;= 0: burned, phi &gt; 0: unburned"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"phi"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Fire Type (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"fire_type"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Spread Rate (m/min)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"spread_rate"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Spread Direction (degrees clockwise from North)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"spread_direction"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Fireline Intensity (kW/m)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"fireline_intensity"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Flame Length (meters)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"flame_length"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Time of Arrival (minutes)"</span>)
pprint(get_array_stats(output_matrices[<span class="org-string">"time_of_arrival"</span>]), sort_dicts<span class="org-operator">=</span><span class="org-constant">False</span>)
</pre>
</div>

<pre class="example" id="org789f62a">
Fire Behavior from Day 2 @ 10:30am - Day 2 @ 6:30pm Spreading from Coordinate (50,50)
====================================================================================================
Stop Time: 2550.0 (minutes)
Stop Condition: max duration reached

Phi (phi &lt;= 0: burned, phi &gt; 0: unburned
{'Min': -0.92403376,
 'Max': -0.027144847,
 'Mean': -0.74992913,
 'Stdev': 0.21444972}

Fire Type (0=unburned, 1=surface, 2=passive_crown, 3=active_crown)
{'Min': 1, 'Max': 1, 'Mean': 1.0, 'Stdev': 0.0}

Spread Rate (m/min)
{'Min': 0.16077071, 'Max': 2.2964673, 'Mean': 1.2123194, 'Stdev': 0.6345803}

Spread Direction (degrees clockwise from North)
{'Min': 0.06370052, 'Max': 359.1836, 'Mean': 191.5278, 'Stdev': 117.83867}

Fireline Intensity (kW/m)
{'Min': 2.277232, 'Max': 32.52824, 'Mean': 17.171862, 'Stdev': 8.988494}

Flame Length (meters)
{'Min': 0.11312101, 'Max': 0.38439327, 'Mean': 0.2753003, 'Stdev': 0.07360656}

Time of Arrival (minutes)
{'Min': 2081.8513, 'Max': 2548.0952, 'Mean': 2385.5647, 'Stdev': 116.835556}
</pre>
</div>
</div>
<div id="outline-container-How to Create Images of Fire Behavior Outputs" class="outline-4">
<h4 id="How to Create Images of Fire Behavior Outputs"><span class="section-number-4">9.2.2.</span> How to Create Images of Fire Behavior Outputs</h4>
<div class="outline-text-4" id="text-How to Create Images of Fire Behavior Outputs">
<div class="org-src-container">
<pre class="src src-python" id="save-matrix-as-figure"><span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np


<span class="org-keyword">def</span> <span class="org-function-name">save_matrix_as_heatmap</span>(matrix, colors, units, title, filename, vmin<span class="org-operator">=</span><span class="org-constant">None</span>, vmax<span class="org-operator">=</span><span class="org-constant">None</span>, ticks<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-variable-name">image</span>    <span class="org-operator">=</span> plt.imshow(matrix, origin<span class="org-operator">=</span><span class="org-string">"lower"</span>, cmap<span class="org-operator">=</span>colors, vmin<span class="org-operator">=</span>vmin, vmax<span class="org-operator">=</span>vmax)
    <span class="org-variable-name">colorbar</span> <span class="org-operator">=</span> plt.colorbar(image, orientation<span class="org-operator">=</span><span class="org-string">"vertical"</span>, ticks<span class="org-operator">=</span>ticks)
    colorbar.set_label(units)
    plt.title(title)
    plt.savefig(filename)
    plt.close(<span class="org-string">"all"</span>)


<span class="org-keyword">def</span> <span class="org-function-name">save_matrix_as_contours</span>(matrix, title, filename, levels<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-variable-name">fig</span>, <span class="org-variable-name">ax</span> <span class="org-operator">=</span> plt.subplots()
    <span class="org-variable-name">cs</span>      <span class="org-operator">=</span> ax.contour(matrix, levels<span class="org-operator">=</span>levels)
    ax.clabel(cs, inline<span class="org-operator">=</span><span class="org-constant">True</span>, fontsize<span class="org-operator">=</span>10)
    ax.set_aspect(<span class="org-string">'equal'</span>, <span class="org-string">'box'</span>)
    ax.set_title(title)
    plt.savefig(filename)
    plt.close(<span class="org-string">"all"</span>)


<span class="org-comment-delimiter"># </span><span class="org-comment">See https://matplotlib.org/stable/gallery/color/colormap_reference.html for the available options for "colors"</span>
<span class="org-variable-name">heatmap_configs</span> <span class="org-operator">=</span> [
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"phi"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"plasma"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"phi &lt;= 0: burned, phi &gt; 0: unburned"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Phi"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"../doc/pics/els_phi.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"fire_type"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"viridis"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"0=unburned, 1=surface, 2=passive_crown, 3=active_crown"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Fire Type"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"../doc/pics/els_fire_type.png"</span>,
        <span class="org-string">"vmin"</span>    : 0,
        <span class="org-string">"vmax"</span>    : 3,
        <span class="org-string">"ticks"</span>   : [0,1,2,3],
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"spread_rate"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"m/min"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Spread Rate"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"../doc/pics/els_spread_rate.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"spread_direction"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"viridis"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"degrees clockwise from North"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Spread Direction"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"../doc/pics/els_spread_direction.png"</span>,
        <span class="org-string">"vmin"</span>    : 0,
        <span class="org-string">"vmax"</span>    : 360,
        <span class="org-string">"ticks"</span>   : [0,45,90,135,180,225,270,315,360]
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"fireline_intensity"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"kW/m"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Fireline Intensity"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"../doc/pics/els_fireline_intensity.png"</span>,
    },
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"flame_length"</span>],
        <span class="org-string">"colors"</span>  : <span class="org-string">"hot"</span>,
        <span class="org-string">"units"</span>   : <span class="org-string">"meters"</span>,
        <span class="org-string">"title"</span>   : <span class="org-string">"Flame Length"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"../doc/pics/els_flame_length.png"</span>,
    },
]


<span class="org-variable-name">contour_configs</span> <span class="org-operator">=</span> [
    {
        <span class="org-string">"matrix"</span>  : output_matrices[<span class="org-string">"time_of_arrival"</span>],
        <span class="org-string">"title"</span>   : <span class="org-string">"Time of Arrival"</span>,
        <span class="org-string">"filename"</span>: <span class="org-string">"../doc/pics/els_time_of_arrival.png"</span>,
        <span class="org-string">"levels"</span>  : <span class="org-builtin">int</span>(start_time) <span class="org-operator">+</span> np.asarray(<span class="org-builtin">range</span>(0, <span class="org-builtin">int</span>(max_duration) <span class="org-operator">+</span> 1, 60)),
    },
]


<span class="org-keyword">for</span> heatmap_config <span class="org-keyword">in</span> heatmap_configs:
    save_matrix_as_heatmap(<span class="org-operator">**</span>heatmap_config)


<span class="org-keyword">for</span> contour_config <span class="org-keyword">in</span> contour_configs:
    save_matrix_as_contours(<span class="org-operator">**</span>contour_config)
</pre>
</div>

<table id="fire-behavior-matplotlib-heatmaps">
<caption class="t-above"><span class="table-number">Table 3:</span> Fire behavior attributes after 8 hours of spread</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="../doc/pics/els_phi.png" alt="els_phi.png"></td>
<td class="org-left"><img src="../doc/pics/els_fire_type.png" alt="els_fire_type.png"></td>
</tr>

<tr>
<td class="org-left"><img src="../doc/pics/els_spread_rate.png" alt="els_spread_rate.png"></td>
<td class="org-left"><img src="../doc/pics/els_spread_direction.png" alt="els_spread_direction.png"></td>
</tr>

<tr>
<td class="org-left"><img src="../doc/pics/els_fireline_intensity.png" alt="els_fireline_intensity.png"></td>
<td class="org-left"><img src="../doc/pics/els_flame_length.png" alt="els_flame_length.png"></td>
</tr>
</tbody>
</table>


<div id="time-of-arrival-matplotlib-countours" class="figure">
<p><img src="../doc/pics/els_time_of_arrival.png" alt="els_time_of_arrival.png">
</p>
<p><span class="figure-number">Figure 1: </span>Time of arrival with hourly perimeters</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-[WIP] Spot Fire Equations (pyretechnics.spot_fire)" class="outline-2">
<h2 id="[WIP] Spot Fire Equations (pyretechnics.spot_fire)"><span class="section-number-2">10.</span> [WIP] Spot Fire Equations (pyretechnics.spot_fire)</h2>
<div class="outline-text-2" id="text-[WIP] Spot Fire Equations (pyretechnics.spot_fire)">
</div>
<div id="outline-container-For Developers" class="outline-3">
<h3 id="For Developers"><span class="section-number-3">10.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-For Developers">
</div>
</div>
<div id="outline-container-For Users" class="outline-3">
<h3 id="For Users"><span class="section-number-3">10.2.</span> For Users</h3>
<div class="outline-text-3" id="text-For Users">
</div>
</div>
</div>
<div id="outline-container-[WIP] Fire Suppression Algorithms (pyretechnics.suppression)" class="outline-2">
<h2 id="[WIP] Fire Suppression Algorithms (pyretechnics.suppression)"><span class="section-number-2">11.</span> [WIP] Fire Suppression Algorithms (pyretechnics.suppression)</h2>
<div class="outline-text-2" id="text-[WIP] Fire Suppression Algorithms (pyretechnics.suppression)">
</div>
<div id="outline-container-For Developers" class="outline-3">
<h3 id="For Developers"><span class="section-number-3">11.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-For Developers">
</div>
</div>
<div id="outline-container-For Users" class="outline-3">
<h3 id="For Users"><span class="section-number-3">11.2.</span> For Users</h3>
<div class="outline-text-3" id="text-For Users">
</div>
</div>
</div>
<div id="outline-container-[WIP] Urban Spread Algorithms" class="outline-2">
<h2 id="[WIP] Urban Spread Algorithms"><span class="section-number-2">12.</span> [WIP] Urban Spread Algorithms</h2>
<div class="outline-text-2" id="text-[WIP] Urban Spread Algorithms">
</div>
<div id="outline-container-For Developers" class="outline-3">
<h3 id="For Developers"><span class="section-number-3">12.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-For Developers">
</div>
</div>
<div id="outline-container-For Users" class="outline-3">
<h3 id="For Users"><span class="section-number-3">12.2.</span> For Users</h3>
<div class="outline-text-3" id="text-For Users">
</div>
</div>
</div>
<div id="outline-container-[WIP] Fire Spread API" class="outline-2">
<h2 id="[WIP] Fire Spread API"><span class="section-number-2">13.</span> [WIP] Fire Spread API</h2>
<div class="outline-text-2" id="text-[WIP] Fire Spread API">
<p>
Pyretechnics provides two main functions for simulating fire behavior over a region of space-time:
</p>
</div>
<div id="outline-container-grow_fire" class="outline-3">
<h3 id="grow_fire"><span class="section-number-3">13.1.</span> grow_fire</h3>
<div class="outline-text-3" id="text-grow_fire">
<p>
Simulates the growth of a fire over space and time starting from one
or more actively burning cells. Suppression effects may be optionally
applied, and several different stop conditions may be specified. A
random seed may be optionally provided to ensure deterministically
reproducible runs, despite the presence of stochastic calculations
within the fire spread algorithm.
</p>
</div>
<div id="outline-container-Inputs" class="outline-4">
<h4 id="Inputs"><span class="section-number-4">13.1.1.</span> Inputs</h4>
<div class="outline-text-4" id="text-Inputs">
<p>
The <code>grow_fire</code> function takes a single <code>world_state</code> dictionary as input with these fields:
</p>

<dl class="org-dl">
<dt>simulation_clock</dt><dd>a float specifying the number of minutes from the start time of the simulated space-time cube to begin the simulation</dd>

<dt>config_dict</dt><dd><p>
a dictionary of parameter names to their values with the following types:
</p>

<p>
<b>TODO</b>: Determine whether rectangular cells will work for the GridFire and ELMFIRE spread algorithms. If not, eliminate this degree of freedom from the API.
<b>TODO</b>: Add interpolation options to the gridded data source class
<b>TODO</b>: simulation_north_angle may be dropped if we require inputs to use North-up projections for both fuels and weather
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Parameter Name</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Units</th>
<th scope="col" class="org-left">Optional?</th>
<th scope="col" class="org-left">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">simulation_shape</td>
<td class="org-left">Tuple (int, int, int)</td>
<td class="org-left">(num timesteps, num rows, num cols)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">simulation_resolution</td>
<td class="org-left">Tuple (float, float, float)</td>
<td class="org-left">(minutes per timestep, meters per row, meters per column)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">simulation_north_angle</td>
<td class="org-left">float</td>
<td class="org-left">degrees clockwise from the top of the circle [0,360)</td>
<td class="org-left">Yes</td>
<td class="org-left">0.0</td>
</tr>

<tr>
<td class="org-left">simulation_stop_condition</td>
<td class="org-left">Dictionary {string: float}</td>
<td class="org-left">either {'max_burn_duration': minutes} or {'max_burned_area': square_meters}</td>
<td class="org-left">Yes</td>
<td class="org-left">None</td>
</tr>

<tr>
<td class="org-left">random_seed</td>
<td class="org-left">number or string</td>
<td class="org-left">the seed value to initialize the random number generator</td>
<td class="org-left">Yes</td>
<td class="org-left">None</td>
</tr>

<tr>
<td class="org-left">overwrite_outputs</td>
<td class="org-left">boolean</td>
<td class="org-left">True or False, whether to mutate or copy the Numpy arrays provided in <b>output_layer_dict</b></td>
<td class="org-left">Yes</td>
<td class="org-left">False</td>
</tr>

<tr>
<td class="org-left">alpha_suppression</td>
<td class="org-left">Dictionary {string: float}</td>
<td class="org-left">parameters for the <b>alpha</b> suppression algorithm (see table below)</td>
<td class="org-left">Yes</td>
<td class="org-left">None</td>
</tr>

<tr>
<td class="org-left">sdi_suppression</td>
<td class="org-left">Dictionary {string: float}</td>
<td class="org-left">parameters for the <b>sdi</b> suppression algorithm (see table below)</td>
<td class="org-left">Yes</td>
<td class="org-left">None</td>
</tr>

<tr>
<td class="org-left">spotting</td>
<td class="org-left">Dictionary {string: float}</td>
<td class="org-left">parameters for the spotting algorithm (see table below)</td>
<td class="org-left">Yes</td>
<td class="org-left">None</td>
</tr>
</tbody>
</table>

<dl class="org-dl">
<dt>alpha_suppression</dt><dd>a dictionary of parameter names to their values for the <b>alpha</b> suppression algorithm:</dd>
</dl>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Parameter Name</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Units</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">suppression_timestep</td>
<td class="org-left">float</td>
<td class="org-left">minutes between suppression events</td>
</tr>

<tr>
<td class="org-left">suppression_coefficient</td>
<td class="org-left">float</td>
<td class="org-left">unitless</td>
</tr>
</tbody>
</table>

<dl class="org-dl">
<dt>sdi_suppression</dt><dd>a dictionary of parameter names to their values for the <b>sdi</b> suppression algorithm:</dd>
</dl>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Parameter Name</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Units</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">suppression_timestep</td>
<td class="org-left">float</td>
<td class="org-left">minutes between suppression events</td>
</tr>

<tr>
<td class="org-left">sdi_sensitivity_to_difficulty</td>
<td class="org-left">float</td>
<td class="org-left">unitless</td>
</tr>

<tr>
<td class="org-left">sdi_containment_overwhelming_area_growth_rate</td>
<td class="org-left">float</td>
<td class="org-left">hectares/day</td>
</tr>

<tr>
<td class="org-left">sdi_reference_suppression_speed</td>
<td class="org-left">float</td>
<td class="org-left">percent/day</td>
</tr>
</tbody>
</table>

<dl class="org-dl">
<dt>spotting</dt><dd>a dictionary of parameter names to their values for the spotting algorithm:</dd>
</dl>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Parameter Name</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Units</th>
<th scope="col" class="org-left">Fire Model</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">firebrands_per_cell</td>
<td class="org-left">int</td>
<td class="org-left">number of embers to cast from each spotting cell</td>
<td class="org-left">GridFire</td>
</tr>

<tr>
<td class="org-left">decay_constant</td>
<td class="org-left">float</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">GridFire</td>
</tr>

<tr>
<td class="org-left">mean_distance</td>
<td class="org-left">float</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">GridFire</td>
</tr>

<tr>
<td class="org-left">flin_exp</td>
<td class="org-left">float</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">GridFire</td>
</tr>

<tr>
<td class="org-left">ws_exp</td>
<td class="org-left">float</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">GridFire</td>
</tr>

<tr>
<td class="org-left">normalized_distance_variance</td>
<td class="org-left">float</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">GridFire</td>
</tr>

<tr>
<td class="org-left">delta_y_sigma</td>
<td class="org-left">float</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">GridFire</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">ember_gr</td>
<td class="org-left">int</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">pign</td>
<td class="org-left">float</td>
<td class="org-left">percent [0-100]</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">pign_max</td>
<td class="org-left">float</td>
<td class="org-left">percent [0-100]</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">pign_min</td>
<td class="org-left">float</td>
<td class="org-left">percent [0-100]</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">tau_embergen</td>
<td class="org-left">float</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">use_umd_spotting_model</td>
<td class="org-left">boolean</td>
<td class="org-left">True or False</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">p_eps</td>
<td class="org-left">float</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">use_physical_spotting_duration</td>
<td class="org-left">boolean</td>
<td class="org-left">True or False</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">use_physical_ember_number</td>
<td class="org-left">boolean</td>
<td class="org-left">True or False</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">ember_sampling_factor</td>
<td class="org-left">float</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">use_superseded_spotting</td>
<td class="org-left">boolean</td>
<td class="org-left">True or False</td>
<td class="org-left">ELMFIRE</td>
</tr>
</tbody>
</table></dd>

<dt>input_layer_dict</dt><dd><p>
a dictionary of layer names to either 2-arity (2D) or 3-arity (3D) functions for accessing the numeric values at each <code>(y,x)</code> or <code>(z,y,x)</code> coordinate in the simulated space-time cube:
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Layer Name</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Units</th>
<th scope="col" class="org-left">Optional?</th>
<th scope="col" class="org-right">Arity</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">elevation</td>
<td class="org-left">float32</td>
<td class="org-left">meters above sea level [0-8850]</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">slope</td>
<td class="org-left">float32</td>
<td class="org-left">meters rise / meters run [0-4]</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">aspect</td>
<td class="org-left">int16</td>
<td class="org-left">degrees clockwise from North [0-360)</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">fuel_model</td>
<td class="org-left">int16</td>
<td class="org-left">integer classes [1-204]</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">canopy_cover</td>
<td class="org-left">float32</td>
<td class="org-left">canopy area / total area [0-0.95]</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">canopy_height</td>
<td class="org-left">float32</td>
<td class="org-left">meters  [0-51]</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">canopy_base_height</td>
<td class="org-left">float32</td>
<td class="org-left">meters  [0-10]</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">canopy_bulk_density</td>
<td class="org-left">float32</td>
<td class="org-left">kilograms/meters^3 [0-0.45]</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">fuel_spread_adjustment</td>
<td class="org-left">float</td>
<td class="org-left">real number &gt;= 0.0 (1.0 means no adjustment)</td>
<td class="org-left">Yes</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">suppression_difficulty_index</td>
<td class="org-left">float</td>
<td class="org-left">integer &gt;= 0  (TODO: What is the correct value range?)</td>
<td class="org-left">Yes</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">surface_spotting_fireline_intensity</td>
<td class="org-left">float</td>
<td class="org-left">kilowatts/meter</td>
<td class="org-left">Yes</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">surface_spotting_percent (TODO: min, max?)</td>
<td class="org-left">float</td>
<td class="org-left">percent [0-1]</td>
<td class="org-left">Yes</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">crown_spotting_percent   (TODO: min, max?)</td>
<td class="org-left">float</td>
<td class="org-left">percent [0-1]</td>
<td class="org-left">Yes</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">temperature</td>
<td class="org-left">float</td>
<td class="org-left">degrees Celsius</td>
<td class="org-left">Yes</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">relative_humidity</td>
<td class="org-left">float</td>
<td class="org-left">percent [0-1+]</td>
<td class="org-left">Yes</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">wind_speed_10m</td>
<td class="org-left">float</td>
<td class="org-left">km/hr</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">upwind_direction</td>
<td class="org-left">int16</td>
<td class="org-left">degrees clockwise from North [0-360)</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">fuel_moisture_dead_1hr</td>
<td class="org-left">float</td>
<td class="org-left">ratio [0-1+] grams moisture/grams ovendry weight</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">fuel_moisture_dead_10hr</td>
<td class="org-left">float</td>
<td class="org-left">ratio [0-1+] grams moisture/grams ovendry weight</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">fuel_moisture_dead_100hr</td>
<td class="org-left">float</td>
<td class="org-left">ratio [0-1+] grams moisture/grams ovendry weight</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">fuel_moisture_live_herbaceous</td>
<td class="org-left">float</td>
<td class="org-left">ratio [0-1+] grams moisture/grams ovendry weight</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">fuel_moisture_live_woody</td>
<td class="org-left">float</td>
<td class="org-left">ratio [0-1+] grams moisture/grams ovendry weight</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">foliar_moisture</td>
<td class="org-left">float</td>
<td class="org-left">ratio [0-1+] grams moisture/grams ovendry weight</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">weather_spread_adjustment</td>
<td class="org-left">float</td>
<td class="org-left">real number &gt;= 0.0 (1.0 means no adjustment)</td>
<td class="org-left">Yes</td>
<td class="org-right">3</td>
</tr>
</tbody>
</table></dd>

<dt>output_layer_dict</dt><dd><p>
an <b>optional</b> dictionary of layer names to 2D Numpy arrays with the following units to pre-populate the simulation output arrays:
<b>TODO</b> Consider whether some of these layers should be kept as internal state and not returned to the user.
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Parameter Name</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Units</th>
<th scope="col" class="org-left">Optional?</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">eulerian_level_set_phi_field</td>
<td class="org-left">float16</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">time_of_arrival</td>
<td class="org-left">float32</td>
<td class="org-left">minutes from the start time of the simulated space-time cube</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">max_surface_spread_direction</td>
<td class="org-left">float16</td>
<td class="org-left">degrees clockwise from North</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">max_crown_spread_direction</td>
<td class="org-left">float16</td>
<td class="org-left">degrees clockwise from North</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">perimeter_spread_direction</td>
<td class="org-left">float16</td>
<td class="org-left">degrees clockwise from North</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">max_surface_spread_rate</td>
<td class="org-left">float16</td>
<td class="org-left">meters/second</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">max_crown_spread_rate</td>
<td class="org-left">float16</td>
<td class="org-left">meters/second</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">perimeter_spread_rate</td>
<td class="org-left">float16</td>
<td class="org-left">meters/second</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">surface_eccentricity</td>
<td class="org-left">float16</td>
<td class="org-left">dimensionless (0: circular fire, &gt;0: elliptical fire)</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">crown_eccentricity</td>
<td class="org-left">float16</td>
<td class="org-left">dimensionless (0: circular fire, &gt;0: elliptical fire)</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">max_surface_fireline_intensity</td>
<td class="org-left">float32</td>
<td class="org-left">kilowatts/meter</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">max_crown_fireline_intensity</td>
<td class="org-left">float32</td>
<td class="org-left">kilowatts/meter</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">perimeter_fireline_intensity</td>
<td class="org-left">float32</td>
<td class="org-left">kilowatts/meter</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">max_surface_flame_length</td>
<td class="org-left">float16</td>
<td class="org-left">meters</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">max_crown_flame_length</td>
<td class="org-left">float16</td>
<td class="org-left">meters</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">perimeter_flame_length</td>
<td class="org-left">float16</td>
<td class="org-left">meters</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">fire_type</td>
<td class="org-left">uint8</td>
<td class="org-left">0 = unburned, 1 = surface, 2 = passive_crown, 3 = active_crown</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">ember_count</td>
<td class="org-left">uint32</td>
<td class="org-left">number of embers landing in each cell</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">ember_ignition</td>
<td class="org-left">bool8</td>
<td class="org-left">True for cells ignited by embers, False otherwise</td>
<td class="org-left">Yes</td>
</tr>
</tbody>
</table></dd>

<dt>ignited_cells_set</dt><dd>set of cells that are actively burning at the simulation start time, specified as 3D coordinates <code>(z,y,x)</code> in the simulated space-time cube</dd>
</dl>
</div>
</div>
<div id="outline-container-Outputs" class="outline-4">
<h4 id="Outputs"><span class="section-number-4">13.1.2.</span> Outputs</h4>
<div class="outline-text-4" id="text-Outputs">
<p>
The <code>grow_fire</code> function will return a dictionary with these fields:
</p>

<dl class="org-dl">
<dt>simulation_clock</dt><dd>a float specifying the number of minutes from the start time of the simulated space-time cube at which the simulation stopped</dd>

<dt>simulation_stop_condition_encountered</dt><dd>max_burn_duration | max_burned_area | no_burnable_fuel | end_of_temporal_data | fully_suppressed</dd>

<dt>config_dict</dt><dd>a dictionary of parameter names to their values as defined in section <a href="#Inputs">13.1.1</a> above</dd>

<dt>input_layer_dict</dt><dd>a dictionary of layer names to either 2-arity (2D) or 3-arity (3D) functions as defined in section <a href="#Inputs">13.1.1</a> above</dd>

<dt>output_layer_dict</dt><dd>a dictionary of layer names to 2D Numpy arrays as defined in section <a href="#Inputs">13.1.1</a> above</dd>

<dt>ignited_cells_set</dt><dd>set of cells that are actively burning at the simulation stop time, specified as 3D coordinates <code>(z,y,x)</code> in the simulated space-time cube</dd>
</dl>

<p>
Note that <code>config_dict</code> and <code>input_layer_dict</code> will be unchanged from
the input dictionary that was provided to <code>grow_fire</code>. All other
fields will contain values updated by the fire spread simulation.
</p>
</div>
</div>
<div id="outline-container-Play/Pause/Continue Workflow" class="outline-4">
<h4 id="Play/Pause/Continue Workflow"><span class="section-number-4">13.1.3.</span> Play/Pause/Continue Workflow</h4>
<div class="outline-text-4" id="text-Play/Pause/Continue Workflow">
<p>
The inputs and outputs of <code>grow_fire</code> are structured so as to enable
you to simulate fire spread from <code>simulation_clock</code> until a stop
condition is encountered and then to easily resume the fire spread
simulation from the output <code>simulation_clock</code> until the next stop
condition is met. Here is an example of how to do this.
</p>

<div class="org-src-container">
<pre class="src src-python" id="play-pause-continue-workflow"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np

<span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Phase 1: Initial fire simulation - first 12 hours</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================</span>

<span class="org-variable-name">world_state</span> <span class="org-operator">=</span> {
    simulation_clock: 0.0,

    config_dict: {
        <span class="org-string">"simulation_shape"</span>         : (24, 1000, 1000),
        <span class="org-string">"simulation_resolution"</span>    : (60, 30, 30),
        <span class="org-string">"simulation_stop_condition"</span>: {<span class="org-string">"max_burn_duration"</span>: 720.0},
    },

    input_layer_dict: {
        <span class="org-comment-delimiter"># </span><span class="org-comment">2D Arrays (e.g. 30m x 30m resolution, 30km x 30km extent)</span>
        <span class="org-string">"elevation"</span>                    : <span class="org-keyword">lambda</span> y,x: 0.0,
        <span class="org-string">"slope"</span>                        : <span class="org-keyword">lambda</span> y,x: 0.0,
        <span class="org-string">"aspect"</span>                       : <span class="org-keyword">lambda</span> y,x: 0.0,
        <span class="org-string">"fuel_model"</span>                   : <span class="org-keyword">lambda</span> y,x: 100,
        <span class="org-string">"canopy_cover"</span>                 : <span class="org-keyword">lambda</span> y,x: 0.0,
        <span class="org-string">"canopy_height"</span>                : <span class="org-keyword">lambda</span> y,x: 0.0,
        <span class="org-string">"canopy_base_height"</span>           : <span class="org-keyword">lambda</span> y,x: 0.0,
        <span class="org-string">"canopy_bulk_density"</span>          : <span class="org-keyword">lambda</span> y,x: 0.0,
        <span class="org-comment-delimiter"># </span><span class="org-comment">3D Arrays (e.g. 1hr x 300m x 300m resolution, 1day x 30km x 30km extent)</span>
        <span class="org-string">"temperature"</span>                  : <span class="org-keyword">lambda</span> z,y,x: 10.0,
        <span class="org-string">"relative_humidity"</span>            : <span class="org-keyword">lambda</span> z,y,x: 10.0,
        <span class="org-string">"wind_speed_10m"</span>               : <span class="org-keyword">lambda</span> z,y,x: 0.0,
        <span class="org-string">"upwind_direction"</span>             : <span class="org-keyword">lambda</span> z,y,x: 0.0,
        <span class="org-string">"fuel_moisture_dead_1hr"</span>       : <span class="org-keyword">lambda</span> z,y,x: 10.0,
        <span class="org-string">"fuel_moisture_dead_10hr"</span>      : <span class="org-keyword">lambda</span> z,y,x: 10.0,
        <span class="org-string">"fuel_moisture_dead_100hr"</span>     : <span class="org-keyword">lambda</span> z,y,x: 10.0,
        <span class="org-string">"fuel_moisture_live_herbaceous"</span>: <span class="org-keyword">lambda</span> z,y,x: 10.0,
        <span class="org-string">"fuel_moisture_live_woody"</span>     : <span class="org-keyword">lambda</span> z,y,x: 10.0,
        <span class="org-string">"foliar_moisture"</span>              : <span class="org-keyword">lambda</span> z,y,x: 10.0,
    },

    output_layer_dict: {
        <span class="org-string">"eulerian_level_set_phi_field"</span> : np.full((1000, 1000), 0.0, dtype<span class="org-operator">=</span><span class="org-string">"float16"</span>),
    },

    ignited_cells_set: <span class="org-builtin">set</span>([(0, 100, 100)]),
}

<span class="org-variable-name">world_state2</span> <span class="org-operator">=</span> grow_fire(world_state)

<span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Phase 2: Continued fire simulation - second 12 hours</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================</span>

<span class="org-variable-name">world_state3</span> <span class="org-operator">=</span> grow_fire(world_state2)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-burn_cells" class="outline-3">
<h3 id="burn_cells"><span class="section-number-3">13.2.</span> burn_cells</h3>
<div class="outline-text-3" id="text-burn_cells">
<p>
TODO: stub
</p>
</div>
</div>
</div>
<div id="outline-container-[WIP] Fire Spread Functions" class="outline-2">
<h2 id="[WIP] Fire Spread Functions"><span class="section-number-2">14.</span> [WIP] Fire Spread Functions</h2>
<div class="outline-text-2" id="text-[WIP] Fire Spread Functions">
<div class="org-src-container">
<pre class="src src-python" id="fire-spread-functions"><span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Compare this with numpy.random (is there a generator object that I can use here?)</span>
<span class="org-keyword">import</span> random
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np

<span class="org-keyword">def</span> <span class="org-function-name">supply_layer</span>(layer_dict, layer_name, layer_shape, layer_type, initial_value, overwrite_layers):
    <span class="org-variable-name">layer</span> <span class="org-operator">=</span> layer_dict.get(layer_name)
    <span class="org-keyword">if</span> layer:
        <span class="org-keyword">if</span> overwrite_layers:
            <span class="org-keyword">return</span> layer
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> layer.copy()
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> np.full(layer_shape, initial_value, dtype<span class="org-operator">=</span>layer_type)


<span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: stub</span>
<span class="org-keyword">def</span> <span class="org-function-name">burn_cells</span>(world_state):
    <span class="org-doc">"""</span>
<span class="org-doc">    1. Validate inputs</span>
<span class="org-doc">       - Make sure that all required parameters are present in config_dict</span>
<span class="org-doc">       - Make sure that all required entries are present in layer_dict</span>
<span class="org-doc">       - Check for entries in output_layer_dict; if present, copy/use as new output layers</span>
<span class="org-doc">         - Use time of arrival raster to identify the burn scar(s); if missing, we are simulating point ignitions</span>
<span class="org-doc">       - Make sure that ignited_cells_set is a set of integer 3-tuples</span>
<span class="org-doc">    2. Iterate through all cells in (rows, cols), compute the maximum spread rate and severity values, and store them in output arrays</span>
<span class="org-doc">       - Run surface and crown equations per cell</span>
<span class="org-doc">    3. Return a dictionary of the outputs</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">simulation_clock</span>  <span class="org-operator">=</span> world_state[<span class="org-string">"simulation_clock"</span>]
    <span class="org-variable-name">config_dict</span>       <span class="org-operator">=</span> world_state[<span class="org-string">"config_dict"</span>]
    <span class="org-variable-name">input_layer_dict</span>  <span class="org-operator">=</span> world_state[<span class="org-string">"input_layer_dict"</span>]
    <span class="org-variable-name">output_layer_dict</span> <span class="org-operator">=</span> world_state.get(<span class="org-string">"output_layer_dict"</span>, {})
    <span class="org-variable-name">ignited_cells_set</span> <span class="org-operator">=</span> world_state[<span class="org-string">"ignited_cells_set"</span>]

    <span class="org-comment-delimiter"># </span><span class="org-comment">The random seed affects input layer perturbations.</span>
    <span class="org-keyword">if</span> config_dict.get(<span class="org-string">"random_seed"</span>):
        random.seed(config_dict.get(<span class="org-string">"random_seed"</span>))

    <span class="org-keyword">return</span> <span class="org-constant">None</span>


<span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: stub</span>
<span class="org-keyword">def</span> <span class="org-function-name">grow_fire</span>(world_state):
    <span class="org-doc">"""</span>
<span class="org-doc">    1. Validate inputs</span>
<span class="org-doc">       - Make sure that all required parameters are present in config_dict</span>
<span class="org-doc">       - Make sure that all required entries are present in layer_dict</span>
<span class="org-doc">       - Check for entries in output_layer_dict; if present, copy/use as new output layers</span>
<span class="org-doc">         - Use time of arrival raster to identify the burn scar(s); if missing, we are simulating point ignitions</span>
<span class="org-doc">       - Make sure that ignited_cells_set is a set of integer 3-tuples</span>
<span class="org-doc">    2. Iterate through all cells in ignited_cells_set, compute the perimeter-oriented spread rate and severity values, and store them in output arrays</span>
<span class="org-doc">    3. Perform constant spread out over the landscape in all directions</span>
<span class="org-doc">       - Run surface, crown, and spot equations per ignited cell</span>
<span class="org-doc">    4. Record the time_of_arrival in each cell as it spreads</span>
<span class="org-doc">    5. Continue until a stop condition is met (e.g., max_burn_duration or max_burned_area)</span>
<span class="org-doc">    6. Return a dictionary of the outputs</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">simulation_clock</span>  <span class="org-operator">=</span> world_state[<span class="org-string">"simulation_clock"</span>]
    <span class="org-variable-name">config_dict</span>       <span class="org-operator">=</span> world_state[<span class="org-string">"config_dict"</span>]
    <span class="org-variable-name">input_layer_dict</span>  <span class="org-operator">=</span> world_state[<span class="org-string">"input_layer_dict"</span>]
    <span class="org-variable-name">output_layer_dict</span> <span class="org-operator">=</span> world_state.get(<span class="org-string">"output_layer_dict"</span>, {})
    <span class="org-variable-name">ignited_cells_set</span> <span class="org-operator">=</span> world_state[<span class="org-string">"ignited_cells_set"</span>]

    <span class="org-comment-delimiter"># </span><span class="org-comment">The random seed affects input layer perturbations and spotting calculations.</span>
    <span class="org-keyword">if</span> config_dict.get(<span class="org-string">"random_seed"</span>):
        random.seed(config_dict.get(<span class="org-string">"random_seed"</span>))

    <span class="org-comment-delimiter"># </span><span class="org-comment">GridFire initializes the following 2D arrays for its spread algorithm:</span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:burn-time-matrix                [float32] time_of_arrival (with -1 for values in the interior of the burn scar)</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:eccentricity-matrix             [float32] -1 in burn scar, 0 otherwise</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:fireline-intensity-matrix       [float32] -1 in burn scar, 0 otherwise</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:fire-spread-matrix              [float32] +1 in burn scar, 0 otherwise</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:fire-type-matrix                [float32] -1 in burn scar, 0 otherwise</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:firebrand-count-matrix          [ int32 ]  0 everywhere (when spotting params are passed)</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:flame-length-matrix             [float32] -1 in burn scar, 0 otherwise</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:directional-flame-length-matrix [float32] -1 in burn scar, 0 otherwise (when compute-directional-values? = true)</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:max-spread-direction-matrix     [float32] -1 in burn scar, 0 otherwise</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:max-spread-rate-matrix          [float32] -1 in burn scar, 0 otherwise</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:modified-time-matrix            [ int32 ]  0 everywhere</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:residence-time-matrix           [float32] -1 in burn scar, 0 otherwise (when compute-directional-values? = true)</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:reaction-intensity-matrix       [float32] -1 in burn scar, 0 otherwise (when compute-directional-values? = true)</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:spot-matrix                     [float32]  0 everywhere (when spotting params are passed)</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:spread-rate-matrix              [float32] -1 in burn scar, 0 otherwise</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:spread-rate-sum-matrix          [float32]  0 everywhere (when compute-directional-values? = true)</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:travel-lines-matrix             [ int16 ]  0 everywhere</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:x-magnitude-sum-matrix          [float32]  0 everywhere (when compute-directional-values? = true)</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:y-magnitude-sum-matrix          [float32]  0 everywhere (when compute-directional-values? = true)</span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Equivalent Pyretechnics 2D arrays in output_layer_dict:</span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">========================= Output 2D Arrays =========================</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">time_of_arrival                  :burn-time-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">max_surface_spread_direction     :max-spread-direction-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">max_crown_spread_direction       :max-spread-direction-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">perimeter_spread_direction       N/A</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">max_surface_spread_rate          :max-spread-rate-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">max_crown_spread_rate            :max-spread-rate-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">perimeter_spread_rate            :spread-rate-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">max_surface_fireline_intensity   :fireline-intensity-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">max_crown_fireline_intensity     :fireline-intensity-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">perimeter_fireline_intensity     :fireline-intensity-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">max_surface_flame_length         :flame-length-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">max_crown_flame_length           :flame-length-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">perimeter_flame_length           :directional-flame-length-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">fire_type                        :fire-type-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">ember_count                      :firebrand-count-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">ember_ignition                   :spot-matrix</span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">======================== Internal 2D Arrays ========================</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">surface_eccentricity             :eccentricity-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">crown_eccentricity               :eccentricity-matrix</span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">GridFire 2D arrays that are not needed by Pyretechnics:</span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">======================== Replaced 2D Arrays ========================</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:fire-spread-matrix              time_of_arrival</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:residence-time-matrix           max_surface_fireline_intensity, max_crown_fireline_intensity, surface_eccentricity, crown_eccentricity</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:reaction-intensity-matrix       max_surface_fireline_intensity, max_crown_fireline_intensity, surface_eccentricity, crown_eccentricity</span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">======================== Internal 2D Arrays ========================</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:modified-time-matrix            \</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:travel-lines-matrix              |</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:spread-rate-sum-matrix           |-- for its 2D spread algorithm</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:x-magnitude-sum-matrix           |</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:y-magnitude-sum-matrix          /</span>

    (<span class="org-variable-name">num_timesteps</span>, <span class="org-variable-name">num_rows</span>, <span class="org-variable-name">num_cols</span>) <span class="org-operator">=</span> config_dict[<span class="org-string">"simulation_shape"</span>]
    <span class="org-variable-name">layer_shape</span> <span class="org-operator">=</span> (num_rows, num_cols)
    <span class="org-variable-name">overwrite_outputs</span> <span class="org-operator">=</span> config_dict[<span class="org-string">"overwrite_outputs"</span>]

    <span class="org-variable-name">output_layer_dict</span> <span class="org-operator">=</span> {
        <span class="org-string">"eulerian_level_set_phi_field"</span>  : supply_layer(output_layer_dict, <span class="org-string">"eulerian_level_set_phi_field"</span>  , layer_shape, <span class="org-string">"float16"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"time_of_arrival"</span>               : supply_layer(output_layer_dict, <span class="org-string">"time_of_arrival"</span>               , layer_shape, <span class="org-string">"float32"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"max_surface_spread_direction"</span>  : supply_layer(output_layer_dict, <span class="org-string">"max_surface_spread_direction"</span>  , layer_shape, <span class="org-string">"float16"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"max_crown_spread_direction"</span>    : supply_layer(output_layer_dict, <span class="org-string">"max_crown_spread_direction"</span>    , layer_shape, <span class="org-string">"float16"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"perimeter_spread_direction"</span>    : supply_layer(output_layer_dict, <span class="org-string">"perimeter_spread_direction"</span>    , layer_shape, <span class="org-string">"float16"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"max_surface_spread_rate"</span>       : supply_layer(output_layer_dict, <span class="org-string">"max_surface_spread_rate"</span>       , layer_shape, <span class="org-string">"float16"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"max_crown_spread_rate"</span>         : supply_layer(output_layer_dict, <span class="org-string">"max_crown_spread_rate"</span>         , layer_shape, <span class="org-string">"float16"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"perimeter_spread_rate"</span>         : supply_layer(output_layer_dict, <span class="org-string">"perimeter_spread_rate"</span>         , layer_shape, <span class="org-string">"float16"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"surface_eccentricity"</span>          : supply_layer(output_layer_dict, <span class="org-string">"surface_eccentricity"</span>          , layer_shape, <span class="org-string">"float16"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"crown_eccentricity"</span>            : supply_layer(output_layer_dict, <span class="org-string">"crown_eccentricity"</span>            , layer_shape, <span class="org-string">"float16"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"max_surface_fireline_intensity"</span>: supply_layer(output_layer_dict, <span class="org-string">"max_surface_fireline_intensity"</span>, layer_shape, <span class="org-string">"float32"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"max_crown_fireline_intensity"</span>  : supply_layer(output_layer_dict, <span class="org-string">"max_crown_fireline_intensity"</span>  , layer_shape, <span class="org-string">"float32"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"perimeter_fireline_intensity"</span>  : supply_layer(output_layer_dict, <span class="org-string">"perimeter_fireline_intensity"</span>  , layer_shape, <span class="org-string">"float32"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"max_surface_flame_length"</span>      : supply_layer(output_layer_dict, <span class="org-string">"max_surface_flame_length"</span>      , layer_shape, <span class="org-string">"float16"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"max_crown_flame_length"</span>        : supply_layer(output_layer_dict, <span class="org-string">"max_crown_flame_length"</span>        , layer_shape, <span class="org-string">"float16"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"perimeter_flame_length"</span>        : supply_layer(output_layer_dict, <span class="org-string">"perimeter_flame_length"</span>        , layer_shape, <span class="org-string">"float16"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"fire_type"</span>                     : supply_layer(output_layer_dict, <span class="org-string">"fire_type"</span>                     , layer_shape, <span class="org-string">"uint8"</span>  ,      0, overwrite_outputs),
        <span class="org-string">"ember_count"</span>                   : supply_layer(output_layer_dict, <span class="org-string">"ember_count"</span>                   , layer_shape, <span class="org-string">"uint32"</span> ,      0, overwrite_outputs),
        <span class="org-string">"ember_ignition"</span>                : supply_layer(output_layer_dict, <span class="org-string">"ember_ignition"</span>                , layer_shape, <span class="org-string">"bool8"</span>  ,  <span class="org-constant">False</span>, overwrite_outputs),
    }

    <span class="org-comment-delimiter"># </span><span class="org-comment">RESUME at [[file:~/code/sig-gis/gridfire/src/gridfire/fire_spread.clj::(defn- run-loop]]</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Investigate ELMFIRE's inputs to determine if we are missing anything needed by its API.</span>

    <span class="org-keyword">return</span> <span class="org-constant">None</span>
</pre>
</div>
</div>
<div id="outline-container-ELMFIRE Inputs" class="outline-3">
<h3 id="ELMFIRE Inputs"><span class="section-number-3">14.1.</span> ELMFIRE Inputs</h3>
<div class="outline-text-3" id="text-ELMFIRE Inputs">
<p>
This section lists the full set of inputs used in any <code>elmfire.data</code> or <code>elmfire.data.in</code> file in:
</p>

<ul class="org-ul">
<li>the current <code>main</code> branch of the <code>elmfire</code> repository located here: <a href="https://github.com/lautenberger/elmfire">https://github.com/lautenberger/elmfire</a></li>
<li>the current <code>main</code> branch of the <code>runway-scripts</code> repository located here: <a href="https://gitlab.sig-gis.com/sig-gis/runway-scripts">https://gitlab.sig-gis.com/sig-gis/runway-scripts</a></li>
</ul>

<p>
The following table contains the current mapping from ELMFIRE parameters to Pyretechnics parameters:
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">ELMFIRE</th>
<th scope="col" class="org-left">Pyretechnics Group</th>
<th scope="col" class="org-left">Pyretechnics Parameter</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">DT_METEOROLOGY</td>
<td class="org-left">config_dict</td>
<td class="org-left">simulation_resolution[0]</td>
</tr>

<tr>
<td class="org-left">COMPUTATIONAL_DOMAIN_CELLSIZE</td>
<td class="org-left">config_dict</td>
<td class="org-left">simulation_resolution[1:]</td>
</tr>

<tr>
<td class="org-left">SIMULATION_TSTART</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">SIMULATION_TSTOP</td>
<td class="org-left">config_dict.simulation_stop_condition</td>
<td class="org-left">max_burn_duration</td>
</tr>

<tr>
<td class="org-left">EMBER_GR</td>
<td class="org-left">config_dict.spotting</td>
<td class="org-left">ember_gr</td>
</tr>

<tr>
<td class="org-left">EMBER_SAMPLING_FACTOR</td>
<td class="org-left">config_dict.spotting</td>
<td class="org-left">ember_sampling_factor</td>
</tr>

<tr>
<td class="org-left">ENABLE_SPOTTING</td>
<td class="org-left">config_dict.spotting</td>
<td class="org-left">Enabled if dictionary is present</td>
</tr>

<tr>
<td class="org-left">P_EPS</td>
<td class="org-left">config_dict.spotting</td>
<td class="org-left">p_eps</td>
</tr>

<tr>
<td class="org-left">PIGN</td>
<td class="org-left">config_dict.spotting</td>
<td class="org-left">pign</td>
</tr>

<tr>
<td class="org-left">PIGN_MAX</td>
<td class="org-left">config_dict.spotting</td>
<td class="org-left">pign_max</td>
</tr>

<tr>
<td class="org-left">PIGN_MIN</td>
<td class="org-left">config_dict.spotting</td>
<td class="org-left">pign_min</td>
</tr>

<tr>
<td class="org-left">TAU_EMBERGEN</td>
<td class="org-left">config_dict.spotting</td>
<td class="org-left">tau_embergen</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">DEM_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">elevation</td>
</tr>

<tr>
<td class="org-left">SLP_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">slope</td>
</tr>

<tr>
<td class="org-left">ASP_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">aspect</td>
</tr>

<tr>
<td class="org-left">FBFM_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">fuel_model</td>
</tr>

<tr>
<td class="org-left">CC_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">canopy_cover</td>
</tr>

<tr>
<td class="org-left">CH_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">canopy_height</td>
</tr>

<tr>
<td class="org-left">CBH_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">canopy_base_height</td>
</tr>

<tr>
<td class="org-left">CBD_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">canopy_bulk_density</td>
</tr>

<tr>
<td class="org-left">ADJ_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">fuel_spread_adjustment</td>
</tr>

<tr>
<td class="org-left">CRITICAL_SPOTTING_FIRELINE_INTENSITY(:)</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">surface_spotting_fireline_intensity</td>
</tr>

<tr>
<td class="org-left">GLOBAL_SURFACE_FIRE_SPOTTING_PERCENT_MAX</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">surface_spotting_percent</td>
</tr>

<tr>
<td class="org-left">GLOBAL_SURFACE_FIRE_SPOTTING_PERCENT_MIN</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">surface_spotting_percent</td>
</tr>

<tr>
<td class="org-left">WS_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">wind_speed_10m</td>
</tr>

<tr>
<td class="org-left">WD_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">upwind_direction</td>
</tr>

<tr>
<td class="org-left">M1_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">fuel_moisture_dead_1hr</td>
</tr>

<tr>
<td class="org-left">M10_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">fuel_moisture_dead_10hr</td>
</tr>

<tr>
<td class="org-left">M100_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">fuel_moisture_dead_100hr</td>
</tr>

<tr>
<td class="org-left">MLH_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">fuel_moisture_live_herbaceous</td>
</tr>

<tr>
<td class="org-left">MLW_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">fuel_moisture_live_woody</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">PHI_FILENAME</td>
<td class="org-left">output_layer_dict</td>
<td class="org-left">eulerian_level_set_phi_field</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">T_IGN(1)</td>
<td class="org-left">ignited_cells_set</td>
<td class="org-left">(t, _, _)</td>
</tr>

<tr>
<td class="org-left">Y_IGN(1)</td>
<td class="org-left">ignited_cells_set</td>
<td class="org-left">(_, y, _)</td>
</tr>

<tr>
<td class="org-left">X_IGN(1)</td>
<td class="org-left">ignited_cells_set</td>
<td class="org-left">(_, _, x)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">BANDTHICKNESS</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">METEOROLOGY_BAND_SKIP_INTERVAL</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">METEOROLOGY_BAND_START</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">METEOROLOGY_BAND_STOP</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">NUM_METEOROLOGY_TIMES</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">CROWN_FIRE_MODEL</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">MODE</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">SIMULATION_DT</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">SIMULATION_DTMAX</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">TARGET_CFL</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">USE_BLDG_SPREAD_MODEL</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">USE_EULERIAN_FRAMEWORK</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">USE_PHYSICAL_EMBER_NUMBER</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">USE_PHYSICAL_SPOTTING_DURATION</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">USE_SUPERSEDED_SPOTTING</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">USE_UMD_SPOTTING_MODEL</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">WX_BILINEAR_INTERPOLATION</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">ALLOW_MULTIPLE_IGNITIONS_AT_A_PIXEL</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">FUELS_AND_TOPOGRAPHY_DIRECTORY</td>
<td class="org-left">N/A</td>
<td class="org-left">Input reading managed externally</td>
</tr>

<tr>
<td class="org-left">A_SRS</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">LATITUDE</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">LONGITUDE</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">COMPUTATIONAL_DOMAIN_XLLCORNER</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">COMPUTATIONAL_DOMAIN_YLLCORNER</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">FORECAST_START_HOUR</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">UTC_OFFSET_HOURS</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">CURRENT_YEAR</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">HOUR_OF_YEAR</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">PATH_TO_GDAL</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">NUM_ENSEMBLE_MEMBERS</td>
<td class="org-left">N/A</td>
<td class="org-left">Random sampling managed externally</td>
</tr>

<tr>
<td class="org-left">NUM_IGNITIONS</td>
<td class="org-left">N/A</td>
<td class="org-left">Random sampling managed externally</td>
</tr>

<tr>
<td class="org-left">RANDOM_IGNITIONS</td>
<td class="org-left">N/A</td>
<td class="org-left">Random sampling managed externally</td>
</tr>

<tr>
<td class="org-left">USE_IGNITION_MASK</td>
<td class="org-left">N/A</td>
<td class="org-left">Random sampling managed externally</td>
</tr>

<tr>
<td class="org-left">USE_CONSTANT_LH</td>
<td class="org-left">N/A</td>
<td class="org-left">Replaced by abstract gridded datasource</td>
</tr>

<tr>
<td class="org-left">USE_CONSTANT_LW</td>
<td class="org-left">N/A</td>
<td class="org-left">Replaced by abstract gridded datasource</td>
</tr>

<tr>
<td class="org-left">LH_MOISTURE_CONTENT</td>
<td class="org-left">N/A</td>
<td class="org-left">Replaced by abstract gridded datasource</td>
</tr>

<tr>
<td class="org-left">LW_MOISTURE_CONTENT</td>
<td class="org-left">N/A</td>
<td class="org-left">Replaced by abstract gridded datasource</td>
</tr>

<tr>
<td class="org-left">OUTPUTS_DIRECTORY</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">SCRATCH</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">CONVERT_TO_GEOTIFF</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">DTDUMP</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">DT_DUMP_EMBER_FLUX</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">DUMP_EMBER_FLUX_UMD</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">DUMP_FLAME_LENGTH</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">DUMP_FLIN</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">DUMP_SPOTTING_OUTPUTS</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">DUMP_SPREAD_RATE</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">DUMP_TIME_OF_ARRIVAL</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-Appendices" class="outline-2">
<h2 id="Appendices"><span class="section-number-2">15.</span> Appendices</h2>
<div class="outline-text-2" id="text-Appendices">
</div>
<div id="outline-container-Units Conversion Functions (pyretechnics.conversion)" class="outline-3">
<h3 id="Units Conversion Functions (pyretechnics.conversion)"><span class="section-number-3">15.1.</span> Units Conversion Functions (pyretechnics.conversion)</h3>
<div class="outline-text-3" id="text-Units Conversion Functions (pyretechnics.conversion)">
<div class="org-src-container">
<pre class="src src-python" id="units-conversion"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> sqrt, degrees, radians, sin, cos, tan, atan, atan2, pi


<span class="org-keyword">def</span> <span class="org-function-name">F_to_K</span>(degrees):
    <span class="org-doc">"""Convert fahrenheit to kelvin."""</span>
    <span class="org-keyword">return</span> (degrees <span class="org-operator">+</span> 459.67) <span class="org-operator">*</span> 0.5555555555555556


<span class="org-keyword">def</span> <span class="org-function-name">K_to_F</span>(degrees):
    <span class="org-doc">"""Convert kelvin to fahrenheit."""</span>
    <span class="org-keyword">return</span> (degrees <span class="org-operator">*</span> 1.8) <span class="org-operator">-</span> 459.67


<span class="org-keyword">def</span> <span class="org-function-name">F_to_C</span>(degrees):
    <span class="org-doc">"""Convert fahrenheit to celsius."""</span>
    <span class="org-keyword">return</span> (degrees <span class="org-operator">-</span> 32.0) <span class="org-operator">*</span> 0.5555555555555556


<span class="org-keyword">def</span> <span class="org-function-name">C_to_F</span>(degrees):
    <span class="org-doc">"""Convert celsius to fahrenheit."""</span>
    <span class="org-keyword">return</span> (degrees <span class="org-operator">*</span> 1.8) <span class="org-operator">+</span> 32.0


<span class="org-keyword">def</span> <span class="org-function-name">deg_to_ratio</span>(degrees):
    <span class="org-doc">"""Convert degrees to ratio."""</span>
    <span class="org-keyword">return</span> tan(radians(degrees))


<span class="org-keyword">def</span> <span class="org-function-name">ratio_to_deg</span>(ratio):
    <span class="org-doc">"""Convert ratio to degrees."""</span>
    <span class="org-keyword">return</span> degrees(atan(ratio))


<span class="org-keyword">def</span> <span class="org-function-name">ch_to_m</span>(ch):
    <span class="org-doc">"""Convert chains to meters."""</span>
    <span class="org-keyword">return</span> ch <span class="org-operator">*</span> 20.1168


<span class="org-keyword">def</span> <span class="org-function-name">m_to_ch</span>(m):
    <span class="org-doc">"""Convert meters to chains."""</span>
    <span class="org-keyword">return</span> m <span class="org-operator">*</span> 0.0497097


<span class="org-keyword">def</span> <span class="org-function-name">m_to_ft</span>(m):
    <span class="org-doc">"""Convert meters to feet."""</span>
    <span class="org-keyword">return</span> m <span class="org-operator">*</span> 3.281


<span class="org-keyword">def</span> <span class="org-function-name">ft_to_m</span>(ft):
    <span class="org-doc">"""Convert feet to meters."""</span>
    <span class="org-keyword">return</span> ft <span class="org-operator">*</span> 0.30478512648582745


<span class="org-keyword">def</span> <span class="org-function-name">mph_to_mps</span>(mph):
    <span class="org-doc">"""Convert miles per hour to meters per second."""</span>
    <span class="org-keyword">return</span> mph <span class="org-operator">*</span> 0.44701818551254696


<span class="org-keyword">def</span> <span class="org-function-name">mps_to_mph</span>(mps):
    <span class="org-doc">"""Convert meters per second to miles per hour."""</span>
    <span class="org-keyword">return</span> mps <span class="org-operator">*</span> 2.237045454545455


<span class="org-keyword">def</span> <span class="org-function-name">mph_to_km_hr</span>(mph):
    <span class="org-doc">"""Convert miles per hour to kilometers per hour."""</span>
    <span class="org-keyword">return</span> mph <span class="org-operator">*</span> 1.609344


<span class="org-keyword">def</span> <span class="org-function-name">km_hr_to_mph</span>(km_hr):
    <span class="org-doc">"""Convert kilometers per hour to miles per hour."""</span>
    <span class="org-keyword">return</span> km_hr <span class="org-operator">*</span> 0.621371192237334


<span class="org-keyword">def</span> <span class="org-function-name">m_min_to_km_hr</span>(m_min):
    <span class="org-doc">"""Convert meters per minute to kilometers per hour."""</span>
    <span class="org-keyword">return</span> m_min <span class="org-operator">*</span> 0.06


<span class="org-keyword">def</span> <span class="org-function-name">km_hr_to_m_min</span>(km_hr):
    <span class="org-doc">"""Convert kilometers per hour to meters per minute."""</span>
    <span class="org-keyword">return</span> km_hr <span class="org-operator">/</span> 0.06


<span class="org-keyword">def</span> <span class="org-function-name">m_min_to_mph</span>(m_min):
    <span class="org-doc">"""Convert meters per minute to miles per hour."""</span>
    <span class="org-keyword">return</span> m_min <span class="org-operator">*</span> 0.0372840909091


<span class="org-keyword">def</span> <span class="org-function-name">mph_to_m_min</span>(mph):
    <span class="org-doc">"""Convert miles per hour to meters per minute."""</span>
    <span class="org-keyword">return</span> mph <span class="org-operator">*</span> 26.8210911307


<span class="org-keyword">def</span> <span class="org-function-name">mps_to_fpm</span>(mps):
    <span class="org-doc">"""Convert meters per second to feet per minute."""</span>
    <span class="org-keyword">return</span> mps <span class="org-operator">*</span> 196.86


<span class="org-keyword">def</span> <span class="org-function-name">fpm_to_mps</span>(fpm):
    <span class="org-doc">"""Convert feet per minute to meters per second."""</span>
    <span class="org-keyword">return</span> fpm <span class="org-operator">/</span> 196.86


<span class="org-keyword">def</span> <span class="org-function-name">mph_to_fpm</span>(mph):
    <span class="org-doc">"""Convert miles per hour to feet per minute."""</span>
    <span class="org-keyword">return</span> mph <span class="org-operator">*</span> 88.0


<span class="org-keyword">def</span> <span class="org-function-name">fpm_to_mph</span>(fpm):
    <span class="org-doc">"""Convert feet per minute to miles per hour."""</span>
    <span class="org-keyword">return</span> fpm <span class="org-operator">/</span> 88.0


<span class="org-keyword">def</span> <span class="org-function-name">Btu_ft_s_to_kW_m</span>(Btu_ft_s):
    <span class="org-doc">"""Convert BTU per feet per second to kilowatt per meter."""</span>
    <span class="org-keyword">return</span> Btu_ft_s <span class="org-operator">*</span> 3.46165186


<span class="org-keyword">def</span> <span class="org-function-name">kW_m_to_Btu_ft_s</span>(kW_m):
    <span class="org-doc">"""Convert kilowatt per meter to BTU per feet per second."""</span>
    <span class="org-keyword">return</span> kW_m <span class="org-operator">*</span> 0.28887942532730604


<span class="org-keyword">def</span> <span class="org-function-name">Btu_lb_to_kJ_kg</span>(Btu_lb):
    <span class="org-doc">"""Convert BTU per lb to kilojoule per kilogram."""</span>
    <span class="org-keyword">return</span> Btu_lb <span class="org-operator">*</span> 2.3259999996185


<span class="org-keyword">def</span> <span class="org-function-name">kJ_kg_to_Btu_lb</span>(kJ_kg):
    <span class="org-doc">"""Convert kilojoule per kilogram to BTU per lb."""</span>
    <span class="org-keyword">return</span> kJ_kg <span class="org-operator">/</span> 2.3259999996185


<span class="org-keyword">def</span> <span class="org-function-name">kg_m3_to_lb_ft3</span>(kg_m3):
    <span class="org-doc">"""Convert kilogram per cubic meter to pound per cubic foot."""</span>
    <span class="org-keyword">return</span> kg_m3 <span class="org-operator">*</span> 0.0624


<span class="org-keyword">def</span> <span class="org-function-name">lb_ft3_to_kg_m3</span>(lb_ft3):
    <span class="org-doc">"""Convert pound per cubic foot to kilogram per cubic meter."""</span>
    <span class="org-keyword">return</span> lb_ft3 <span class="org-operator">*</span> 16.025641025641026


<span class="org-keyword">def</span> <span class="org-function-name">percent_to_dec</span>(percent):
    <span class="org-doc">"""Convert percent to decimal."""</span>
    <span class="org-keyword">return</span> percent <span class="org-operator">*</span> 0.01


<span class="org-keyword">def</span> <span class="org-function-name">dec_to_percent</span>(decimal):
    <span class="org-doc">"""Convert decimal to percent."""</span>
    <span class="org-keyword">return</span> decimal <span class="org-operator">*</span> 100.0


<span class="org-keyword">def</span> <span class="org-function-name">sec_to_min</span>(seconds):
    <span class="org-doc">"""Convert seconds to minutes."""</span>
    <span class="org-keyword">return</span> seconds <span class="org-operator">*</span> 0.016666666666666666


<span class="org-keyword">def</span> <span class="org-function-name">min_to_sec</span>(minutes):
    <span class="org-doc">"""Convert minutes to seconds."""</span>
    <span class="org-keyword">return</span> minutes <span class="org-operator">*</span> 60.0


<span class="org-keyword">def</span> <span class="org-function-name">ms_to_min</span>(milliseconds):
    <span class="org-doc">"""Convert milliseconds to minutes."""</span>
    <span class="org-keyword">return</span> milliseconds <span class="org-operator">*</span> 0.000016667


<span class="org-keyword">def</span> <span class="org-function-name">min_to_ms</span>(minutes):
    <span class="org-doc">"""Convert minutes to milliseconds."""</span>
    <span class="org-keyword">return</span> <span class="org-builtin">int</span>(minutes <span class="org-operator">*</span> 60000.0)


<span class="org-keyword">def</span> <span class="org-function-name">hour_to_min</span>(hours):
    <span class="org-doc">"""Converts hours to minutes."""</span>
    <span class="org-keyword">return</span> hours <span class="org-operator">*</span> 60.0


<span class="org-keyword">def</span> <span class="org-function-name">min_to_hour</span>(minutes):
    <span class="org-doc">"""Converts minutes to hours. (rounds down)"""</span>
    <span class="org-keyword">return</span> <span class="org-builtin">int</span>(minutes <span class="org-operator">/</span> 60.0)


<span class="org-keyword">def</span> <span class="org-function-name">day_to_min</span>(days):
    <span class="org-doc">"""Convert days to minutes."""</span>
    <span class="org-keyword">return</span> days <span class="org-operator">*</span> 1440.0


<span class="org-keyword">def</span> <span class="org-function-name">min_to_day</span>(minutes):
    <span class="org-doc">"""Convert minutes to days."""</span>
    <span class="org-keyword">return</span> minutes <span class="org-operator">/</span> 1440.0


<span class="org-keyword">def</span> <span class="org-function-name">cartesian_to_polar</span>(x, y):
    <span class="org-doc">"""Convert cartesian coordinates (x, y) to polar coordinates (r, theta)."""</span>
    <span class="org-variable-name">r</span>         <span class="org-operator">=</span> sqrt(x <span class="org-operator">**</span> 2.0 <span class="org-operator">+</span> y <span class="org-operator">**</span> 2.0)
    <span class="org-variable-name">theta_rad</span> <span class="org-operator">=</span> atan2(y, x)
    <span class="org-variable-name">theta</span>     <span class="org-operator">=</span> degrees(theta_rad) <span class="org-operator">%</span> 360.0
    <span class="org-keyword">return</span> (r, theta)


<span class="org-keyword">def</span> <span class="org-function-name">polar_to_cartesian</span>(r, theta):
    <span class="org-doc">"""Convert polar coordinates (r, theta) to cartesian coordinates (x, y)."""</span>
    <span class="org-variable-name">theta_rad</span> <span class="org-operator">=</span> radians(theta)
    <span class="org-variable-name">x</span>         <span class="org-operator">=</span> r <span class="org-operator">*</span> cos(theta_rad)
    <span class="org-variable-name">y</span>         <span class="org-operator">=</span> r <span class="org-operator">*</span> sin(theta_rad)
    <span class="org-keyword">return</span> (x, y)


<span class="org-keyword">def</span> <span class="org-function-name">cartesian_to_azimuthal</span>(x, y):
    <span class="org-doc">"""Convert cartesian coordinates (x, y) to azimuthal coordinates (r, azimuth)."""</span>
    <span class="org-variable-name">r</span>           <span class="org-operator">=</span> sqrt(x <span class="org-operator">**</span> 2.0 <span class="org-operator">+</span> y <span class="org-operator">**</span> 2.0)
    <span class="org-variable-name">azimuth_rad</span> <span class="org-operator">=</span> atan2(x, y)
    <span class="org-variable-name">azimuth</span>     <span class="org-operator">=</span> degrees(azimuth_rad) <span class="org-operator">%</span> 360.0
    <span class="org-keyword">return</span> (r, azimuth)


<span class="org-keyword">def</span> <span class="org-function-name">azimuthal_to_cartesian</span>(r, azimuth):
    <span class="org-doc">"""Convert azimuthal coordinates (r, azimuth) to cartesian coordinates (x, y)."""</span>
    <span class="org-variable-name">azimuth_rad</span> <span class="org-operator">=</span> radians(azimuth)
    <span class="org-variable-name">x</span>           <span class="org-operator">=</span> r <span class="org-operator">*</span> sin(azimuth_rad)
    <span class="org-variable-name">y</span>           <span class="org-operator">=</span> r <span class="org-operator">*</span> cos(azimuth_rad)
    <span class="org-keyword">return</span> (x, y)


<span class="org-keyword">def</span> <span class="org-function-name">opposite_direction</span>(theta):
    <span class="org-doc">"""Convert theta to theta + 180 degrees."""</span>
    <span class="org-keyword">return</span> (theta <span class="org-operator">+</span> 180.0) <span class="org-operator">%</span> 360.0


<span class="org-keyword">def</span> <span class="org-function-name">wind_speed_10m_to_wind_speed_20ft</span>(wind_speed_10m):
    <span class="org-doc">"""Convert wind speed at 10m to wind speed at 20ft."""</span>
    <span class="org-keyword">return</span> 0.87 <span class="org-operator">*</span> wind_speed_10m


<span class="org-keyword">def</span> <span class="org-function-name">wind_speed_20ft_to_wind_speed_10m</span>(wind_speed_20ft):
    <span class="org-doc">"""Convert wind speed at 20ft to wind speed at 10m."""</span>
    <span class="org-keyword">return</span> wind_speed_20ft <span class="org-operator">/</span> 0.87
</pre>
</div>
</div>
</div>
<div id="outline-container-Vector Utility Functions (pyretechnics.vector_utils)" class="outline-3">
<h3 id="Vector Utility Functions (pyretechnics.vector_utils)"><span class="section-number-3">15.2.</span> Vector Utility Functions (pyretechnics.vector_utils)</h3>
<div class="outline-text-3" id="text-Vector Utility Functions (pyretechnics.vector_utils)">
<div class="org-src-container">
<pre class="src src-python" id="vector-utilities"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> radians, sin, cos, sqrt
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv


<span class="org-keyword">def</span> <span class="org-function-name">vector_magnitude</span>(vector):
    <span class="org-keyword">return</span> sqrt(np.dot(vector, vector))


<span class="org-keyword">def</span> <span class="org-function-name">as_unit_vector</span>(vector):
    <span class="org-keyword">return</span> np.asarray(vector) <span class="org-operator">/</span> vector_magnitude(vector)


<span class="org-keyword">def</span> <span class="org-function-name">to_slope_plane</span>(vector_2d, elevation_gradient):
    <span class="org-keyword">return</span> np.asarray((
        vector_2d[0],
        vector_2d[1],
        np.dot(vector_2d, elevation_gradient)
    ))


<span class="org-keyword">def</span> <span class="org-function-name">to_horizontal_plane</span>(vector_3d):
    <span class="org-keyword">return</span> np.asarray(vector_3d[0:2])


<span class="org-keyword">def</span> <span class="org-function-name">get_slope_normal_vector</span>(elevation_gradient):
    <span class="org-variable-name">slope_normal_vector</span> <span class="org-operator">=</span> (<span class="org-operator">-</span>elevation_gradient[0], <span class="org-operator">-</span>elevation_gradient[1], 1)
    <span class="org-keyword">return</span> as_unit_vector(slope_normal_vector)


<span class="org-keyword">def</span> <span class="org-function-name">rotate_on_sloped_plane</span>(vector, theta, slope, aspect):
    <span class="org-doc">"""Rotate a 3D vector &lt;x,y,z&gt; theta degrees clockwise on the plane defined by the slope and aspect."""</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the slope normal vector from the slope and aspect</span>
    <span class="org-variable-name">elevation_gradient</span>  <span class="org-operator">=</span> conv.azimuthal_to_cartesian(slope, conv.opposite_direction(aspect))
    <span class="org-variable-name">slope_normal_vector</span> <span class="org-operator">=</span> get_slope_normal_vector(elevation_gradient)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Rotate theta degrees clockwise around the slope_normal_vector</span>
    <span class="org-variable-name">theta_rad</span> <span class="org-operator">=</span> radians(theta)
    <span class="org-keyword">return</span> cos(theta_rad) <span class="org-operator">*</span> vector <span class="org-operator">+</span> np.cross(sin(theta_rad) <span class="org-operator">*</span> vector, slope_normal_vector)
</pre>
</div>
</div>
</div>
<div id="outline-container-SpaceTimeCube and LazySpaceTimeCube Tests (pyretechnics_test.test_space_time_cube)" class="outline-3">
<h3 id="SpaceTimeCube and LazySpaceTimeCube Tests (pyretechnics_test.test_space_time_cube)"><span class="section-number-3">15.3.</span> SpaceTimeCube and LazySpaceTimeCube Tests (pyretechnics_test.test_space_time_cube)</h3>
<div class="outline-text-3" id="text-SpaceTimeCube and LazySpaceTimeCube Tests (pyretechnics_test.test_space_time_cube)">
<div class="org-src-container">
<pre class="src src-python" id="test-space-time-cube"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube, LazySpaceTimeCube

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Raw Data - Managed by the Caller</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">2D Arrays (e.g. 30m x 30m resolution, 30km x 30km extent)</span>
<span class="org-variable-name">elevation_layer</span>                    <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">slope_layer</span>                        <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">aspect_layer</span>                       <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">fuel_model_layer</span>                   <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">canopy_cover_layer</span>                 <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">canopy_height_layer</span>                <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">canopy_base_height_layer</span>           <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">canopy_bulk_density_layer</span>          <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">fuel_spread_adjustment_layer</span>       <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000) <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>
<span class="org-variable-name">suppression_difficulty_index_layer</span> <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000) <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">3D Arrays (e.g. 1hr x 300m x 300m resolution, 1day x 30km x 30km extent)</span>
<span class="org-variable-name">temperature_layer</span>                   <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">relative_humidity_layer</span>             <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">wind_speed_10m_layer</span>                <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">upwind_direction_layer</span>              <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">fuel_moisture_dead_1hr_layer</span>        <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">fuel_moisture_dead_10hr_layer</span>       <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">fuel_moisture_dead_100hr_layer</span>      <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">fuel_moisture_live_herbaceous_layer</span> <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">fuel_moisture_live_woody_layer</span>      <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">foliar_moisture_layer</span>               <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">weather_spread_adjustment_layer</span>     <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100) <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube Dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (
    24,   <span class="org-comment-delimiter"># </span><span class="org-comment">bands: 1 day @ 1 hour/band</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">rows:  30 km @ 30 meters/row</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">cols:  30 km @ 30 meters/col</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Create the Dictionary of Layer Names to SpaceTimeCubes</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

<span class="org-keyword">def</span> <span class="org-function-name">test_make_layer_lookup</span>():
    <span class="org-variable-name">layer_lookup</span> <span class="org-operator">=</span> {
        <span class="org-comment-delimiter"># </span><span class="org-comment">2D Arrays (e.g. 30m x 30m resolution, 30km x 30km extent)</span>
        <span class="org-string">"elevation"</span>                    : SpaceTimeCube(cube_shape, elevation_layer),
        <span class="org-string">"slope"</span>                        : SpaceTimeCube(cube_shape, slope_layer),
        <span class="org-string">"aspect"</span>                       : SpaceTimeCube(cube_shape, aspect_layer),
        <span class="org-string">"fuel_model"</span>                   : SpaceTimeCube(cube_shape, fuel_model_layer),
        <span class="org-string">"canopy_cover"</span>                 : SpaceTimeCube(cube_shape, canopy_cover_layer),
        <span class="org-string">"canopy_height"</span>                : SpaceTimeCube(cube_shape, canopy_height_layer),
        <span class="org-string">"canopy_base_height"</span>           : SpaceTimeCube(cube_shape, canopy_base_height_layer),
        <span class="org-string">"canopy_bulk_density"</span>          : SpaceTimeCube(cube_shape, canopy_bulk_density_layer),
        <span class="org-string">"fuel_spread_adjustment"</span>       : SpaceTimeCube(cube_shape, fuel_spread_adjustment_layer),       <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>
        <span class="org-string">"suppression_difficulty_index"</span> : SpaceTimeCube(cube_shape, suppression_difficulty_index_layer), <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">3D Arrays (e.g. 1hr x 300m x 300m resolution, 1day x 30km x 30km extent)</span>
        <span class="org-string">"temperature"</span>                  : SpaceTimeCube(cube_shape, temperature_layer),
        <span class="org-string">"relative_humidity"</span>            : SpaceTimeCube(cube_shape, relative_humidity_layer),
        <span class="org-string">"wind_speed_10m"</span>               : SpaceTimeCube(cube_shape, wind_speed_10m_layer),
        <span class="org-string">"upwind_direction"</span>             : SpaceTimeCube(cube_shape, upwind_direction_layer),
        <span class="org-string">"fuel_moisture_dead_1hr"</span>       : SpaceTimeCube(cube_shape, fuel_moisture_dead_1hr_layer),
        <span class="org-string">"fuel_moisture_dead_10hr"</span>      : SpaceTimeCube(cube_shape, fuel_moisture_dead_10hr_layer),
        <span class="org-string">"fuel_moisture_dead_100hr"</span>     : SpaceTimeCube(cube_shape, fuel_moisture_dead_100hr_layer),
        <span class="org-string">"fuel_moisture_live_herbaceous"</span>: SpaceTimeCube(cube_shape, fuel_moisture_live_herbaceous_layer),
        <span class="org-string">"fuel_moisture_live_woody"</span>     : SpaceTimeCube(cube_shape, fuel_moisture_live_woody_layer),
        <span class="org-string">"foliar_moisture"</span>              : SpaceTimeCube(cube_shape, foliar_moisture_layer),
        <span class="org-string">"weather_spread_adjustment"</span>    : SpaceTimeCube(cube_shape, weather_spread_adjustment_layer),    <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>
    }
    <span class="org-keyword">assert</span> <span class="org-builtin">all</span>(<span class="org-builtin">map</span>(<span class="org-keyword">lambda</span> cube: <span class="org-builtin">isinstance</span>(cube.data, np.ndarray), layer_lookup.values()))
    <span class="org-keyword">return</span> layer_lookup

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Looking Up Values in the Layers</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

<span class="org-keyword">def</span> <span class="org-function-name">test_use_layer_lookup_2d</span>():
    <span class="org-variable-name">layer_lookup</span> <span class="org-operator">=</span> test_make_layer_lookup()
    <span class="org-variable-name">dem_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"elevation"</span>].get(0,100,100)
    <span class="org-variable-name">slp_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"slope"</span>].get(0,100,100)
    <span class="org-variable-name">asp_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"aspect"</span>].get(0,100,100)
    <span class="org-variable-name">fbfm_100_100</span> <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_model"</span>].get(0,100,100)
    <span class="org-variable-name">cc_100_100</span>   <span class="org-operator">=</span> layer_lookup[<span class="org-string">"canopy_cover"</span>].get(0,100,100)
    <span class="org-variable-name">ch_100_100</span>   <span class="org-operator">=</span> layer_lookup[<span class="org-string">"canopy_height"</span>].get(0,100,100)
    <span class="org-variable-name">cbh_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"canopy_base_height"</span>].get(0,100,100)
    <span class="org-variable-name">cbd_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"canopy_bulk_density"</span>].get(0,100,100)
    <span class="org-variable-name">fsa_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_spread_adjustment"</span>].get(0,100,100)           <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>
    <span class="org-variable-name">sdi_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"suppression_difficulty_index"</span>].get(0,100,100)     <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>
    <span class="org-keyword">assert</span> dem_100_100  <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> slp_100_100  <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> asp_100_100  <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> fbfm_100_100 <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> cc_100_100   <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> ch_100_100   <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> cbh_100_100  <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> cbd_100_100  <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> fsa_100_100  <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> sdi_100_100  <span class="org-operator">==</span> 100100


<span class="org-keyword">def</span> <span class="org-function-name">test_use_layer_lookup_3d</span>():
    <span class="org-variable-name">layer_lookup</span>     <span class="org-operator">=</span> test_make_layer_lookup()
    <span class="org-variable-name">temp_12_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"temperature"</span>].get(12,100,100)
    <span class="org-variable-name">rh_12_100_100</span>    <span class="org-operator">=</span> layer_lookup[<span class="org-string">"relative_humidity"</span>].get(12,100,100)
    <span class="org-variable-name">wsp_12_100_100</span>   <span class="org-operator">=</span> layer_lookup[<span class="org-string">"wind_speed_10m"</span>].get(12,100,100)
    <span class="org-variable-name">wdir_12_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"upwind_direction"</span>].get(12,100,100)
    <span class="org-variable-name">md1_12_100_100</span>   <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_moisture_dead_1hr"</span>].get(12,100,100)
    <span class="org-variable-name">md10_12_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_moisture_dead_10hr"</span>].get(12,100,100)
    <span class="org-variable-name">md100_12_100_100</span> <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_moisture_dead_100hr"</span>].get(12,100,100)
    <span class="org-variable-name">mlh_12_100_100</span>   <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_moisture_live_herbaceous"</span>].get(12,100,100)
    <span class="org-variable-name">mlw_12_100_100</span>   <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_moisture_live_woody"</span>].get(12,100,100)
    <span class="org-variable-name">fm_12_100_100</span>    <span class="org-operator">=</span> layer_lookup[<span class="org-string">"foliar_moisture"</span>].get(12,100,100)
    <span class="org-variable-name">wsa_12_100_100</span>   <span class="org-operator">=</span> layer_lookup[<span class="org-string">"weather_spread_adjustment"</span>].get(12,100,100) <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>
    <span class="org-keyword">assert</span> temp_12_100_100  <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> rh_12_100_100    <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> wsp_12_100_100   <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> wdir_12_100_100  <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> md1_12_100_100   <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> md10_12_100_100  <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> md100_12_100_100 <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> mlh_12_100_100   <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> mlw_12_100_100   <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> fm_12_100_100    <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> wsa_12_100_100   <span class="org-operator">==</span> 121010
</pre>
</div>
</div>
</div>
<div id="outline-container-Loading LANDFIRE Inputs (pyretechnics.load_landfire)" class="outline-3">
<h3 id="Loading LANDFIRE Inputs (pyretechnics.load_landfire)"><span class="section-number-3">15.4.</span> Loading LANDFIRE Inputs (pyretechnics.load_landfire)</h3>
<div class="outline-text-3" id="text-Loading LANDFIRE Inputs (pyretechnics.load_landfire)">
<p>
In order to use the functions from <code>pyretechnics.burn_cells</code> (see
section <a href="#Burning Cells on a Grid (pyretechnics.burn_cells)">8</a>), we must
first create a collection of <code>SpaceTimeCube</code> objects, representing all
of the input layers that are needed to describe the simulation
environment. A popular source of data for the space-varying
topography, fuels, and vegetation layers are the 30m raster layers
provided by the US LANDFIRE program<sup><a id="fnr.34" class="footref" href="#fn.34" role="doc-backlink">34</a></sup> (see
table <a href="#tab:landfire-layers">4</a> for details).
</p>

<table id="tab:landfire-layers">
<caption class="t-above"><span class="table-number">Table 4:</span> 2022 LANDFIRE Raster Layers</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Layer Name</th>
<th scope="col" class="org-left">Label</th>
<th scope="col" class="org-left">Units</th>
<th scope="col" class="org-right">Min</th>
<th scope="col" class="org-right">Max</th>
<th scope="col" class="org-right">NoData</th>
<th scope="col" class="org-left">Notes</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">SRID</th>
<th scope="col" class="org-left">Cell Size</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Elevation</td>
<td class="org-left">DEM</td>
<td class="org-left">meters above sea level</td>
<td class="org-right">0</td>
<td class="org-right">8850</td>
<td class="org-right">32767</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Slope</td>
<td class="org-left">SLP</td>
<td class="org-left">percent (100 * meters rise / meters run)</td>
<td class="org-right">0</td>
<td class="org-right">400</td>
<td class="org-right">32767</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Aspect</td>
<td class="org-left">ASP</td>
<td class="org-left">degrees CW from North</td>
<td class="org-right">0</td>
<td class="org-right">359</td>
<td class="org-right">32767</td>
<td class="org-left">-1 = no slope</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Fuel Model (S&amp;B 40)</td>
<td class="org-left">FBFM40</td>
<td class="org-left">integer classes</td>
<td class="org-right">91</td>
<td class="org-right">204</td>
<td class="org-right">32767</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Canopy Cover</td>
<td class="org-left">CC</td>
<td class="org-left">percent (100 * canopy area / total area)</td>
<td class="org-right">0</td>
<td class="org-right">95</td>
<td class="org-right">32767</td>
<td class="org-left">0 = no canopy</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Canopy Height</td>
<td class="org-left">CH</td>
<td class="org-left">meters * 10</td>
<td class="org-right">0</td>
<td class="org-right">510</td>
<td class="org-right">32767</td>
<td class="org-left">0 = no canopy</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Canopy Base Height</td>
<td class="org-left">CBH</td>
<td class="org-left">meters * 10</td>
<td class="org-right">0</td>
<td class="org-right">100</td>
<td class="org-right">32767</td>
<td class="org-left">0 = no canopy</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Canopy Bulk Density</td>
<td class="org-left">CBD</td>
<td class="org-left">kg/m^3 * 100</td>
<td class="org-right">0</td>
<td class="org-right">45</td>
<td class="org-right">32767</td>
<td class="org-left">0 = no canopy</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>
</tbody>
</table>

<p>
For convenience, this section introduces functionality to load these
raster layers from files on disk into a Python dictionary of
<code>SpaceTimeCube</code> objects.
</p>
</div>
<div id="outline-container-Loading Raster Files with Python Rasterio" class="outline-4">
<h4 id="Loading Raster Files with Python Rasterio"><span class="section-number-4">15.4.1.</span> Loading Raster Files with Python Rasterio</h4>
<div class="outline-text-4" id="text-Loading Raster Files with Python Rasterio">
<p>
We will begin by defining a <code>load_raster</code> function that takes a path
to a raster file (e.g., a GeoTIFF) and returns a dictionary containing
these keys:
</p>

<dl class="org-dl">
<dt>array</dt><dd>raster data as a 3D Numpy array <code>(bands, rows, cols)</code> of the specified <code>dtype</code> (default: <code>float32</code>)</dd>
<dt>metadata</dt><dd>dictionary of raster metadata values (e.g., number of bands/rows/cols, band dtypes, nodata value, georeferencing info)</dd>
</dl>

<div class="org-src-container">
<pre class="src src-python" id="load-raster"><span class="org-keyword">import</span> rasterio


<span class="org-keyword">def</span> <span class="org-function-name">raster_metadata</span>(raster):
    <span class="org-keyword">return</span> {
        <span class="org-string">"name"</span>      : raster.name,
        <span class="org-string">"bands"</span>     : raster.count,
        <span class="org-string">"rows"</span>      : raster.height,
        <span class="org-string">"cols"</span>      : raster.width,
        <span class="org-string">"band_types"</span>: {i: dtype <span class="org-keyword">for</span> i, dtype <span class="org-keyword">in</span> <span class="org-builtin">zip</span>(raster.indexes, raster.dtypes)},
        <span class="org-string">"nodata"</span>    : raster.nodata,
        <span class="org-string">"crs"</span>       : raster.crs,
        <span class="org-string">"bounds"</span>    : raster.bounds,
        <span class="org-string">"transform"</span> : raster.transform,
    }


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: rasterio.open can also load chunks of a raster file: https://pypi.org/project/rasterio/</span>
<span class="org-keyword">def</span> <span class="org-function-name">load_raster</span>(file_path, dtype<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-keyword">with</span> rasterio.<span class="org-builtin">open</span>(file_path, <span class="org-string">"r"</span>) <span class="org-keyword">as</span> input_raster:
        <span class="org-keyword">return</span> {
            <span class="org-string">"array"</span>   : input_raster.read(out_dtype<span class="org-operator">=</span>dtype),
            <span class="org-string">"metadata"</span>: raster_metadata(input_raster),
        }
</pre>
</div>
</div>
</div>
<div id="outline-container-Converting LANDFIRE Units and Datatypes" class="outline-4">
<h4 id="Converting LANDFIRE Units and Datatypes"><span class="section-number-4">15.4.2.</span> Converting LANDFIRE Units and Datatypes</h4>
<div class="outline-text-4" id="text-Converting LANDFIRE Units and Datatypes">
<p>
The units and datatypes of our LANDFIRE GeoTIFFs are documented in
Table <a href="#tab:landfire-layers">4</a>. In order to make them match those required
by the Pyretechnics Fire Spread API, we need to apply some conversions
during the layer loading process.
</p>

<div class="org-src-container">
<pre class="src src-python" id="load-and-convert-landfire-rasters"><span class="org-variable-name">landfire_array_conversions</span> <span class="org-operator">=</span> {
    <span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Layer Name         : (New dtype, Mult), # New Units                [Min-Max]</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================================</span>
    <span class="org-string">"elevation"</span>          : (<span class="org-string">"float32"</span>, 1.00), <span class="org-comment-delimiter"># </span><span class="org-comment">meters above sea level   [0-8850]</span>
    <span class="org-string">"slope"</span>              : (<span class="org-string">"float32"</span>, 0.01), <span class="org-comment-delimiter"># </span><span class="org-comment">meters rise / meters run [0-4]</span>
    <span class="org-string">"aspect"</span>             : (<span class="org-string">"int16"</span>  , 1   ), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees CW from North    [0-359]</span>
    <span class="org-string">"fuel_model"</span>         : (<span class="org-string">"int16"</span>  , 1   ), <span class="org-comment-delimiter"># </span><span class="org-comment">integer classes          [1-204]</span>
    <span class="org-string">"canopy_cover"</span>       : (<span class="org-string">"float32"</span>, 0.01), <span class="org-comment-delimiter"># </span><span class="org-comment">canopy area / total area [0-0.95]</span>
    <span class="org-string">"canopy_height"</span>      : (<span class="org-string">"float32"</span>, 0.10), <span class="org-comment-delimiter"># </span><span class="org-comment">meters                   [0-51]</span>
    <span class="org-string">"canopy_base_height"</span> : (<span class="org-string">"float32"</span>, 0.10), <span class="org-comment-delimiter"># </span><span class="org-comment">meters                   [0-10]</span>
    <span class="org-string">"canopy_bulk_density"</span>: (<span class="org-string">"float32"</span>, 0.01), <span class="org-comment-delimiter"># </span><span class="org-comment">kilograms/meters^3       [0-0.45]</span>
}


<span class="org-keyword">def</span> <span class="org-function-name">load_and_convert_landfire_rasters</span>(landfire_file_paths):
    <span class="org-variable-name">landfire_rasters</span> <span class="org-operator">=</span> {}

    <span class="org-keyword">for</span> name, path <span class="org-keyword">in</span> landfire_file_paths.items():
        (<span class="org-variable-name">dtype</span>, <span class="org-variable-name">multiplier</span>) <span class="org-operator">=</span> landfire_array_conversions[name]
        <span class="org-variable-name">landfire_rasters</span>[name] <span class="org-operator">=</span> load_raster(path, dtype)
        <span class="org-keyword">if</span> multiplier <span class="org-operator">!=</span> 1:
            <span class="org-variable-name">array</span>  <span class="org-operator">=</span> landfire_rasters[name][<span class="org-string">"array"</span>]
            <span class="org-variable-name">nodata</span> <span class="org-operator">=</span> landfire_rasters[name][<span class="org-string">"metadata"</span>][<span class="org-string">"nodata"</span>]
            <span class="org-variable-name">array</span>[array <span class="org-operator">!=</span> nodata] <span class="org-operator">*=</span> multiplier

    <span class="org-keyword">return</span> landfire_rasters
</pre>
</div>
</div>
</div>
<div id="outline-container-Verifying Raster Constraints" class="outline-4">
<h4 id="Verifying Raster Constraints"><span class="section-number-4">15.4.3.</span> Verifying Raster Constraints</h4>
<div class="outline-text-4" id="text-Verifying Raster Constraints">
<p>
In order to work with the Pyretechnics Fire Spread API, all rasters
must meet certain requirements:
</p>

<ol class="org-ol">
<li>All rasters must have array shapes <code>(bands, rows, cols)</code> that evenly divide a user-specified space-time cube shape <code>(t,y,x)</code>.</li>
<li>All rasters must share the same spatial extent and projection.</li>
</ol>

<p>
Below we implement functions to check these constraints:
</p>

<div class="org-src-container">
<pre class="src src-python" id="verify-raster-constraints"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np


<span class="org-keyword">def</span> <span class="org-function-name">verify_cube_compatible_dimensions</span>(cube_shape, rasters):
    <span class="org-variable-name">cube_shape_</span> <span class="org-operator">=</span> np.asarray(cube_shape)
    <span class="org-keyword">for</span> r <span class="org-keyword">in</span> rasters:
        <span class="org-variable-name">raster_shape</span> <span class="org-operator">=</span> np.asarray((r[<span class="org-string">"metadata"</span>][<span class="org-string">"bands"</span>],
                                   r[<span class="org-string">"metadata"</span>][<span class="org-string">"rows"</span>],
                                   r[<span class="org-string">"metadata"</span>][<span class="org-string">"cols"</span>]))
        <span class="org-keyword">if</span> <span class="org-builtin">any</span>(<span class="org-builtin">map</span>(<span class="org-keyword">lambda</span> x: x <span class="org-operator">!=</span> 0, cube_shape_ <span class="org-operator">%</span> raster_shape)):
            <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"Some rasters do not evenly divide the space-time cube dimensions."</span>)

    <span class="org-keyword">return</span> <span class="org-constant">True</span>


<span class="org-keyword">def</span> <span class="org-function-name">verify_same_georeferences</span>(rasters):
    <span class="org-variable-name">georeferences</span> <span class="org-operator">=</span> [
        (r[<span class="org-string">"metadata"</span>][<span class="org-string">"crs"</span>],
         r[<span class="org-string">"metadata"</span>][<span class="org-string">"bounds"</span>],
         r[<span class="org-string">"metadata"</span>][<span class="org-string">"transform"</span>])
        <span class="org-keyword">for</span> r <span class="org-keyword">in</span> rasters
    ]
    <span class="org-keyword">if</span> <span class="org-builtin">len</span>(<span class="org-builtin">set</span>(georeferences)) <span class="org-operator">==</span> 1:
        <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">else</span>:
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"All rasters do not share the same georeferences."</span>)


<span class="org-keyword">def</span> <span class="org-function-name">verify_raster_constraints</span>(cube_shape, rasters):
    <span class="org-keyword">return</span> verify_cube_compatible_dimensions(cube_shape, rasters) <span class="org-keyword">and</span> verify_same_georeferences(rasters)
</pre>
</div>
</div>
</div>
<div id="outline-container-Converting Rasters to SpaceTimeCubes" class="outline-4">
<h4 id="Converting Rasters to SpaceTimeCubes"><span class="section-number-4">15.4.4.</span> Converting Rasters to SpaceTimeCubes</h4>
<div class="outline-text-4" id="text-Converting Rasters to SpaceTimeCubes">
<p>
Another requirement of the Pyretechnics Fire Spread API is that each
input layer must be specified as a <code>SpaceTimeCube</code> or
<code>LazySpaceTimeCube</code> object (see section <a href="#Loading Data into the 3D Space-Time Cube (pyretechnics.space_time_cube)">3</a>). This abstracts away
the underlying data representation (e.g., an ND array, a single
constant value, a random sampling function), allowing many different
sources of information to interoperate through a simple unified
interface.
</p>

<p>
For our LANDFIRE use case, the following function converts a
dictionary of single-band rasters <code>(1, rows, cols)</code> into a dictionary
of <code>SpaceTimeCube</code> objects, that always return the same value for each
<code>(t,y,x)</code> coordinate regardless of the time value <code>t</code> specified in
lookup calls.
</p>

<div class="org-src-container">
<pre class="src src-python" id="convert-rasters-to-space-time-cubes"><span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube


<span class="org-keyword">def</span> <span class="org-function-name">convert_rasters_to_space_time_cubes</span>(cube_shape, raster_dict):
    <span class="org-variable-name">fn_dict</span> <span class="org-operator">=</span> {}

    <span class="org-keyword">for</span> name, raster <span class="org-keyword">in</span> raster_dict.items():
        <span class="org-variable-name">fn_dict</span>[name] <span class="org-operator">=</span> SpaceTimeCube(cube_shape, raster[<span class="org-string">"array"</span>])

    <span class="org-keyword">return</span> fn_dict
</pre>
</div>
</div>
</div>
<div id="outline-container-Putting It All Together" class="outline-4">
<h4 id="Putting It All Together"><span class="section-number-4">15.4.5.</span> Putting It All Together</h4>
<div class="outline-text-4" id="text-Putting It All Together">
<p>
By combining the functions defined in the previous sections, we can
now read in a dictionary of layer names to file paths, load the
associated rasters and apply the correct dtype and unit conversions,
verify all of our raster constraints, and wrap each raster's array
with a <code>SpaceTimeCube</code> object.
</p>

<div class="org-src-container">
<pre class="src src-python" id="read-landfire-rasters-as-space-time-cubes"><span class="org-keyword">def</span> <span class="org-function-name">read_landfire_rasters_as_space_time_cubes</span>(cube_shape, landfire_file_paths):
    <span class="org-variable-name">landfire_rasters</span> <span class="org-operator">=</span> load_and_convert_landfire_rasters(landfire_file_paths)
    <span class="org-keyword">if</span> verify_raster_constraints(cube_shape, landfire_rasters.values()):
        <span class="org-keyword">return</span> convert_rasters_to_space_time_cubes(cube_shape, landfire_rasters)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-[WIP] Testing pyretechnics.burn_cells on Worcester, VT (pyretechnics_test.test_burn_cells)" class="outline-3">
<h3 id="[WIP] Testing pyretechnics.burn_cells on Worcester, VT (pyretechnics_test.test_burn_cells)"><span class="section-number-3">15.5.</span> [WIP] Testing pyretechnics.burn_cells on Worcester, VT (pyretechnics_test.test_burn_cells)</h3>
<div class="outline-text-3" id="text-[WIP] Testing pyretechnics.burn_cells on Worcester, VT (pyretechnics_test.test_burn_cells)">
<p>
<b>Note:</b> For testing purposes, we have downloaded the LANDFIRE rasters
described in table <a href="#tab:landfire-layers">4</a>, clipped to a small region in
central Vermont, and stored them in the <a href="../test/data/landfire_inputs">../test/data/landfire_inputs</a>
directory of this repository.
</p>
</div>
<div id="outline-container-Loading Topography, Fuel Model, and Tree Canopy Inputs from LANDFIRE GeoTIFFs" class="outline-4">
<h4 id="Loading Topography, Fuel Model, and Tree Canopy Inputs from LANDFIRE GeoTIFFs"><span class="section-number-4">15.5.1.</span> Loading Topography, Fuel Model, and Tree Canopy Inputs from LANDFIRE GeoTIFFs</h4>
<div class="outline-text-4" id="text-Loading Topography, Fuel Model, and Tree Canopy Inputs from LANDFIRE GeoTIFFs">
<p>
We begin by loading in the eight LANDFIRE GeoTIFFs that we downloaded
from <a href="https://landfire.gov/">https://landfire.gov/</a>, using the function we defined in section
<a href="#Putting It All Together">15.4.5</a>.
</p>

<div class="org-src-container">
<pre class="src src-python" id="add-landfire-layers-to-test-dataset"><span class="org-keyword">import</span> os
<span class="org-keyword">from</span> pyretechnics.load_landfire <span class="org-keyword">import</span> read_landfire_rasters_as_space_time_cubes
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube


<span class="org-keyword">def</span> <span class="org-function-name">get_project_root</span>(current_dir<span class="org-operator">=</span>os.curdir):
    <span class="org-doc">"""</span>
<span class="org-doc">    Search up the directory tree from current_dir until we find a directory containing guix.scm,</span>
<span class="org-doc">    and return this directory path. If the filesystem root directory (/) is reached, return None.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">if</span> current_dir <span class="org-operator">==</span> <span class="org-string">"/"</span>:
        <span class="org-keyword">return</span> <span class="org-constant">None</span>
    <span class="org-keyword">elif</span> os.path.exists(current_dir <span class="org-operator">+</span> <span class="org-string">"/guix.scm"</span>):
        <span class="org-keyword">return</span> current_dir
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> get_project_root(os.path.dirname(os.path.abspath(current_dir)))


<span class="org-variable-name">project_root</span> <span class="org-operator">=</span> get_project_root()


<span class="org-variable-name">landfire_file_paths</span> <span class="org-operator">=</span> {
    <span class="org-string">"elevation"</span>          : project_root <span class="org-operator">+</span> <span class="org-string">"/test/data/landfire_inputs/LF2020_Elev_220_CONUS/LC20_Elev_220.tif"</span>,
    <span class="org-string">"slope"</span>              : project_root <span class="org-operator">+</span> <span class="org-string">"/test/data/landfire_inputs/LF2020_SlpP_220_CONUS/LC20_SlpP_220.tif"</span>,
    <span class="org-string">"aspect"</span>             : project_root <span class="org-operator">+</span> <span class="org-string">"/test/data/landfire_inputs/LF2020_Asp_220_CONUS/LC20_Asp_220.tif"</span>,
    <span class="org-string">"fuel_model"</span>         : project_root <span class="org-operator">+</span> <span class="org-string">"/test/data/landfire_inputs/LF2022_FBFM40_230_CONUS/LC22_F40_230.tif"</span>,
    <span class="org-string">"canopy_cover"</span>       : project_root <span class="org-operator">+</span> <span class="org-string">"/test/data/landfire_inputs/LF2022_CC_230_CONUS/LC22_CC_230.tif"</span>,
    <span class="org-string">"canopy_height"</span>      : project_root <span class="org-operator">+</span> <span class="org-string">"/test/data/landfire_inputs/LF2022_CH_230_CONUS/LC22_CH_230.tif"</span>,
    <span class="org-string">"canopy_base_height"</span> : project_root <span class="org-operator">+</span> <span class="org-string">"/test/data/landfire_inputs/LF2022_CBH_230_CONUS/LC22_CBH_230.tif"</span>,
    <span class="org-string">"canopy_bulk_density"</span>: project_root <span class="org-operator">+</span> <span class="org-string">"/test/data/landfire_inputs/LF2022_CBD_230_CONUS/LC22_CBD_230.tif"</span>,
}

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (1, 613, 549) <span class="org-comment-delimiter"># </span><span class="org-comment">Matches the resolution of the GeoTIFFs</span>

<span class="org-keyword">def</span> <span class="org-function-name">test_read_landfire_rasters</span>():
    <span class="org-variable-name">input_layer_dict</span> <span class="org-operator">=</span> read_landfire_rasters_as_space_time_cubes(cube_shape, landfire_file_paths)
    <span class="org-keyword">assert</span> <span class="org-builtin">type</span>(input_layer_dict) <span class="org-operator">==</span> <span class="org-builtin">dict</span>
    <span class="org-keyword">assert</span> input_layer_dict.keys() <span class="org-operator">==</span> landfire_file_paths.keys()
    <span class="org-keyword">assert</span> <span class="org-builtin">all</span>(<span class="org-builtin">map</span>(<span class="org-keyword">lambda</span> cube: <span class="org-builtin">isinstance</span>(cube, SpaceTimeCube), input_layer_dict.values()))
    <span class="org-keyword">return</span> input_layer_dict
</pre>
</div>
</div>
</div>
<div id="outline-container-Adding Constant Wind and Moisture Values" class="outline-4">
<h4 id="Adding Constant Wind and Moisture Values"><span class="section-number-4">15.5.2.</span> Adding Constant Wind and Moisture Values</h4>
<div class="outline-text-4" id="text-Adding Constant Wind and Moisture Values">
<p>
In order to complete our input dataset for a test run of the
<code>pyretechnics.burn_cells</code> functions, we need to provide the remaining
required wind and moisture layers as <code>SpaceTimeCube</code> objects. The
following example shows how we can easily set constant values for each
of these layers:
</p>

<div class="org-src-container">
<pre class="src src-python" id="add-constant-wind-and-moisture-to-test-dataset"><span class="org-variable-name">weather_cubes</span> <span class="org-operator">=</span> {
    <span class="org-string">"wind_speed_10m"</span>               : SpaceTimeCube(cube_shape, 0.00), <span class="org-comment-delimiter"># </span><span class="org-comment">km/hr</span>
    <span class="org-string">"upwind_direction"</span>             : SpaceTimeCube(cube_shape, 0.00), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees clockwise from North</span>
    <span class="org-string">"fuel_moisture_dead_1hr"</span>       : SpaceTimeCube(cube_shape, 0.06), <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_10hr"</span>      : SpaceTimeCube(cube_shape, 0.08), <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_dead_100hr"</span>     : SpaceTimeCube(cube_shape, 0.10), <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_herbaceous"</span>: SpaceTimeCube(cube_shape, 0.75), <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"fuel_moisture_live_woody"</span>     : SpaceTimeCube(cube_shape, 0.60), <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
    <span class="org-string">"foliar_moisture"</span>              : SpaceTimeCube(cube_shape, 1.20), <span class="org-comment-delimiter"># </span><span class="org-comment">kg moisture/kg ovendry weight</span>
}


<span class="org-keyword">def</span> <span class="org-function-name">test_add_weather_cubes</span>():
    <span class="org-variable-name">input_layer_dict</span> <span class="org-operator">=</span> test_read_landfire_rasters()
    input_layer_dict.update(weather_cubes)
    <span class="org-keyword">assert</span> <span class="org-builtin">type</span>(input_layer_dict) <span class="org-operator">==</span> <span class="org-builtin">dict</span>
    <span class="org-keyword">assert</span> <span class="org-builtin">set</span>(input_layer_dict.keys()) <span class="org-operator">==</span> <span class="org-builtin">set</span>(landfire_file_paths.keys()).union(<span class="org-builtin">set</span>(weather_cubes.keys()))
    <span class="org-keyword">assert</span> <span class="org-builtin">all</span>(<span class="org-builtin">map</span>(<span class="org-keyword">lambda</span> cube: <span class="org-builtin">isinstance</span>(cube, SpaceTimeCube), input_layer_dict.values()))
    <span class="org-keyword">return</span> input_layer_dict
</pre>
</div>
</div>
</div>
<div id="outline-container-Burning a Single Cell in the Dataset as a Head Fire" class="outline-4">
<h4 id="Burning a Single Cell in the Dataset as a Head Fire"><span class="section-number-4">15.5.3.</span> Burning a Single Cell in the Dataset as a Head Fire</h4>
<div class="outline-text-4" id="text-Burning a Single Cell in the Dataset as a Head Fire">
<p>
Now that our input layers are all loaded, our next step will be to
make sure that we can burn a single cell as a head fire and get back
meaningful results.
</p>

<div class="org-src-container">
<pre class="src src-python" id="burn-single-cell-in-test-dataset"><span class="org-keyword">from</span> pyretechnics.burn_cells <span class="org-keyword">import</span> burn_cell_as_head_fire


<span class="org-keyword">def</span> <span class="org-function-name">test_burn_cell_as_head_fire</span>():
    <span class="org-variable-name">input_layer_dict</span>           <span class="org-operator">=</span> test_add_weather_cubes()
    <span class="org-variable-name">space_time_coordinate</span>      <span class="org-operator">=</span> (0, 100, 100) <span class="org-comment-delimiter"># </span><span class="org-comment">(t,y,x)</span>
    <span class="org-variable-name">result</span>                     <span class="org-operator">=</span> burn_cell_as_head_fire(input_layer_dict, space_time_coordinate)
    <span class="org-variable-name">result</span>[<span class="org-string">"spread_direction"</span>] <span class="org-operator">=</span> <span class="org-builtin">list</span>(result[<span class="org-string">"spread_direction"</span>])

    <span class="org-keyword">assert</span> result[<span class="org-string">"fire_type"</span>] <span class="org-operator">==</span> <span class="org-string">"surface"</span>
    <span class="org-keyword">assert</span> result[<span class="org-string">"spread_rate"</span>]         <span class="org-operator">-</span> 0.32044995422500555 <span class="org-operator">&lt;</span> 0.001
    <span class="org-keyword">assert</span> result[<span class="org-string">"spread_direction"</span>][0] <span class="org-operator">-</span> 0.644528432121562   <span class="org-operator">&lt;</span> 0.001
    <span class="org-keyword">assert</span> result[<span class="org-string">"spread_direction"</span>][1] <span class="org-operator">-</span> 0.7414451458683358  <span class="org-operator">&lt;</span> 0.001
    <span class="org-keyword">assert</span> result[<span class="org-string">"spread_direction"</span>][2] <span class="org-operator">-</span> 0.18666064356259804 <span class="org-operator">&lt;</span> 0.001
    <span class="org-keyword">assert</span> result[<span class="org-string">"fireline_intensity"</span>]  <span class="org-operator">-</span> 26.66139842420774   <span class="org-operator">&lt;</span> 0.001
    <span class="org-keyword">assert</span> result[<span class="org-string">"flame_length"</span>]        <span class="org-operator">-</span> 0.3507858529698898  <span class="org-operator">&lt;</span> 0.001

    <span class="org-keyword">return</span> result
</pre>
</div>
</div>
</div>
<div id="outline-container-Burning All Cells in the Dataset as a Head Fire" class="outline-4">
<h4 id="Burning All Cells in the Dataset as a Head Fire"><span class="section-number-4">15.5.4.</span> Burning All Cells in the Dataset as a Head Fire</h4>
<div class="outline-text-4" id="text-Burning All Cells in the Dataset as a Head Fire">
<div class="org-src-container">
<pre class="src src-python" id="burn-all-cells-in-test-dataset"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pyretechnics.burn_cells <span class="org-keyword">import</span> burn_cell_as_head_fire
<span class="org-keyword">import</span> pyretechnics.conversion <span class="org-keyword">as</span> conv
<span class="org-keyword">import</span> pyretechnics.vector_utils <span class="org-keyword">as</span> vu


<span class="org-variable-name">fire_type_codes</span> <span class="org-operator">=</span> {
    <span class="org-string">"unburned"</span>      : 0,
    <span class="org-string">"surface"</span>       : 1,
    <span class="org-string">"passive_crown"</span> : 2,
    <span class="org-string">"active_crown"</span>  : 3,
}


<span class="org-keyword">def</span> <span class="org-function-name">spread_direction_vector_to_angle</span>(vector_3d):
    (<span class="org-variable-name">x</span>, <span class="org-variable-name">y</span>)       <span class="org-operator">=</span> vu.to_horizontal_plane(vector_3d)
    (<span class="org-variable-name">r</span>, <span class="org-variable-name">azimuth</span>) <span class="org-operator">=</span> conv.cartesian_to_azimuthal(x, y)
    <span class="org-keyword">return</span> azimuth


<span class="org-keyword">def</span> <span class="org-function-name">test_burn_all_cells_as_head_fire</span>():
    <span class="org-variable-name">input_layer_dict</span>     <span class="org-operator">=</span> test_add_weather_cubes()
    (<span class="org-variable-name">_bands</span>, <span class="org-variable-name">rows</span>, <span class="org-variable-name">cols</span>) <span class="org-operator">=</span> input_layer_dict[<span class="org-string">"elevation"</span>].shape
    <span class="org-variable-name">output_layer_shape</span>   <span class="org-operator">=</span> (rows, cols)

    <span class="org-variable-name">max_fire_type_matrix</span>          <span class="org-operator">=</span> np.zeros(output_layer_shape, dtype<span class="org-operator">=</span><span class="org-string">"uint8"</span>)
    <span class="org-variable-name">max_spread_rate_matrix</span>        <span class="org-operator">=</span> np.zeros(output_layer_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)
    <span class="org-variable-name">max_spread_direction_matrix</span>   <span class="org-operator">=</span> np.zeros(output_layer_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)
    <span class="org-variable-name">max_fireline_intensity_matrix</span> <span class="org-operator">=</span> np.zeros(output_layer_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)
    <span class="org-variable-name">max_flame_length_matrix</span>       <span class="org-operator">=</span> np.zeros(output_layer_shape, dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)

    <span class="org-keyword">for</span> y <span class="org-keyword">in</span> <span class="org-builtin">range</span>(rows):
        <span class="org-keyword">for</span> x <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cols):
            <span class="org-variable-name">space_time_coordinate</span>              <span class="org-operator">=</span> (0, y, x) <span class="org-comment-delimiter"># </span><span class="org-comment">(t,y,x)</span>
            <span class="org-variable-name">results</span>                            <span class="org-operator">=</span> burn_cell_as_head_fire(input_layer_dict, space_time_coordinate)
            <span class="org-variable-name">max_fire_type_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]          <span class="org-operator">=</span> fire_type_codes[results[<span class="org-string">"fire_type"</span>]]
            <span class="org-variable-name">max_spread_rate_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]        <span class="org-operator">=</span> results[<span class="org-string">"spread_rate"</span>]
            <span class="org-variable-name">max_spread_direction_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]   <span class="org-operator">=</span> spread_direction_vector_to_angle(results[<span class="org-string">"spread_direction"</span>])
            <span class="org-variable-name">max_fireline_intensity_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>] <span class="org-operator">=</span> results[<span class="org-string">"fireline_intensity"</span>]
            <span class="org-variable-name">max_flame_length_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]       <span class="org-operator">=</span> results[<span class="org-string">"flame_length"</span>]

    <span class="org-keyword">return</span> {
        <span class="org-string">"max_fire_type"</span>         : max_fire_type_matrix,
        <span class="org-string">"max_spread_rate"</span>       : max_spread_rate_matrix,
        <span class="org-string">"max_spread_direction"</span>  : max_spread_direction_matrix,
        <span class="org-string">"max_fireline_intensity"</span>: max_fireline_intensity_matrix,
        <span class="org-string">"max_flame_length"</span>      : max_flame_length_matrix,
    }
</pre>
</div>
</div>
</div>
<div id="outline-container-Comparing Pyretechnics Outputs with FLAMMAP Outputs" class="outline-4">
<h4 id="Comparing Pyretechnics Outputs with FLAMMAP Outputs"><span class="section-number-4">15.5.5.</span> Comparing Pyretechnics Outputs with FLAMMAP Outputs</h4>
<div class="outline-text-4" id="text-Comparing Pyretechnics Outputs with FLAMMAP Outputs">
<div class="org-src-container">
<pre class="src src-python" id="load-flammap-outputs"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> pi
<span class="org-keyword">from</span> pyretechnics.load_landfire <span class="org-keyword">import</span> load_raster, verify_raster_constraints


<span class="org-variable-name">flammap_file_paths</span> <span class="org-operator">=</span> {
    <span class="org-string">"max_fire_type"</span>         : project_root <span class="org-operator">+</span> <span class="org-string">"/test/data/flammap_outputs/fire_type.tif"</span>,
    <span class="org-string">"max_spread_rate"</span>       : project_root <span class="org-operator">+</span> <span class="org-string">"/test/data/flammap_outputs/ROS_ch_hr.tif"</span>,
    <span class="org-string">"max_spread_direction"</span>  : project_root <span class="org-operator">+</span> <span class="org-string">"/test/data/flammap_outputs/max_spread_direction_radians.tif"</span>,
    <span class="org-string">"max_fireline_intensity"</span>: project_root <span class="org-operator">+</span> <span class="org-string">"/test/data/flammap_outputs/FLI_BTU_ft-s.tif"</span>,
    <span class="org-string">"max_flame_length"</span>      : project_root <span class="org-operator">+</span> <span class="org-string">"/test/data/flammap_outputs/FL_ft.tif"</span>,
}


<span class="org-variable-name">flammap_array_conversions</span> <span class="org-operator">=</span> {
    <span class="org-comment-delimiter">#</span><span class="org-comment">====================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Layer Name            : (New dtype, Mult),                # In Units -&gt; Out Units</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">====================================================================================</span>
    <span class="org-string">"max_fire_type"</span>         : (<span class="org-string">"uint8"</span>  , 1.0),                 <span class="org-comment-delimiter"># </span><span class="org-comment">0=unburned,1=surface,2=passive_crown,3=active_crown</span>
    <span class="org-string">"max_spread_rate"</span>       : (<span class="org-string">"float32"</span>, 0.33528),             <span class="org-comment-delimiter"># </span><span class="org-comment">ch/hr -&gt; m/min</span>
    <span class="org-string">"max_spread_direction"</span>  : (<span class="org-string">"float32"</span>, 180.0 <span class="org-operator">/</span> pi),          <span class="org-comment-delimiter"># </span><span class="org-comment">radians -&gt; degrees</span>
    <span class="org-string">"max_fireline_intensity"</span>: (<span class="org-string">"float32"</span>, 3.46165186),          <span class="org-comment-delimiter"># </span><span class="org-comment">Btu/ft/s -&gt; kW/m</span>
    <span class="org-string">"max_flame_length"</span>      : (<span class="org-string">"float32"</span>, 0.30478512648582745), <span class="org-comment-delimiter"># </span><span class="org-comment">ft -&gt; m</span>
}


<span class="org-keyword">def</span> <span class="org-function-name">load_and_convert_flammap_rasters</span>(flammap_file_paths):
    <span class="org-variable-name">flammap_rasters</span> <span class="org-operator">=</span> {}

    <span class="org-keyword">for</span> name, path <span class="org-keyword">in</span> flammap_file_paths.items():
        (<span class="org-variable-name">dtype</span>, <span class="org-variable-name">multiplier</span>)    <span class="org-operator">=</span> flammap_array_conversions[name]
        <span class="org-variable-name">flammap_rasters</span>[name]  <span class="org-operator">=</span> load_raster(path, dtype)
        <span class="org-variable-name">array</span>                  <span class="org-operator">=</span> flammap_rasters[name][<span class="org-string">"array"</span>]
        <span class="org-variable-name">nodata</span>                 <span class="org-operator">=</span> flammap_rasters[name][<span class="org-string">"metadata"</span>][<span class="org-string">"nodata"</span>]
        <span class="org-variable-name">array</span>[array <span class="org-operator">==</span> nodata] <span class="org-operator">=</span> 0
        <span class="org-keyword">if</span> multiplier <span class="org-operator">!=</span> 1:
            <span class="org-variable-name">array</span> <span class="org-operator">*=</span> multiplier

    <span class="org-keyword">return</span> flammap_rasters


<span class="org-keyword">def</span> <span class="org-function-name">read_flammap_outputs</span>(flammap_file_paths):
    <span class="org-variable-name">cube_shape</span>  <span class="org-operator">=</span> (1, 613, 549) <span class="org-comment-delimiter"># </span><span class="org-comment">Matches the resolution of the GeoTIFFs</span>
    <span class="org-variable-name">raster_dict</span> <span class="org-operator">=</span> load_and_convert_flammap_rasters(flammap_file_paths)
    <span class="org-keyword">if</span> verify_raster_constraints(cube_shape, raster_dict.values()):
        <span class="org-keyword">return</span> {name: raster[<span class="org-string">"array"</span>] <span class="org-keyword">for</span> name, raster <span class="org-keyword">in</span> raster_dict.items()}


<span class="org-keyword">def</span> <span class="org-function-name">test_read_flammap_outputs</span>():
    <span class="org-keyword">return</span> read_flammap_outputs(flammap_file_paths)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-[WIP] Visualizing the Burned Layers" class="outline-3">
<h3 id="[WIP] Visualizing the Burned Layers"><span class="section-number-3">15.6.</span> [WIP] Visualizing the Burned Layers</h3>
<div class="outline-text-3" id="text-[WIP] Visualizing the Burned Layers">
<div class="org-src-container">
<pre class="src src-python" id="compute-worcester-burned-layers"><span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt
<span class="org-comment-delimiter"># </span><span class="org-comment">import numpy as np</span>
<span class="org-keyword">from</span> pyretechnics_test.test_burn_cells <span class="org-keyword">import</span> test_burn_all_cells_as_head_fire, test_read_flammap_outputs


<span class="org-variable-name">pyretechnics</span> <span class="org-operator">=</span> test_burn_all_cells_as_head_fire()
<span class="org-variable-name">flammap</span>      <span class="org-operator">=</span> test_read_flammap_outputs()


<span class="org-keyword">def</span> <span class="org-function-name">savefig</span>(title, layer, units, colors):
    <span class="org-variable-name">title</span>     <span class="org-operator">=</span> <span class="org-string">"Worcester, VT - "</span> <span class="org-operator">+</span> title
    <span class="org-variable-name">file_name</span> <span class="org-operator">=</span> <span class="org-string">"../doc/pics/worcester_"</span> <span class="org-operator">+</span> layer <span class="org-operator">+</span> <span class="org-string">".png"</span>
    <span class="org-variable-name">image</span>     <span class="org-operator">=</span> plt.imshow(pyretechnics[layer], cmap<span class="org-operator">=</span>colors)
    <span class="org-comment-delimiter"># </span><span class="org-comment">image     = plt.imshow(flammap[layer][0], cmap=colors)</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">image     = plt.imshow(pyretechnics[layer] - flammap[layer][0], cmap=colors)</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">copy      = np.zeros((613, 549))</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">copy[crown_fire == 0] = (pyretechnics[layer][crown_fire == 0] - flammap[layer][0][crown_fire == 0])</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">image     = plt.imshow(copy, clim=(-0.05,0.05))</span>
    <span class="org-variable-name">colorbar</span>  <span class="org-operator">=</span> plt.colorbar(image, orientation<span class="org-operator">=</span><span class="org-string">"vertical"</span>)
    colorbar.set_label(units)
    plt.title(title)
    plt.savefig(file_name)
    plt.close(<span class="org-string">"all"</span>)
    <span class="org-keyword">return</span> file_name
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">savefig(title<span class="org-operator">=</span><span class="org-string">"Max Fire Type"</span>, layer<span class="org-operator">=</span><span class="org-string">"max_fire_type"</span>, units<span class="org-operator">=</span><span class="org-string">"0=unburned,1=surface,2=passive_crown,3=active_crown"</span>, colors<span class="org-operator">=</span><span class="org-string">"viridis"</span>)
</pre>
</div>


<div id="org4ad5151" class="figure">
<p><img src="../doc/pics/worcester_max_fire_type.png" alt="worcester_max_fire_type.png">
</p>
</div>

<div class="org-src-container">
<pre class="src src-python">savefig(title<span class="org-operator">=</span><span class="org-string">"Max Spread Rate"</span>, layer<span class="org-operator">=</span><span class="org-string">"max_spread_rate"</span>, units<span class="org-operator">=</span><span class="org-string">"m/min"</span>, colors<span class="org-operator">=</span><span class="org-string">"hot"</span>)
</pre>
</div>


<div id="orga68919e" class="figure">
<p><img src="../doc/pics/worcester_max_spread_rate.png" alt="worcester_max_spread_rate.png">
</p>
</div>

<p>
Layer Disagreement: [-10.93608, 8.9857025] inches/min
</p>

<div class="org-src-container">
<pre class="src src-python">savefig(title<span class="org-operator">=</span><span class="org-string">"Max Spread Direction"</span>, layer<span class="org-operator">=</span><span class="org-string">"max_spread_direction"</span>, units<span class="org-operator">=</span><span class="org-string">"degrees"</span>, colors<span class="org-operator">=</span><span class="org-string">"viridis"</span>)
</pre>
</div>


<div id="org87aa3e5" class="figure">
<p><img src="../doc/pics/worcester_max_spread_direction.png" alt="worcester_max_spread_direction.png">
</p>
</div>

<div class="org-src-container">
<pre class="src src-python">savefig(title<span class="org-operator">=</span><span class="org-string">"Max Fireline Intensity"</span>, layer<span class="org-operator">=</span><span class="org-string">"max_fireline_intensity"</span>, units<span class="org-operator">=</span><span class="org-string">"kW/m"</span>, colors<span class="org-operator">=</span><span class="org-string">"hot"</span>)
</pre>
</div>


<div id="orgf52f53e" class="figure">
<p><img src="../doc/pics/worcester_max_fireline_intensity.png" alt="worcester_max_fireline_intensity.png">
</p>
</div>

<div class="org-src-container">
<pre class="src src-python">savefig(title<span class="org-operator">=</span><span class="org-string">"Max Flame Length"</span>, layer<span class="org-operator">=</span><span class="org-string">"max_flame_length"</span>, units<span class="org-operator">=</span><span class="org-string">"m"</span>, colors<span class="org-operator">=</span><span class="org-string">"hot"</span>)
</pre>
</div>


<div id="orga44391a" class="figure">
<p><img src="../doc/pics/worcester_max_flame_length.png" alt="worcester_max_flame_length.png">
</p>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://en.wikipedia.org/wiki/Literate_programming">https://en.wikipedia.org/wiki/Literate_programming</a></p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://guix.gnu.org">https://guix.gnu.org</a></p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://landfire.gov">https://landfire.gov</a></p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://www.nco.ncep.noaa.gov/pmb/products/rtma/">https://www.nco.ncep.noaa.gov/pmb/products/rtma/</a></p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5" role="doc-backlink">5</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Anderson1982</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6" role="doc-backlink">6</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Scott2005</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7" role="doc-backlink">7</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Burgan1979</p></div></div>

<div class="footdef"><sup><a id="fn.8" class="footnum" href="#fnr.8" role="doc-backlink">8</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Rothermel1972</p></div></div>

<div class="footdef"><sup><a id="fn.9" class="footnum" href="#fnr.9" role="doc-backlink">9</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Rothermel1972</p></div></div>

<div class="footdef"><sup><a id="fn.10" class="footnum" href="#fnr.10" role="doc-backlink">10</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1976</p></div></div>

<div class="footdef"><sup><a id="fn.11" class="footnum" href="#fnr.11" role="doc-backlink">11</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Rothermel1972</p></div></div>

<div class="footdef"><sup><a id="fn.12" class="footnum" href="#fnr.12" role="doc-backlink">12</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1976</p></div></div>

<div class="footdef"><sup><a id="fn.13" class="footnum" href="#fnr.13" role="doc-backlink">13</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Andrews2018</p></div></div>

<div class="footdef"><sup><a id="fn.14" class="footnum" href="#fnr.14" role="doc-backlink">14</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Anderson1969</p></div></div>

<div class="footdef"><sup><a id="fn.15" class="footnum" href="#fnr.15" role="doc-backlink">15</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Byram1959</p></div></div>

<div class="footdef"><sup><a id="fn.16" class="footnum" href="#fnr.16" role="doc-backlink">16</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1976</p></div></div>

<div class="footdef"><sup><a id="fn.17" class="footnum" href="#fnr.17" role="doc-backlink">17</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1979</p></div></div>

<div class="footdef"><sup><a id="fn.18" class="footnum" href="#fnr.18" role="doc-backlink">18</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Andrews2012</p></div></div>

<div class="footdef"><sup><a id="fn.19" class="footnum" href="#fnr.19" role="doc-backlink">19</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Rothermel1983</p></div></div>

<div class="footdef"><sup><a id="fn.20" class="footnum" href="#fnr.20" role="doc-backlink">20</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Waeselynck2024</p></div></div>

<div class="footdef"><sup><a id="fn.21" class="footnum" href="#fnr.21" role="doc-backlink">21</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1980</p></div></div>

<div class="footdef"><sup><a id="fn.22" class="footnum" href="#fnr.22" role="doc-backlink">22</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Rothermel1991</p></div></div>

<div class="footdef"><sup><a id="fn.23" class="footnum" href="#fnr.23" role="doc-backlink">23</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://github.com/firelab/behave/blob/00b90853182031c9e22e33f22bb0ac497bad9415/src/behave/fireSize.cpp#L93">https://github.com/firelab/behave/blob/00b90853182031c9e22e33f22bb0ac497bad9415/src/behave/fireSize.cpp#L93</a></p></div></div>

<div class="footdef"><sup><a id="fn.24" class="footnum" href="#fnr.24" role="doc-backlink">24</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Rothermel1972</p></div></div>

<div class="footdef"><sup><a id="fn.25" class="footnum" href="#fnr.25" role="doc-backlink">25</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Andrews2013</p></div></div>

<div class="footdef"><sup><a id="fn.26" class="footnum" href="#fnr.26" role="doc-backlink">26</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">VanWagner1977</p></div></div>

<div class="footdef"><sup><a id="fn.27" class="footnum" href="#fnr.27" role="doc-backlink">27</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Cruz2005</p></div></div>

<div class="footdef"><sup><a id="fn.28" class="footnum" href="#fnr.28" role="doc-backlink">28</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">VanWagner1977</p></div></div>

<div class="footdef"><sup><a id="fn.29" class="footnum" href="#fnr.29" role="doc-backlink">29</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Cruz2005</p></div></div>

<div class="footdef"><sup><a id="fn.30" class="footnum" href="#fnr.30" role="doc-backlink">30</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Rothermel1991</p></div></div>

<div class="footdef"><sup><a id="fn.31" class="footnum" href="#fnr.31" role="doc-backlink">31</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1980</p></div></div>

<div class="footdef"><sup><a id="fn.32" class="footnum" href="#fnr.32" role="doc-backlink">32</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Waeselynck2024</p></div></div>

<div class="footdef"><sup><a id="fn.33" class="footnum" href="#fnr.33" role="doc-backlink">33</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://elmfire.io">https://elmfire.io</a></p></div></div>

<div class="footdef"><sup><a id="fn.34" class="footnum" href="#fnr.34" role="doc-backlink">34</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://landfire.gov">https://landfire.gov</a></p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Gary W. Johnson, Valentin Waeselynck, Chris Lautenberger</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
