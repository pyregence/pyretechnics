<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Pyretechnics Fire Behavior Library</title>
<meta name="author" content="Gary W. Johnson, Valentin Waeselynck, Chris Lautenberger" />
<meta name="description" content="A Python library for simulating fire behavior in a variety of ways." />
<meta name="keywords" content="pyretechnics fire behavior model python library pyregence pyrecast" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="pyretechnics-base.css" />
<link rel="stylesheet" type="text/css" href="pyretechnics-custom.css" />
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">The Pyretechnics Fire Behavior Library
<br>
<span class="subtitle">Copyright Â© 2023-2024 Spatial Informatics Group, LLC</span>
</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgfb9faaa">1. Preface</a></li>
<li><a href="#orgc5b0696">2. Data Model</a>
<ul>
<li><a href="#orgab78fb6">2.1. Working in a 3D Space-Time Cube</a></li>
<li><a href="#orgaf22510">2.2. Fires as Conical Shapes in Space-Time</a></li>
<li><a href="#orgd989c26">2.3. Support for Input Datasets of Varying Dimensionality</a></li>
<li><a href="#org2dd5b69">2.4. Support for Input Datasets of Varying Resolution</a></li>
</ul>
</li>
<li><a href="#org1a7eb5e">3. Loading Data into the 3D Space-Time Cube (pyretechnics.space_time_cube)</a>
<ul>
<li><a href="#orgec8c774">3.1. For Developers</a>
<ul>
<li><a href="#org38510a3">3.1.1. Module Imports</a></li>
<li><a href="#org2646469">3.1.2. Utility Functions</a></li>
<li><a href="#orgef4a8ba">3.1.3. SpaceTimeCube Class</a></li>
<li><a href="#org38a3ffe">3.1.4. LazySpaceTimeCube Class</a></li>
</ul>
</li>
<li><a href="#orgc69d42c">3.2. For Users</a>
<ul>
<li><a href="#org9652a54">3.2.1. How to Use SpaceTimeCube</a></li>
<li><a href="#orgee73c54">3.2.2. How to Use LazySpaceTimeCube</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org33e0010">4. [WIP] Fire Behavior Model</a></li>
<li><a href="#org742a728">5. Fuel Model and Moisture Definitions (pyretechnics.fuel_models)</a>
<ul>
<li><a href="#org4eea284">5.1. For Developers</a>
<ul>
<li><a href="#orgb506a85">5.1.1. Fuel Model Properties</a></li>
<li><a href="#orgff3ddb3">5.1.2. Fuel Model Definitions</a></li>
<li><a href="#orgde154a1">5.1.3. Fuel Categories and Size Classes</a></li>
<li><a href="#orgcf3d571">5.1.4. Dynamic Fuel Loading</a></li>
<li><a href="#org796f519">5.1.5. Size Class Weighting Factors</a></li>
<li><a href="#org76e7608">5.1.6. Live Moisture of Extinction</a></li>
<li><a href="#orgc1c1a02">5.1.7. Applying Fuel Moisture to a Fuel Model</a></li>
</ul>
</li>
<li><a href="#org4c20516">5.2. For Users</a>
<ul>
<li><a href="#org760dc81">5.2.1. How to Look Up a Fuel Model's Properties</a></li>
<li><a href="#orgc066ec7">5.2.2. How to Apply Fuel Moisture to a Fuel Model</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge582768">6. [WIP] Surface Fire Equations (pyretechnics.surface_fire)</a>
<ul>
<li><a href="#org11ca683">6.1. For Developers</a>
<ul>
<li><a href="#orgb5cef2e">6.1.1. Rothermel's Surface Fire Rate of Spread Equation</a></li>
<li><a href="#org6a7311b">6.1.2. Surface Fire Spread Rate Functions without Wind or Slope</a></li>
<li><a href="#org58d8c21">6.1.3. Surface Fire Intensity Functions</a></li>
<li><a href="#org633d02b">6.1.4. Stored Auxiliary Values and Functions</a></li>
<li><a href="#org7feb5f5">6.1.5. Main Rothermel Entrypoint Function</a></li>
<li><a href="#org2d75aa7">6.1.6. Surface Fire Spread Rate with Wind and Slope</a></li>
</ul>
</li>
<li><a href="#org247ce45">6.2. For Users</a></li>
</ul>
</li>
<li><a href="#org32229a3">7. [WIP] Crown Fire Equations (pyretechnics.crown_fire)</a>
<ul>
<li><a href="#org6c8ccc1">7.1. For Developers</a></li>
<li><a href="#org6ebdfb1">7.2. For Users</a></li>
</ul>
</li>
<li><a href="#org0376fa1">8. [WIP] Spot Fire Equations (pyretechnics.spot_fire)</a>
<ul>
<li><a href="#org1c45bdc">8.1. For Developers</a></li>
<li><a href="#org9b5d0f2">8.2. For Users</a></li>
</ul>
</li>
<li><a href="#orgccc2eb4">9. [WIP] Fire Spread Algorithms (pyretechnics.eulerian_level_set)</a>
<ul>
<li><a href="#org46182d0">9.1. For Developers</a></li>
<li><a href="#org43d1da5">9.2. For Users</a>
<ul>
<li><a href="#orge25c25f">9.2.1. Eulerian Level Set Method</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org59f7996">10. [WIP] Fire Suppression Algorithms (pyretechnics.suppression)</a>
<ul>
<li><a href="#org91fa720">10.1. For Developers</a></li>
<li><a href="#org7a10282">10.2. For Users</a></li>
</ul>
</li>
<li><a href="#org68d02a7">11. [WIP] Fire Spread API</a>
<ul>
<li><a href="#orgfc31810">11.1. grow_fire</a>
<ul>
<li><a href="#orga38c036">11.1.1. Inputs</a></li>
<li><a href="#org93e1ef6">11.1.2. Outputs</a></li>
<li><a href="#orgba47f93">11.1.3. Play/Pause/Continue Workflow</a></li>
</ul>
</li>
<li><a href="#org8c95a34">11.2. burn_cells</a></li>
</ul>
</li>
<li><a href="#orgc5148dd">12. [WIP] Fire Spread Functions</a>
<ul>
<li><a href="#org00e9a8e">12.1. ELMFIRE Inputs</a></li>
</ul>
</li>
<li><a href="#orgc902ec4">13. [WIP] Burning All Cells as a Head-Fire (similar to FLAMMAP)</a></li>
<li><a href="#orgdafc07e">14. [WIP] Loading LANDFIRE Inputs</a>
<ul>
<li><a href="#orgfaa8441">14.1. Loading Raster Files with Python Rasterio</a></li>
<li><a href="#org1f80f77">14.2. Convert LANDFIRE Units and Datatypes</a></li>
<li><a href="#orge299621">14.3. Verifying Raster Constraints</a></li>
<li><a href="#org8a87c26">14.4. Converting Rasters to 3D Lookup Functions</a></li>
<li><a href="#orgf7e7390">14.5. Putting It All Together</a></li>
</ul>
</li>
<li><a href="#org77115bf">15. [WIP] Testing burn_cells on Worcester, VT</a>
<ul>
<li><a href="#org3f77282">15.1. Loading Topography, Fuel Model, and Vegetation Inputs from LANDFIRE GeoTIFFs</a></li>
<li><a href="#orgdeb9a46">15.2. Adding Constant Wind and Moisture Values</a></li>
<li><a href="#org97d1bbf">15.3. Burning a Single Cell in the Dataset</a></li>
<li><a href="#org291f40e">15.4. Running Burn Cells on the Test Dataset</a></li>
<li><a href="#org29e515e">15.5. Visualizing the Burned Layers</a></li>
<li><a href="#org31cbc8e">15.6. Comparing Pyretechnics Outputs with FLAMMAP Outputs</a></li>
</ul>
</li>
<li><a href="#orgcebff7c">16. Appendix</a>
<ul>
<li><a href="#org97a9436">16.1. Units Conversion Functions (pyretechnics.conversion)</a></li>
<li><a href="#orgebedc9d">16.2. SpaceTimeCube and LazySpaceTimeCube Tests (pyretechnics_test.test_space_time_cube)</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgfb9faaa" class="outline-2">
<h2 id="orgfb9faaa"><span class="section-number-2">1.</span> Preface</h2>
<div class="outline-text-2" id="text-1">
<p>
This document is a Literate
Program<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>,
containing both the source code of the software it describes as well
as the rationale used in each step of its design and implementation.
The purpose of this approach is to enable both programmers and
non-programmers alike to retrace the author's footsteps as they read
through the text and code. By the time they have reached the end of
this document, the reader should have just as strong a grasp of the
system as the original programmer.
</p>

<p>
The source code repository containing this document provides a
comprehensive reproducible development environment through the use of
the open source GNU Guix<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup> transactional
package manager. This tool will automatically install all the software
needed to tangle, detangle, weave, test, build, and install this
library on your machine without conflicting with the main package
manager of your operating system. See <a href="../README.md">README.md</a> for more details.
</p>
</div>
</div>
<div id="outline-container-orgc5b0696" class="outline-2">
<h2 id="orgc5b0696"><span class="section-number-2">2.</span> Data Model</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgab78fb6" class="outline-3">
<h3 id="orgab78fb6"><span class="section-number-3">2.1.</span> Working in a 3D Space-Time Cube</h3>
<div class="outline-text-3" id="text-2-1">
<p>
In Pyretechnics, a fire is viewed as a three-dimensional event
occurring within a bounded region of space-time \((T,Y,X)\). In this
mental model, the environment in which a fire develops can be
visualized as a cube in which space is described in 2D by the \(X\) and
\(Y\) dimensions and time projects this 2D world into 3D along the \(T\)
dimension.
</p>

<p>
Note, in particular, that this is not the same thing as a
three-dimensional model of fire behavior that incorporates surface
elevation as the third dimension. Although terrain data (such as
elevation, slope, and aspect) and tree cover characteristics (such as
canopy height and canopy base height) are incorporated into the
implemented spread equations in order to determine the rate,
direction, and mode of fire spread, the outputs of the fire behavior
algorithms in Pyretechnics currently only use two dimensions to
describe spatial heterogeneity within the simulation environment. The
third dimension is instead reserved for temporal variations in the
model inputs and outputs.
</p>
</div>
</div>
<div id="outline-container-orgaf22510" class="outline-3">
<h3 id="orgaf22510"><span class="section-number-3">2.2.</span> Fires as Conical Shapes in Space-Time</h3>
<div class="outline-text-3" id="text-2-2">
<p>
All fire events begin from an ignition somewhere in space-time. As
combustion and propagation occur in burnable fuels, the burned area
(a.k.a "burn scar") of a fire spreads monotonically outward in space.
Viewed from the lens of our 3D space-time cube, these monotonically
expanding burn scars form conical solids within the simulation
environment, with the bottom point of the cone representing the
initial ignition point and the upper edge of the cone representing the
actively burning fire perimeter. Of course, we only expect idealized
fire cones to appear in environments with homogeneous topography,
weather, fuels, and fuel moisture. As these inputs become more
heterogenous throughout the burned region of space-time, these
idealized cones will become distorted in the directions of faster or
slower spread and their perimeters may become more finely dissected.
However, we use this conical shape description of fire events within
the simulated space-time cube to convey both their monotonically
increasing spatial area over time as well as to provide the foundation
for a more visually intuitive understanding of the effect of
temporally varying environmental conditions on the behavior (and thus
shape) of fires.
</p>
</div>
</div>
<div id="outline-container-orgd989c26" class="outline-3">
<h3 id="orgd989c26"><span class="section-number-3">2.3.</span> Support for Input Datasets of Varying Dimensionality</h3>
<div class="outline-text-3" id="text-2-3">
<p>
At the beginning of a fire behavior simulation, our 3D space-time cube
will be populated with all of the information that describes the
environment and will remain effectively static as the fire event
unfolds. This includes (but is not limited to) topography, weather,
fuels, and fuel moisture. In many common simulation scenarios, we
expect that topography and fuels will probably vary in space but not
in time, and weather and fuel moisture may vary in both space and
time. However, we use "may" in these statements because the data model
within Pyretechnics is flexibly designed to allow any of these
environmental input variables to take on any of these forms:
</p>

<dl class="org-dl">
<dt>Constant</dt><dd>Constant in both space and time. <br>
<b>Ex</b>: A single constant foliar moisture value could be used over the
simulation area for the entire simulation duration.</dd>

<dt>Temporal</dt><dd>Constant in space but variable in time. <br>
<b>Ex</b>: An hourly sequence of spread rate adjustment factors could be
used to globally ramp up and down fire spread rates throughout a
day/night cycle, creating burn periods of arbitrary length and
intensity.</dd>

<dt>Spatial</dt><dd>Variable in space but constant in time. <br>
<b>Ex</b>: A raster layer downloaded from
LANDFIRE<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup> can be used to specify the
spatial distribution of FBFM40 fuel model values on a landscape.</dd>

<dt>Spatio-temporal</dt><dd>Variable in both space and time. <br>
<b>Ex</b>: Hourly
RTMA<sup><a id="fnr.4" class="footref" href="#fn.4" role="doc-backlink">4</a></sup> weather
data can be loaded from a multi-band raster and used to specify the
spatio-temporal distribution of wind speed and direction throughout
the simulation domain.</dd>
</dl>

<p>
This is accomplished by representing each such input value as an
abstract datatype with a set of 3D space-time lookup functions for
accessing its values within 0D, 1D, 2D, and 3D slices of the
space-time cube at the simulation resolution. Such lookups should
always be referentially transparent, so as to ensure that subsequent
lookups with the same coordinate will always yield the same values.
See section <a href="#org1a7eb5e">3</a> for implementation details.
</p>
</div>
</div>
<div id="outline-container-org2dd5b69" class="outline-3">
<h3 id="org2dd5b69"><span class="section-number-3">2.4.</span> Support for Input Datasets of Varying Resolution</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Even when dimensions are the same between input datasets, they may be
provided at different resolutions from one another, provided that the
following conditions are met:
</p>

<dl class="org-dl">
<dt>Same Projection</dt><dd>All spatially varying datasets must share the
same projection.</dd>

<dt>Same Extent</dt><dd>All spatial and temporal extents must match.</dd>

<dt>Data Resolutions Divide Simulation Resolutions Evenly</dt><dd>All
spatial and temporal resolutions must be exact divisors of the
simulation resolution.</dd>
</dl>

<p>
The simulated space-time cube will share the same projection and
extent as the input datasets, but its resolution may be specified by
the user, provided that it meets condition 3 above. The 3D lookup
functions for each input will then be responsible for translating the
space-time coordinates they receive at the simulation resolution into
the correct coordinates for their underlying dataset's native
resolution. See section <a href="#org1a7eb5e">3</a> for implementation details.
</p>
</div>
</div>
</div>
<div id="outline-container-org1a7eb5e" class="outline-2">
<h2 id="org1a7eb5e"><span class="section-number-2">3.</span> Loading Data into the 3D Space-Time Cube (pyretechnics.space_time_cube)</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-orgec8c774" class="outline-3">
<h3 id="orgec8c774"><span class="section-number-3">3.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-3-1">
<p>
The following sections define Python classes that construct 3D
space-time cubes corresponding to the data model described above for
various types of input datasets.
</p>
</div>
<div id="outline-container-org38510a3" class="outline-4">
<h4 id="org38510a3"><span class="section-number-4">3.1.1.</span> Module Imports</h4>
<div class="outline-text-4" id="text-3-1-1">
<div class="org-src-container">
<pre class="src src-python" id="org92d5f16"><span class="org-keyword">from</span> functools <span class="org-keyword">import</span> <span class="org-builtin">reduce</span>
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
</pre>
</div>
</div>
</div>
<div id="outline-container-org2646469" class="outline-4">
<h4 id="org2646469"><span class="section-number-4">3.1.2.</span> Utility Functions</h4>
<div class="outline-text-4" id="text-3-1-2">
<div class="org-src-container">
<pre class="src src-python" id="org044a211"><span class="org-keyword">def</span> <span class="org-function-name">is_pos_int</span>(x):
    <span class="org-keyword">return</span> <span class="org-builtin">isinstance</span>(x, <span class="org-builtin">int</span>) <span class="org-keyword">and</span> x <span class="org-operator">&gt;</span> 0


<span class="org-keyword">def</span> <span class="org-function-name">divide_evenly</span>(dividend, divisor):
    (<span class="org-variable-name">quotient</span>, <span class="org-variable-name">remainder</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(dividend, divisor)
    <span class="org-keyword">if</span> remainder <span class="org-operator">==</span> 0:
        <span class="org-keyword">return</span> quotient
    <span class="org-keyword">else</span>:
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-builtin">str</span>(dividend) <span class="org-operator">+</span> <span class="org-string">" must be an exact multiple of "</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(divisor) <span class="org-operator">+</span> <span class="org-string">"."</span>)


<span class="org-keyword">def</span> <span class="org-function-name">to_positive_index_range</span>(index_range, axis_length):
    <span class="org-doc">"""</span>
<span class="org-doc">    Translate None and negative indices to positive indices.</span>
<span class="org-doc">    """</span>
    (<span class="org-variable-name">start</span>, <span class="org-variable-name">stop</span>) <span class="org-operator">=</span> index_range
    <span class="org-keyword">return</span> (
        0 <span class="org-keyword">if</span> start <span class="org-operator">==</span> <span class="org-constant">None</span> <span class="org-keyword">else</span> axis_length <span class="org-operator">+</span> start <span class="org-keyword">if</span> start <span class="org-operator">&lt;</span> 0 <span class="org-keyword">else</span> start,
        axis_length <span class="org-keyword">if</span> stop <span class="org-operator">==</span> <span class="org-constant">None</span> <span class="org-keyword">else</span> axis_length <span class="org-operator">+</span> stop <span class="org-keyword">if</span> stop <span class="org-operator">&lt;</span> 0 <span class="org-keyword">else</span> stop
    )


<span class="org-keyword">def</span> <span class="org-function-name">maybe_repeat_array</span>(array, axis_repetitions):
    <span class="org-doc">"""</span>
<span class="org-doc">    Return a new array that is created by repeating the elements from the input</span>
<span class="org-doc">    array repetitions times along the specified array axis. Avoid allocating</span>
<span class="org-doc">    new memory if repetitions == 1 or if the repeated array axis has length 1.</span>
<span class="org-doc">    """</span>
    (<span class="org-variable-name">axis</span>, <span class="org-variable-name">repetitions</span>) <span class="org-operator">=</span> axis_repetitions
    <span class="org-keyword">if</span> repetitions <span class="org-operator">==</span> 1:
        <span class="org-keyword">return</span> array
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">array_shape</span> <span class="org-operator">=</span> <span class="org-builtin">list</span>(np.shape(array))
        <span class="org-keyword">if</span> array_shape[axis] <span class="org-operator">==</span> 1:
            <span class="org-variable-name">array_shape</span>[axis] <span class="org-operator">=</span> repetitions
            <span class="org-keyword">return</span> np.broadcast_to(array, array_shape)
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> np.repeat(array, repetitions, axis)
</pre>
</div>
</div>
</div>
<div id="outline-container-orgef4a8ba" class="outline-4">
<h4 id="orgef4a8ba"><span class="section-number-4">3.1.3.</span> SpaceTimeCube Class</h4>
<div class="outline-text-4" id="text-3-1-3">
<p>
When an input dataset is already loaded into memory as either a single
scalar value or a 1D, 2D, or 3D array of values, it can be made
available to the various Pyretechnics algorithms by wrapping it in a
<code>SpaceTimeCube</code> object. As described in sections <a href="#orgd989c26">2.3</a> and <a href="#org2dd5b69">2.4</a>, this input data can be provided in a variety of
dimensions and resolutions, subject to some simple constraints.
</p>

<p>
The <code>SpaceTimeCube</code> object will be created with a tuple of
user-specified spatio-temporal resolutions, called the <i>cube shape</i>,
which must be equal to or exact multiples of those of the underlying
data. For memory efficiency, input values are stored within the
<code>SpaceTimeCube</code> object at their native resolution but can be accessed
at any spatio-temporal point or region within the <code>SpaceTimeCube</code>'s
extent using coordinates from the <i>cube shape</i> resolution.
</p>

<p>
The various accessor functions provided by this class receive 3D
space-time coordinates at the <i>cube shape</i> resolution and will
correctly map them into the corresponding index within the native
dataset. Whenever a bounded region of space-time is requested via an
accessor function, the underlying data will be expanded to fill a new
Numpy array at the <i>cube shape</i> resolution. Whenever possible, Numpy
array broadcasting will be used instead of data copying for any
constant input dimensions.
</p>

<div class="org-src-container">
<pre class="src src-python" id="org46c8dcf"><span class="org-keyword">class</span> <span class="org-type">SpaceTimeCube</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Create an object that represents a 3D array with dimensions (T,Y,X) given by cube_shape.</span>
<span class="org-doc">    Internally, data is stored as a 3D Numpy array at the resolution of the provided base data.</span>
<span class="org-doc">    Whenever a point value or contiguous space-time region of values is requested, translate</span>
<span class="org-doc">    the given cube_shape coordinates into base coordinates, look up the values from the base data,</span>
<span class="org-doc">    expand them (if necessary) back into the cube_shape resolution, and return the resulting scalar</span>
<span class="org-doc">    value or array to the caller.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, cube_shape, base):
        <span class="org-doc">"""</span>
<span class="org-doc">        NOTE: The resolutions in cube_shape must be exact multiples of any existing dimensions</span>
<span class="org-doc">              in the base data.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that cube_shape contains 3 values or throw an error</span>
        (<span class="org-variable-name">cube_bands</span>, <span class="org-variable-name">cube_rows</span>, <span class="org-variable-name">cube_cols</span>) <span class="org-operator">=</span> cube_shape

        <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that cube_shape only contains positive integers or throw an error</span>
        <span class="org-keyword">if</span> <span class="org-keyword">not</span>(<span class="org-builtin">all</span>(<span class="org-builtin">map</span>(is_pos_int, cube_shape))):
            <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The cube_shape must only contain positive integers."</span>)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Store the cube metadata for later</span>
        <span class="org-keyword">self</span>.<span class="org-variable-name">ndim</span>  <span class="org-operator">=</span> 3
        <span class="org-keyword">self</span>.<span class="org-variable-name">size</span>  <span class="org-operator">=</span> cube_bands <span class="org-operator">*</span> cube_rows <span class="org-operator">*</span> cube_cols
        <span class="org-keyword">self</span>.<span class="org-variable-name">shape</span> <span class="org-operator">=</span> cube_shape
        <span class="org-keyword">self</span>.<span class="org-variable-name">base</span>  <span class="org-operator">=</span> base

        <span class="org-keyword">match</span> np.ndim(base):
            <span class="org-comment-delimiter"># </span><span class="org-comment">0D: Constant Input</span>
            <span class="org-keyword">case</span> 0:
                <span class="org-keyword">self</span>.<span class="org-variable-name">t_repetitions</span> <span class="org-operator">=</span> cube_bands
                <span class="org-keyword">self</span>.<span class="org-variable-name">y_repetitions</span> <span class="org-operator">=</span> cube_rows
                <span class="org-keyword">self</span>.<span class="org-variable-name">x_repetitions</span> <span class="org-operator">=</span> cube_cols
                <span class="org-keyword">self</span>.<span class="org-variable-name">data</span> <span class="org-operator">=</span> np.asarray([[[base]]])

            <span class="org-comment-delimiter"># </span><span class="org-comment">1D: Time-Series Input</span>
            <span class="org-keyword">case</span> 1:
                <span class="org-variable-name">base_bands</span> <span class="org-operator">=</span> <span class="org-builtin">len</span>(base)
                <span class="org-keyword">self</span>.<span class="org-variable-name">t_repetitions</span> <span class="org-operator">=</span> divide_evenly(cube_bands, base_bands)
                <span class="org-keyword">self</span>.<span class="org-variable-name">y_repetitions</span> <span class="org-operator">=</span> cube_rows
                <span class="org-keyword">self</span>.<span class="org-variable-name">x_repetitions</span> <span class="org-operator">=</span> cube_cols
                <span class="org-comment-delimiter"># </span><span class="org-comment">Expand (base_bands) -&gt; (base_bands,1,1)</span>
                <span class="org-keyword">self</span>.<span class="org-variable-name">data</span> <span class="org-operator">=</span> np.expand_dims(base, axis<span class="org-operator">=</span>(1,2))

            <span class="org-comment-delimiter"># </span><span class="org-comment">2D: Spatial Input</span>
            <span class="org-keyword">case</span> 2:
                (<span class="org-variable-name">base_rows</span>, <span class="org-variable-name">base_cols</span>) <span class="org-operator">=</span> np.shape(base)
                <span class="org-keyword">self</span>.<span class="org-variable-name">t_repetitions</span> <span class="org-operator">=</span> cube_bands
                <span class="org-keyword">self</span>.<span class="org-variable-name">y_repetitions</span> <span class="org-operator">=</span> divide_evenly(cube_rows, base_rows)
                <span class="org-keyword">self</span>.<span class="org-variable-name">x_repetitions</span> <span class="org-operator">=</span> divide_evenly(cube_cols, base_cols)
                <span class="org-comment-delimiter"># </span><span class="org-comment">Expand (base_rows,base_cols) -&gt; (1,base_rows,base_cols)</span>
                <span class="org-keyword">self</span>.<span class="org-variable-name">data</span> <span class="org-operator">=</span> np.expand_dims(base, axis<span class="org-operator">=</span>0)

            <span class="org-comment-delimiter"># </span><span class="org-comment">3D: Spatio-Temporal Input</span>
            <span class="org-keyword">case</span> 3:
                (<span class="org-variable-name">base_bands</span>, <span class="org-variable-name">base_rows</span>, <span class="org-variable-name">base_cols</span>) <span class="org-operator">=</span> np.shape(base)
                <span class="org-keyword">self</span>.<span class="org-variable-name">t_repetitions</span> <span class="org-operator">=</span> divide_evenly(cube_bands, base_bands)
                <span class="org-keyword">self</span>.<span class="org-variable-name">y_repetitions</span> <span class="org-operator">=</span> divide_evenly(cube_rows, base_rows)
                <span class="org-keyword">self</span>.<span class="org-variable-name">x_repetitions</span> <span class="org-operator">=</span> divide_evenly(cube_cols, base_cols)
                <span class="org-keyword">self</span>.<span class="org-variable-name">data</span> <span class="org-operator">=</span> np.asarray(base)

            <span class="org-comment-delimiter"># </span><span class="org-comment">4D+: Invalid Input</span>
            <span class="org-keyword">case</span> _:
                <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"Invalid input: base must have 0-3 dimensions."</span>)


    <span class="org-keyword">def</span> <span class="org-function-name">get</span>(<span class="org-keyword">self</span>, t, y, x):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the scalar value at index (t,y,x) by translating these cube coordinates</span>
<span class="org-doc">        to base coordinates and looking up the value within the base data.</span>

<span class="org-doc">        NOTE: (t,y,x) = (0,0,0) is the upper-left corner of the array in the first timestep.</span>
<span class="org-doc">        NOTE: Indices may be negative.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select value by spatio-temporal coordinate</span>
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>.data[t <span class="org-operator">//</span> <span class="org-keyword">self</span>.t_repetitions,
                         y <span class="org-operator">//</span> <span class="org-keyword">self</span>.y_repetitions,
                         x <span class="org-operator">//</span> <span class="org-keyword">self</span>.x_repetitions]


    <span class="org-keyword">def</span> <span class="org-function-name">getTimeSeries</span>(<span class="org-keyword">self</span>, t_range, y, x):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 1D array given by the slice (t_range,y,x) by translating these cube</span>
<span class="org-doc">        coordinates to base coordinates, looking up the array slice within the base data,</span>
<span class="org-doc">        and expanding it back to the cube_shape resolution.</span>

<span class="org-doc">        NOTE: (t,y,x) = (0,0,0) is the upper-left corner of the array in the first timestep.</span>
<span class="org-doc">        NOTE: Indices may be negative.</span>
<span class="org-doc">        NOTE: Range indices may include one or more None values and</span>
<span class="org-doc">              provide (inclusion, exclusion) semantics like Python array slice notation.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the argument range</span>
        (<span class="org-variable-name">t_start</span>, <span class="org-variable-name">t_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(t_range, <span class="org-keyword">self</span>.shape[0])
        <span class="org-variable-name">t_stop</span> <span class="org-operator">=</span> t_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res coordinates to low-res coordinates</span>
        <span class="org-variable-name">t_start_chunk</span> <span class="org-operator">=</span> t_start <span class="org-operator">//</span> <span class="org-keyword">self</span>.t_repetitions
        <span class="org-variable-name">t_stop_chunk</span>  <span class="org-operator">=</span> t_stop  <span class="org-operator">//</span> <span class="org-keyword">self</span>.t_repetitions
        <span class="org-variable-name">y_chunk</span>       <span class="org-operator">=</span> y       <span class="org-operator">//</span> <span class="org-keyword">self</span>.y_repetitions
        <span class="org-variable-name">x_chunk</span>       <span class="org-operator">=</span> x       <span class="org-operator">//</span> <span class="org-keyword">self</span>.x_repetitions
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select the array slice that completely contains all low-res coordinates</span>
        <span class="org-variable-name">low_res_time</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.data[t_start_chunk:(t_stop_chunk <span class="org-operator">+</span> 1),
                                 y_chunk,
                                 x_chunk]
        <span class="org-comment-delimiter"># </span><span class="org-comment">Expand the low-res slice into a high-res slice</span>
        <span class="org-variable-name">high_res_time</span> <span class="org-operator">=</span> maybe_repeat_array(low_res_time, (0, <span class="org-keyword">self</span>.t_repetitions))
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res global coordinates to high-res slice coordinates</span>
        <span class="org-variable-name">t_chunk_origin</span> <span class="org-operator">=</span> t_start_chunk <span class="org-operator">*</span> <span class="org-keyword">self</span>.t_repetitions
        <span class="org-variable-name">t_start_idx</span>    <span class="org-operator">=</span> t_start <span class="org-operator">-</span> t_chunk_origin
        <span class="org-variable-name">t_stop_idx</span>     <span class="org-operator">=</span> t_stop  <span class="org-operator">-</span> t_chunk_origin
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select the array slice that matches the high-res slice coordinates</span>
        <span class="org-keyword">return</span> high_res_time[t_start_idx:(t_stop_idx <span class="org-operator">+</span> 1)]


    <span class="org-keyword">def</span> <span class="org-function-name">getSpatialPlane</span>(<span class="org-keyword">self</span>, t, y_range, x_range):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 2D array given by the slice (t,y_range,x_range) by translating these</span>
<span class="org-doc">        cube coordinates to base coordinates, looking up the array slice within the base</span>
<span class="org-doc">        data, and expanding it back to the cube_shape resolution.</span>

<span class="org-doc">        NOTE: (t,y,x) = (0,0,0) is the upper-left corner of the array in the first timestep.</span>
<span class="org-doc">        NOTE: Indices may be negative.</span>
<span class="org-doc">        NOTE: Range indices may include one or more None values and</span>
<span class="org-doc">              provide (inclusion, exclusion) semantics like Python array slice notation.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the argument ranges</span>
        (<span class="org-variable-name">y_start</span>, <span class="org-variable-name">y_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(y_range, <span class="org-keyword">self</span>.shape[1])
        (<span class="org-variable-name">x_start</span>, <span class="org-variable-name">x_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(x_range, <span class="org-keyword">self</span>.shape[2])
        <span class="org-variable-name">y_stop</span> <span class="org-operator">=</span> y_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-variable-name">x_stop</span> <span class="org-operator">=</span> x_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res coordinates to low-res coordinates</span>
        <span class="org-variable-name">t_chunk</span>       <span class="org-operator">=</span> t       <span class="org-operator">//</span> <span class="org-keyword">self</span>.t_repetitions
        <span class="org-variable-name">y_start_chunk</span> <span class="org-operator">=</span> y_start <span class="org-operator">//</span> <span class="org-keyword">self</span>.y_repetitions
        <span class="org-variable-name">y_stop_chunk</span>  <span class="org-operator">=</span> y_stop  <span class="org-operator">//</span> <span class="org-keyword">self</span>.y_repetitions
        <span class="org-variable-name">x_start_chunk</span> <span class="org-operator">=</span> x_start <span class="org-operator">//</span> <span class="org-keyword">self</span>.x_repetitions
        <span class="org-variable-name">x_stop_chunk</span>  <span class="org-operator">=</span> x_stop  <span class="org-operator">//</span> <span class="org-keyword">self</span>.x_repetitions
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select the array slice that completely contains all low-res coordinates</span>
        <span class="org-variable-name">low_res_space</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.data[t_chunk,
                                  y_start_chunk:(y_stop_chunk <span class="org-operator">+</span> 1),
                                  x_start_chunk:(x_stop_chunk <span class="org-operator">+</span> 1)]
        <span class="org-comment-delimiter"># </span><span class="org-comment">Expand the low-res slice into a high-res slice</span>
        <span class="org-variable-name">high_res_space</span> <span class="org-operator">=</span> <span class="org-builtin">reduce</span>(maybe_repeat_array,
                                ((0, <span class="org-keyword">self</span>.y_repetitions),
                                 (1, <span class="org-keyword">self</span>.x_repetitions)),
                                low_res_space)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res global coordinates to high-res slice coordinates</span>
        <span class="org-variable-name">y_chunk_origin</span> <span class="org-operator">=</span> y_start_chunk <span class="org-operator">*</span> <span class="org-keyword">self</span>.y_repetitions
        <span class="org-variable-name">x_chunk_origin</span> <span class="org-operator">=</span> x_start_chunk <span class="org-operator">*</span> <span class="org-keyword">self</span>.x_repetitions
        <span class="org-variable-name">y_start_idx</span>    <span class="org-operator">=</span> y_start <span class="org-operator">-</span> y_chunk_origin
        <span class="org-variable-name">y_stop_idx</span>     <span class="org-operator">=</span> y_stop  <span class="org-operator">-</span> y_chunk_origin
        <span class="org-variable-name">x_start_idx</span>    <span class="org-operator">=</span> x_start <span class="org-operator">-</span> x_chunk_origin
        <span class="org-variable-name">x_stop_idx</span>     <span class="org-operator">=</span> x_stop  <span class="org-operator">-</span> x_chunk_origin
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select the array slice that matches the high-res slice coordinates</span>
        <span class="org-keyword">return</span> high_res_space[y_start_idx:(y_stop_idx <span class="org-operator">+</span> 1),
                              x_start_idx:(x_stop_idx <span class="org-operator">+</span> 1)]


    <span class="org-keyword">def</span> <span class="org-function-name">getSubcube</span>(<span class="org-keyword">self</span>, t_range, y_range, x_range):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 3D array given by the slice (t_range,y_range,x_range) by translating</span>
<span class="org-doc">        these cube coordinates to base coordinates, looking up the array slice within the</span>
<span class="org-doc">        base data, and expanding it back to the cube_shape resolution.</span>

<span class="org-doc">        NOTE: (t,y,x) = (0,0,0) is the upper-left corner of the array in the first timestep.</span>
<span class="org-doc">        NOTE: Indices may be negative.</span>
<span class="org-doc">        NOTE: Range indices may include one or more None values and</span>
<span class="org-doc">              provide (inclusion, exclusion) semantics like Python array slice notation.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the argument ranges</span>
        (<span class="org-variable-name">t_start</span>, <span class="org-variable-name">t_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(t_range, <span class="org-keyword">self</span>.shape[0])
        (<span class="org-variable-name">y_start</span>, <span class="org-variable-name">y_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(y_range, <span class="org-keyword">self</span>.shape[1])
        (<span class="org-variable-name">x_start</span>, <span class="org-variable-name">x_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(x_range, <span class="org-keyword">self</span>.shape[2])
        <span class="org-variable-name">t_stop</span> <span class="org-operator">=</span> t_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-variable-name">y_stop</span> <span class="org-operator">=</span> y_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-variable-name">x_stop</span> <span class="org-operator">=</span> x_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res coordinates to low-res coordinates</span>
        <span class="org-variable-name">t_start_chunk</span> <span class="org-operator">=</span> t_start <span class="org-operator">//</span> <span class="org-keyword">self</span>.t_repetitions
        <span class="org-variable-name">t_stop_chunk</span>  <span class="org-operator">=</span> t_stop  <span class="org-operator">//</span> <span class="org-keyword">self</span>.t_repetitions
        <span class="org-variable-name">y_start_chunk</span> <span class="org-operator">=</span> y_start <span class="org-operator">//</span> <span class="org-keyword">self</span>.y_repetitions
        <span class="org-variable-name">y_stop_chunk</span>  <span class="org-operator">=</span> y_stop  <span class="org-operator">//</span> <span class="org-keyword">self</span>.y_repetitions
        <span class="org-variable-name">x_start_chunk</span> <span class="org-operator">=</span> x_start <span class="org-operator">//</span> <span class="org-keyword">self</span>.x_repetitions
        <span class="org-variable-name">x_stop_chunk</span>  <span class="org-operator">=</span> x_stop  <span class="org-operator">//</span> <span class="org-keyword">self</span>.x_repetitions
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select the array slice that completely contains all low-res coordinates</span>
        <span class="org-variable-name">low_res_cube</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.data[t_start_chunk:(t_stop_chunk <span class="org-operator">+</span> 1),
                                 y_start_chunk:(y_stop_chunk <span class="org-operator">+</span> 1),
                                 x_start_chunk:(x_stop_chunk <span class="org-operator">+</span> 1)]
        <span class="org-comment-delimiter"># </span><span class="org-comment">Expand the low-res slice into a high-res slice</span>
        <span class="org-variable-name">high_res_cube</span> <span class="org-operator">=</span> <span class="org-builtin">reduce</span>(maybe_repeat_array,
                               ((0, <span class="org-keyword">self</span>.t_repetitions),
                                (1, <span class="org-keyword">self</span>.y_repetitions),
                                (2, <span class="org-keyword">self</span>.x_repetitions)),
                               low_res_cube)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res global coordinates to high-res slice coordinates</span>
        <span class="org-variable-name">t_chunk_origin</span> <span class="org-operator">=</span> t_start_chunk <span class="org-operator">*</span> <span class="org-keyword">self</span>.t_repetitions
        <span class="org-variable-name">y_chunk_origin</span> <span class="org-operator">=</span> y_start_chunk <span class="org-operator">*</span> <span class="org-keyword">self</span>.y_repetitions
        <span class="org-variable-name">x_chunk_origin</span> <span class="org-operator">=</span> x_start_chunk <span class="org-operator">*</span> <span class="org-keyword">self</span>.x_repetitions
        <span class="org-variable-name">t_start_idx</span>    <span class="org-operator">=</span> t_start <span class="org-operator">-</span> t_chunk_origin
        <span class="org-variable-name">t_stop_idx</span>     <span class="org-operator">=</span> t_stop  <span class="org-operator">-</span> t_chunk_origin
        <span class="org-variable-name">y_start_idx</span>    <span class="org-operator">=</span> y_start <span class="org-operator">-</span> y_chunk_origin
        <span class="org-variable-name">y_stop_idx</span>     <span class="org-operator">=</span> y_stop  <span class="org-operator">-</span> y_chunk_origin
        <span class="org-variable-name">x_start_idx</span>    <span class="org-operator">=</span> x_start <span class="org-operator">-</span> x_chunk_origin
        <span class="org-variable-name">x_stop_idx</span>     <span class="org-operator">=</span> x_stop  <span class="org-operator">-</span> x_chunk_origin
        <span class="org-comment-delimiter"># </span><span class="org-comment">Select the array slice that matches the high-res slice coordinates</span>
        <span class="org-keyword">return</span> high_res_cube[t_start_idx:(t_stop_idx <span class="org-operator">+</span> 1),
                             y_start_idx:(y_stop_idx <span class="org-operator">+</span> 1),
                             x_start_idx:(x_stop_idx <span class="org-operator">+</span> 1)]


    <span class="org-keyword">def</span> <span class="org-function-name">__getFullyRealizedCube</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 3D array created by expanding the base data to the cube_shape resolution.</span>
<span class="org-doc">        Wherever possible, Numpy broadcasting is used to avoid memory allocation along</span>
<span class="org-doc">        constant array dimensions.</span>
<span class="org-doc">        """</span>
        <span class="org-keyword">match</span> np.ndim(<span class="org-keyword">self</span>.base):
            <span class="org-comment-delimiter"># </span><span class="org-comment">0D: Constant Input</span>
            <span class="org-keyword">case</span> 0:
                <span class="org-comment-delimiter"># </span><span class="org-comment">Broadcast (0,0,0) -&gt; (t,y,x)</span>
                <span class="org-keyword">return</span> np.broadcast_to(<span class="org-keyword">self</span>.data, <span class="org-keyword">self</span>.shape)

            <span class="org-comment-delimiter"># </span><span class="org-comment">1D: Time-Series Input</span>
            <span class="org-keyword">case</span> 1:
                <span class="org-comment-delimiter"># </span><span class="org-comment">Repeat (t0,1,1) -&gt; (t,1,1)</span>
                <span class="org-variable-name">repeated_array</span> <span class="org-operator">=</span> maybe_repeat_array(<span class="org-keyword">self</span>.data, (0, <span class="org-keyword">self</span>.t_repetitions))
                <span class="org-comment-delimiter"># </span><span class="org-comment">Broadcast (t,1,1) -&gt; (t,y,x)</span>
                <span class="org-keyword">return</span> np.broadcast_to(repeated_array, <span class="org-keyword">self</span>.shape)

            <span class="org-comment-delimiter"># </span><span class="org-comment">2D: Spatial Input</span>
            <span class="org-keyword">case</span> 2:
                <span class="org-comment-delimiter"># </span><span class="org-comment">Repeat (1,y0,x0) -&gt; (1,y,x)</span>
                <span class="org-variable-name">repeated_array</span> <span class="org-operator">=</span> <span class="org-builtin">reduce</span>(maybe_repeat_array,
                                        ((1, <span class="org-keyword">self</span>.y_repetitions),
                                         (2, <span class="org-keyword">self</span>.x_repetitions)),
                                        <span class="org-keyword">self</span>.data)
                <span class="org-comment-delimiter"># </span><span class="org-comment">Broadcast (1,y,x) -&gt; (t,y,x)</span>
                <span class="org-keyword">return</span> np.broadcast_to(repeated_array, <span class="org-keyword">self</span>.shape)

            <span class="org-comment-delimiter"># </span><span class="org-comment">3D: Spatio-Temporal Input</span>
            <span class="org-keyword">case</span> 3:
                <span class="org-comment-delimiter"># </span><span class="org-comment">Repeat (t0,y0,x0) -&gt; (t,y,x)</span>
                <span class="org-keyword">return</span> <span class="org-builtin">reduce</span>(maybe_repeat_array,
                              ((0, <span class="org-keyword">self</span>.t_repetitions),
                               (1, <span class="org-keyword">self</span>.y_repetitions),
                               (2, <span class="org-keyword">self</span>.x_repetitions)),
                              <span class="org-keyword">self</span>.data)


    <span class="org-keyword">def</span> <span class="org-function-name">getFullyRealizedCube</span>(<span class="org-keyword">self</span>, cache<span class="org-operator">=</span><span class="org-constant">False</span>):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 3D array created by expanding the base data to the cube_shape resolution.</span>
<span class="org-doc">        Wherever possible, Numpy broadcasting is used to avoid memory allocation along</span>
<span class="org-doc">        constant array dimensions. When cache == True, this expanded 3D array is cached</span>
<span class="org-doc">        within the SpaceTimeCube object for future immediate retrieval.</span>
<span class="org-doc">        """</span>
        <span class="org-keyword">if</span> <span class="org-builtin">hasattr</span>(<span class="org-keyword">self</span>, <span class="org-string">"cube"</span>):
            <span class="org-keyword">return</span> <span class="org-keyword">self</span>.cube
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">cube</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.__getFullyRealizedCube()
            <span class="org-keyword">if</span> cache <span class="org-keyword">is</span> <span class="org-constant">True</span>:
                <span class="org-keyword">self</span>.<span class="org-variable-name">cube</span> <span class="org-operator">=</span> cube
            <span class="org-keyword">return</span> cube


    <span class="org-keyword">def</span> <span class="org-function-name">releaseFullyRealizedCube</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">"""</span>
<span class="org-doc">        Deletes the cached fully realized cube if it exists.</span>
<span class="org-doc">        """</span>
        <span class="org-keyword">if</span> <span class="org-builtin">hasattr</span>(<span class="org-keyword">self</span>, <span class="org-string">"cube"</span>):
            <span class="org-builtin">delattr</span>(<span class="org-keyword">self</span>, <span class="org-string">"cube"</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-org38a3ffe" class="outline-4">
<h4 id="org38a3ffe"><span class="section-number-4">3.1.4.</span> LazySpaceTimeCube Class</h4>
<div class="outline-text-4" id="text-3-1-4">
<p>
When a dataset is too large to fit easily into memory, it can be
partitioned into a collection of subcubes, which will be lazily loaded
on demand into a 3D cache grid of <code>SpaceTimeCube</code> objects provided by
the <code>LazySpaceTimeCube</code> class.
</p>

<p>
The <code>LazySpaceTimeCube</code> object will be created with a tuple of
user-specified spatio-temporal resolutions, called the <i>cube shape</i>,
which must be equal to or exact multiples of the <i>subcube shape</i>.
</p>

<p>
The various accessor functions provided by this class receive 3D
space-time coordinates at the <i>cube shape</i> resolution and will
correctly map them into the corresponding cache and subcube indexes.
Any intersected subcubes that are not already present in the cache
grid will be loaded on demand by calling a user-supplied
<code>load_subcube</code> function and stored in the cache grid for faster
retrieval later. If a bounded region of space-time that spans multiple
subcubes is requested via an accessor function, each of the
intersected subcubes will be loaded and cached, their relevant array
slices will be extracted, and these slices will be merged into a new
array at the <i>cube shape</i> resolution.
</p>

<p>
Fire spread simulations that use the <code>LazySpaceTimeCube</code> class will
only need to load into memory those subcubes which are intersected by
the expanding conical burn scar (see section <a href="#orgaf22510">2.2</a>). In simulations of fires that are small relative to the
extent of the full 3D space-time environment, these memory savings may
be substantial and may make it possible to run simulations over larger
extents and/or finer resolutions than have been used previously.
</p>

<div class="org-src-container">
<pre class="src src-python" id="orgb74c423"><span class="org-keyword">class</span> <span class="org-type">LazySpaceTimeCube</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Create an object that represents a 3D array with dimensions (T,Y,X) given by cube_shape.</span>
<span class="org-doc">    Internally, data is stored as an initially empty 3D array of SpaceTimeCube objects.</span>
<span class="org-doc">    Whenever a point value or contiguous space-time region of values is requested, identify</span>
<span class="org-doc">    which SpaceTimeCubes contain the requested coordinates, load them into the cache array</span>
<span class="org-doc">    by calling load_subcube for any that are not already present, request the values from</span>
<span class="org-doc">    these SpaceTimeCubes, combine them together if necessary, and return the resulting scalar</span>
<span class="org-doc">    value or array to the caller.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, cube_shape, subcube_shape, load_subcube):
        <span class="org-doc">"""</span>
<span class="org-doc">        NOTE: The resolutions in cube_shape must be exact multiples of those in subcube_shape.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that cube_shape and subcube_shape both contain 3 values or throw an error</span>
        (<span class="org-variable-name">cube_bands</span>, <span class="org-variable-name">cube_rows</span>, <span class="org-variable-name">cube_cols</span>) <span class="org-operator">=</span> cube_shape
        (<span class="org-variable-name">subcube_bands</span>, <span class="org-variable-name">subcube_rows</span>, <span class="org-variable-name">subcube_cols</span>) <span class="org-operator">=</span> subcube_shape

        <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that cube_shape and subcube_shape only contain positive integers or throw an error</span>
        <span class="org-keyword">if</span> <span class="org-keyword">not</span>(<span class="org-builtin">all</span>(<span class="org-builtin">map</span>(is_pos_int, cube_shape <span class="org-operator">+</span> subcube_shape))):
            <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"The cube_shape and subcube_shape must only contain positive integers."</span>)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Ensure that cube_shape is divided evenly by subcube_shape or throw an error</span>
        <span class="org-variable-name">cache_bands</span> <span class="org-operator">=</span> divide_evenly(cube_bands, subcube_bands)
        <span class="org-variable-name">cache_rows</span>  <span class="org-operator">=</span> divide_evenly(cube_rows, subcube_rows)
        <span class="org-variable-name">cache_cols</span>  <span class="org-operator">=</span> divide_evenly(cube_cols, subcube_cols)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Store the cube metadata, subcube_shape, cache_shape, cache, and load_subcube functions for later</span>
        <span class="org-keyword">self</span>.<span class="org-variable-name">ndim</span>          <span class="org-operator">=</span> 3
        <span class="org-keyword">self</span>.<span class="org-variable-name">size</span>          <span class="org-operator">=</span> cube_bands <span class="org-operator">*</span> cube_rows <span class="org-operator">*</span> cube_cols
        <span class="org-keyword">self</span>.<span class="org-variable-name">shape</span>         <span class="org-operator">=</span> cube_shape
        <span class="org-keyword">self</span>.<span class="org-variable-name">subcube_shape</span> <span class="org-operator">=</span> subcube_shape
        <span class="org-keyword">self</span>.<span class="org-variable-name">cache_shape</span>   <span class="org-operator">=</span> (cache_bands, cache_rows, cache_cols)
        <span class="org-keyword">self</span>.<span class="org-variable-name">cache</span>         <span class="org-operator">=</span> np.empty(<span class="org-keyword">self</span>.cache_shape, dtype<span class="org-operator">=</span><span class="org-builtin">object</span>)
        <span class="org-keyword">self</span>.<span class="org-variable-name">load_subcube</span>  <span class="org-operator">=</span> load_subcube


    <span class="org-keyword">def</span> <span class="org-function-name">__getOrLoadSubcube</span>(<span class="org-keyword">self</span>, cache_t, cache_y, cache_x):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the SpaceTimeCube stored at self.cache[cache_t, cache_y, cache_x] if it</span>
<span class="org-doc">        has already been loaded. Otherwise, call self.load_subcube to load it, store</span>
<span class="org-doc">        it in self.cache, and return it.</span>
<span class="org-doc">        """</span>
        <span class="org-variable-name">subcube</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.cache[cache_t, cache_y, cache_x]
        <span class="org-keyword">if</span> subcube:
            <span class="org-keyword">return</span> subcube
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">subcube</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.load_subcube((cache_t, cache_y, cache_x), <span class="org-keyword">self</span>.subcube_shape)
            <span class="org-keyword">self</span>.<span class="org-variable-name">cache</span>[<span class="org-variable-name">cache_t</span>, <span class="org-variable-name">cache_y</span>, <span class="org-variable-name">cache_x</span>] <span class="org-operator">=</span> subcube
            <span class="org-keyword">return</span> subcube


    <span class="org-keyword">def</span> <span class="org-function-name">get</span>(<span class="org-keyword">self</span>, t, y, x):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the scalar value at index (t,y,x) by translating these cube coordinates</span>
<span class="org-doc">        to cache and subcube coordinates, loading the matching subcube into the cache grid</span>
<span class="org-doc">        if not already present, and looking up the value within this subcube.</span>

<span class="org-doc">        NOTE: (t,y,x) = (0,0,0) is the upper-left corner of the array in the first timestep.</span>
<span class="org-doc">        NOTE: Indices may be negative provided that your load_subcube function can handle</span>
<span class="org-doc">              negative indices in its cache_index argument.</span>
<span class="org-doc">        """</span>
        (<span class="org-variable-name">subcube_bands</span>, <span class="org-variable-name">subcube_rows</span>, <span class="org-variable-name">subcube_cols</span>) <span class="org-operator">=</span> <span class="org-keyword">self</span>.subcube_shape
        (<span class="org-variable-name">cache_t</span>, <span class="org-variable-name">subcube_t</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(t, subcube_bands)
        (<span class="org-variable-name">cache_y</span>, <span class="org-variable-name">subcube_y</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(y, subcube_rows)
        (<span class="org-variable-name">cache_x</span>, <span class="org-variable-name">subcube_x</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(x, subcube_cols)
        <span class="org-variable-name">subcube</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.__getOrLoadSubcube(cache_t, cache_y, cache_x)
        <span class="org-keyword">return</span> subcube.get(subcube_t, subcube_y, subcube_x)


    <span class="org-keyword">def</span> <span class="org-function-name">getTimeSeries</span>(<span class="org-keyword">self</span>, t_range, y, x):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 1D array given by the slice (t_range,y,x) by translating these cube</span>
<span class="org-doc">        coordinates to cache and subcube coordinates, loading the matching subcubes into</span>
<span class="org-doc">        the cache grid if not already present, looking up the array slices within each</span>
<span class="org-doc">        subcube, and merging them together into a single 1D array.</span>

<span class="org-doc">        NOTE: (t,y,x) = (0,0,0) is the upper-left corner of the array in the first timestep.</span>
<span class="org-doc">        NOTE: Indices may be negative provided that your load_subcube function can handle</span>
<span class="org-doc">              negative indices in its cache_index argument.</span>
<span class="org-doc">        NOTE: Range indices may include one or more None values and</span>
<span class="org-doc">              provide (inclusion, exclusion) semantics like Python array slice notation.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the argument range</span>
        (<span class="org-variable-name">t_start</span>, <span class="org-variable-name">t_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(t_range, <span class="org-keyword">self</span>.shape[0])
        <span class="org-variable-name">t_stop</span> <span class="org-operator">=</span> t_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res coordinates to cache and subcube coordinates</span>
        (<span class="org-variable-name">subcube_bands</span>, <span class="org-variable-name">subcube_rows</span>, <span class="org-variable-name">subcube_cols</span>) <span class="org-operator">=</span> <span class="org-keyword">self</span>.subcube_shape
        (<span class="org-variable-name">cache_t_start</span>, <span class="org-variable-name">subcube_t_start</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(t_start, subcube_bands)
        (<span class="org-variable-name">cache_t_stop</span>,  <span class="org-variable-name">subcube_t_stop</span>)  <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(t_stop,  subcube_bands)
        (<span class="org-variable-name">cache_y</span>,       <span class="org-variable-name">subcube_y</span>)       <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(y,       subcube_rows)
        (<span class="org-variable-name">cache_x</span>,       <span class="org-variable-name">subcube_x</span>)       <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(x,       subcube_cols)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Load, expand, and combine subcubes</span>
        <span class="org-keyword">return</span> np.concatenate(
            [<span class="org-keyword">self</span>.__getOrLoadSubcube(cache_t,
                                     cache_y,
                                     cache_x
                                    ).getTimeSeries(
                                        (subcube_t_start    <span class="org-keyword">if</span> cache_t <span class="org-operator">==</span> cache_t_start <span class="org-keyword">else</span> 0,
                                         subcube_t_stop <span class="org-operator">+</span> 1 <span class="org-keyword">if</span> cache_t <span class="org-operator">==</span> cache_t_stop  <span class="org-keyword">else</span> subcube_bands),
                                        subcube_y,
                                        subcube_x
                                    )
             <span class="org-keyword">for</span> cache_t <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cache_t_start, cache_t_stop <span class="org-operator">+</span> 1)]
        )


    <span class="org-keyword">def</span> <span class="org-function-name">getSpatialPlane</span>(<span class="org-keyword">self</span>, t, y_range, x_range):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 2D array given by the slice (t,y_range,x_range) by translating these</span>
<span class="org-doc">        cube coordinates to cache and subcube coordinates, loading the matching subcubes</span>
<span class="org-doc">        into the cache grid if not already present, looking up the array slices within each</span>
<span class="org-doc">        subcube, and merging them together into a single 2D array.</span>

<span class="org-doc">        NOTE: (t,y,x) = (0,0,0) is the upper-left corner of the array in the first timestep.</span>
<span class="org-doc">        NOTE: Indices may be negative provided that your load_subcube function can handle</span>
<span class="org-doc">              negative indices in its cache_index argument.</span>
<span class="org-doc">        NOTE: Range indices may include one or more None values and</span>
<span class="org-doc">              provide (inclusion, exclusion) semantics like Python array slice notation.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the argument ranges</span>
        (<span class="org-variable-name">y_start</span>, <span class="org-variable-name">y_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(y_range, <span class="org-keyword">self</span>.shape[1])
        (<span class="org-variable-name">x_start</span>, <span class="org-variable-name">x_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(x_range, <span class="org-keyword">self</span>.shape[2])
        <span class="org-variable-name">y_stop</span> <span class="org-operator">=</span> y_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-variable-name">x_stop</span> <span class="org-operator">=</span> x_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res coordinates to cache and subcube coordinates</span>
        (<span class="org-variable-name">subcube_bands</span>, <span class="org-variable-name">subcube_rows</span>, <span class="org-variable-name">subcube_cols</span>) <span class="org-operator">=</span> <span class="org-keyword">self</span>.subcube_shape
        (<span class="org-variable-name">cache_t</span>,       <span class="org-variable-name">subcube_t</span>)       <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(t,       subcube_bands)
        (<span class="org-variable-name">cache_y_start</span>, <span class="org-variable-name">subcube_y_start</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(y_start, subcube_rows)
        (<span class="org-variable-name">cache_y_stop</span>,  <span class="org-variable-name">subcube_y_stop</span>)  <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(y_stop,  subcube_rows)
        (<span class="org-variable-name">cache_x_start</span>, <span class="org-variable-name">subcube_x_start</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(x_start, subcube_cols)
        (<span class="org-variable-name">cache_x_stop</span>,  <span class="org-variable-name">subcube_x_stop</span>)  <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(x_stop,  subcube_cols)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Load, expand, and combine subcubes</span>
        <span class="org-keyword">return</span> np.block(
            [[<span class="org-keyword">self</span>.__getOrLoadSubcube(cache_t,
                                      cache_y,
                                      cache_x
                                      ).getSpatialPlane(
                                          subcube_t,
                                          (subcube_y_start    <span class="org-keyword">if</span> cache_y <span class="org-operator">==</span> cache_y_start <span class="org-keyword">else</span> 0,
                                           subcube_y_stop <span class="org-operator">+</span> 1 <span class="org-keyword">if</span> cache_y <span class="org-operator">==</span> cache_y_stop  <span class="org-keyword">else</span> subcube_rows),
                                          (subcube_x_start    <span class="org-keyword">if</span> cache_x <span class="org-operator">==</span> cache_x_start <span class="org-keyword">else</span> 0,
                                           subcube_x_stop <span class="org-operator">+</span> 1 <span class="org-keyword">if</span> cache_x <span class="org-operator">==</span> cache_x_stop  <span class="org-keyword">else</span> subcube_cols)
                                      )
              <span class="org-keyword">for</span> cache_x <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cache_x_start, cache_x_stop <span class="org-operator">+</span> 1)]
             <span class="org-keyword">for</span> cache_y <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cache_y_start, cache_y_stop <span class="org-operator">+</span> 1)]
        )


    <span class="org-keyword">def</span> <span class="org-function-name">getSubcube</span>(<span class="org-keyword">self</span>, t_range, y_range, x_range):
        <span class="org-doc">"""</span>
<span class="org-doc">        Return the 3D array given by the slice (t_range,y_range,x_range) by translating</span>
<span class="org-doc">        these cube coordinates to cache and subcube coordinates, loading the matching</span>
<span class="org-doc">        subcubes into the cache grid if not already present, looking up the array slices</span>
<span class="org-doc">        within each subcube, and merging them together into a single 3D array.</span>

<span class="org-doc">        NOTE: (t,y,x) = (0,0,0) is the upper-left corner of the array in the first timestep.</span>
<span class="org-doc">        NOTE: Indices may be negative provided that your load_subcube function can handle</span>
<span class="org-doc">              negative indices in its cache_index argument.</span>
<span class="org-doc">        NOTE: Range indices may include one or more None values and</span>
<span class="org-doc">              provide (inclusion, exclusion) semantics like Python array slice notation.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Destructure the argument ranges</span>
        (<span class="org-variable-name">t_start</span>, <span class="org-variable-name">t_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(t_range, <span class="org-keyword">self</span>.shape[0])
        (<span class="org-variable-name">y_start</span>, <span class="org-variable-name">y_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(y_range, <span class="org-keyword">self</span>.shape[1])
        (<span class="org-variable-name">x_start</span>, <span class="org-variable-name">x_stop_exclusive</span>) <span class="org-operator">=</span> to_positive_index_range(x_range, <span class="org-keyword">self</span>.shape[2])
        <span class="org-variable-name">t_stop</span> <span class="org-operator">=</span> t_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-variable-name">y_stop</span> <span class="org-operator">=</span> y_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-variable-name">x_stop</span> <span class="org-operator">=</span> x_stop_exclusive <span class="org-operator">-</span> 1
        <span class="org-comment-delimiter"># </span><span class="org-comment">Translate high-res coordinates to cache and subcube coordinates</span>
        (<span class="org-variable-name">subcube_bands</span>, <span class="org-variable-name">subcube_rows</span>, <span class="org-variable-name">subcube_cols</span>) <span class="org-operator">=</span> <span class="org-keyword">self</span>.subcube_shape
        (<span class="org-variable-name">cache_t_start</span>, <span class="org-variable-name">subcube_t_start</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(t_start, subcube_bands)
        (<span class="org-variable-name">cache_t_stop</span>,  <span class="org-variable-name">subcube_t_stop</span>)  <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(t_stop,  subcube_bands)
        (<span class="org-variable-name">cache_y_start</span>, <span class="org-variable-name">subcube_y_start</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(y_start, subcube_rows)
        (<span class="org-variable-name">cache_y_stop</span>,  <span class="org-variable-name">subcube_y_stop</span>)  <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(y_stop,  subcube_rows)
        (<span class="org-variable-name">cache_x_start</span>, <span class="org-variable-name">subcube_x_start</span>) <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(x_start, subcube_cols)
        (<span class="org-variable-name">cache_x_stop</span>,  <span class="org-variable-name">subcube_x_stop</span>)  <span class="org-operator">=</span> <span class="org-builtin">divmod</span>(x_stop,  subcube_cols)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Load, expand, and combine subcubes</span>
        <span class="org-keyword">return</span> np.block(
            [[[<span class="org-keyword">self</span>.__getOrLoadSubcube(cache_t,
                                       cache_y,
                                       cache_x
                                       ).getSubcube(
                                           (subcube_t_start    <span class="org-keyword">if</span> cache_t <span class="org-operator">==</span> cache_t_start <span class="org-keyword">else</span> 0,
                                            subcube_t_stop <span class="org-operator">+</span> 1 <span class="org-keyword">if</span> cache_t <span class="org-operator">==</span> cache_t_stop  <span class="org-keyword">else</span> subcube_bands),
                                           (subcube_y_start    <span class="org-keyword">if</span> cache_y <span class="org-operator">==</span> cache_y_start <span class="org-keyword">else</span> 0,
                                            subcube_y_stop <span class="org-operator">+</span> 1 <span class="org-keyword">if</span> cache_y <span class="org-operator">==</span> cache_y_stop  <span class="org-keyword">else</span> subcube_rows),
                                           (subcube_x_start    <span class="org-keyword">if</span> cache_x <span class="org-operator">==</span> cache_x_start <span class="org-keyword">else</span> 0,
                                            subcube_x_stop <span class="org-operator">+</span> 1 <span class="org-keyword">if</span> cache_x <span class="org-operator">==</span> cache_x_stop  <span class="org-keyword">else</span> subcube_cols)
                                       )
               <span class="org-keyword">for</span> cache_x <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cache_x_start, cache_x_stop <span class="org-operator">+</span> 1)]
              <span class="org-keyword">for</span> cache_y <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cache_y_start, cache_y_stop <span class="org-operator">+</span> 1)]
             <span class="org-keyword">for</span> cache_t <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cache_t_start, cache_t_stop <span class="org-operator">+</span> 1)]
        )


    <span class="org-keyword">def</span> <span class="org-function-name">getFullyRealizedCube</span>(<span class="org-keyword">self</span>, cache<span class="org-operator">=</span><span class="org-constant">False</span>):
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"getFullyRealizedCube is not implemented for LazySpaceTimeCube.</span><span class="org-constant">\n</span><span class="org-string">"</span>
                         <span class="org-operator">+</span> <span class="org-string">"You probably don't want to do this anyway."</span>)


    <span class="org-keyword">def</span> <span class="org-function-name">releaseFullyRealizedCube</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"releaseFullyRealizedCube is not implemented for LazySpaceTimeCube.</span><span class="org-constant">\n</span><span class="org-string">"</span>
                         <span class="org-operator">+</span> <span class="org-string">"You probably don't want to do this anyway."</span>)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc69d42c" class="outline-3">
<h3 id="orgc69d42c"><span class="section-number-3">3.2.</span> For Users</h3>
<div class="outline-text-3" id="text-3-2">
<p>
In the following sections, we will use functions from <a href="https://pypi.org/project/numpy/">numpy</a> and the
Python standard library to construct arrays of different resolutions
in memory to use in our <code>SpaceTimeCube</code> and <code>LazySpaceTimeCube</code>
examples. In many real world applications, this array data will
probably be read in from files or databases using Python libraries
such as <a href="https://pypi.org/project/rasterio/">rasterio</a> or <a href="https://pypi.org/project/psycopg2/">psycopg2</a>. All examples should apply equally well
in either case.
</p>
</div>
<div id="outline-container-org9652a54" class="outline-4">
<h4 id="org9652a54"><span class="section-number-4">3.2.1.</span> How to Use SpaceTimeCube</h4>
<div class="outline-text-4" id="text-3-2-1">
</div>
<ol class="org-ol">
<li><a id="org13c80cb"></a>Create a SpaceTimeCube from 0D, 1D, 2D, or 3D Input Data<br>
<div class="outline-text-5" id="text-3-2-1-1">
<div class="org-src-container">
<pre class="src src-python" id="org28781bc"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Set a Random Seed</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

np.random.seed(0)

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube Dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (
    240,  <span class="org-comment-delimiter"># </span><span class="org-comment">bands: 10 days @ 1 hour/band</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">rows:  30 km @ 30 meters/row</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">cols:  30 km @ 30 meters/col</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Constant Data: foliar moisture = 70% everywhere</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">foliar_moisture</span> <span class="org-operator">=</span> 0.7
<span class="org-variable-name">constant_cube</span>   <span class="org-operator">=</span> SpaceTimeCube(cube_shape, foliar_moisture)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Temporal Data: 24-hour burn period with ramp up and ramp down for 10 days</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">spread_rate_adjustments</span> <span class="org-operator">=</span> ([0] <span class="org-operator">*</span> 6 <span class="org-operator">+</span> [0.33, 0.66] <span class="org-operator">+</span> [1] <span class="org-operator">*</span> 12 <span class="org-operator">+</span> [0.66, 0.33] <span class="org-operator">+</span> [0] <span class="org-operator">*</span> 2) <span class="org-operator">*</span> 10
<span class="org-variable-name">time_series_cube</span>        <span class="org-operator">=</span> SpaceTimeCube(cube_shape, spread_rate_adjustments)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Spatial Data: 2D elevation raster with 1000 (30m) x 1000 (30m) cells</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">elevation_raster</span> <span class="org-operator">=</span> np.random.normal(500, 100, 1000000).astype(<span class="org-string">"int"</span>).reshape(1000,1000)
<span class="org-variable-name">spatial_cube</span>     <span class="org-operator">=</span> SpaceTimeCube(cube_shape, elevation_raster)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Spatio-Temporal Data: 3D daily max wind speed raster with 10 (days) x 100 (300m) x 100 (300m) cells</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">wind_speed_raster</span>   <span class="org-operator">=</span> np.random.normal(30, 5, 100000).astype(<span class="org-string">"int"</span>).reshape(10,100,100)
<span class="org-variable-name">spatiotemporal_cube</span> <span class="org-operator">=</span> SpaceTimeCube(cube_shape, wind_speed_raster)
</pre>
</div>
</div>
</li>
<li><a id="orgbc6efdb"></a>Retrieve a Scalar Value at a Space-Time Coordinate<br>
<div class="outline-text-5" id="text-3-2-1-2">
<div class="org-src-container">
<pre class="src src-python" id="orgcd2ad53"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinate</span>
<span class="org-variable-name">band</span> <span class="org-operator">=</span> 12
<span class="org-variable-name">row</span>  <span class="org-operator">=</span> 100
<span class="org-variable-name">col</span>  <span class="org-operator">=</span> 100

<span class="org-builtin">print</span>(<span class="org-string">"Value from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.get(band, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Value from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.get(band, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Value from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.get(band, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Value from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.get(band, row, col))
</pre>
</div>

<pre class="example" id="orgf7c69fe">
Value from Constant Data: Foliar Moisture
0.7 

Value from Time Series Data: Spread Rate Adjustment
1.0 

Value from Spatial Data: Elevation
564 

Value from Spatio-Temporal Data: Wind Speed
32
</pre>
</div>
</li>
<li><a id="org86cc4fd"></a>Retrieve a Time Series at a Spatial Coordinate<br>
<div class="outline-text-5" id="text-3-2-1-3">
<div class="org-src-container">
<pre class="src src-python" id="org323bfa5"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinates</span>
<span class="org-variable-name">band_range</span> <span class="org-operator">=</span> (18,30)
<span class="org-variable-name">row</span>        <span class="org-operator">=</span> 100
<span class="org-variable-name">col</span>        <span class="org-operator">=</span> 100

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.getTimeSeries(band_range, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.getTimeSeries(band_range, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.getTimeSeries(band_range, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.getTimeSeries(band_range, row, col))
</pre>
</div>

<pre class="example" id="org0ac81ff">
Time Series from Constant Data: Foliar Moisture
[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7] 

Time Series from Time Series Data: Spread Rate Adjustment
[1.   1.   0.66 0.33 0.   0.   0.   0.   0.   0.   0.   0.  ] 

Time Series from Spatial Data: Elevation
[564 564 564 564 564 564 564 564 564 564 564 564] 

Time Series from Spatio-Temporal Data: Wind Speed
[32 32 32 32 32 32 37 37 37 37 37 37]
</pre>
</div>
</li>
<li><a id="orga1f5a34"></a>Retrieve a Spatial Plane at a Temporal Coordinate<br>
<div class="outline-text-5" id="text-3-2-1-4">
<div class="org-src-container">
<pre class="src src-python" id="orge579503"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinates</span>
<span class="org-variable-name">band</span>      <span class="org-operator">=</span> 12
<span class="org-variable-name">row_range</span> <span class="org-operator">=</span> (95,105)
<span class="org-variable-name">col_range</span> <span class="org-operator">=</span> (95,105)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.getSpatialPlane(band, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.getSpatialPlane(band, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.getSpatialPlane(band, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.getSpatialPlane(band, row_range, col_range))
</pre>
</div>

<pre class="example" id="org99ce8bd">
Spatial Plane from Constant Data: Foliar Moisture
[[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]] 

Spatial Plane from Time Series Data: Spread Rate Adjustment
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]] 

Spatial Plane from Spatial Data: Elevation
[[574 369 544 310 517 488 565 549 450 470]
 [443 551 480 476 432 561 578 361 468 480]
 [520 712 396 393 584 292 424 391 494 586]
 [707 534 246 423 521 500 426 340 288 482]
 [542 285 607 555 645 559 461 603 330 452]
 [498 497 664 445 518 564 461 508 600 380]
 [454 500 276 487 447 591 413 378 458 508]
 [573 890 485 501 357 413 356 635 374 618]
 [535 558 491 482 539 572 598 703 463 329]
 [487 555 580 492 462 484 495 396 711 356]] 

Spatial Plane from Spatio-Temporal Data: Wind Speed
[[31 31 31 31 31 31 31 31 31 31]
 [31 31 31 31 31 31 31 31 31 31]
 [31 31 31 31 31 31 31 31 31 31]
 [31 31 31 31 31 31 31 31 31 31]
 [31 31 31 31 31 31 31 31 31 31]
 [26 26 26 26 26 32 32 32 32 32]
 [26 26 26 26 26 32 32 32 32 32]
 [26 26 26 26 26 32 32 32 32 32]
 [26 26 26 26 26 32 32 32 32 32]
 [26 26 26 26 26 32 32 32 32 32]]
</pre>
</div>
</li>
<li><a id="org2870606"></a>Retrieve a Subcube within a Space-Time Region<br>
<div class="outline-text-5" id="text-3-2-1-5">
<div class="org-src-container">
<pre class="src src-python" id="org3c841bc"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinates</span>
<span class="org-variable-name">band_range</span> <span class="org-operator">=</span> (23,25)
<span class="org-variable-name">row_range</span>  <span class="org-operator">=</span> (95,105)
<span class="org-variable-name">col_range</span>  <span class="org-operator">=</span> (95,105)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.getSubcube(band_range, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.getSubcube(band_range, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.getSubcube(band_range, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.getSubcube(band_range, row_range, col_range))
</pre>
</div>

<pre class="example" id="org047d375">
Subcube from Constant Data: Foliar Moisture
[[[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]]

 [[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]]] 

Subcube from Time Series Data: Spread Rate Adjustment
[[[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]]

 [[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]]] 

Subcube from Spatial Data: Elevation
[[[574 369 544 310 517 488 565 549 450 470]
  [443 551 480 476 432 561 578 361 468 480]
  [520 712 396 393 584 292 424 391 494 586]
  [707 534 246 423 521 500 426 340 288 482]
  [542 285 607 555 645 559 461 603 330 452]
  [498 497 664 445 518 564 461 508 600 380]
  [454 500 276 487 447 591 413 378 458 508]
  [573 890 485 501 357 413 356 635 374 618]
  [535 558 491 482 539 572 598 703 463 329]
  [487 555 580 492 462 484 495 396 711 356]]

 [[574 369 544 310 517 488 565 549 450 470]
  [443 551 480 476 432 561 578 361 468 480]
  [520 712 396 393 584 292 424 391 494 586]
  [707 534 246 423 521 500 426 340 288 482]
  [542 285 607 555 645 559 461 603 330 452]
  [498 497 664 445 518 564 461 508 600 380]
  [454 500 276 487 447 591 413 378 458 508]
  [573 890 485 501 357 413 356 635 374 618]
  [535 558 491 482 539 572 598 703 463 329]
  [487 555 580 492 462 484 495 396 711 356]]] 

Subcube from Spatio-Temporal Data: Wind Speed
[[[31 31 31 31 31 31 31 31 31 31]
  [31 31 31 31 31 31 31 31 31 31]
  [31 31 31 31 31 31 31 31 31 31]
  [31 31 31 31 31 31 31 31 31 31]
  [31 31 31 31 31 31 31 31 31 31]
  [26 26 26 26 26 32 32 32 32 32]
  [26 26 26 26 26 32 32 32 32 32]
  [26 26 26 26 26 32 32 32 32 32]
  [26 26 26 26 26 32 32 32 32 32]
  [26 26 26 26 26 32 32 32 32 32]]

 [[30 30 30 30 30 36 36 36 36 36]
  [30 30 30 30 30 36 36 36 36 36]
  [30 30 30 30 30 36 36 36 36 36]
  [30 30 30 30 30 36 36 36 36 36]
  [30 30 30 30 30 36 36 36 36 36]
  [34 34 34 34 34 37 37 37 37 37]
  [34 34 34 34 34 37 37 37 37 37]
  [34 34 34 34 34 37 37 37 37 37]
  [34 34 34 34 34 37 37 37 37 37]
  [34 34 34 34 34 37 37 37 37 37]]]
</pre>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgee73c54" class="outline-4">
<h4 id="orgee73c54"><span class="section-number-4">3.2.2.</span> How to Use LazySpaceTimeCube</h4>
<div class="outline-text-4" id="text-3-2-2">
</div>
<ol class="org-ol">
<li><a id="orgdcf56d6"></a>Create a LazySpaceTimeCube from 0D, 1D, 2D, or 3D Input Data<br>
<div class="outline-text-5" id="text-3-2-2-1">
<div class="org-src-container">
<pre class="src src-python" id="org8c8d57d"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube, LazySpaceTimeCube

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Set a Random Seed</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

np.random.seed(0)

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube Dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (
    240,  <span class="org-comment-delimiter"># </span><span class="org-comment">bands: 10 days @ 1 hour/band</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">rows:  30 km @ 30 meters/row</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">cols:  30 km @ 30 meters/col</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Constant Data: foliar moisture = 70% everywhere</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">foliar_moisture</span>               <span class="org-operator">=</span> 0.7
<span class="org-variable-name">foliar_moisture_subcube_shape</span> <span class="org-operator">=</span> cube_shape <span class="org-comment-delimiter"># </span><span class="org-comment">Only 1 subcube necessary</span>

<span class="org-keyword">def</span> <span class="org-function-name">foliar_moisture_load_subcube</span>(_, subcube_shape):
    <span class="org-keyword">return</span> SpaceTimeCube(subcube_shape, foliar_moisture)

<span class="org-variable-name">constant_cube</span> <span class="org-operator">=</span> LazySpaceTimeCube(cube_shape,
                                  foliar_moisture_subcube_shape,
                                  foliar_moisture_load_subcube)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Temporal Data: 24-hour burn period with ramp up and ramp down for 10 days</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">spread_rate_adjustments</span>               <span class="org-operator">=</span> ([0] <span class="org-operator">*</span> 6 <span class="org-operator">+</span> [0.33, 0.66] <span class="org-operator">+</span> [1] <span class="org-operator">*</span> 12 <span class="org-operator">+</span> [0.66, 0.33] <span class="org-operator">+</span> [0] <span class="org-operator">*</span> 2) <span class="org-operator">*</span> 10
<span class="org-variable-name">spread_rate_adjustments_subcube_shape</span> <span class="org-operator">=</span> (24, 1000, 1000) <span class="org-comment-delimiter"># </span><span class="org-comment">1 subcube per day (10 total)</span>

<span class="org-keyword">def</span> <span class="org-function-name">spread_rate_adjustments_load_subcube</span>(cache_index, subcube_shape):
    (<span class="org-variable-name">cache_t</span>, <span class="org-variable-name">_</span>, <span class="org-variable-name">_</span>) <span class="org-operator">=</span> cache_index
    <span class="org-variable-name">t_start</span> <span class="org-operator">=</span> 24 <span class="org-operator">*</span> cache_t
    <span class="org-variable-name">t_stop</span>  <span class="org-operator">=</span> 24 <span class="org-operator">*</span> (cache_t <span class="org-operator">+</span> 1)
    <span class="org-keyword">return</span> SpaceTimeCube(subcube_shape,
                         spread_rate_adjustments[t_start:t_stop])

<span class="org-variable-name">time_series_cube</span> <span class="org-operator">=</span> LazySpaceTimeCube(cube_shape,
                                     spread_rate_adjustments_subcube_shape,
                                     spread_rate_adjustments_load_subcube)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Spatial Data: 2D elevation raster with 1000 (30m) x 1000 (30m) cells</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">elevation_raster</span>               <span class="org-operator">=</span> np.random.normal(500, 100, 1000000).astype(<span class="org-string">"int"</span>).reshape(1000,1000)
<span class="org-variable-name">elevation_raster_subcube_shape</span> <span class="org-operator">=</span> (240, 100, 100) <span class="org-comment-delimiter"># </span><span class="org-comment">1 subcube per 100x100 cell region (10x10 = 100 total)</span>

<span class="org-keyword">def</span> <span class="org-function-name">elevation_raster_load_subcube</span>(cache_index, subcube_shape):
    (<span class="org-variable-name">_</span>, <span class="org-variable-name">cache_y</span>, <span class="org-variable-name">cache_x</span>) <span class="org-operator">=</span> cache_index
    <span class="org-variable-name">y_start</span> <span class="org-operator">=</span> 100 <span class="org-operator">*</span> cache_y
    <span class="org-variable-name">y_stop</span>  <span class="org-operator">=</span> 100 <span class="org-operator">*</span> (cache_y <span class="org-operator">+</span> 1)
    <span class="org-variable-name">x_start</span> <span class="org-operator">=</span> 100 <span class="org-operator">*</span> cache_x
    <span class="org-variable-name">x_stop</span>  <span class="org-operator">=</span> 100 <span class="org-operator">*</span> (cache_x <span class="org-operator">+</span> 1)
    <span class="org-keyword">return</span> SpaceTimeCube(subcube_shape,
                         elevation_raster[y_start:y_stop,
                                          x_start:x_stop])

<span class="org-variable-name">spatial_cube</span> <span class="org-operator">=</span> LazySpaceTimeCube(cube_shape,
                                 elevation_raster_subcube_shape,
                                 elevation_raster_load_subcube)

<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Spatio-Temporal Data: 3D daily max wind speed raster with 10 (days) x 100 (300m) x 100 (300m) cells</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=====================================================================================================</span>

<span class="org-variable-name">wind_speed_raster</span>               <span class="org-operator">=</span> np.random.normal(30, 5, 100000).astype(<span class="org-string">"int"</span>).reshape(10,100,100)
<span class="org-variable-name">wind_speed_raster_subcube_shape</span> <span class="org-operator">=</span> (24, 100, 100) <span class="org-comment-delimiter"># </span><span class="org-comment">1 subcube per day per 100x100 cell region (10x10x10 = 1000 total)</span>

<span class="org-keyword">def</span> <span class="org-function-name">wind_speed_raster_load_subcube</span>(cache_index, subcube_shape):
    (<span class="org-variable-name">cache_t</span>, <span class="org-variable-name">cache_y</span>, <span class="org-variable-name">cache_x</span>) <span class="org-operator">=</span> cache_index
    <span class="org-variable-name">t_start</span> <span class="org-operator">=</span> cache_t
    <span class="org-variable-name">t_stop</span>  <span class="org-operator">=</span> cache_t <span class="org-operator">+</span> 1
    <span class="org-variable-name">y_start</span> <span class="org-operator">=</span> 10 <span class="org-operator">*</span> cache_y
    <span class="org-variable-name">y_stop</span>  <span class="org-operator">=</span> 10 <span class="org-operator">*</span> (cache_y <span class="org-operator">+</span> 1)
    <span class="org-variable-name">x_start</span> <span class="org-operator">=</span> 10 <span class="org-operator">*</span> cache_x
    <span class="org-variable-name">x_stop</span>  <span class="org-operator">=</span> 10 <span class="org-operator">*</span> (cache_x <span class="org-operator">+</span> 1)
    <span class="org-keyword">return</span> SpaceTimeCube(subcube_shape,
                         wind_speed_raster[t_start:t_stop,
                                           y_start:y_stop,
                                           x_start:x_stop])

<span class="org-variable-name">spatiotemporal_cube</span> <span class="org-operator">=</span> LazySpaceTimeCube(cube_shape,
                                        wind_speed_raster_subcube_shape,
                                        wind_speed_raster_load_subcube)
</pre>
</div>
</div>
</li>
<li><a id="org8f12fb2"></a>Retrieve a Scalar Value at a Space-Time Coordinate<br>
<div class="outline-text-5" id="text-3-2-2-2">
<div class="org-src-container">
<pre class="src src-python" id="org15b71ec"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinate</span>
<span class="org-variable-name">band</span> <span class="org-operator">=</span> 12
<span class="org-variable-name">row</span>  <span class="org-operator">=</span> 100
<span class="org-variable-name">col</span>  <span class="org-operator">=</span> 100

<span class="org-builtin">print</span>(<span class="org-string">"Value from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.get(band, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Value from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.get(band, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Value from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.get(band, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Value from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.get(band, row, col))
</pre>
</div>

<pre class="example" id="org28b974e">
Value from Constant Data: Foliar Moisture
0.7 

Value from Time Series Data: Spread Rate Adjustment
1.0 

Value from Spatial Data: Elevation
564 

Value from Spatio-Temporal Data: Wind Speed
32
</pre>
</div>
</li>
<li><a id="orga4a7b4d"></a>Retrieve a Time Series at a Spatial Coordinate<br>
<div class="outline-text-5" id="text-3-2-2-3">
<div class="org-src-container">
<pre class="src src-python" id="orgc0eea60"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinates</span>
<span class="org-variable-name">band_range</span> <span class="org-operator">=</span> (18,30)
<span class="org-variable-name">row</span>        <span class="org-operator">=</span> 100
<span class="org-variable-name">col</span>        <span class="org-operator">=</span> 100

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.getTimeSeries(band_range, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.getTimeSeries(band_range, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.getTimeSeries(band_range, row, col), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Time Series from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.getTimeSeries(band_range, row, col))
</pre>
</div>

<pre class="example" id="org22a9404">
Time Series from Constant Data: Foliar Moisture
[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7] 

Time Series from Time Series Data: Spread Rate Adjustment
[1.   1.   0.66 0.33 0.   0.   0.   0.   0.   0.   0.   0.  ] 

Time Series from Spatial Data: Elevation
[564 564 564 564 564 564 564 564 564 564 564 564] 

Time Series from Spatio-Temporal Data: Wind Speed
[32 32 32 32 32 32 37 37 37 37 37 37]
</pre>
</div>
</li>
<li><a id="org74ed71b"></a>Retrieve a Spatial Plane at a Temporal Coordinate<br>
<div class="outline-text-5" id="text-3-2-2-4">
<div class="org-src-container">
<pre class="src src-python" id="orgeba06bc"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinates</span>
<span class="org-variable-name">band</span>      <span class="org-operator">=</span> 12
<span class="org-variable-name">row_range</span> <span class="org-operator">=</span> (95,105)
<span class="org-variable-name">col_range</span> <span class="org-operator">=</span> (95,105)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.getSpatialPlane(band, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.getSpatialPlane(band, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.getSpatialPlane(band, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Spatial Plane from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.getSpatialPlane(band, row_range, col_range))
</pre>
</div>

<pre class="example" id="org3bf232e">
Spatial Plane from Constant Data: Foliar Moisture
[[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
 [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]] 

Spatial Plane from Time Series Data: Spread Rate Adjustment
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]] 

Spatial Plane from Spatial Data: Elevation
[[574 369 544 310 517 488 565 549 450 470]
 [443 551 480 476 432 561 578 361 468 480]
 [520 712 396 393 584 292 424 391 494 586]
 [707 534 246 423 521 500 426 340 288 482]
 [542 285 607 555 645 559 461 603 330 452]
 [498 497 664 445 518 564 461 508 600 380]
 [454 500 276 487 447 591 413 378 458 508]
 [573 890 485 501 357 413 356 635 374 618]
 [535 558 491 482 539 572 598 703 463 329]
 [487 555 580 492 462 484 495 396 711 356]] 

Spatial Plane from Spatio-Temporal Data: Wind Speed
[[31 31 31 31 31 31 31 31 31 31]
 [31 31 31 31 31 31 31 31 31 31]
 [31 31 31 31 31 31 31 31 31 31]
 [31 31 31 31 31 31 31 31 31 31]
 [31 31 31 31 31 31 31 31 31 31]
 [26 26 26 26 26 32 32 32 32 32]
 [26 26 26 26 26 32 32 32 32 32]
 [26 26 26 26 26 32 32 32 32 32]
 [26 26 26 26 26 32 32 32 32 32]
 [26 26 26 26 26 32 32 32 32 32]]
</pre>
</div>
</li>
<li><a id="org0f84e18"></a>Retrieve a Subcube within a Space-Time Region<br>
<div class="outline-text-5" id="text-3-2-2-5">
<div class="org-src-container">
<pre class="src src-python" id="org10fcdfd"><span class="org-comment-delimiter"># </span><span class="org-comment">Space-Time Coordinates</span>
<span class="org-variable-name">band_range</span> <span class="org-operator">=</span> (23,25)
<span class="org-variable-name">row_range</span>  <span class="org-operator">=</span> (95,105)
<span class="org-variable-name">col_range</span>  <span class="org-operator">=</span> (95,105)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Constant Data: Foliar Moisture"</span>)
<span class="org-builtin">print</span>(constant_cube.getSubcube(band_range, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Time Series Data: Spread Rate Adjustment"</span>)
<span class="org-builtin">print</span>(time_series_cube.getSubcube(band_range, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Spatial Data: Elevation"</span>)
<span class="org-builtin">print</span>(spatial_cube.getSubcube(band_range, row_range, col_range), <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"Subcube from Spatio-Temporal Data: Wind Speed"</span>)
<span class="org-builtin">print</span>(spatiotemporal_cube.getSubcube(band_range, row_range, col_range))
</pre>
</div>

<pre class="example" id="orgad8edb4">
Subcube from Constant Data: Foliar Moisture
[[[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]]

 [[0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]
  [0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7 0.7]]] 

Subcube from Time Series Data: Spread Rate Adjustment
[[[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]]

 [[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]]] 

Subcube from Spatial Data: Elevation
[[[574 369 544 310 517 488 565 549 450 470]
  [443 551 480 476 432 561 578 361 468 480]
  [520 712 396 393 584 292 424 391 494 586]
  [707 534 246 423 521 500 426 340 288 482]
  [542 285 607 555 645 559 461 603 330 452]
  [498 497 664 445 518 564 461 508 600 380]
  [454 500 276 487 447 591 413 378 458 508]
  [573 890 485 501 357 413 356 635 374 618]
  [535 558 491 482 539 572 598 703 463 329]
  [487 555 580 492 462 484 495 396 711 356]]

 [[574 369 544 310 517 488 565 549 450 470]
  [443 551 480 476 432 561 578 361 468 480]
  [520 712 396 393 584 292 424 391 494 586]
  [707 534 246 423 521 500 426 340 288 482]
  [542 285 607 555 645 559 461 603 330 452]
  [498 497 664 445 518 564 461 508 600 380]
  [454 500 276 487 447 591 413 378 458 508]
  [573 890 485 501 357 413 356 635 374 618]
  [535 558 491 482 539 572 598 703 463 329]
  [487 555 580 492 462 484 495 396 711 356]]] 

Subcube from Spatio-Temporal Data: Wind Speed
[[[31 31 31 31 31 31 31 31 31 31]
  [31 31 31 31 31 31 31 31 31 31]
  [31 31 31 31 31 31 31 31 31 31]
  [31 31 31 31 31 31 31 31 31 31]
  [31 31 31 31 31 31 31 31 31 31]
  [26 26 26 26 26 32 32 32 32 32]
  [26 26 26 26 26 32 32 32 32 32]
  [26 26 26 26 26 32 32 32 32 32]
  [26 26 26 26 26 32 32 32 32 32]
  [26 26 26 26 26 32 32 32 32 32]]

 [[30 30 30 30 30 36 36 36 36 36]
  [30 30 30 30 30 36 36 36 36 36]
  [30 30 30 30 30 36 36 36 36 36]
  [30 30 30 30 30 36 36 36 36 36]
  [30 30 30 30 30 36 36 36 36 36]
  [34 34 34 34 34 37 37 37 37 37]
  [34 34 34 34 34 37 37 37 37 37]
  [34 34 34 34 34 37 37 37 37 37]
  [34 34 34 34 34 37 37 37 37 37]
  [34 34 34 34 34 37 37 37 37 37]]]
</pre>
</div>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org33e0010" class="outline-2">
<h2 id="org33e0010"><span class="section-number-2">4.</span> [WIP] Fire Behavior Model</h2>
<div class="outline-text-2" id="text-4">
<p>
Pyretechnics implements the following fire behavior formulas from the
fire science literature:
</p>

<ul class="org-ul">
<li>Surface Fire Spread: Rothermel 1972 with FIREMODS adjustments from Albini 1976</li>
<li>Crown Fire Initiation: Van Wagner 1977</li>
<li>Passive/Active Crown Fire Spread: Cruz 2005</li>
<li>Flame Length and Fireline Intensity: Byram 1959</li>
<li>Midflame Wind Adjustment Factor: Albini &amp; Baughman 1979 parameterized as in BehavePlus, FARSITE, FlamMap, FSPro, and FPA according to Andrews 2012</li>
<li>Fire Spread on a Raster Grid: Morais 2001 (method of adaptive timesteps and fractional distances)</li>
<li>Spot Fire: Perryman 2013</li>
</ul>

<p>
The following fuel models are supported:
</p>

<ul class="org-ul">
<li>Anderson 13: no dynamic loading</li>
<li>Scott &amp; Burgan 40: dynamic loading implemented according to Scott &amp; Burgan 2005</li>
</ul>

<p>
In the following sections, we describe the operation of this system in
detail.
</p>
</div>
</div>
<div id="outline-container-org742a728" class="outline-2">
<h2 id="org742a728"><span class="section-number-2">5.</span> Fuel Model and Moisture Definitions (pyretechnics.fuel_models)</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org4eea284" class="outline-3">
<h3 id="org4eea284"><span class="section-number-3">5.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-5-1">
<p>
The following sections encode various fire behavior fuel models as
Python dictionaries and then provide functions to augment their static
properties with additional information that is dependent upon fuel
moisture. This combination of fuel models and moisture form the basis
of many fire behavior analyses.
</p>
</div>
<div id="outline-container-orgb506a85" class="outline-4">
<h4 id="orgb506a85"><span class="section-number-4">5.1.1.</span> Fuel Model Properties</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
All fires ignite and travel through some form of burnable fuel.
Although the effects of wind and slope on the rate of fire spread can
be quite pronounced, its fundamental thermodynamic characteristics are
largely determined by the fuel type in which it is sustained. For
wildfires, these fuels are predominantly herbaceous and woody
vegetation (both alive and dead) as well as decomposing elements of
dead vegetation, such as duff or leaf litter. To estimate the heat
output and rate of spread of a fire burning through any of these
fuels, we must determine those physical properties that affect heat
absorption and release.
</p>

<p>
Of course, measuring these fuel properties for every kind of
vegetation that may be burned in a wildfire is an intractable task. To
cope with this, fuels are classified into categories called "fuel
models" which share similar burning characteristics. Each fuel model
is then assigned a set of representative values for each of the
thermally relevant physical properties shown in Table
<a href="#org660ca2b">1</a>.
</p>

<table id="org660ca2b">
<caption class="t-above"><span class="table-number">Table 1:</span> Physical properties assigned to each fuel model</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Property</th>
<th scope="col" class="org-left">Description</th>
<th scope="col" class="org-left">Units</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">\(\delta\)</td>
<td class="org-left">fuel depth</td>
<td class="org-left">\(\text{ft}\)</td>
</tr>

<tr>
<td class="org-left">\(w_o\)</td>
<td class="org-left">ovendry fuel loading</td>
<td class="org-left">\(\text{lb}/\text{ft}^2\)</td>
</tr>

<tr>
<td class="org-left">\(\rho_p\)</td>
<td class="org-left">ovendry particle density</td>
<td class="org-left">\(\text{lb}/\text{ft}^3\)</td>
</tr>

<tr>
<td class="org-left">\(\sigma\)</td>
<td class="org-left">fuel particle surface-area-to-volume ratio</td>
<td class="org-left">\(\text{ft}^2/\text{ft}^3\)</td>
</tr>

<tr>
<td class="org-left">\(h\)</td>
<td class="org-left">fuel particle low heat content</td>
<td class="org-left">\(\text{Btu}/\text{lb}\)</td>
</tr>

<tr>
<td class="org-left">\(S_T\)</td>
<td class="org-left">fuel particle total mineral content</td>
<td class="org-left">\(\text{lb minerals}/\text{lb ovendry wood}\)</td>
</tr>

<tr>
<td class="org-left">\(S_e\)</td>
<td class="org-left">fuel particle effective mineral content</td>
<td class="org-left">\(\text{lb silica-free minerals}/\text{lb ovendry wood}\)</td>
</tr>

<tr>
<td class="org-left">\(M_x\)</td>
<td class="org-left">fuel particle moisture of extinction</td>
<td class="org-left">\(\text{lb moisture}/\text{lb ovendry wood}\)</td>
</tr>

<tr>
<td class="org-left">\(M_f\)</td>
<td class="org-left">fuel particle moisture content</td>
<td class="org-left">\(\text{lb moisture}/\text{lb ovendry wood}\)</td>
</tr>
</tbody>
</table>

<p>
<b>Note:</b> While \(M_f\) is not, in fact, directly assigned to any of these
fuel models, their definitions remain incomplete for the purposes of
fire spread modelling (particularly those reliant on the curing
formulas of dynamic fuel loading) until it is provided as a
characteristic of local weather conditions.
</p>

<p>
Although most fuel model properties are static with respect to
environmental conditions, the fuel moisture content can have two
significant impacts on a fuel model's burning potential:
</p>

<ul class="org-ul">
<li>Dynamic fuel loading</li>
<li>Live moisture of extinction</li>
</ul>

<p>
These two topics are discussed in sections <a href="#orgcf3d571">5.1.4</a> and
<a href="#org76e7608">5.1.6</a>.
</p>
</div>
</div>
<div id="outline-container-orgff3ddb3" class="outline-4">
<h4 id="orgff3ddb3"><span class="section-number-4">5.1.2.</span> Fuel Model Definitions</h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
The fuel models supported by Pyretechnics include the standard 13 fuel
models of Rothermel, Albini, and Anderson<sup><a id="fnr.5" class="footref" href="#fn.5" role="doc-backlink">5</a></sup> and the
additional 40 fuel models defined by Scott and Burgan<sup><a id="fnr.6" class="footref" href="#fn.6" role="doc-backlink">6</a></sup>.
These are all concisely encoded in an internal data structure, which
may be updated to include additional custom fuel models desired by the
user.
</p>

<div class="org-src-container">
<pre class="src src-python" id="org3db08e0"><span class="org-comment-delimiter"># </span><span class="org-comment">Lookup table including entries for each of the Anderson 13 and Scott &amp; Burgan 40 fuel models.</span>
<span class="org-comment-delimiter">#</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">The fields have the following meanings:</span>
<span class="org-comment-delimiter">#   </span><span class="org-comment">{fuel-model-number : [name, delta, M_x-dead, h, w_o, sigma]}</span>
<span class="org-comment-delimiter">#</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">where:</span>
<span class="org-comment-delimiter">#   </span><span class="org-comment">w_o   = [  w_o-dead-1hr,   w_o-dead-10hr,   w_o-dead-100hr,   w_o-live-herbaceous,   w_o-live-woody]</span>
<span class="org-comment-delimiter">#   </span><span class="org-comment">sigma = [sigma-dead-1hr, sigma-dead-10hr, sigma-dead-100hr, sigma-live-herbaceous, sigma-live-woody]</span>
<span class="org-variable-name">fuel_model_compact_table</span> <span class="org-operator">=</span> {
    <span class="org-comment-delimiter"># </span><span class="org-comment">Anderson 13:</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Grass and Grass-dominated (short-grass,timber-grass-and-understory,tall-grass)</span>
    1   : [<span class="org-string">"R01"</span>, 1.0, 12, 8, [0.0340, 0.0000, 0.0000, 0.0000, 0.0000], [3500.0,   0.0,  0.0,    0.0,    0.0]],
    2   : [<span class="org-string">"R02"</span>, 1.0, 15, 8, [0.0920, 0.0460, 0.0230, 0.0230, 0.0000], [3000.0, 109.0, 30.0, 1500.0,    0.0]],
    3   : [<span class="org-string">"R03"</span>, 2.5, 25, 8, [0.1380, 0.0000, 0.0000, 0.0000, 0.0000], [1500.0,   0.0,  0.0,    0.0,    0.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Chaparral and Shrubfields (chaparral,brush,dormant-brush-hardwood-slash,southern-rough)</span>
    4   : [<span class="org-string">"R04"</span>, 6.0, 20, 8, [0.2300, 0.1840, 0.0920, 0.2300, 0.0000], [2000.0, 109.0, 30.0, 1500.0,    0.0]],
    5   : [<span class="org-string">"R05"</span>, 2.0, 20, 8, [0.0460, 0.0230, 0.0000, 0.0920, 0.0000], [2000.0, 109.0,  0.0, 1500.0,    0.0]],
    6   : [<span class="org-string">"R06"</span>, 2.5, 25, 8, [0.0690, 0.1150, 0.0920, 0.0000, 0.0000], [1750.0, 109.0, 30.0,    0.0,    0.0]],
    7   : [<span class="org-string">"R07"</span>, 2.5, 40, 8, [0.0520, 0.0860, 0.0690, 0.0170, 0.0000], [1750.0, 109.0, 30.0, 1550.0,    0.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Timber Litter (closed-timber-litter,hardwood-litter,timber-litter-and-understory)</span>
    8   : [<span class="org-string">"R08"</span>, 0.2, 30, 8, [0.0690, 0.0460, 0.1150, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    9   : [<span class="org-string">"R09"</span>, 0.2, 25, 8, [0.1340, 0.0190, 0.0070, 0.0000, 0.0000], [2500.0, 109.0, 30.0,    0.0,    0.0]],
    10  : [<span class="org-string">"R10"</span>, 1.0, 25, 8, [0.1380, 0.0920, 0.2300, 0.0920, 0.0000], [2000.0, 109.0, 30.0, 1500.0,    0.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Logging Slash (light-logging-slash,medium-logging-slash,heavy-logging-slash)</span>
    11  : [<span class="org-string">"R11"</span>, 1.0, 15, 8, [0.0690, 0.2070, 0.2530, 0.0000, 0.0000], [1500.0, 109.0, 30.0,    0.0,    0.0]],
    12  : [<span class="org-string">"R12"</span>, 2.3, 20, 8, [0.1840, 0.6440, 0.7590, 0.0000, 0.0000], [1500.0, 109.0, 30.0,    0.0,    0.0]],
    13  : [<span class="org-string">"R13"</span>, 3.0, 25, 8, [0.3220, 1.0580, 1.2880, 0.0000, 0.0000], [1500.0, 109.0, 30.0,    0.0,    0.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Nonburnable (NB)</span>
    91  : [<span class="org-string">"NB1"</span>, 0.0,  0, 0, [0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [   0.0,   0.0,  0.0,    0.0,    0.0]],
    92  : [<span class="org-string">"NB2"</span>, 0.0,  0, 0, [0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [   0.0,   0.0,  0.0,    0.0,    0.0]],
    93  : [<span class="org-string">"NB3"</span>, 0.0,  0, 0, [0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [   0.0,   0.0,  0.0,    0.0,    0.0]],
    98  : [<span class="org-string">"NB4"</span>, 0.0,  0, 0, [0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [   0.0,   0.0,  0.0,    0.0,    0.0]],
    99  : [<span class="org-string">"NB5"</span>, 0.0,  0, 0, [0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [   0.0,   0.0,  0.0,    0.0,    0.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Scott &amp; Burgan 40:</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Grass (GR)</span>
    101 : [<span class="org-string">"GR1"</span>, 0.4, 15, 8, [0.0046, 0.0000, 0.0000, 0.0138, 0.0000], [2200.0, 109.0, 30.0, 2000.0,    0.0]],
    102 : [<span class="org-string">"GR2"</span>, 1.0, 15, 8, [0.0046, 0.0000, 0.0000, 0.0459, 0.0000], [2000.0, 109.0, 30.0, 1800.0,    0.0]],
    103 : [<span class="org-string">"GR3"</span>, 2.0, 30, 8, [0.0046, 0.0184, 0.0000, 0.0689, 0.0000], [1500.0, 109.0, 30.0, 1300.0,    0.0]],
    104 : [<span class="org-string">"GR4"</span>, 2.0, 15, 8, [0.0115, 0.0000, 0.0000, 0.0872, 0.0000], [2000.0, 109.0, 30.0, 1800.0,    0.0]],
    105 : [<span class="org-string">"GR5"</span>, 1.5, 40, 8, [0.0184, 0.0000, 0.0000, 0.1148, 0.0000], [1800.0, 109.0, 30.0, 1600.0,    0.0]],
    106 : [<span class="org-string">"GR6"</span>, 1.5, 40, 9, [0.0046, 0.0000, 0.0000, 0.1561, 0.0000], [2200.0, 109.0, 30.0, 2000.0,    0.0]],
    107 : [<span class="org-string">"GR7"</span>, 3.0, 15, 8, [0.0459, 0.0000, 0.0000, 0.2479, 0.0000], [2000.0, 109.0, 30.0, 1800.0,    0.0]],
    108 : [<span class="org-string">"GR8"</span>, 4.0, 30, 8, [0.0230, 0.0459, 0.0000, 0.3352, 0.0000], [1500.0, 109.0, 30.0, 1300.0,    0.0]],
    109 : [<span class="org-string">"GR9"</span>, 5.0, 40, 8, [0.0459, 0.0459, 0.0000, 0.4132, 0.0000], [1800.0, 109.0, 30.0, 1600.0,    0.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Grass-Shrub (GS)</span>
    121 : [<span class="org-string">"GS1"</span>, 0.9, 15, 8, [0.0092, 0.0000, 0.0000, 0.0230, 0.0298], [2000.0, 109.0, 30.0, 1800.0, 1800.0]],
    122 : [<span class="org-string">"GS2"</span>, 1.5, 15, 8, [0.0230, 0.0230, 0.0000, 0.0275, 0.0459], [2000.0, 109.0, 30.0, 1800.0, 1800.0]],
    123 : [<span class="org-string">"GS3"</span>, 1.8, 40, 8, [0.0138, 0.0115, 0.0000, 0.0666, 0.0574], [1800.0, 109.0, 30.0, 1600.0, 1600.0]],
    124 : [<span class="org-string">"GS4"</span>, 2.1, 40, 8, [0.0872, 0.0138, 0.0046, 0.1561, 0.3260], [1800.0, 109.0, 30.0, 1600.0, 1600.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Shrub (SH)</span>
    141 : [<span class="org-string">"SH1"</span>, 1.0, 15, 8, [0.0115, 0.0115, 0.0000, 0.0069, 0.0597], [2000.0, 109.0, 30.0, 1800.0, 1600.0]],
    142 : [<span class="org-string">"SH2"</span>, 1.0, 15, 8, [0.0620, 0.1102, 0.0344, 0.0000, 0.1768], [2000.0, 109.0, 30.0,    0.0, 1600.0]],
    143 : [<span class="org-string">"SH3"</span>, 2.4, 40, 8, [0.0207, 0.1377, 0.0000, 0.0000, 0.2847], [1600.0, 109.0, 30.0,    0.0, 1400.0]],
    144 : [<span class="org-string">"SH4"</span>, 3.0, 30, 8, [0.0390, 0.0528, 0.0092, 0.0000, 0.1171], [2000.0, 109.0, 30.0, 1800.0, 1600.0]],
    145 : [<span class="org-string">"SH5"</span>, 6.0, 15, 8, [0.1653, 0.0964, 0.0000, 0.0000, 0.1331], [ 750.0, 109.0, 30.0,    0.0, 1600.0]],
    146 : [<span class="org-string">"SH6"</span>, 2.0, 30, 8, [0.1331, 0.0666, 0.0000, 0.0000, 0.0643], [ 750.0, 109.0, 30.0,    0.0, 1600.0]],
    147 : [<span class="org-string">"SH7"</span>, 6.0, 15, 8, [0.1607, 0.2433, 0.1010, 0.0000, 0.1561], [ 750.0, 109.0, 30.0,    0.0, 1600.0]],
    148 : [<span class="org-string">"SH8"</span>, 3.0, 40, 8, [0.0941, 0.1561, 0.0390, 0.0000, 0.1997], [ 750.0, 109.0, 30.0,    0.0, 1600.0]],
    149 : [<span class="org-string">"SH9"</span>, 4.4, 40, 8, [0.2066, 0.1125, 0.0000, 0.0712, 0.3214], [ 750.0, 109.0, 30.0, 1800.0, 1500.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Timber-Understory (TU)</span>
    161 : [<span class="org-string">"TU1"</span>, 0.6, 20, 8, [0.0092, 0.0413, 0.0689, 0.0092, 0.0413], [2000.0, 109.0, 30.0, 1800.0, 1600.0]],
    162 : [<span class="org-string">"TU2"</span>, 1.0, 30, 8, [0.0436, 0.0826, 0.0574, 0.0000, 0.0092], [2000.0, 109.0, 30.0,    0.0, 1600.0]],
    163 : [<span class="org-string">"TU3"</span>, 1.3, 30, 8, [0.0505, 0.0069, 0.0115, 0.0298, 0.0505], [1800.0, 109.0, 30.0, 1600.0, 1400.0]],
    164 : [<span class="org-string">"TU4"</span>, 0.5, 12, 8, [0.2066, 0.0000, 0.0000, 0.0000, 0.0918], [2300.0, 109.0, 30.0,    0.0, 2000.0]],
    165 : [<span class="org-string">"TU5"</span>, 1.0, 25, 8, [0.1837, 0.1837, 0.1377, 0.0000, 0.1377], [1500.0, 109.0, 30.0,    0.0,  750.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Timber Litter (TL)</span>
    181 : [<span class="org-string">"TL1"</span>, 0.2, 30, 8, [0.0459, 0.1010, 0.1653, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    182 : [<span class="org-string">"TL2"</span>, 0.2, 25, 8, [0.0643, 0.1056, 0.1010, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    183 : [<span class="org-string">"TL3"</span>, 0.3, 20, 8, [0.0230, 0.1010, 0.1286, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    184 : [<span class="org-string">"TL4"</span>, 0.4, 25, 8, [0.0230, 0.0689, 0.1928, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    185 : [<span class="org-string">"TL5"</span>, 0.6, 25, 8, [0.0528, 0.1148, 0.2020, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0, 1600.0]],
    186 : [<span class="org-string">"TL6"</span>, 0.3, 25, 8, [0.1102, 0.0551, 0.0551, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    187 : [<span class="org-string">"TL7"</span>, 0.4, 25, 8, [0.0138, 0.0643, 0.3719, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    188 : [<span class="org-string">"TL8"</span>, 0.3, 35, 8, [0.2663, 0.0643, 0.0505, 0.0000, 0.0000], [1800.0, 109.0, 30.0,    0.0,    0.0]],
    189 : [<span class="org-string">"TL9"</span>, 0.6, 35, 8, [0.3053, 0.1515, 0.1905, 0.0000, 0.0000], [1800.0, 109.0, 30.0,    0.0, 1600.0]],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Slash-Blowdown (SB)</span>
    201 : [<span class="org-string">"SB1"</span>, 1.0, 25, 8, [0.0689, 0.1377, 0.5051, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    202 : [<span class="org-string">"SB2"</span>, 1.0, 25, 8, [0.2066, 0.1951, 0.1837, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    203 : [<span class="org-string">"SB3"</span>, 1.2, 25, 8, [0.2525, 0.1263, 0.1377, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
    204 : [<span class="org-string">"SB4"</span>, 2.7, 25, 8, [0.2410, 0.1607, 0.2410, 0.0000, 0.0000], [2000.0, 109.0, 30.0,    0.0,    0.0]],
}
</pre>
</div>

<p>
Although this compact data structure contains all the properties that
vary by fuel model (i.e., \(\delta\), \(w_o\), \(\sigma\),
\(M_{x-\text{dead}}\), \(h\)), several of their values need to be
multiplied by a coefficient to make their units match those listed in
Table <a href="#org660ca2b">1</a>. We also need to add in the missing
\(\rho_p\), \(S_T\), and \(S_e\) values, which are constant across all of
these fuel models, and to expand those properties whose values may
vary by size class into lists with the following encoding:
</p>

<pre class="example" id="orgf6fb1b0">
[dead_1hr dead_10hr dead_100hr dead_herbaceous live_herbaceous live_woody]
</pre>

<p>
As a performance optimization, we set the dead herbaceous values that
don't depend on fuel moisture for the dynamic Scott &amp; Burgan 40 fuel
models. Finally, we add two boolean properties (<code>dynamic</code> and
<code>burnable</code>) to each fuel model for reference in later calculations.
</p>

<div class="org-src-container">
<pre class="src src-python" id="org690bf43"><span class="org-keyword">def</span> <span class="org-function-name">expand_compact_fuel_model</span>(fuel_model_number):
    [<span class="org-variable-name">name</span>, <span class="org-variable-name">delta</span>, <span class="org-variable-name">M_x_dead</span>, <span class="org-variable-name">h</span>, <span class="org-variable-name">w_o</span>, <span class="org-variable-name">sigma</span>] <span class="org-operator">=</span> fuel_model_compact_table[fuel_model_number]
    [<span class="org-variable-name">w_o_dead_1hr</span>, <span class="org-variable-name">w_o_dead_10hr</span>, <span class="org-variable-name">w_o_dead_100hr</span>, <span class="org-variable-name">w_o_live_herbaceous</span>, <span class="org-variable-name">w_o_live_woody</span>] <span class="org-operator">=</span> w_o
    [<span class="org-variable-name">sigma_dead_1hr</span>, <span class="org-variable-name">sigma_dead_10hr</span>, <span class="org-variable-name">sigma_dead_100hr</span>, <span class="org-variable-name">sigma_live_herbaceous</span>, <span class="org-variable-name">sigma_live_woody</span>] <span class="org-operator">=</span> sigma
    <span class="org-variable-name">M_x_dead</span> <span class="org-operator">=</span> M_x_dead <span class="org-operator">*</span> 0.01
    <span class="org-variable-name">h</span>        <span class="org-operator">=</span> h <span class="org-operator">*</span> 1000.0
    <span class="org-comment-delimiter"># </span><span class="org-comment">Conditionally set dead_herbaceous values</span>
    <span class="org-variable-name">dynamic</span>               <span class="org-operator">=</span> fuel_model_number <span class="org-operator">&gt;</span> 100 <span class="org-keyword">and</span> w_o_live_herbaceous <span class="org-operator">&gt;</span> 0.0
    <span class="org-variable-name">M_x_dead_herbaceous</span>   <span class="org-operator">=</span> M_x_dead              <span class="org-keyword">if</span> dynamic <span class="org-keyword">else</span> 0.0
    <span class="org-variable-name">sigma_dead_herbaceous</span> <span class="org-operator">=</span> sigma_live_herbaceous <span class="org-keyword">if</span> dynamic <span class="org-keyword">else</span> 0.0
    <span class="org-keyword">return</span> {
        <span class="org-string">"name"</span>    : name,
        <span class="org-string">"number"</span>  : fuel_model_number,
        <span class="org-string">"delta"</span>   : delta,
        <span class="org-string">"M_x"</span>     : [M_x_dead, M_x_dead, M_x_dead, M_x_dead_herbaceous, 0.0, 0.0],
        <span class="org-string">"w_o"</span>     : [w_o_dead_1hr, w_o_dead_10hr, w_o_dead_100hr, 0.0, w_o_live_herbaceous, w_o_live_woody],
        <span class="org-string">"sigma"</span>   : [sigma_dead_1hr, sigma_dead_10hr, sigma_dead_100hr, sigma_dead_herbaceous, sigma_live_herbaceous, sigma_live_woody],
        <span class="org-string">"h"</span>       : 6 <span class="org-operator">*</span> [h],
        <span class="org-string">"rho_p"</span>   : 6 <span class="org-operator">*</span> [32.0],
        <span class="org-string">"S_T"</span>     : 6 <span class="org-operator">*</span> [0.0555],
        <span class="org-string">"S_e"</span>     : 6 <span class="org-operator">*</span> [0.01],
        <span class="org-string">"dynamic"</span> : dynamic,
        <span class="org-string">"burnable"</span>: <span class="org-keyword">not</span> (91 <span class="org-operator">&lt;=</span> fuel_model_number <span class="org-operator">&lt;=</span> 99),
    }


<span class="org-variable-name">fuel_model_table</span> <span class="org-operator">=</span> {k: expand_compact_fuel_model(k) <span class="org-keyword">for</span> k <span class="org-keyword">in</span> fuel_model_compact_table.keys()}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgde154a1" class="outline-4">
<h4 id="orgde154a1"><span class="section-number-4">5.1.3.</span> Fuel Categories and Size Classes</h4>
<div class="outline-text-4" id="text-5-1-3">
<p>
Each fuel model applies to a collection of burnable material that may
be live or dead and whose constituent elements may vary in size
considerably.
</p>

<p>
The two terms <b>category</b> and <b>size class</b> are used to describe this
heterogeneity within each fuel model.
</p>

<p>
In Pyretechnics, when we refer to a fuel category, we mean one of
these two values:
</p>

<ul class="org-ul">
<li>Dead</li>
<li>Live</li>
</ul>

<p>
When we refer to a fuel size class, we mean one of these six values:
</p>

<ul class="org-ul">
<li>Dead 1 hour (&lt; 1/4" diameter)</li>
<li>Dead 10 hour (1/4"-1" diameter)</li>
<li>Dead 100 hour (1"-3" diameter)</li>
<li>Dead herbaceous (dynamic fuel models only)</li>
<li>Live herbaceous</li>
<li>Live woody</li>
</ul>

<p>
In order to more easily encode mathematical operations over these fuel
categories and size classes, we define a collection of utility
functions that will later be used in both the fuel moisture and
surface fire equations.
</p>

<div class="org-src-container">
<pre class="src src-python" id="orgbd532c1"><span class="org-keyword">def</span> <span class="org-function-name">map_category</span>(f):
    <span class="org-keyword">return</span> [f(0), f(1)]


<span class="org-keyword">def</span> <span class="org-function-name">map_size_class</span>(f):
    <span class="org-keyword">return</span> [f(0), f(1), f(2), f(3), f(4), f(5)]


<span class="org-keyword">def</span> <span class="org-function-name">category_sum</span>(f):
    <span class="org-keyword">return</span> f(0) <span class="org-operator">+</span> f(1)


<span class="org-keyword">def</span> <span class="org-function-name">size_class_sum</span>(f):
    <span class="org-keyword">return</span> [f(0) <span class="org-operator">+</span> f(1) <span class="org-operator">+</span> f(2) <span class="org-operator">+</span> f(3), f(4) <span class="org-operator">+</span> f(5)]
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcf3d571" class="outline-4">
<h4 id="orgcf3d571"><span class="section-number-4">5.1.4.</span> Dynamic Fuel Loading</h4>
<div class="outline-text-4" id="text-5-1-4">
<p>
All of the Scott &amp; Burgan 40 fuel models with a live herbaceous
component are considered dynamic. In these models, a fraction of the
live herbaceous load is transferred to a new dead herbaceous category
as a function of live herbaceous moisture content (see equation
below).<sup><a id="fnr.7" class="footref" href="#fn.7" role="doc-backlink">7</a></sup> The dead herbaceous size class uses the dead 1
hour moisture content, dead moisture of extinction, and live
herbaceous surface-area-to-volume-ratio. In the following formula,
\(M_f^{lh}\) is the live herbaceous moisture content.
</p>

\begin{align}
  \text{FractionGreen} &= \left\{
    \begin{array}{lr}
      0 & M_f^{lh} \le 0.3 \\
      1 & M_f^{lh} \ge 1.2 \\
      M_f^{lh} / 0.9 - 1/3 & \text{else}
    \end{array}
  \right. \\
  \nonumber \\
  \text{FractionCured} &= 1 - \text{FractionGreen}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="org8982867"><span class="org-keyword">def</span> <span class="org-function-name">add_dynamic_fuel_loading</span>(fuel_model, M_f):
    <span class="org-keyword">if</span> fuel_model[<span class="org-string">"dynamic"</span>]:
        <span class="org-comment-delimiter"># </span><span class="org-comment">dynamic fuel model</span>
        <span class="org-variable-name">w_o</span>                       <span class="org-operator">=</span> fuel_model[<span class="org-string">"w_o"</span>]
        <span class="org-variable-name">live_herbaceous_load</span>      <span class="org-operator">=</span> w_o[4]
        <span class="org-variable-name">live_herbaceous_moisture</span>  <span class="org-operator">=</span> M_f[4]
        <span class="org-variable-name">fraction_green</span>            <span class="org-operator">=</span> <span class="org-builtin">max</span>(0.0, <span class="org-builtin">min</span>(1.0, (live_herbaceous_moisture <span class="org-operator">/</span> 0.9) <span class="org-operator">-</span> 0.3333333333333333))
        <span class="org-variable-name">fraction_cured</span>            <span class="org-operator">=</span> 1.0 <span class="org-operator">-</span> fraction_green
        <span class="org-variable-name">dynamic_fuel_model</span>        <span class="org-operator">=</span> fuel_model.copy() <span class="org-comment-delimiter"># </span><span class="org-comment">shallow copy</span>
        <span class="org-variable-name">dynamic_fuel_model</span>[<span class="org-string">"M_f"</span>] <span class="org-operator">=</span> [
            M_f[0],
            M_f[1],
            M_f[2],
            M_f[0], <span class="org-comment-delimiter"># </span><span class="org-comment">set dead_herbaceous to dead_1hr</span>
            M_f[4],
            M_f[5],
        ]
        <span class="org-variable-name">dynamic_fuel_model</span>[<span class="org-string">"w_o"</span>] <span class="org-operator">=</span> [
            w_o[0],
            w_o[1],
            w_o[2],
            live_herbaceous_load <span class="org-operator">*</span> fraction_cured, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_herbaceous</span>
            live_herbaceous_load <span class="org-operator">*</span> fraction_green, <span class="org-comment-delimiter"># </span><span class="org-comment">live_herbaceous</span>
            w_o[5],
        ]
        <span class="org-keyword">return</span> dynamic_fuel_model
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">static fuel model</span>
        <span class="org-variable-name">static_fuel_model</span> <span class="org-operator">=</span> fuel_model.copy() <span class="org-comment-delimiter"># </span><span class="org-comment">shallow copy</span>
        <span class="org-variable-name">static_fuel_model</span>[<span class="org-string">"M_f"</span>] <span class="org-operator">=</span> M_f
        <span class="org-keyword">return</span> static_fuel_model
</pre>
</div>
</div>
</div>
<div id="outline-container-org796f519" class="outline-4">
<h4 id="org796f519"><span class="section-number-4">5.1.5.</span> Size Class Weighting Factors</h4>
<div class="outline-text-4" id="text-5-1-5">
<p>
Once the dynamic fuel loading is applied, we can compute the size
class weighting factors expressed in equations 53-57 in Rothermel
1972<sup><a id="fnr.8" class="footref" href="#fn.8" role="doc-backlink">8</a></sup>. For brevity, these formulas are elided from
this text.
</p>

<div class="org-src-container">
<pre class="src src-python" id="orgb86640f"><span class="org-keyword">def</span> <span class="org-function-name">add_weighting_factors</span>(fuel_model):
    <span class="org-variable-name">w_o</span>                         <span class="org-operator">=</span> fuel_model[<span class="org-string">"w_o"</span>]
    <span class="org-variable-name">sigma</span>                       <span class="org-operator">=</span> fuel_model[<span class="org-string">"sigma"</span>]
    <span class="org-variable-name">rho_p</span>                       <span class="org-operator">=</span> fuel_model[<span class="org-string">"rho_p"</span>]
    <span class="org-variable-name">A_ij</span>                        <span class="org-operator">=</span> map_size_class(<span class="org-keyword">lambda</span> i: (sigma[i] <span class="org-operator">*</span> w_o[i]) <span class="org-operator">/</span> rho_p[i])
    <span class="org-variable-name">A_i</span>                         <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: A_ij[i])
    <span class="org-variable-name">A_T</span>                         <span class="org-operator">=</span> category_sum(<span class="org-keyword">lambda</span> i: A_i[i])
    <span class="org-variable-name">f_ij</span>                        <span class="org-operator">=</span> map_size_class(<span class="org-keyword">lambda</span> i: (<span class="org-keyword">lambda</span> A: (A_ij[i] <span class="org-operator">/</span> A) <span class="org-keyword">if</span> A <span class="org-operator">&gt;</span> 0.0 <span class="org-keyword">else</span> 0.0)(A_i[i<span class="org-operator">//</span>4]))
    <span class="org-variable-name">f_i</span>                         <span class="org-operator">=</span> map_category(<span class="org-keyword">lambda</span> i: (A_i[i] <span class="org-operator">/</span> A_T) <span class="org-keyword">if</span> A_T <span class="org-operator">&gt;</span> 0.0 <span class="org-keyword">else</span> 0.0)
    <span class="org-variable-name">firemod_size_classes</span>        <span class="org-operator">=</span> map_size_class(<span class="org-keyword">lambda</span> i: (<span class="org-keyword">lambda</span> s:
                                                            1 <span class="org-keyword">if</span> (s <span class="org-operator">&gt;=</span> 1200.0)
                                                            <span class="org-keyword">else</span> 2 <span class="org-keyword">if</span> (s <span class="org-operator">&gt;=</span> 192.0)
                                                            <span class="org-keyword">else</span> 3 <span class="org-keyword">if</span> (s <span class="org-operator">&gt;=</span> 96.0)
                                                            <span class="org-keyword">else</span> 4 <span class="org-keyword">if</span> (s <span class="org-operator">&gt;=</span> 48.0)
                                                            <span class="org-keyword">else</span> 5 <span class="org-keyword">if</span> (s <span class="org-operator">&gt;=</span> 16.0)
                                                            <span class="org-keyword">else</span> 6
                                                            )(sigma[i]))
    <span class="org-variable-name">g_ij</span>                        <span class="org-operator">=</span> map_size_class(<span class="org-keyword">lambda</span> i: (<span class="org-keyword">lambda</span> c:
                                                            ((f_ij[0] <span class="org-keyword">if</span> (c <span class="org-operator">==</span> firemod_size_classes[0]) <span class="org-keyword">else</span> 0.0)
                                                             <span class="org-operator">+</span> (f_ij[1] <span class="org-keyword">if</span> (c <span class="org-operator">==</span> firemod_size_classes[1]) <span class="org-keyword">else</span> 0.0)
                                                             <span class="org-operator">+</span> (f_ij[2] <span class="org-keyword">if</span> (c <span class="org-operator">==</span> firemod_size_classes[2]) <span class="org-keyword">else</span> 0.0)
                                                             <span class="org-operator">+</span> (f_ij[3] <span class="org-keyword">if</span> (c <span class="org-operator">==</span> firemod_size_classes[3]) <span class="org-keyword">else</span> 0.0))
                                                            <span class="org-keyword">if</span> (i <span class="org-operator">&lt;</span> 4) <span class="org-keyword">else</span>
                                                            ((f_ij[4] <span class="org-keyword">if</span> (c <span class="org-operator">==</span> firemod_size_classes[4]) <span class="org-keyword">else</span> 0.0)
                                                             <span class="org-operator">+</span> (f_ij[5] <span class="org-keyword">if</span> (c <span class="org-operator">==</span> firemod_size_classes[5]) <span class="org-keyword">else</span> 0.0))
                                                            )(firemod_size_classes[i]))
    <span class="org-variable-name">weighted_fuel_model</span>         <span class="org-operator">=</span> fuel_model.copy() <span class="org-comment-delimiter"># </span><span class="org-comment">shallow copy</span>
    <span class="org-variable-name">weighted_fuel_model</span>[<span class="org-string">"f_ij"</span>] <span class="org-operator">=</span> f_ij
    <span class="org-variable-name">weighted_fuel_model</span>[<span class="org-string">"f_i"</span>]  <span class="org-operator">=</span> f_i
    <span class="org-variable-name">weighted_fuel_model</span>[<span class="org-string">"g_ij"</span>] <span class="org-operator">=</span> g_ij
    <span class="org-keyword">return</span> weighted_fuel_model
</pre>
</div>
</div>
</div>
<div id="outline-container-org76e7608" class="outline-4">
<h4 id="org76e7608"><span class="section-number-4">5.1.6.</span> Live Moisture of Extinction</h4>
<div class="outline-text-4" id="text-5-1-6">
<p>
The live moisture of extinction for each fuel model is determined from
the dead fuel moisture content, the dead moisture of extinction, and
the ratio of dead fuel loading to live fuel loading using Equation 88
from Rothermel 1972, adjusted according to Albini 1976 Appendix III to
match the behavior of Albini's original FIREMODS
library.<sup><a id="fnr.9" class="footref" href="#fn.9" role="doc-backlink">9</a></sup><sup>, </sup><sup><a id="fnr.10" class="footref" href="#fn.10" role="doc-backlink">10</a></sup> Whenever the fuel moisture
content becomes greater than or equal to the moisture of extinction, a
fire will no longer spread through that fuel. Here are the formulas
referenced above:
</p>

\begin{align}
  M_x^l &= \max(M_x^d, 2.9 \, W' \, (1 - M_f^d / M_x^d) - 0.226) \\
  \nonumber \\
  W' &= \frac{\sum_{c \in D}{w_o^c \> e^{-138/\sigma^c}}}{\sum_{c \in L}{w_o^c \> e^{-500/\sigma^c}}} \\
  \nonumber \\
  M_f^d &= \frac{\sum_{c \in D}{w_o^c \> M_f^c \> e^{-138/\sigma^c}}}{\sum_{c \in D}{w_o^c \> e^{-138/\sigma^c}}}
\end{align}

<p>
where \(M_{x}^{l}\) is the live moisture of extinction, \(M_{x}^{d}\) is
the dead moisture of extinction, \(D\) is the set of dead fuel size
classes (1hr, 10hr, 100hr, herbaceous), \(L\) is the set of live fuel
size classes (herbaceous, woody), \(w_{o}^{c}\) is the dry weight
loading of size class \(c\), \(\sigma^{c}\) is the surface area to volume
ratio of size class \(c\), and \(M_{f}^{c}\) is the moisture content of
size class \(c\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="org87449d9"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> exp

<span class="org-keyword">def</span> <span class="org-function-name">add_live_moisture_of_extinction</span>(fuel_model):
    <span class="org-doc">"""</span>
<span class="org-doc">    Equation 88 from Rothermel 1972 adjusted by Albini 1976 Appendix III.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">w_o</span>                       <span class="org-operator">=</span> fuel_model[<span class="org-string">"w_o"</span>]
    <span class="org-variable-name">sigma</span>                     <span class="org-operator">=</span> fuel_model[<span class="org-string">"sigma"</span>]
    <span class="org-variable-name">M_f</span>                       <span class="org-operator">=</span> fuel_model[<span class="org-string">"M_f"</span>]
    <span class="org-variable-name">M_x</span>                       <span class="org-operator">=</span> fuel_model[<span class="org-string">"M_x"</span>]
    <span class="org-variable-name">loading_factors</span>           <span class="org-operator">=</span> map_size_class(<span class="org-keyword">lambda</span> i:
                                               (<span class="org-keyword">lambda</span> sigma_ij, A:
                                                w_o[i] <span class="org-operator">*</span> exp(A <span class="org-operator">/</span> sigma_ij) <span class="org-keyword">if</span> (sigma_ij <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 0.0
                                                )(sigma[i], <span class="org-operator">-</span>138.0 <span class="org-keyword">if</span> (i <span class="org-operator">&lt;</span> 4) <span class="org-keyword">else</span> <span class="org-operator">-</span>500.0))
    [dead_loading_factor,
     live_loading_factor]     <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: loading_factors[i])
    [<span class="org-variable-name">dead_moisture_factor</span>, <span class="org-variable-name">_</span>] <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: M_f[i] <span class="org-operator">*</span> loading_factors[i])
    <span class="org-variable-name">dead_to_live_ratio</span>        <span class="org-operator">=</span> (dead_loading_factor <span class="org-operator">/</span> live_loading_factor) <span class="org-keyword">if</span> (live_loading_factor <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> <span class="org-constant">None</span>
    <span class="org-variable-name">dead_fuel_moisture</span>        <span class="org-operator">=</span> (dead_moisture_factor <span class="org-operator">/</span> dead_loading_factor) <span class="org-keyword">if</span> (dead_loading_factor <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 0.0
    <span class="org-variable-name">M_x_dead</span>                  <span class="org-operator">=</span> M_x[0]
    <span class="org-variable-name">M_x_live</span>                  <span class="org-operator">=</span> <span class="org-builtin">max</span>(M_x_dead,
                                    (2.9 <span class="org-operator">*</span> dead_to_live_ratio <span class="org-operator">*</span> (1.0 <span class="org-operator">-</span> (dead_fuel_moisture <span class="org-operator">/</span> M_x_dead))) <span class="org-operator">-</span> 0.226
                                    ) <span class="org-keyword">if</span> (live_loading_factor <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> M_x_dead
    <span class="org-variable-name">moisturized_fuel_model</span>    <span class="org-operator">=</span> fuel_model.copy() <span class="org-comment-delimiter"># </span><span class="org-comment">shallow copy</span>
    <span class="org-variable-name">moisturized_fuel_model</span>[<span class="org-string">"M_x"</span>] <span class="org-operator">=</span> [
        M_x[0],
        M_x[1],
        M_x[2],
        M_x[3],
        M_x_live,
        M_x_live,
    ]
    <span class="org-keyword">return</span> moisturized_fuel_model
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc1c1a02" class="outline-4">
<h4 id="orgc1c1a02"><span class="section-number-4">5.1.7.</span> Applying Fuel Moisture to a Fuel Model</h4>
<div class="outline-text-4" id="text-5-1-7">
<p>
The preceding sections augmented the baseline fuel models by adding
dynamic fuel loading (section <a href="#orgcf3d571">5.1.4</a>), size class
weighting factors (section <a href="#org796f519">5.1.5</a>), and live
moisture of extinction (section <a href="#org76e7608">5.1.6</a>). In
typical usage, we will want to carry out all three of these steps when
applying fuel moisture to a fuel model. To simplify this task,
Pyretechnics provides the <code>moisturize</code> utility function.
</p>

<div class="org-src-container">
<pre class="src src-python" id="orgc58cbf0"><span class="org-comment-delimiter"># </span><span class="org-comment">TODO: If these functions aren't called anywhere else, create a copy</span>
<span class="org-comment-delimiter">#       </span><span class="org-comment">of the fuel model here and mutate it in the called functions.</span>
<span class="org-keyword">def</span> <span class="org-function-name">moisturize</span>(fuel_model, fuel_moisture):
    <span class="org-variable-name">dynamic_fuel_model</span>     <span class="org-operator">=</span> add_dynamic_fuel_loading(fuel_model, fuel_moisture)
    <span class="org-variable-name">weighted_fuel_model</span>    <span class="org-operator">=</span> add_weighting_factors(dynamic_fuel_model)
    <span class="org-variable-name">moisturized_fuel_model</span> <span class="org-operator">=</span> add_live_moisture_of_extinction(weighted_fuel_model)
    <span class="org-keyword">return</span> moisturized_fuel_model
</pre>
</div>

<p>
This concludes our coverage of fuel models and fuel moisture.
</p>
</div>
</div>
</div>
<div id="outline-container-org4c20516" class="outline-3">
<h3 id="org4c20516"><span class="section-number-3">5.2.</span> For Users</h3>
<div class="outline-text-3" id="text-5-2">
<p>
In the following sections, we will demonstrate how to access fuel
model properties by fuel model number both alone and combined with
fuel moisture.
</p>
</div>
<div id="outline-container-org760dc81" class="outline-4">
<h4 id="org760dc81"><span class="section-number-4">5.2.1.</span> How to Look Up a Fuel Model's Properties</h4>
<div class="outline-text-4" id="text-5-2-1">
<div class="org-src-container">
<pre class="src src-python" id="org487c33c"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">from</span> pyretechnics.fuel_models <span class="org-keyword">import</span> fuel_model_table

<span class="org-variable-name">static_fuel_model_number</span>  <span class="org-operator">=</span> 1   <span class="org-comment-delimiter"># </span><span class="org-comment">R01</span>
<span class="org-variable-name">dynamic_fuel_model_number</span> <span class="org-operator">=</span> 101 <span class="org-comment-delimiter"># </span><span class="org-comment">GR1</span>

<span class="org-variable-name">static_fuel_model</span>  <span class="org-operator">=</span> fuel_model_table.get(static_fuel_model_number)
<span class="org-variable-name">dynamic_fuel_model</span> <span class="org-operator">=</span> fuel_model_table.get(dynamic_fuel_model_number)

<span class="org-builtin">print</span>(<span class="org-string">"Static Fuel Model: R01"</span>)
pprint(static_fuel_model)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Dynamic Fuel Model: GR1"</span>)
pprint(dynamic_fuel_model)
</pre>
</div>

<pre class="example" id="orge6e3fa5">
Static Fuel Model: R01
{'M_x': [0.12, 0.12, 0.12, 0.0, 0.0, 0.0],
 'S_T': [0.0555, 0.0555, 0.0555, 0.0555, 0.0555, 0.0555],
 'S_e': [0.01, 0.01, 0.01, 0.01, 0.01, 0.01],
 'burnable': True,
 'delta': 1.0,
 'dynamic': False,
 'h': [8000.0, 8000.0, 8000.0, 8000.0, 8000.0, 8000.0],
 'name': 'R01',
 'number': 1,
 'rho_p': [32.0, 32.0, 32.0, 32.0, 32.0, 32.0],
 'sigma': [3500.0, 0.0, 0.0, 0.0, 0.0, 0.0],
 'w_o': [0.034, 0.0, 0.0, 0.0, 0.0, 0.0]}

Dynamic Fuel Model: GR1
{'M_x': [0.15, 0.15, 0.15, 0.15, 0.0, 0.0],
 'S_T': [0.0555, 0.0555, 0.0555, 0.0555, 0.0555, 0.0555],
 'S_e': [0.01, 0.01, 0.01, 0.01, 0.01, 0.01],
 'burnable': True,
 'delta': 0.4,
 'dynamic': True,
 'h': [8000.0, 8000.0, 8000.0, 8000.0, 8000.0, 8000.0],
 'name': 'GR1',
 'number': 101,
 'rho_p': [32.0, 32.0, 32.0, 32.0, 32.0, 32.0],
 'sigma': [2200.0, 109.0, 30.0, 2000.0, 2000.0, 0.0],
 'w_o': [0.0046, 0.0, 0.0, 0.0, 0.0138, 0.0]}
</pre>
</div>
</div>
<div id="outline-container-orgc066ec7" class="outline-4">
<h4 id="orgc066ec7"><span class="section-number-4">5.2.2.</span> How to Apply Fuel Moisture to a Fuel Model</h4>
<div class="outline-text-4" id="text-5-2-2">
<div class="org-src-container">
<pre class="src src-python" id="orgf538c6e"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">from</span> pyretechnics.fuel_models <span class="org-keyword">import</span> fuel_model_table, moisturize

<span class="org-variable-name">static_fuel_model_number</span>  <span class="org-operator">=</span> 1   <span class="org-comment-delimiter"># </span><span class="org-comment">R01</span>
<span class="org-variable-name">dynamic_fuel_model_number</span> <span class="org-operator">=</span> 101 <span class="org-comment-delimiter"># </span><span class="org-comment">GR1</span>

<span class="org-variable-name">static_fuel_model</span>  <span class="org-operator">=</span> fuel_model_table.get(static_fuel_model_number)
<span class="org-variable-name">dynamic_fuel_model</span> <span class="org-operator">=</span> fuel_model_table.get(dynamic_fuel_model_number)

<span class="org-variable-name">fuel_moisture</span> <span class="org-operator">=</span> [
    0.05, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_1hr</span>
    0.10, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_10hr</span>
    0.15, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_100hr</span>
    0.00, <span class="org-comment-delimiter"># </span><span class="org-comment">dead_herbaceous (will be set by moisturize for dynamic fuel models)</span>
    0.30, <span class="org-comment-delimiter"># </span><span class="org-comment">live_herbaceous</span>
    0.50, <span class="org-comment-delimiter"># </span><span class="org-comment">live_woody</span>
]

<span class="org-builtin">print</span>(<span class="org-string">"Moisturized Static Fuel Model: R01"</span>)
pprint(moisturize(static_fuel_model, fuel_moisture))

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Moisturized Dynamic Fuel Model: GR1"</span>)
pprint(moisturize(dynamic_fuel_model, fuel_moisture))
</pre>
</div>

<pre class="example" id="org24dfd28">
Moisturized Static Fuel Model: R01
{'M_f': [0.05, 0.1, 0.15, 0.0, 0.3, 0.5],
 'M_x': [0.12, 0.12, 0.12, 0.0, 0.12, 0.12],
 'S_T': [0.0555, 0.0555, 0.0555, 0.0555, 0.0555, 0.0555],
 'S_e': [0.01, 0.01, 0.01, 0.01, 0.01, 0.01],
 'burnable': True,
 'delta': 1.0,
 'dynamic': False,
 'f_i': [1.0, 0.0],
 'f_ij': [1.0, 0.0, 0.0, 0.0, 0.0, 0.0],
 'g_ij': [1.0, 0.0, 0.0, 0.0, 0.0, 0.0],
 'h': [8000.0, 8000.0, 8000.0, 8000.0, 8000.0, 8000.0],
 'name': 'R01',
 'number': 1,
 'rho_p': [32.0, 32.0, 32.0, 32.0, 32.0, 32.0],
 'sigma': [3500.0, 0.0, 0.0, 0.0, 0.0, 0.0],
 'w_o': [0.034, 0.0, 0.0, 0.0, 0.0, 0.0]}

Moisturized Dynamic Fuel Model: GR1
{'M_f': [0.05, 0.1, 0.15, 0.05, 0.3, 0.5],
 'M_x': [0.15, 0.15, 0.15, 0.15, 0.15, 0.15],
 'S_T': [0.0555, 0.0555, 0.0555, 0.0555, 0.0555, 0.0555],
 'S_e': [0.01, 0.01, 0.01, 0.01, 0.01, 0.01],
 'burnable': True,
 'delta': 0.4,
 'dynamic': True,
 'f_i': [1.0, 0.0],
 'f_ij': [0.26829268292682923, 0.0, 0.0, 0.7317073170731707, 0.0, 0.0],
 'g_ij': [1.0, 0.0, 0.0, 1.0, 0.0, 0.0],
 'h': [8000.0, 8000.0, 8000.0, 8000.0, 8000.0, 8000.0],
 'name': 'GR1',
 'number': 101,
 'rho_p': [32.0, 32.0, 32.0, 32.0, 32.0, 32.0],
 'sigma': [2200.0, 109.0, 30.0, 2000.0, 2000.0, 0.0],
 'w_o': [0.0046, 0.0, 0.0, 0.0138, 0.0, 0.0]}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orge582768" class="outline-2">
<h2 id="orge582768"><span class="section-number-2">6.</span> [WIP] Surface Fire Equations (pyretechnics.surface_fire)</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-org11ca683" class="outline-3">
<h3 id="org11ca683"><span class="section-number-3">6.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-6-1">
<p>
The following sections define functions that calculate the spread rate
and intensity of a fire burning through surface fuels. These functions
combine fuel models and fuel moisture values (as defined in section
<a href="#org742a728">5</a>) with
wind and topography inputs to determine the maximum spread rate and
direction of a surface fire as well as its fireline intensity and
flame length.
</p>
</div>
<div id="outline-container-orgb5cef2e" class="outline-4">
<h4 id="orgb5cef2e"><span class="section-number-4">6.1.1.</span> Rothermel's Surface Fire Rate of Spread Equation</h4>
<div class="outline-text-4" id="text-6-1-1">
<p>
To simulate fire behavior in as similar a way as possible to the US
government-sponsored fire models (e.g., FARSITE, FlamMap, FPA,
BehavePlus), Pyretechnics adopts the surface fire spread and reaction
intensity formulas from Rothermel's 1972 publication "A Mathematical
Model for Predicting Fire Spread in Wildland Fuels", adjusted
according to Albini 1976 Appendix III to match the behavior of
Albini's original FIREMODS library.<sup><a id="fnr.11" class="footref" href="#fn.11" role="doc-backlink">11</a></sup><sup>, </sup><sup><a id="fnr.12" class="footref" href="#fn.12" role="doc-backlink">12</a></sup>
This should align with the updated description provided in Patricia
Andrews' 2018 publication "The Rothermel Surface Fire Spread Model and
Associated Developments: A Comprehensive
Explanation".<sup><a id="fnr.13" class="footref" href="#fn.13" role="doc-backlink">13</a></sup>
</p>

<p>
Very briefly, the surface rate of spread of a fire's leading edge \(R\)
is described by the following formula:
</p>

\begin{align}
  R = \frac{I_R \, \xi \, (1 + \phi_W + \phi_S)}{\rho_b \, \epsilon \, Q_{ig}}
\end{align}

<p>
where these terms have the meanings shown in Table
<a href="#orgc98ce71">2</a>.
</p>

<table id="orgc98ce71">
<caption class="t-above"><span class="table-number">Table 2:</span> Inputs to Rothermel's surface fire rate of spread equation</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Term</th>
<th scope="col" class="org-left">Description</th>
<th scope="col" class="org-left">Units</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">\(R\)</td>
<td class="org-left">surface fire spread rate</td>
<td class="org-left">\(\text{ft}/\text{min}\)</td>
</tr>

<tr>
<td class="org-left">\(I_R\)</td>
<td class="org-left">reaction intensity</td>
<td class="org-left">\(\text{Btu}/\text{ft}^2/\text{min}\)</td>
</tr>

<tr>
<td class="org-left">\(\xi\)</td>
<td class="org-left">propagating flux ratio</td>
<td class="org-left">\(\text{unitless}\)</td>
</tr>

<tr>
<td class="org-left">\(\phi_W\)</td>
<td class="org-left">wind factor</td>
<td class="org-left">\(\text{unitless}\)</td>
</tr>

<tr>
<td class="org-left">\(\phi_S\)</td>
<td class="org-left">slope factor</td>
<td class="org-left">\(\text{unitless}\)</td>
</tr>

<tr>
<td class="org-left">\(\rho_b\)</td>
<td class="org-left">oven-dry fuel bed bulk density</td>
<td class="org-left">\(\text{lb}/\text{ft}^3\)</td>
</tr>

<tr>
<td class="org-left">\(\epsilon\)</td>
<td class="org-left">effective heating number</td>
<td class="org-left">\(\text{unitless}\)</td>
</tr>

<tr>
<td class="org-left">\(Q_{ig}\)</td>
<td class="org-left">heat of preignition</td>
<td class="org-left">\(\text{Btu}/\text{lb}\)</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org6a7311b" class="outline-4">
<h4 id="org6a7311b"><span class="section-number-4">6.1.2.</span> Surface Fire Spread Rate Functions without Wind or Slope</h4>
<div class="outline-text-4" id="text-6-1-2">
<p>
In this section, Rothermel's surface fire spread rate equation will be
computed without introducing the effects of wind or slope (i.e.,
\(\phi_W = \phi_S = 0\)). In this case, the only necessary input is a
moisturized fuel model (as created in section <a href="#orgc1c1a02">5.1.7</a>). Thus, the functions here will focus on this
simplified version of Rothermel's spread rate equation:
</p>

\begin{align}
  R_{\text{base}} = \frac{I_R \, \xi}{\rho_b \, \epsilon \, Q_{ig}}
\end{align}

<p>
Each term will be defined in its own section, and finally they will be
combined together in a single function that computes \(R_{\text{base}}\).
</p>
</div>
<ol class="org-ol">
<li><a id="org92b4e5b"></a>Module Imports<br>
<div class="outline-text-5" id="text-6-1-2-1">
<div class="org-src-container">
<pre class="src src-python" id="orge5a7843"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> exp
<span class="org-keyword">from</span> pyretechnics.fuel_models <span class="org-keyword">import</span> map_category, map_size_class, category_sum, size_class_sum
</pre>
</div>
</div>
</li>
<li><a id="org3b41a87"></a>Common Intermediate Calculations: \(\sigma', \beta, \beta_{op}\)<br>
<div class="outline-text-5" id="text-6-1-2-2">
<div class="org-src-container">
<pre class="src src-python" id="org0c36318"><span class="org-keyword">def</span> <span class="org-function-name">calc_surface_area_to_volume_ratio</span>(f_i, f_ij, sigma):
    <span class="org-variable-name">sigma_prime_i</span> <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: f_ij[i] <span class="org-operator">*</span> sigma[i])
    <span class="org-keyword">return</span> category_sum(<span class="org-keyword">lambda</span> i: f_i[i] <span class="org-operator">*</span> sigma_prime_i[i])


<span class="org-keyword">def</span> <span class="org-function-name">calc_packing_ratio</span>(w_o, rho_p, delta):
    <span class="org-keyword">if</span> (delta <span class="org-operator">&gt;</span> 0.0):
        <span class="org-variable-name">beta_i</span> <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: w_o[i] <span class="org-operator">/</span> rho_p[i])
        <span class="org-keyword">return</span> category_sum(<span class="org-keyword">lambda</span> i: beta_i[i]) <span class="org-operator">/</span> delta
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> 0.0


<span class="org-keyword">def</span> <span class="org-function-name">calc_optimum_packing_ratio</span>(sigma_prime):
    <span class="org-keyword">return</span> (3.348 <span class="org-operator">/</span> sigma_prime <span class="org-operator">**</span> 0.8189) <span class="org-keyword">if</span> (sigma_prime <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 1.0
</pre>
</div>
</div>
</li>
<li><a id="orgfac33d6"></a>Reaction Intensity: \(I_R\)<br>
<div class="outline-text-5" id="text-6-1-2-3">
<div class="org-src-container">
<pre class="src src-python" id="org84ab826"><span class="org-keyword">def</span> <span class="org-function-name">calc_mineral_damping_coefficients</span>(f_ij, S_e):
    <span class="org-variable-name">S_e_i</span> <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: f_ij[i] <span class="org-operator">*</span> S_e[i])
    <span class="org-keyword">return</span> map_category(<span class="org-keyword">lambda</span> i:
                        (<span class="org-keyword">lambda</span> S_e_i:
                         0.174 <span class="org-operator">/</span> (S_e_i <span class="org-operator">**</span> 0.19) <span class="org-keyword">if</span> (S_e_i <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 1.0
                         )(S_e_i[i]))


<span class="org-keyword">def</span> <span class="org-function-name">calc_moisture_damping_coefficients</span>(f_ij, M_f, M_x):
    <span class="org-variable-name">M_f_i</span> <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: f_ij[i] <span class="org-operator">*</span> M_f[i])
    <span class="org-variable-name">M_x_i</span> <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: f_ij[i] <span class="org-operator">*</span> M_x[i])
    <span class="org-keyword">return</span> map_category(<span class="org-keyword">lambda</span> i:
                        (<span class="org-keyword">lambda</span> M_f, M_x:
                         (<span class="org-keyword">lambda</span> r_M:
                          1.0 <span class="org-operator">-</span> 2.59 <span class="org-operator">*</span> r_M <span class="org-operator">+</span> 5.11 <span class="org-operator">*</span> r_M <span class="org-operator">**</span> 2.0 <span class="org-operator">-</span> 3.52 <span class="org-operator">*</span> r_M <span class="org-operator">**</span> 3.0
                          )(<span class="org-builtin">min</span>(1.0, M_f <span class="org-operator">/</span> M_x) <span class="org-keyword">if</span> (M_x <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 1.0)
                         )(M_f_i[i], M_x_i[i]))


<span class="org-keyword">def</span> <span class="org-function-name">calc_low_heat_content</span>(f_ij, h):
    <span class="org-keyword">return</span> size_class_sum(<span class="org-keyword">lambda</span> i: f_ij[i] <span class="org-operator">*</span> h[i])


<span class="org-keyword">def</span> <span class="org-function-name">calc_net_fuel_loading</span>(g_ij, w_o, S_T):
    <span class="org-keyword">return</span> size_class_sum(<span class="org-keyword">lambda</span> i:
                          (<span class="org-keyword">lambda</span> g_ij, w_o, S_T:
                           g_ij <span class="org-operator">*</span> w_o <span class="org-operator">*</span> (1.0 <span class="org-operator">-</span> S_T)
                           )(g_ij[i], w_o[i], S_T[i]))


<span class="org-keyword">def</span> <span class="org-function-name">calc_heat_per_unit_area</span>(eta_S_i, eta_M_i, h_i, W_n_i):
    <span class="org-keyword">return</span> category_sum(<span class="org-keyword">lambda</span> i: W_n_i[i] <span class="org-operator">*</span> h_i[i] <span class="org-operator">*</span> eta_M_i[i] <span class="org-operator">*</span> eta_S_i[i])


<span class="org-keyword">def</span> <span class="org-function-name">calc_optimum_reaction_velocity</span>(sigma_prime, beta, beta_op):
    <span class="org-comment-delimiter"># </span><span class="org-comment">Albini 1976 replaces 1 / (4.774 * (sigma_prime ** 0.1) - 7.27)</span>
    <span class="org-variable-name">A</span>               <span class="org-operator">=</span> (133.0 <span class="org-operator">/</span> sigma_prime <span class="org-operator">**</span> 0.7913) <span class="org-keyword">if</span> (sigma_prime <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 0.0
    <span class="org-variable-name">B</span>               <span class="org-operator">=</span> sigma_prime <span class="org-operator">**</span> 1.5
    <span class="org-variable-name">C</span>               <span class="org-operator">=</span> beta <span class="org-operator">/</span> beta_op
    <span class="org-comment-delimiter"># </span><span class="org-comment">Maximum reaction velocity (1/min)</span>
    <span class="org-variable-name">Gamma_prime_max</span> <span class="org-operator">=</span> B <span class="org-operator">/</span> (495.0 <span class="org-operator">+</span> 0.0594 <span class="org-operator">*</span> B)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Optimum reaction velocity (1/min)</span>
    <span class="org-keyword">return</span> Gamma_prime_max <span class="org-operator">*</span> (C <span class="org-operator">**</span> A) <span class="org-operator">*</span> exp(A <span class="org-operator">*</span> (1.0 <span class="org-operator">-</span> C))


<span class="org-keyword">def</span> <span class="org-function-name">calc_reaction_intensity</span>(moisturized_fuel_model, sigma_prime, beta, beta_op):
    <span class="org-variable-name">w_o</span>         <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"w_o"</span>]
    <span class="org-variable-name">h</span>           <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"h"</span>]
    <span class="org-variable-name">S_T</span>         <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"S_T"</span>]
    <span class="org-variable-name">S_e</span>         <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"S_e"</span>]
    <span class="org-variable-name">M_x</span>         <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"M_x"</span>]
    <span class="org-variable-name">M_f</span>         <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"M_f"</span>]
    <span class="org-variable-name">f_ij</span>        <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"f_ij"</span>]
    <span class="org-variable-name">g_ij</span>        <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"g_ij"</span>]
    <span class="org-variable-name">eta_S_i</span>     <span class="org-operator">=</span> calc_mineral_damping_coefficients(f_ij, S_e)
    <span class="org-variable-name">eta_M_i</span>     <span class="org-operator">=</span> calc_moisture_damping_coefficients(f_ij, M_f, M_x)
    <span class="org-variable-name">h_i</span>         <span class="org-operator">=</span> calc_low_heat_content(f_ij, h)                             <span class="org-comment-delimiter"># </span><span class="org-comment">(Btu/lb)</span>
    <span class="org-variable-name">W_n_i</span>       <span class="org-operator">=</span> calc_net_fuel_loading(g_ij, w_o, S_T)                      <span class="org-comment-delimiter"># </span><span class="org-comment">(lb/ft^2)</span>
    <span class="org-variable-name">Btus</span>        <span class="org-operator">=</span> calc_heat_per_unit_area(eta_S_i, eta_M_i, h_i, W_n_i)      <span class="org-comment-delimiter"># </span><span class="org-comment">(Btu/ft^2)</span>
    <span class="org-variable-name">Gamma_prime</span> <span class="org-operator">=</span> calc_optimum_reaction_velocity(sigma_prime, beta, beta_op) <span class="org-comment-delimiter"># </span><span class="org-comment">(1/min)</span>
    <span class="org-keyword">return</span> Btus <span class="org-operator">*</span> Gamma_prime                                                <span class="org-comment-delimiter"># </span><span class="org-comment">(Btu/ft^2/min)</span>
</pre>
</div>
</div>
</li>
<li><a id="org9a10279"></a>Propagating Flux Ratio: \(\xi\)<br>
<div class="outline-text-5" id="text-6-1-2-4">
<div class="org-src-container">
<pre class="src src-python" id="orgb5fedd3"><span class="org-keyword">def</span> <span class="org-function-name">calc_propagating_flux_ratio</span>(sigma_prime, beta):
    <span class="org-keyword">return</span> exp((0.792 <span class="org-operator">+</span> 0.681 <span class="org-operator">*</span> (sigma_prime <span class="org-operator">**</span> 0.5)) <span class="org-operator">*</span> (beta <span class="org-operator">+</span> 0.1)) <span class="org-operator">/</span> (192.0 <span class="org-operator">+</span> 0.2595 <span class="org-operator">*</span> sigma_prime)
</pre>
</div>
</div>
</li>
<li><a id="org03cabf1"></a>Heat Source (No Wind No Slope): \(I_R \, \xi\)<br>
<div class="outline-text-5" id="text-6-1-2-5">
<div class="org-src-container">
<pre class="src src-python" id="org419421e"><span class="org-keyword">def</span> <span class="org-function-name">calc_heat_source</span>(I_R, xi):
    <span class="org-keyword">return</span> I_R <span class="org-operator">*</span> xi
</pre>
</div>
</div>
</li>
<li><a id="org9dbd0ce"></a>Oven-Dry Fuel Bed Bulk Density: \(\rho_b\)<br>
<div class="outline-text-5" id="text-6-1-2-6">
<div class="org-src-container">
<pre class="src src-python" id="org01c8560"><span class="org-keyword">def</span> <span class="org-function-name">calc_ovendry_bulk_density</span>(w_o, delta):
    <span class="org-keyword">if</span> (delta <span class="org-operator">&gt;</span> 0.0):
        <span class="org-variable-name">rho_b_i</span> <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: w_o[i])
        <span class="org-keyword">return</span> category_sum(<span class="org-keyword">lambda</span> i: rho_b_i[i]) <span class="org-operator">/</span> delta
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> 0.0
</pre>
</div>
</div>
</li>
<li><a id="orgbdb9080"></a>Effective Heating Number Distribution: \(\epsilon_{ij}\)<br>
<div class="outline-text-5" id="text-6-1-2-7">
<div class="org-src-container">
<pre class="src src-python" id="org4118f3e"><span class="org-keyword">def</span> <span class="org-function-name">calc_effective_heating_number_distribution</span>(sigma):
    <span class="org-keyword">return</span> map_size_class(<span class="org-keyword">lambda</span> i:
                          (<span class="org-keyword">lambda</span> sigma:
                           exp(<span class="org-operator">-</span>138.0 <span class="org-operator">/</span> sigma) <span class="org-keyword">if</span> (sigma <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 0.0
                           )(sigma[i]))
</pre>
</div>
</div>
</li>
<li><a id="org7b5dcf6"></a>Heat of Preignition Distribution: \((Q_{ig})_{ij}\)<br>
<div class="outline-text-5" id="text-6-1-2-8">
<div class="org-src-container">
<pre class="src src-python" id="org833a2c9"><span class="org-keyword">def</span> <span class="org-function-name">calc_heat_of_preignition_distribution</span>(M_f):
    <span class="org-keyword">return</span> map_size_class(<span class="org-keyword">lambda</span> i: 250.0 <span class="org-operator">+</span> 1116.0 <span class="org-operator">*</span> M_f[i])
</pre>
</div>
</div>
</li>
<li><a id="org0c5c390"></a>Heat Sink: \(\rho_b \, \epsilon \, Q_{ig}\)<br>
<div class="outline-text-5" id="text-6-1-2-9">
<div class="org-src-container">
<pre class="src src-python" id="org3fd8c95"><span class="org-keyword">def</span> <span class="org-function-name">calc_heat_sink</span>(f_i, f_ij, rho_b, epsilon_ij, Q_ig_ij):
    <span class="org-variable-name">effective_heat_of_preignition_i</span> <span class="org-operator">=</span> size_class_sum(<span class="org-keyword">lambda</span> i: f_ij[i] <span class="org-operator">*</span> epsilon_ij[i] <span class="org-operator">*</span> Q_ig_ij[i])
    <span class="org-variable-name">effective_heat_of_preignition</span>   <span class="org-operator">=</span> category_sum(<span class="org-keyword">lambda</span> i: f_i[i] <span class="org-operator">*</span> effective_heat_of_preignition_i[i])
    <span class="org-keyword">return</span> rho_b <span class="org-operator">*</span> effective_heat_of_preignition
</pre>
</div>
</div>
</li>
<li><a id="org5ee2976"></a>Spread Rate (No Wind No Slope): \(I_R \, \xi \, / \, \rho_b \, \epsilon \, Q_{ig}\)<br>
<div class="outline-text-5" id="text-6-1-2-10">
<div class="org-src-container">
<pre class="src src-python" id="orgb223c5b"><span class="org-keyword">def</span> <span class="org-function-name">calc_spread_rate</span>(heat_source, heat_sink):
    <span class="org-keyword">return</span> heat_source <span class="org-operator">/</span> heat_sink <span class="org-keyword">if</span> (heat_sink <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 0.0
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-org58d8c21" class="outline-4">
<h4 id="org58d8c21"><span class="section-number-4">6.1.3.</span> Surface Fire Intensity Functions</h4>
<div class="outline-text-4" id="text-6-1-3">
<p>
Using these surface fire spread rate and reaction intensity values, we
can now calculate surface fire intensity values by applying Anderson's
flame depth formula and Byram's fireline intensity and flame length
equations as described below.<sup><a id="fnr.14" class="footref" href="#fn.14" role="doc-backlink">14</a></sup><sup>, </sup><sup><a id="fnr.15" class="footref" href="#fn.15" role="doc-backlink">15</a></sup>
</p>

\begin{align}
  t_{\text{res}} &= \frac{384}{\sigma'} \\
  \nonumber \\
  D_A &= R \, t_{\text{res}} \\
  \nonumber \\
  I_B &= \frac{I_R \, D_A}{60} \\
  \nonumber \\
  L_B &= 0.45(I_B)^{0.46}
\end{align}

<p>
where \(\sigma'\) is the weighted sum by size class of the fuel model's
surface area to volume ratio in \(\text{ft}^2/\text{ft}^3\),
\(t_{\text{res}}\) is the residence time in \(\text{minutes}\), \(R\) is the
surface fire spread rate in \(\text{ft}/\text{min}\), \(D_A\) is the flame
depth in \(\text{ft}\), \(I_R\) is the reaction intensity in
\(\text{Btu}/\text{ft}^2/\text{min}\), \(I_B\) is the fireline intensity
in \(\text{Btu}/\text{ft}/\text{s}\), and \(L_B\) is the flame length in
\(\text{ft}\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="orga1e990b"><span class="org-keyword">def</span> <span class="org-function-name">calc_residence_time</span>(sigma_prime):
    <span class="org-keyword">return</span> 384.0 <span class="org-operator">/</span> sigma_prime


<span class="org-keyword">def</span> <span class="org-function-name">calc_flame_depth</span>(spread_rate, residence_time):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the depth, or front-to-back distance, of the actively flaming zone</span>
<span class="org-doc">    of a free-spreading fire in ft given:</span>
<span class="org-doc">    - spread-rate (ft/min) orthogonal to the fireline.</span>
<span class="org-doc">    - residence-time (min)</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> spread_rate <span class="org-operator">*</span> residence_time


<span class="org-keyword">def</span> <span class="org-function-name">calc_fire_line_intensity</span>(reaction_intensity, flame_depth):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the rate of heat release per unit of fire edge in Btu/ft/s given:</span>
<span class="org-doc">    - reaction-intensity (Btu/ft^2/min)</span>
<span class="org-doc">    - flame-depth (ft)</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> (reaction_intensity <span class="org-operator">*</span> flame_depth) <span class="org-operator">/</span> 60.0


<span class="org-keyword">def</span> <span class="org-function-name">calc_flame_length</span>(fire_line_intensity):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the average flame length in ft given:</span>
<span class="org-doc">    - fire-line-intensity (Btu/ft/s)</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> 0.45 <span class="org-operator">*</span> (fire_line_intensity <span class="org-operator">**</span> 0.46)
</pre>
</div>
</div>
</div>
<div id="outline-container-org633d02b" class="outline-4">
<h4 id="org633d02b"><span class="section-number-4">6.1.4.</span> Stored Auxiliary Values and Functions</h4>
<div class="outline-text-4" id="text-6-1-4">
<p>
In order to compute the maximum spread rate, direction, and intensity
of the surface fire front, we will need to incorporate the effects of
wind and slope on the fire. However, we can precompute several
intermediate values and functions needed for this step based solely on
the fuel bed characteristics already available to us with just a
moisturized fuel model (see section <a href="#orgc1c1a02">5.1.7</a>).
</p>
</div>
<ol class="org-ol">
<li><a id="orgaef3345"></a>Slope Factor Function: \(\tan(\theta_S) \mapsto \phi_S\)<br>
<div class="outline-text-5" id="text-6-1-4-1">
<div class="org-src-container">
<pre class="src src-python" id="org795ef86"><span class="org-keyword">def</span> <span class="org-function-name">get_phi_S_fn</span>(beta):
    <span class="org-keyword">if</span> (beta <span class="org-operator">&gt;</span> 0.0):
        <span class="org-variable-name">G</span> <span class="org-operator">=</span> 5.275 <span class="org-operator">*</span> beta <span class="org-operator">**</span> <span class="org-operator">-</span>0.3
        <span class="org-keyword">return</span> <span class="org-keyword">lambda</span> slope: (slope <span class="org-operator">**</span> 2.0) <span class="org-operator">*</span> G <span class="org-keyword">if</span> (slope <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 0.0
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> <span class="org-keyword">lambda</span> _: 0.0
</pre>
</div>
</div>
</li>
<li><a id="orga5ec14c"></a>Wind Factor Function: \(U_{\text{mid}} \mapsto \phi_W\)<br>
<div class="outline-text-5" id="text-6-1-4-2">
<div class="org-src-container">
<pre class="src src-python" id="orgb7b0368"><span class="org-keyword">def</span> <span class="org-function-name">get_phi_W_fn</span>(beta, B, C, F):
    <span class="org-keyword">if</span> (beta <span class="org-operator">&gt;</span> 0.0):
        <span class="org-variable-name">C_over_F</span> <span class="org-operator">=</span> C <span class="org-operator">/</span> F
        <span class="org-keyword">return</span> <span class="org-keyword">lambda</span> midflame_wind_speed: (midflame_wind_speed <span class="org-operator">**</span> B) <span class="org-operator">*</span> C_over_F <span class="org-keyword">if</span> (midflame_wind_speed <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">else</span> 0.0
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> <span class="org-keyword">lambda</span> _: 0.0
</pre>
</div>
</div>
</li>
<li><a id="org1857d46"></a>Wind Speed Function: \(\phi_W \mapsto U_{\text{mid}}\)<br>
<div class="outline-text-5" id="text-6-1-4-3">
<div class="org-src-container">
<pre class="src src-python" id="orgae3e9f8"><span class="org-keyword">def</span> <span class="org-function-name">get_wind_speed_fn</span>(B, C, F):
    <span class="org-variable-name">F_over_C</span>  <span class="org-operator">=</span> F <span class="org-operator">/</span> C
    <span class="org-variable-name">B_inverse</span> <span class="org-operator">=</span> 1.0 <span class="org-operator">/</span> B
    <span class="org-keyword">return</span> <span class="org-keyword">lambda</span> phi_W: (phi_W <span class="org-operator">*</span> F_over_C) <span class="org-operator">**</span> B_inverse
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-org7feb5f5" class="outline-4">
<h4 id="org7feb5f5"><span class="section-number-4">6.1.5.</span> Main Rothermel Entrypoint Function</h4>
<div class="outline-text-4" id="text-6-1-5">
<div class="org-src-container">
<pre class="src src-python" id="orgfda797a"><span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Replace reaction_intensity and residence_time with fireline_intensity and max_wind_speed</span>
<span class="org-keyword">def</span> <span class="org-function-name">rothermel_surface_fire_spread_no_wind_no_slope</span>(moisturized_fuel_model):
    <span class="org-doc">"""</span>
<span class="org-doc">    Given a dictionary containing these keys:</span>
<span class="org-doc">    - delta [fuel depth (ft)]</span>
<span class="org-doc">    - w_o   [ovendry fuel loading (lb/ft^2)]</span>
<span class="org-doc">    - rho_p [ovendry particle density (lb/ft^3)]</span>
<span class="org-doc">    - sigma [fuel particle surface-area-to-volume ratio (ft^2/ft^3)]</span>
<span class="org-doc">    - h     [fuel particle low heat content (Btu/lb)]</span>
<span class="org-doc">    - S_T   [fuel particle total mineral content (lb minerals/lb ovendry wood)]</span>
<span class="org-doc">    - S_e   [fuel particle effective mineral content (lb silica-free minerals/lb ovendry wood)]</span>
<span class="org-doc">    - M_x   [fuel particle moisture of extinction (lb moisture/lb ovendry wood)]</span>
<span class="org-doc">    - M_f   [fuel particle moisture content (lb moisture/lb ovendry wood)]</span>
<span class="org-doc">    - f_ij  [percent of load per size class (%)]</span>
<span class="org-doc">    - f_i   [percent of load per category (%)]</span>
<span class="org-doc">    - g_ij  [percent of load per size class from Albini_1976_FIREMOD, page 20]</span>

<span class="org-doc">    return a dictionary containing these keys:</span>
<span class="org-doc">    - base_spread_rate   (ft/min)</span>
<span class="org-doc">    - reaction_intensity (Btu/ft^2/min)</span>
<span class="org-doc">    - residence_time     (min)</span>
<span class="org-doc">    - get_phi_S          (lambda: slope =&gt; phi_S)</span>
<span class="org-doc">    - get_phi_W          (lambda: midflame_wind_speed =&gt; phi_W)</span>
<span class="org-doc">    - get_wind_speed     (lambda: phi_W =&gt; midflame_wind_speed)</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">delta</span>          <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"delta"</span>]
    <span class="org-variable-name">w_o</span>            <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"w_o"</span>]
    <span class="org-variable-name">rho_p</span>          <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"rho_p"</span>]
    <span class="org-variable-name">sigma</span>          <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"sigma"</span>]
    <span class="org-variable-name">M_f</span>            <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"M_f"</span>]
    <span class="org-variable-name">f_ij</span>           <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"f_ij"</span>]
    <span class="org-variable-name">f_i</span>            <span class="org-operator">=</span> moisturized_fuel_model[<span class="org-string">"f_i"</span>]
    <span class="org-variable-name">sigma_prime</span>    <span class="org-operator">=</span> calc_surface_area_to_volume_ratio(f_i, f_ij, sigma)
    <span class="org-variable-name">beta</span>           <span class="org-operator">=</span> calc_packing_ratio(w_o, rho_p, delta)
    <span class="org-variable-name">beta_op</span>        <span class="org-operator">=</span> calc_optimum_packing_ratio(sigma_prime)
    <span class="org-variable-name">I_R</span>            <span class="org-operator">=</span> calc_reaction_intensity(moisturized_fuel_model, sigma_prime, beta, beta_op) <span class="org-comment-delimiter"># </span><span class="org-comment">Btu/ft^2/min</span>
    <span class="org-variable-name">xi</span>             <span class="org-operator">=</span> calc_propagating_flux_ratio(sigma_prime, beta)
    <span class="org-variable-name">heat_source</span>    <span class="org-operator">=</span> calc_heat_source(I_R, xi)                                  <span class="org-comment-delimiter"># </span><span class="org-comment">Btu/ft^2/min</span>
    <span class="org-variable-name">rho_b</span>          <span class="org-operator">=</span> calc_ovendry_bulk_density(w_o, delta)                      <span class="org-comment-delimiter"># </span><span class="org-comment">lb/ft^3</span>
    <span class="org-variable-name">epsilon_ij</span>     <span class="org-operator">=</span> calc_effective_heating_number_distribution(sigma)
    <span class="org-variable-name">Q_ig_ij</span>        <span class="org-operator">=</span> calc_heat_of_preignition_distribution(M_f)                 <span class="org-comment-delimiter"># </span><span class="org-comment">Btu/lb</span>
    <span class="org-variable-name">heat_sink</span>      <span class="org-operator">=</span> calc_heat_sink(f_i, f_ij, rho_b, epsilon_ij, Q_ig_ij)      <span class="org-comment-delimiter"># </span><span class="org-comment">Btu/ft^3</span>
    <span class="org-variable-name">R</span>              <span class="org-operator">=</span> calc_spread_rate(heat_source, heat_sink)                   <span class="org-comment-delimiter"># </span><span class="org-comment">ft/min</span>
    <span class="org-variable-name">t_res</span>          <span class="org-operator">=</span> calc_residence_time(sigma_prime)                           <span class="org-comment-delimiter"># </span><span class="org-comment">min</span>
    <span class="org-variable-name">B</span>              <span class="org-operator">=</span> 0.02526 <span class="org-operator">*</span> (sigma_prime <span class="org-operator">**</span> 0.54)
    <span class="org-variable-name">C</span>              <span class="org-operator">=</span> 7.47 <span class="org-operator">*</span> exp(<span class="org-operator">-</span>0.133 <span class="org-operator">*</span> (sigma_prime <span class="org-operator">**</span> 0.55))
    <span class="org-variable-name">E</span>              <span class="org-operator">=</span> 0.715 <span class="org-operator">*</span> exp(<span class="org-operator">-</span>3.59 <span class="org-operator">*</span> (sigma_prime <span class="org-operator">/</span> 10000.0))
    <span class="org-variable-name">F</span>              <span class="org-operator">=</span> (beta <span class="org-operator">/</span> beta_op) <span class="org-operator">**</span> E
    <span class="org-variable-name">get_phi_S</span>      <span class="org-operator">=</span> get_phi_S_fn(beta)
    <span class="org-variable-name">get_phi_W</span>      <span class="org-operator">=</span> get_phi_W_fn(beta, B, C, F)
    <span class="org-variable-name">get_wind_speed</span> <span class="org-operator">=</span> get_wind_speed_fn(B, C, F)
    <span class="org-keyword">return</span> {
        <span class="org-string">"base_spread_rate"</span>  : R,
        <span class="org-string">"reaction_intensity"</span>: I_R,
        <span class="org-string">"residence_time"</span>    : t_res,
        <span class="org-string">"get_phi_S"</span>         : get_phi_S,
        <span class="org-string">"get_phi_W"</span>         : get_phi_W,
        <span class="org-string">"get_wind_speed"</span>    : get_wind_speed,
    }
</pre>
</div>
</div>
</div>
<div id="outline-container-org2d75aa7" class="outline-4">
<h4 id="org2d75aa7"><span class="section-number-4">6.1.6.</span> Surface Fire Spread Rate with Wind and Slope</h4>
<div class="outline-text-4" id="text-6-1-6">
<p>
Later, this no-wind-no-slope value is used to compute the maximum
spread rate and direction for the leading edge of the surface fire
under analysis. Since Rothermel's original equations assume that the
wind direction and slope are aligned, the effects of cross-slope winds
must be taken into effect. To accomplish this, Pyretechnics implements
the vector addition procedure defined in Rothermel 1983 that combines
the wind-only and slope-only spread rates independently to calculate
the effective fire spread direction and magnitude.<sup><a id="fnr.16" class="footref" href="#fn.16" role="doc-backlink">16</a></sup>
</p>

<p>
A minor wrinkle is introduced when putting these calculations into
practice because Rothermel's formulas all expect a measure of midflame
wind speed. However, wind speed data is often collected at a height 20
feet above either unsheltered ground or a tree canopy layer if
present. To convert this 20-ft wind speed to the required midflame
wind speed value, Pyretechnics uses the <b>wind adjustment factor</b>
formula from Albini &amp; Baughman 1979, parameterized as in BehavePlus,
FARSITE, FlamMap, FSPro, and FPA according to Andrews
2012<sup><a id="fnr.17" class="footref" href="#fn.17" role="doc-backlink">17</a></sup><sup>, </sup><sup><a id="fnr.18" class="footref" href="#fn.18" role="doc-backlink">18</a></sup>. This formula is shown below:
</p>

\begin{align}
  WAF = \left\{
    \begin{array}{lr}
      1.83 \ln(\frac{20.0 + 0.36 FBD}{0.13 FBD})^{-1} & CC = 0 \\
      0.555 (\sqrt{CH (CC/3.0)} \ln(\frac{20 + 0.36 CH}{0.13 CH}))^{-1} & CC > 0
    \end{array}
  \right.
\end{align}

<p>
where WAF is the unitless wind adjustment factor, FBD is the fuel bed
depth in feet, CH is the canopy height in ft, and CC is the canopy
cover percentage (0-1).
</p>

<div class="org-src-container">
<pre class="src src-python" id="org15df90e"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> log, sqrt

<span class="org-keyword">def</span> <span class="org-function-name">wind_adjustment_factor</span>(fuel_bed_depth, canopy_height, canopy_cover):
    <span class="org-doc">"""</span>
<span class="org-doc">    fuel_bed_depth :: ft</span>
<span class="org-doc">    canopy_height  :: ft</span>
<span class="org-doc">    canopy_cover   :: 0-1</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">if</span> (canopy_cover <span class="org-operator">&gt;</span> 0.0) <span class="org-keyword">and</span> (canopy_height <span class="org-operator">&gt;</span> 0.0):
        <span class="org-comment-delimiter"># </span><span class="org-comment">sheltered: equation 2 based on CC and CH, CR=1 (Andrews 2012)</span>
        <span class="org-variable-name">A</span> <span class="org-operator">=</span> sqrt((canopy_cover <span class="org-operator">/</span> 3.0) <span class="org-operator">*</span> canopy_height)
        <span class="org-variable-name">B</span> <span class="org-operator">=</span> log((20.0 <span class="org-operator">+</span> 0.36 <span class="org-operator">*</span> canopy_height) <span class="org-operator">/</span> (0.13 <span class="org-operator">*</span> canopy_height))
        <span class="org-keyword">return</span> 0.555 <span class="org-operator">/</span> (A <span class="org-operator">*</span> B)
    <span class="org-keyword">elif</span> (fuel_bed_depth <span class="org-operator">&gt;</span> 0.0):
        <span class="org-comment-delimiter"># </span><span class="org-comment">unsheltered: equation 6 H_F = H (Andrews 2012)</span>
        <span class="org-variable-name">A</span> <span class="org-operator">=</span> log((20.0 <span class="org-operator">+</span> 0.36 <span class="org-operator">*</span> fuel_bed_depth) <span class="org-operator">/</span> (0.13 <span class="org-operator">*</span> fuel_bed_depth))
        <span class="org-keyword">return</span> 1.83 <span class="org-operator">/</span> A <span class="org-comment-delimiter"># </span><span class="org-comment">1.83 truncated from 1.8328795184533409</span>
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">non-burnable fuel model</span>
        <span class="org-keyword">return</span> 0.0
</pre>
</div>

<p>
The midflame wind speed that would be required to produce the combined
spread rate in a no-slope scenario is termed the effective windspeed
\(U_{\text{eff}}\). Following the recommendations given in Appendix III
of Albini 1976, these midflame wind speeds are all limited to \(0.9
I_{R}\).<sup><a id="fnr.19" class="footref" href="#fn.19" role="doc-backlink">19</a></sup>
</p>

<p>
Next, the effective wind speed is used to compute the length to width
ratio \(\frac{L}{W}\) of an ellipse that approximates the surface fire
front using equation 9 from Rothermel 1991.<sup><a id="fnr.20" class="footref" href="#fn.20" role="doc-backlink">20</a></sup> This
length to width ratio is then converted into an eccentricity measure
of the ellipse using equation 8 from Albini and Chase
1980.<sup><a id="fnr.21" class="footref" href="#fn.21" role="doc-backlink">21</a></sup> Finally, this eccentricity \(E\) is used to
project the maximum spread rate to any point along the fire front.
Here are the formulas used:
</p>

\begin{align}
  \frac{L}{W} &= 1 + 0.25 \, U_{\text{eff}} \\
  \nonumber \\
  E &= \frac{\sqrt{(\frac{L}{W})^{2} - 1}}{\frac{L}{W}} \\
  \nonumber \\
  R_{\theta} &= R_{\max}\left(\frac{1-E}{1-E\cos\theta}\right)
\end{align}

<p>
where \(U_{eff}\) is the effective wind speed in mph, \(\theta\) is the
angular offset from the direction of maximum fire spread, \(R_{max}\) is
the maximum spread rate, and \(R_{\theta}\) is the spread rate in
direction \(\theta\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="org2b68251"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> sin, cos, asin, exp, sqrt, radians, degrees
<span class="org-keyword">from</span> pyretechnics.conversion <span class="org-keyword">import</span> fpm_to_mph

<span class="org-keyword">def</span> <span class="org-function-name">almost_zero</span>(x):
    <span class="org-keyword">return</span> <span class="org-builtin">abs</span>(x) <span class="org-operator">&lt;</span> 0.000001


<span class="org-keyword">def</span> <span class="org-function-name">smallest_angle_between</span>(theta1, theta2):
  <span class="org-doc">"""</span>
<span class="org-doc">  Computes the absolute difference between two angles as an angle between 0&#176; and 180&#176;.</span>
<span class="org-doc">  The return angle has the same cosine as (- theta1 theta2) but may have an opposite sine.</span>
<span class="org-doc">  """</span>
  <span class="org-variable-name">angle</span> <span class="org-operator">=</span> <span class="org-builtin">abs</span>(theta1 <span class="org-operator">-</span> theta2)
  <span class="org-keyword">return</span> (360.0 <span class="org-operator">-</span> angle) <span class="org-keyword">if</span> (angle <span class="org-operator">&gt;</span> 180.0) <span class="org-keyword">else</span> angle


<span class="org-keyword">def</span> <span class="org-function-name">determine_spread_drivers</span>(midflame_wind_speed, wind_to_direction, slope, slope_direction):
    <span class="org-keyword">if</span> almost_zero(slope):
        <span class="org-keyword">if</span> almost_zero(midflame_wind_speed):
            <span class="org-keyword">return</span> <span class="org-string">"no_wind_no_slope"</span>
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> <span class="org-string">"wind_only"</span>
    <span class="org-keyword">elif</span> almost_zero(midflame_wind_speed):
        <span class="org-keyword">return</span> <span class="org-string">"slope_only"</span>
    <span class="org-keyword">elif</span> smallest_angle_between(wind_to_direction, slope_direction) <span class="org-operator">&lt;</span> 15.0:
        <span class="org-keyword">return</span> <span class="org-string">"wind_blows_upslope"</span>
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> <span class="org-string">"wind_blows_across_slope"</span>


<span class="org-keyword">def</span> <span class="org-function-name">spread_info_max_no_wind_no_slope</span>(spread_rate):
    <span class="org-keyword">return</span> {
        <span class="org-string">"max_spread_rate"</span>     : spread_rate,
        <span class="org-string">"max_spread_direction"</span>: 0.0,
        <span class="org-string">"effective_wind_speed"</span>: 0.0,
        <span class="org-string">"eccentricity"</span>        : 0.0,
    }


<span class="org-keyword">def</span> <span class="org-function-name">spread_info_max_wind_only</span>(spread_rate, phi_W, midflame_wind_speed, wind_to_direction):
    <span class="org-keyword">return</span> {
        <span class="org-string">"max_spread_rate"</span>     : spread_rate <span class="org-operator">*</span> (1.0 <span class="org-operator">+</span> phi_W),
        <span class="org-string">"max_spread_direction"</span>: wind_to_direction,
        <span class="org-string">"effective_wind_speed"</span>: midflame_wind_speed,
        <span class="org-string">"eccentricity"</span>        : 0.0,
    }


<span class="org-keyword">def</span> <span class="org-function-name">spread_info_max_slope_only</span>(spread_rate, phi_S, slope_direction, get_wind_speed):
    <span class="org-keyword">return</span> {
        <span class="org-string">"max_spread_rate"</span>     : spread_rate <span class="org-operator">*</span> (1.0 <span class="org-operator">+</span> phi_S),
        <span class="org-string">"max_spread_direction"</span>: slope_direction,
        <span class="org-string">"effective_wind_speed"</span>: get_wind_speed(phi_S),
        <span class="org-string">"eccentricity"</span>        : 0.0,
    }


<span class="org-keyword">def</span> <span class="org-function-name">spread_info_max_wind_blows_upslope</span>(spread_rate, phi_combined, slope_direction, get_wind_speed):
    <span class="org-keyword">return</span> {
        <span class="org-string">"max_spread_rate"</span>     : spread_rate <span class="org-operator">*</span> (1.0 <span class="org-operator">+</span> phi_combined),
        <span class="org-string">"max_spread_direction"</span>: slope_direction,
        <span class="org-string">"effective_wind_speed"</span>: get_wind_speed(phi_combined),
        <span class="org-string">"eccentricity"</span>        : 0.0,
    }


<span class="org-keyword">def</span> <span class="org-function-name">get_offset_prime</span>(x, y, offset):
    <span class="org-keyword">if</span> (x <span class="org-operator">&gt;=</span> 0.0):
        <span class="org-keyword">if</span> (y <span class="org-operator">&gt;=</span> 0.0):
            <span class="org-keyword">return</span> offset
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> 360.0 <span class="org-operator">-</span> offset
    <span class="org-keyword">elif</span> (y <span class="org-operator">&gt;=</span> 0.0):
        <span class="org-keyword">return</span> 180.0 <span class="org-operator">-</span> offset
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> 180.0 <span class="org-operator">+</span> offset


<span class="org-keyword">def</span> <span class="org-function-name">spread_info_max_wind_blows_across_slope</span>(spread_rate, phi_W, phi_S, wind_to_direction,
                                            slope_direction, get_wind_speed):
    <span class="org-variable-name">wind_magnitude</span>     <span class="org-operator">=</span> spread_rate <span class="org-operator">*</span> phi_W
    <span class="org-variable-name">slope_magnitude</span>    <span class="org-operator">=</span> spread_rate <span class="org-operator">*</span> phi_S
    <span class="org-variable-name">difference_angle</span>   <span class="org-operator">=</span> radians((wind_to_direction <span class="org-operator">-</span> slope_direction) <span class="org-operator">%</span> 360.0)
    <span class="org-variable-name">x</span>                  <span class="org-operator">=</span> slope_magnitude <span class="org-operator">+</span> wind_magnitude <span class="org-operator">*</span> cos(difference_angle)
    <span class="org-variable-name">y</span>                  <span class="org-operator">=</span> wind_magnitude <span class="org-operator">*</span> sin(difference_angle)
    <span class="org-variable-name">combined_magnitude</span> <span class="org-operator">=</span> sqrt(x <span class="org-operator">*</span> x <span class="org-operator">+</span> y <span class="org-operator">*</span> y)
    <span class="org-keyword">if</span> almost_zero(combined_magnitude):
        <span class="org-keyword">return</span> {
            <span class="org-string">"max_spread_rate"</span>     : spread_rate,
            <span class="org-string">"max_spread_direction"</span>: 0.0,
            <span class="org-string">"effective_wind_speed"</span>: 0.0,
            <span class="org-string">"eccentricity"</span>        : 0.0,
        }
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">max_spread_rate</span>      <span class="org-operator">=</span> spread_rate <span class="org-operator">+</span> combined_magnitude
        <span class="org-variable-name">phi_combined</span>         <span class="org-operator">=</span> (max_spread_rate <span class="org-operator">/</span> spread_rate) <span class="org-operator">-</span> 1.0
        <span class="org-variable-name">offset</span>               <span class="org-operator">=</span> degrees(asin(<span class="org-builtin">abs</span>(y) <span class="org-operator">/</span> combined_magnitude))
        <span class="org-variable-name">offset_prime</span>         <span class="org-operator">=</span> get_offset_prime(x, y, offset)
        <span class="org-variable-name">max_spread_direction</span> <span class="org-operator">=</span> (slope_direction <span class="org-operator">+</span> offset_prime) <span class="org-operator">%</span> 360.0
        <span class="org-variable-name">effective_wind_speed</span> <span class="org-operator">=</span> get_wind_speed(phi_combined)
        <span class="org-keyword">return</span> {
            <span class="org-string">"max_spread_rate"</span>     : max_spread_rate,
            <span class="org-string">"max_spread_direction"</span>: max_spread_direction,
            <span class="org-string">"effective_wind_speed"</span>: effective_wind_speed,
            <span class="org-string">"eccentricity"</span>        : 0.0,
        }


<span class="org-keyword">def</span> <span class="org-function-name">get_spread_info_max</span>(spread_drivers, spread_rate, phi_W, phi_S, midflame_wind_speed,
                        wind_to_direction, slope_direction, get_wind_speed):
    <span class="org-keyword">match</span> spread_drivers:
        <span class="org-keyword">case</span> <span class="org-string">"no_wind_no_slope"</span>:
            <span class="org-keyword">return</span> spread_info_max_no_wind_no_slope(spread_rate)
        <span class="org-keyword">case</span> <span class="org-string">"wind_only"</span>:
            <span class="org-keyword">return</span> spread_info_max_wind_only(spread_rate, phi_W, midflame_wind_speed, wind_to_direction)
        <span class="org-keyword">case</span> <span class="org-string">"slope_only"</span>:
            <span class="org-keyword">return</span> spread_info_max_slope_only(spread_rate, phi_S, slope_direction, get_wind_speed)
        <span class="org-keyword">case</span> <span class="org-string">"wind_blows_upslope"</span>:
            <span class="org-keyword">return</span> spread_info_max_wind_blows_upslope(spread_rate, (phi_W <span class="org-operator">+</span> phi_S), slope_direction, get_wind_speed)
        <span class="org-keyword">case</span> <span class="org-string">"wind_blows_across_slope"</span>:
            <span class="org-keyword">return</span> spread_info_max_wind_blows_across_slope(spread_rate, phi_W, phi_S, wind_to_direction,
                                                           slope_direction, get_wind_speed)


<span class="org-keyword">def</span> <span class="org-function-name">scale_spread_to_max_wind_speed</span>(spread_properties, spread_rate, max_wind_speed, phi_max):
    <span class="org-doc">"""</span>
<span class="org-doc">    Warning: Mutates spread_properties</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">effective_wind_speed</span> <span class="org-operator">=</span> spread_properties[<span class="org-string">"effective_wind_speed"</span>]
    <span class="org-keyword">if</span> (effective_wind_speed <span class="org-operator">&gt;</span> max_wind_speed):
        <span class="org-variable-name">spread_properties</span>[<span class="org-string">"max_spread_rate"</span>]      <span class="org-operator">=</span> spread_rate <span class="org-operator">*</span> (1.0 <span class="org-operator">+</span> phi_max)
        <span class="org-variable-name">spread_properties</span>[<span class="org-string">"effective_wind_speed"</span>] <span class="org-operator">=</span> max_wind_speed
        <span class="org-keyword">return</span> spread_properties
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> spread_properties


<span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Surface L/W uses 0.25 but Crown L/W uses 0.125. Check Rothermel 1991.</span>
<span class="org-keyword">def</span> <span class="org-function-name">surface_length_to_width_ratio</span>(effective_wind_speed):
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the length_to_width_ratio of the surface fire front using eq. 9 from</span>
<span class="org-doc">    Rothermel 1991 given:</span>
<span class="org-doc">    - effective_wind_speed (ft/min)</span>

<span class="org-doc">    L/W = 1 + 0.25 * Ueff_mph</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">effective_wind_speed_mph</span> <span class="org-operator">=</span> fpm_to_mph(effective_wind_speed)
    <span class="org-keyword">return</span> 1.0 <span class="org-operator">+</span> 0.25 <span class="org-operator">*</span> effective_wind_speed_mph


<span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: unused</span>
<span class="org-keyword">def</span> <span class="org-function-name">surface_length_to_width_ratio_elmfire</span>(effective_wind_speed):
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the length_to_width_ratio of the surface fire front given:</span>
<span class="org-doc">    - effective_wind_speed (ft/min)</span>

<span class="org-doc">    L/W = min(0.936 * e^(0.2566 * Ueff_mph) + 0.461 * e^(-0.1548 * Ueff_mph) - 0.397, 8.0)</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">effective_wind_speed_mph</span> <span class="org-operator">=</span> fpm_to_mph(effective_wind_speed)
    <span class="org-keyword">return</span> <span class="org-builtin">min</span>((0.936 <span class="org-operator">*</span> exp(0.2566 <span class="org-operator">*</span> effective_wind_speed_mph))
               <span class="org-operator">+</span>
               (0.461 <span class="org-operator">*</span> exp(<span class="org-operator">-</span>0.1548 <span class="org-operator">*</span> effective_wind_speed_mph))
               <span class="org-operator">-</span>
               0.397,
               8.0)


<span class="org-keyword">def</span> <span class="org-function-name">surface_fire_eccentricity</span>(effective_wind_speed):
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the eccentricity (E) of the surface fire front using eq. 9 from</span>
<span class="org-doc">    Rothermel 1991 and eq. 8 from Albini and Chase 1980 given:</span>
<span class="org-doc">    - effective_wind_speed (ft/min)</span>

<span class="org-doc">    L/W = 1 + 0.25 * Ueff_mph</span>
<span class="org-doc">    E = sqrt( L/W^2 - 1 ) / L/W</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">length_width_ratio</span> <span class="org-operator">=</span> surface_length_to_width_ratio(effective_wind_speed)
    <span class="org-keyword">return</span> sqrt(length_width_ratio <span class="org-operator">**</span> 2.0 <span class="org-operator">-</span> 1.0) <span class="org-operator">/</span> length_width_ratio


<span class="org-keyword">def</span> <span class="org-function-name">add_eccentricity</span>(spread_properties):
    <span class="org-doc">"""</span>
<span class="org-doc">    Warning: Mutates spread_properties</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">effective_wind_speed</span>              <span class="org-operator">=</span> spread_properties[<span class="org-string">"effective_wind_speed"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">ft/min</span>
    <span class="org-variable-name">spread_properties</span>[<span class="org-string">"eccentricity"</span>] <span class="org-operator">=</span> surface_fire_eccentricity(effective_wind_speed)
    <span class="org-keyword">return</span> spread_properties


<span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: No longer takes ellipse_adjustment_factor parameter</span>
<span class="org-keyword">def</span> <span class="org-function-name">rothermel_surface_fire_spread_max</span>(surface_fire_min, midflame_wind_speed, wind_from_direction,
                                      slope, aspect, spread_rate_adjustment<span class="org-operator">=</span>1.0):
    <span class="org-variable-name">spread_rate</span>        <span class="org-operator">=</span> surface_fire_min[<span class="org-string">"base_spread_rate"</span>] <span class="org-operator">*</span> spread_rate_adjustment
    <span class="org-variable-name">reaction_intensity</span> <span class="org-operator">=</span> surface_fire_min[<span class="org-string">"reaction_intensity"</span>]
    <span class="org-variable-name">get_phi_S</span>          <span class="org-operator">=</span> surface_fire_min[<span class="org-string">"get_phi_S"</span>]
    <span class="org-variable-name">get_phi_W</span>          <span class="org-operator">=</span> surface_fire_min[<span class="org-string">"get_phi_W"</span>]
    <span class="org-variable-name">get_wind_speed</span>     <span class="org-operator">=</span> surface_fire_min[<span class="org-string">"get_wind_speed"</span>]
    <span class="org-variable-name">slope_direction</span>    <span class="org-operator">=</span> (aspect <span class="org-operator">+</span> 180.0) <span class="org-operator">%</span> 360.0
    <span class="org-variable-name">wind_to_direction</span>  <span class="org-operator">=</span> (wind_from_direction <span class="org-operator">+</span> 180.0) <span class="org-operator">%</span> 360.0
    <span class="org-variable-name">max_wind_speed</span>     <span class="org-operator">=</span> 0.9 <span class="org-operator">*</span> reaction_intensity
    <span class="org-variable-name">phi_S</span>              <span class="org-operator">=</span> get_phi_S(slope)
    <span class="org-variable-name">phi_W</span>              <span class="org-operator">=</span> get_phi_W(midflame_wind_speed)
    <span class="org-variable-name">phi_max</span>            <span class="org-operator">=</span> get_phi_W(max_wind_speed)
    <span class="org-variable-name">spread_drivers</span>     <span class="org-operator">=</span> determine_spread_drivers(midflame_wind_speed, wind_to_direction, slope, slope_direction)
    <span class="org-variable-name">spread_info_max</span>    <span class="org-operator">=</span> get_spread_info_max(spread_drivers, spread_rate, phi_W, phi_S, midflame_wind_speed,
                                             wind_to_direction, slope_direction, get_wind_speed)
    <span class="org-keyword">return</span> add_eccentricity(scale_spread_to_max_wind_speed(spread_info_max, spread_rate, max_wind_speed, phi_max))


<span class="org-keyword">def</span> <span class="org-function-name">compute_spread_rate</span>(max_spread_rate, max_spread_direction, eccentricity, spread_direction):
    <span class="org-variable-name">theta</span> <span class="org-operator">=</span> smallest_angle_between(max_spread_direction, spread_direction)
    <span class="org-keyword">if</span> almost_zero(eccentricity) <span class="org-keyword">or</span> almost_zero(theta):
        <span class="org-keyword">return</span> max_spread_rate
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> max_spread_rate <span class="org-operator">*</span> (1.0 <span class="org-operator">-</span> eccentricity) <span class="org-operator">/</span> (1.0 <span class="org-operator">-</span> eccentricity <span class="org-operator">*</span> cos(radians(theta)))
</pre>
</div>

<p>
This concludes our coverage of the surface fire behavior equations
implemented in Pyretechnics. In Section <a href="#orgccc2eb4">9</a> these formulas will be translated
from one-dimension to two-dimensional spread on a raster grid. Before
we move on to that, however, the following section explains how crown
fire behavior metrics are incorporated into our model.
</p>
</div>
</div>
</div>
<div id="outline-container-org247ce45" class="outline-3">
<h3 id="org247ce45"><span class="section-number-3">6.2.</span> For Users</h3>
<div class="outline-text-3" id="text-6-2">
</div>
</div>
</div>
<div id="outline-container-org32229a3" class="outline-2">
<h2 id="org32229a3"><span class="section-number-2">7.</span> [WIP] Crown Fire Equations (pyretechnics.crown_fire)</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-org6c8ccc1" class="outline-3">
<h3 id="org6c8ccc1"><span class="section-number-3">7.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-7-1">
</div>
</div>
<div id="outline-container-org6ebdfb1" class="outline-3">
<h3 id="org6ebdfb1"><span class="section-number-3">7.2.</span> For Users</h3>
<div class="outline-text-3" id="text-7-2">
<p>
In order to incorporate the effects of crown fire behavior,
Pyretechnics includes the crown fire initiation routine from Van
Wagner 1977.<sup><a id="fnr.22" class="footref" href="#fn.22" role="doc-backlink">22</a></sup> According to this approach, there are
two threshold values (<i>critical intensity</i> and <i>critical spread rate</i>)
that must be calculated in order to determine whether a fire will
become an active or passive crown fire or simply remain a surface
fire. The formulas for these thresholds are as follows:
</p>

\begin{align}
  H &= 460 + 2600 M^f \\
  \nonumber \\
  I^* &= (0.01 \, Z_b \, H)^{1.5} \\
  \nonumber \\
  R^* &= \frac{3.0}{B_m}
\end{align}

<p>
where \(H\) is the heat of ignition for the herbaceous material in the
canopy in kJ/kg, \(M^{f}\) is the foliar moisture content in lb
moisture/lb ovendry weight, \(Z_{b}\) is the canopy base height in
meters, \(I^{*}\) is the critical intensity in kW/m, \(B_{m}\) is the
crown bulk density in kg/m<sup>3</sup>, and \(R^{*}\) is the critical spread
rate in m/min.
</p>

<p>
If the canopy cover is greater than 40% and the surface fire line
intensity is greater than the critical intensity (\(I > I^{*}\)), then
crown fire initiation occurs.
</p>

<div class="org-src-container">
<pre class="src src-python" id="org0dc61ab"><span class="org-keyword">def</span> <span class="org-function-name">van_wagner_critical_fire_line_intensity</span>(canopy_base_height, foliar_moisture):
    <span class="org-doc">"""</span>
<span class="org-doc">    Ouputs the critical fire line intensity (kW/m) using:</span>
<span class="org-doc">    - canopy_base_height (m)</span>
<span class="org-doc">    - foliar_moisture (0-1)</span>

<span class="org-doc">    Constants used:</span>
<span class="org-doc">    460.0 = heat-of-ignition (kJ/kg)</span>
<span class="org-doc">    0.01 = empirical estimate for C in eq. 4</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> ((foliar_moisture <span class="org-operator">*</span> 2600.0 <span class="org-operator">+</span> 460.0) <span class="org-operator">*</span> 0.01 <span class="org-operator">*</span> canopy_base_height) <span class="org-operator">**</span> 1.5


<span class="org-keyword">def</span> <span class="org-function-name">van_wagner_crown_fire_initiation</span>(canopy_cover, canopy_base_height, foliar_moisture, fire_line_intensity):
    <span class="org-doc">"""</span>
<span class="org-doc">    - canopy_cover (0-1)</span>
<span class="org-doc">    - canopy_base_height (m)</span>
<span class="org-doc">    - foliar_moisture (0-1)</span>
<span class="org-doc">    - fire_line_intensity (kW/m)</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> ((canopy_cover <span class="org-operator">&gt;</span> 0.4)
            <span class="org-keyword">and</span>
            (fire_line_intensity <span class="org-operator">&gt;</span> 0.0)
            <span class="org-keyword">and</span>
            (canopy_base_height <span class="org-operator">&gt;</span> 0.0)
            <span class="org-keyword">and</span>
            (fire_line_intensity <span class="org-operator">&gt;=</span> van_wagner_critical_fire_line_intensity(canopy_base_height, foliar_moisture)))
</pre>
</div>

<p>
If crowning occurs, then the active and passive crown fire spread
rates are calculated from the formulas given in Cruz
2005.<sup><a id="fnr.23" class="footref" href="#fn.23" role="doc-backlink">23</a></sup>
</p>

\begin{align}
  \text{CROS}_A &= 11.02 \> U_{10m}^{0.90} \> B_m^{0.19} \> e^{-17 \, \text{EFFM}} \\
  \nonumber \\
  \text{CROS}_P &= \text{CROS}_A \> e^{\frac{-\text{CROS}_A}{R^*}}
\end{align}

<p>
where \(\text{CROS}_{A}\) is the active crown fire spread rate in
m/min, \(U_{10m}\) is the 10 meter windspeed in km/hr, \(B_{m}\) is the
crown bulk density in kg/m<sup>3</sup>, EFFM is the estimated fine fuel
moisture as a percent (0-1), and \(\text{CROS}_{P}\) is the passive
crown fire spread rate in m/min.
</p>

<p>
If the active crown fire spread rate is greater than the critical
spread rate (\(\text{CROS}_{A} > R^{*}\)), then the crown fire will be
active, otherwise passive.
</p>

<div class="org-src-container">
<pre class="src src-python" id="org08b1082"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> exp

<span class="org-keyword">def</span> <span class="org-function-name">cruz_active_crown_fire_spread</span>(wind_speed_10m, canopy_bulk_density, estimated_fine_fuel_moisture):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns active spread-rate in m/min given:</span>
<span class="org-doc">    - wind_speed_10m (km/hr)</span>
<span class="org-doc">    - canopy_bulk_density (kg/m^3)</span>
<span class="org-doc">    - estimated_fine_fuel_moisture (M_f[0] "dead-1hr") (0-1)</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> (11.02
            <span class="org-operator">*</span> wind_speed_10m <span class="org-operator">**</span> 0.90
            <span class="org-operator">*</span> canopy_bulk_density <span class="org-operator">**</span> 0.19
            <span class="org-operator">*</span> exp(<span class="org-operator">-</span>17.0 <span class="org-operator">*</span> estimated_fine_fuel_moisture))


<span class="org-keyword">def</span> <span class="org-function-name">cruz_passive_crown_fire_spread</span>(active_spread_rate, critical_spread_rate):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns passive spread-rate in m/min given:</span>
<span class="org-doc">    - active_spread_rate (m/min)</span>
<span class="org-doc">    - critical_spread_rate (m/min)</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> active_spread_rate <span class="org-operator">*</span> exp(<span class="org-operator">-</span>1.0 <span class="org-operator">*</span> active_spread_rate <span class="org-operator">/</span> critical_spread_rate)


<span class="org-keyword">def</span> <span class="org-function-name">cruz_crown_fire_spread</span>(wind_speed_10m, canopy_bulk_density, estimated_fine_fuel_moisture):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns spread-rate in m/min given:</span>
<span class="org-doc">    - wind_speed_10m (km/hr)</span>
<span class="org-doc">    - canopy_bulk_density (kg/m^3)</span>
<span class="org-doc">    - estimated_fine_fuel_moisture (M_f[0] "dead-1hr") (0-1)</span>
<span class="org-doc">    NOTE: A positive spread-rate indicates active crowning.</span>
<span class="org-doc">          A negative spread-rate indicates passive crowning.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">active_spread_rate</span>   <span class="org-operator">=</span> cruz_active_crown_fire_spread(wind_speed_10m,
                                                         canopy_bulk_density,
                                                         estimated_fine_fuel_moisture)
    <span class="org-variable-name">critical_spread_rate</span> <span class="org-operator">=</span> 3.0 <span class="org-operator">/</span> canopy_bulk_density <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
    <span class="org-keyword">if</span> (active_spread_rate <span class="org-operator">&gt;</span> critical_spread_rate):
        <span class="org-keyword">return</span> active_spread_rate
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: Use minus as passive flag</span>
        <span class="org-keyword">return</span> <span class="org-operator">-</span>1.0 <span class="org-operator">*</span> cruz_passive_crown_fire_spread(active_spread_rate, critical_spread_rate)
</pre>
</div>

<p>
Once the crown fire spread rate is determined, the crown fire line
intensity and flame lengths may be derived using the following
formulas:
</p>

\begin{align}
  I_c &= \frac{R_c B (Z - Z_b) h}{60} \\
  \nonumber \\
  L_c &= 0.45(I + I_c)^{0.46}
\end{align}

<p>
where \(I_{c}\) is the crown fire line intensity in Btu/ft/s, \(R_{c}\) is
the crown fire spread rate (either \(\text{CROS}_{A}\) or
\(\text{CROS}_{P}\)) in ft/min, \(B\) is the crown bulk density in
lb/ft<sup>3</sup>, \(Z\) is the canopy height in ft, \(Z_{b}\) is the canopy base
height in ft, \(h\) is the fuel model heat of combustion (generally 8000
Btu/lb), \(L_{c}\) is the crown flame length in ft, and \(I\) is the
surface fire line intensity in Btu/ft/s.
</p>

<div class="org-src-container">
<pre class="src src-python" id="org2d18d3e"><span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: heat_of_combustion is h from the fuel models (generally 8000 Btu/lb)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: ELMFIRE hard-codes heat_of_combustion to 18000 kJ/kg = 7738.6 Btu/lb</span>
<span class="org-keyword">def</span> <span class="org-function-name">crown_fire_line_intensity</span>(crown_spread_rate, canopy_bulk_density, canopy_height_difference, heat_of_combustion):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the crown_fire_line_intensity in Btu/ft/s OR kW/m, given:</span>
<span class="org-doc">    - crown_spread_rate (ft/min OR m/min)</span>
<span class="org-doc">    - canopy_bulk_density (lb/ft^3 OR kg/m^3)</span>
<span class="org-doc">    - canopy_height_difference (canopy_height - canopy_base_height) (ft OR m)</span>
<span class="org-doc">    - heat_of_combustion (Btu/lb OR kJ/kg)</span>

<span class="org-doc">    (ft/min * lb/ft^3 * ft * Btu/lb)/60 = (Btu/ft/min)/60 = Btu/ft/s</span>
<span class="org-doc">    OR</span>
<span class="org-doc">    (m/min * kg/m^3 * m * kJ/kg)/60 = (kJ/m*min)/60 = kJ/m*s = kW/m</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> (crown_spread_rate <span class="org-operator">*</span> canopy_bulk_density <span class="org-operator">*</span> canopy_height_difference <span class="org-operator">*</span> heat_of_combustion) <span class="org-operator">/</span> 60.0
</pre>
</div>

<p>
As with surface fire spread, the wind speed (this time the 20-ft wind
speed in mph \(U_{20}\)) is used to compute the length to width ratio
\(\frac{L}{W}\) of an ellipse that approximates the crown fire front
using equation 9 from Rothermel 1991.<sup><a id="fnr.24" class="footref" href="#fn.24" role="doc-backlink">24</a></sup> This length
to width ratio is then converted into an eccentricity measure of the
ellipse using equation 8 from Albini and Chase 1980.<sup><a id="fnr.25" class="footref" href="#fn.25" role="doc-backlink">25</a></sup>
Finally, this eccentricity \(E\) is used to project the maximum spread
rate to any point along the fire front. Here are the formulas used:
</p>

\begin{align}
  \frac{L}{W} &= 1 + 0.125 \, U_{20} \\
  \nonumber \\
  E &= \frac{\sqrt{(\frac{L}{W})^2 - 1}}{\frac{L}{W}} \\
  \nonumber \\
  R_{\theta} &= R_{\max}\left(\frac{1-E}{1-E\cos\theta}\right)
\end{align}

<p>
where \(\theta\) is the angular offset from the direction of maximum fire
spread, \(R_{max}\) is the maximum spread rate, and \(R_{\theta}\) is the
spread rate in direction \(\theta\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="org317277c"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> sqrt

<span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: No longer takes ellipse_adjustment_factor argument</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: Surface L/W uses 0.25 but Crown L/W uses 0.125. Check Rothermel 1991.</span>
<span class="org-keyword">def</span> <span class="org-function-name">crown_length_to_width_ratio</span>(wind_speed_20ft):
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the length_to_width_ratio of the crown fire front using eq. 9 from</span>
<span class="org-doc">    Rothermel 1991 given:</span>
<span class="org-doc">    - wind_speed_20ft (mph)</span>

<span class="org-doc">    L/W = 1 + 0.125 * U20_mph</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> 1.0 <span class="org-operator">+</span> 0.125 <span class="org-operator">*</span> wind_speed_20ft


<span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: unused</span>
<span class="org-keyword">def</span> <span class="org-function-name">crown_length_to_width_ratio_elmfire</span>(wind_speed_20ft, max_length_to_width_ratio):
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the length_to_width_ratio of the crown fire front using eq. 9 from</span>
<span class="org-doc">    Rothermel 1991 given:</span>
<span class="org-doc">    - wind_speed_20ft (mph)</span>
<span class="org-doc">    - max_length_to_width_ratio (int &gt; 0)</span>

<span class="org-doc">    L/W = min(1.0 + 0.125 * U20_mph, L/W_max)</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> <span class="org-builtin">min</span>((1.0 <span class="org-operator">+</span> 0.125 <span class="org-operator">*</span> wind_speed_20ft), max_length_to_width_ratio)


<span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: No longer takes ellipse_adjustment_factor argument</span>
<span class="org-keyword">def</span> <span class="org-function-name">crown_fire_eccentricity</span>(wind_speed_20ft):
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the eccentricity (E) of the crown fire front using eq. 9 from</span>
<span class="org-doc">    Rothermel 1991 and eq. 8 from Albini and Chase 1980 given:</span>
<span class="org-doc">    - wind_speed_20ft (mph)</span>

<span class="org-doc">    L/W = 1 + 0.125 * U20_mph</span>
<span class="org-doc">    E = sqrt( L/W^2 - 1 ) / L/W</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">length_width_ratio</span> <span class="org-operator">=</span> crown_length_to_width_ratio(wind_speed_20ft)
    <span class="org-keyword">return</span> sqrt(length_width_ratio <span class="org-operator">**</span> 2.0 <span class="org-operator">-</span> 1.0) <span class="org-operator">/</span> length_width_ratio
</pre>
</div>

<p>
This concludes our discussion of the crown fire behavior formulas used
in Pyretechnics.
</p>
</div>
</div>
</div>
<div id="outline-container-org0376fa1" class="outline-2">
<h2 id="org0376fa1"><span class="section-number-2">8.</span> [WIP] Spot Fire Equations (pyretechnics.spot_fire)</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-org1c45bdc" class="outline-3">
<h3 id="org1c45bdc"><span class="section-number-3">8.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-8-1">
</div>
</div>
<div id="outline-container-org9b5d0f2" class="outline-3">
<h3 id="org9b5d0f2"><span class="section-number-3">8.2.</span> For Users</h3>
<div class="outline-text-3" id="text-8-2">
</div>
</div>
</div>
<div id="outline-container-orgccc2eb4" class="outline-2">
<h2 id="orgccc2eb4"><span class="section-number-2">9.</span> [WIP] Fire Spread Algorithms (pyretechnics.eulerian_level_set)</h2>
<div class="outline-text-2" id="text-9">
</div>
<div id="outline-container-org46182d0" class="outline-3">
<h3 id="org46182d0"><span class="section-number-3">9.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-9-1">
</div>
</div>
<div id="outline-container-org43d1da5" class="outline-3">
<h3 id="org43d1da5"><span class="section-number-3">9.2.</span> For Users</h3>
<div class="outline-text-3" id="text-9-2">
<p>
In order to simulate the spread of a fire from a starting point or
perimeter, we will need to implement a model that projects the
one-dimensional spread and intensity equations presented above into
the three-dimensional space-time cube introduced in section <a href="#orgc5b0696">2</a>.
</p>

<p>
As a library, Pyretechnics has the flexibility to implement more than
one such algorithm for the purposes of comparison in both performance
and accuracy. The following sections will introduce the spread
algorithms implemented thus far.
</p>
</div>
<div id="outline-container-orge25c25f" class="outline-4">
<h4 id="orge25c25f"><span class="section-number-4">9.2.1.</span> Eulerian Level Set Method</h4>
<div class="outline-text-4" id="text-9-2-1">
</div>
<ol class="org-ol">
<li><a id="org2ed1c43"></a>The \(\phi\) Field<br>
<div class="outline-text-5" id="text-9-2-1-1">
<p>
In the Eulerian level set method of fire spread, operationalized in
Chris Lautenberger's ELMFire model<sup><a id="fnr.26" class="footref" href="#fn.26" role="doc-backlink">26</a></sup>, a
continuous field called \(\phi\) fills the simulation space and is used
to track the progression of the fire front through space and time.
Within Pyretechnics, the \(\phi\) field is discretized into grid cells
and initialized with the following values:
</p>

<ul class="org-ul">
<li>-1 for cells that have already been burned and are inside the fire perimeter</li>
<li>1 for cells that have not been burned and are outside the fire perimeter</li>
</ul>

<p>
If a fire is being simulated starting from an actively burning
perimeter, the \(\phi\) grid cells indicate the initially burning region.
If a point fire is being simulated, then a single \(\phi\) cell will be
set to -1 and the remaining cells will have the value 1.
</p>
</div>
</li>
<li><a id="org7bcb054"></a>Fire Front Normal Vector<br>
<div class="outline-text-5" id="text-9-2-1-2">
<p>
In this fire spread algorithm, the fire front only propagates normal
to itself. Given a \(\phi\) raster, we can calculate the normal vector to
the \(\phi\) field by using the following formula:
</p>

\begin{align}
  \hat{n} &= n_x\hat{i} + n_y\hat{j} = \frac{1}{|\nabla\phi|}\left(\frac{\partial \phi}{\partial x}\hat{i} + \frac{\partial \phi}{\partial y}\hat{j}\right) \\
  \nonumber \\
  |\nabla\phi| &= \sqrt{\left(\frac{\partial \phi}{\partial x}\right)^2 + \left(\frac{\partial \phi}{\partial y}\right)^2}
\end{align}

<p>
We begin by approximating the spatial gradients of the \(\phi\) field with
node-centered central differences, represented by the values in the
\(\phi\) raster's grid cells.
</p>

\begin{align}
  \left(\frac{\partial \phi}{\partial x}\right)_{i,j} &\approx \frac{\phi_{i+1,j} - \phi_{i-1,j}}{2 \Delta x} \\
  \nonumber \\
  \left(\frac{\partial \phi}{\partial y}\right)_{i,j} &\approx \frac{\phi_{i,j+1} - \phi_{i,j-1}}{2 \Delta y}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="org8846920"><span class="org-keyword">def</span> <span class="org-function-name">calc_dphi_dx_approx</span>(phi, x, y, dx):
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the spatial gradient of the phi raster in the x (west-&gt;east)</span>
<span class="org-doc">    direction at grid cell (x,y) given the cell width dx.</span>

<span class="org-doc">    NOTE: The origin cell (x=0,y=0) is located in the upper left corner</span>
<span class="org-doc">          of the grid in Python arrays. Thus, as x increases, we move</span>
<span class="org-doc">          to the east, and as y increases, we move to the south.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> (phi[y][x<span class="org-operator">+</span>1] <span class="org-operator">-</span> phi[y][x<span class="org-operator">-</span>1]) <span class="org-operator">/</span> (2.0 <span class="org-operator">*</span> dx)


<span class="org-keyword">def</span> <span class="org-function-name">calc_dphi_dy_approx</span>(phi, x, y, dy):
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the spatial gradient of the phi raster in the y (south-&gt;north)</span>
<span class="org-doc">    direction at grid cell (x,y) given the cell height dy.</span>

<span class="org-doc">    NOTE: The origin cell (x=0,y=0) is located in the upper left corner</span>
<span class="org-doc">          of the grid in Python arrays. Thus, as x increases, we move</span>
<span class="org-doc">          to the east, and as y increases, we move to the south.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> (phi[y<span class="org-operator">-</span>1][x] <span class="org-operator">-</span> phi[y<span class="org-operator">+</span>1][x]) <span class="org-operator">/</span> (2.0 <span class="org-operator">*</span> dy)
</pre>
</div>

<p>
We can now combine these spatial gradients with the magnitude of the
gradient of the \(\phi\) field at any location on the grid to compute
the fire front normal vector as follows:
</p>

<div class="org-src-container">
<pre class="src src-python" id="orgcf1c9e6"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> sqrt

<span class="org-keyword">def</span> <span class="org-function-name">calc_phi_gradient_magnitude</span>(dphi_dx, dphi_dy):
    <span class="org-doc">"""Calculate the magnitude of the gradient of the phi field."""</span>
    <span class="org-keyword">return</span> sqrt(dphi_dx <span class="org-operator">**</span> 2 <span class="org-operator">+</span> dphi_dy <span class="org-operator">**</span> 2)


<span class="org-keyword">def</span> <span class="org-function-name">calc_phi_normal_vector</span>(phi, dx, dy, x, y):
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the phi field normal vector in the x and y dimensions.</span>

<span class="org-doc">    n_x: eastward component of the unit normal vector</span>
<span class="org-doc">    n_y: northward component of the unit normal vector</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">dphi_dx</span> <span class="org-operator">=</span> calc_dphi_dx_approx(phi, x, y, dx)
    <span class="org-variable-name">dphi_dy</span> <span class="org-operator">=</span> calc_dphi_dy_approx(phi, x, y, dy)
    <span class="org-keyword">if</span> dphi_dx <span class="org-operator">==</span> 0.0 <span class="org-keyword">and</span> dphi_dy <span class="org-operator">==</span> 0.0:
        <span class="org-keyword">return</span> {
            <span class="org-string">"n_x"</span>: 0.0,
            <span class="org-string">"n_y"</span>: 0.0,
        }
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">phi_gradient_magnitude</span> <span class="org-operator">=</span> calc_phi_gradient_magnitude(dphi_dx, dphi_dy)
        <span class="org-keyword">return</span> {
            <span class="org-string">"n_x"</span>: dphi_dx <span class="org-operator">/</span> phi_gradient_magnitude,
            <span class="org-string">"n_y"</span>: dphi_dy <span class="org-operator">/</span> phi_gradient_magnitude,
        }
</pre>
</div>

<p>
Next, we can use the following geometrical relations to calculate the
angle \(\theta_n\) (measured clockwise from North) to which the normal
vector points:
</p>

\begin{equation}
  \theta_n =
  \begin{cases}
    \frac{1}{2}\pi - \tan^{-1}(\frac{n_y}{n_x}) & \text{for}\ n_x > 0 & \text{and}\ n_y \geq 0 \\
    \frac{1}{2}\pi + \tan^{-1}(\frac{|n_y|}{n_x}) & \text{for}\ n_x > 0 & \text{and}\ n_y < 0 \\
    \frac{3}{2}\pi + \tan^{-1}(\frac{n_y}{|n_x|}) & \text{for}\ n_x < 0 & \text{and}\ n_y \geq 0 \\
    \frac{3}{2}\pi - \tan^{-1}(\frac{n_y}{n_x}) & \text{for}\ n_x < 0 & \text{and}\ n_y < 0 \\
    0 & \text{for}\ n_x = 0 & \text{and}\ n_y \geq 0 \\
    \pi & \text{for}\ n_x = 0 & \text{and}\ n_y < 0
  \end{cases}
\end{equation}

<div class="org-src-container">
<pre class="src src-python" id="org502d92a"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> atan, pi

<span class="org-keyword">def</span> <span class="org-function-name">calc_phi_normal_vector_angle</span>(phi_normal_vector):
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the angle (measured in radians clockwise from North)</span>
<span class="org-doc">    to which the phi field's normal vector points.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">n_x</span> <span class="org-operator">=</span> phi_normal_vector[<span class="org-string">"n_x"</span>]
    <span class="org-variable-name">n_y</span> <span class="org-operator">=</span> phi_normal_vector[<span class="org-string">"n_y"</span>]
    <span class="org-keyword">if</span> n_x <span class="org-operator">&gt;</span> 0:
        <span class="org-keyword">if</span> n_y <span class="org-operator">&gt;=</span> 0:
            <span class="org-keyword">return</span> 1<span class="org-operator">/</span>2 <span class="org-operator">*</span> pi <span class="org-operator">-</span> atan(n_y <span class="org-operator">/</span> n_x)
        <span class="org-keyword">elif</span> n_y <span class="org-operator">&lt;</span> 0:
            <span class="org-keyword">return</span> 1<span class="org-operator">/</span>2 <span class="org-operator">*</span> pi <span class="org-operator">+</span> atan(<span class="org-builtin">abs</span>(n_y) <span class="org-operator">/</span> n_x)
    <span class="org-keyword">elif</span> n_x <span class="org-operator">&lt;</span> 0:
        <span class="org-keyword">if</span> n_y <span class="org-operator">&gt;=</span> 0:
            <span class="org-keyword">return</span> 3<span class="org-operator">/</span>2 <span class="org-operator">*</span> pi <span class="org-operator">+</span> atan(n_y <span class="org-operator">/</span> <span class="org-builtin">abs</span>(n_x))
        <span class="org-keyword">elif</span> n_y <span class="org-operator">&lt;</span> 0:
            <span class="org-keyword">return</span> 3<span class="org-operator">/</span>2 <span class="org-operator">*</span> pi <span class="org-operator">-</span> atan(n_y <span class="org-operator">/</span> n_x)
    <span class="org-keyword">else</span>:
        <span class="org-keyword">if</span> n_y <span class="org-operator">&gt;=</span> 0:
            <span class="org-keyword">return</span> 0.0
        <span class="org-keyword">elif</span> n_y <span class="org-operator">&lt;</span> 0:
            <span class="org-keyword">return</span> pi
</pre>
</div>

<p>
Now that we can compute the fire front normal vector, we can find the
spread rate in this direction by combining this vector with the
maximum spread rate vector and elliptical eccentricity values
calculated for each grid cell, using the approaches described in
sections <a href="#orge582768">6</a>
and <a href="#org32229a3">7</a>.
</p>

<p>
We will refer to the spread rate vector normal to the fire front in
the following sections as \(U\) with spatial components \(U_x\) and \(U_y\).
</p>
</div>
</li>
<li><a id="org3de9a09"></a>Numerical Solution of the \(\phi\) Field Equation<br>
<div class="outline-text-5" id="text-9-2-1-3">
<p>
In order to evolve the \(\phi\) field through time and space, we must
solve the following hyperbolic differential equation for the scalar
variable \(\phi\).
</p>

\begin{align}
  \frac{\partial \phi}{\partial t} + U_x \frac{\partial \phi}{\partial x} + U_y \frac{\partial \phi}{\partial y} = 0
\end{align}

<p>
This is accomplished after applying a flux limiter to the convective
terms, in order to ensure solution monotonicity and prevent spurious
oscillations that can be induced in its absence.
</p>

<p>
First, we define the parameter \(r\) and the Superbee flux limiter
\(B(r)\) as follows:
</p>

\begin{align}
  r &= \frac{\delta\phi_{\text{up}}}{\delta\phi_{\text{loc}}} \\
  \nonumber \\
  B(r) &= \text{max}(0, \text{min}(2r, 1), \text{min}(r, 2))
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="org8244256"><span class="org-keyword">def</span> <span class="org-function-name">calc_superbee_flux_limiter</span>(dphi_up, dphi_loc):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">r</span> <span class="org-operator">=</span> dphi_up <span class="org-operator">/</span> dphi_loc
    <span class="org-keyword">return</span> <span class="org-builtin">max</span>(0,
               <span class="org-builtin">min</span>(2 <span class="org-operator">*</span> r, 1),
               <span class="org-builtin">min</span>(r, 2))
</pre>
</div>

<p>
To compute the inputs to this function, we build up the partial
derivatives of the \(\phi\) field in terms of "east", "west", "north",
and "south" values as follows:
</p>

\begin{align}
  \frac{\partial \phi}{\partial x} &\approx \frac{\phi_{\text{east}} - \phi_{\text{west}}}{\Delta x} \\
  \nonumber \\
  \frac{\partial \phi}{\partial y} &\approx \frac{\phi_{\text{north}} - \phi_{\text{south}}}{\Delta y}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="org2eac052"><span class="org-keyword">def</span> <span class="org-function-name">calc_dphi_dx</span>(phi_east, phi_west, dx):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> (phi_east <span class="org-operator">-</span> phi_west) <span class="org-operator">/</span> dx

<span class="org-keyword">def</span> <span class="org-function-name">calc_dphi_dy</span>(phi_north, phi_south, dy):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> (phi_north <span class="org-operator">-</span> phi_south) <span class="org-operator">/</span> dy
</pre>
</div>

<p>
For the east face:
</p>

\begin{align}
  \delta\phi_{\text{loc}} &= \phi_{i+1,j} - \phi{i,j} \\
  \nonumber \\
  \delta\phi_{\text{up}} &= \begin{cases}
                              \phi_{i,j} - \phi_{i-1,j} & \text{for}\ u_{x,i,j} > 0 \\
                              \phi_{i+2,j} - \phi_{i+1,j} & \text{for}\ u_{x,i,j} < 0
                            \end{cases} \\
  \nonumber \\
  \phi_{\text{east}} &= \begin{cases}
                          \phi_{i,j} + \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{x,i,j} > 0 \\
                          \phi_{i+1,j} - \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{x,i,j} < 0
                        \end{cases}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="orgd6069d1"><span class="org-keyword">def</span> <span class="org-function-name">calc_phi_east</span>(phi, u_x, x, y):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">dphi_loc</span> <span class="org-operator">=</span> phi[y][x<span class="org-operator">+</span>1] <span class="org-operator">-</span> phi[y][x]
    <span class="org-variable-name">u_xij</span> <span class="org-operator">=</span> u_x[y][x]
    <span class="org-keyword">if</span> u_xij <span class="org-operator">&gt;</span> 0:
        <span class="org-variable-name">dphi_up</span> <span class="org-operator">=</span> phi[y][x] <span class="org-operator">-</span> phi[y][x<span class="org-operator">-</span>1]
        <span class="org-variable-name">B</span> <span class="org-operator">=</span> calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span class="org-keyword">return</span> phi[y][x] <span class="org-operator">+</span> 0.5 <span class="org-operator">*</span> B <span class="org-operator">*</span> dphi_loc
    <span class="org-keyword">elif</span> u_xij <span class="org-operator">&lt;</span> 0:
        <span class="org-variable-name">dphi_up</span> <span class="org-operator">=</span> phi[y][x<span class="org-operator">+</span>2] <span class="org-operator">-</span> phi[y][x<span class="org-operator">+</span>1]
        <span class="org-variable-name">B</span> <span class="org-operator">=</span> calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span class="org-keyword">return</span> phi[y][x<span class="org-operator">+</span>1] <span class="org-operator">-</span> 0.5 <span class="org-operator">*</span> B <span class="org-operator">*</span> dphi_loc
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: What is the correct value for this case? Update the equation above accordingly.</span>
        <span class="org-keyword">return</span> 0.0
</pre>
</div>

<p>
For the west face:
</p>

\begin{align}
  \delta\phi_{\text{loc}} &= \phi_{i-1,j} - \phi{i,j} \\
  \nonumber \\
  \delta\phi_{\text{up}} &= \begin{cases}
                              \phi_{i-2,j} - \phi_{i-1,j} & \text{for}\ u_{x,i,j} > 0 \\
                              \phi_{i,j} - \phi_{i+1,j} & \text{for}\ u_{x,i,j} < 0
                            \end{cases} \\
  \nonumber \\
  \phi_{\text{west}} &= \begin{cases}
                          \phi_{i-1,j} - \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{x,i,j} > 0 \\
                          \phi_{i,j} + \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{x,i,j} < 0
                        \end{cases}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="orgfd45e31"><span class="org-keyword">def</span> <span class="org-function-name">calc_phi_west</span>(phi, u_x, x, y):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">dphi_loc</span> <span class="org-operator">=</span> phi[y][x<span class="org-operator">-</span>1] <span class="org-operator">-</span> phi[y][x]
    <span class="org-variable-name">u_xij</span> <span class="org-operator">=</span> u_x[y][x]
    <span class="org-keyword">if</span> u_xij <span class="org-operator">&gt;</span> 0:
        <span class="org-variable-name">dphi_up</span> <span class="org-operator">=</span> phi[y][x<span class="org-operator">-</span>2] <span class="org-operator">-</span> phi[y][x<span class="org-operator">-</span>1]
        <span class="org-variable-name">B</span> <span class="org-operator">=</span> calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span class="org-keyword">return</span> phi[y][x<span class="org-operator">-</span>1] <span class="org-operator">-</span> 0.5 <span class="org-operator">*</span> B <span class="org-operator">*</span> dphi_loc
    <span class="org-keyword">elif</span> u_xij <span class="org-operator">&lt;</span> 0:
        <span class="org-variable-name">dphi_up</span> <span class="org-operator">=</span> phi[y][x] <span class="org-operator">-</span> phi[y][x<span class="org-operator">+</span>1]
        <span class="org-variable-name">B</span> <span class="org-operator">=</span> calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span class="org-keyword">return</span> phi[y][x] <span class="org-operator">+</span> 0.5 <span class="org-operator">*</span> B <span class="org-operator">*</span> dphi_loc
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: What is the correct value for this case? Update the equation above accordingly.</span>
        <span class="org-keyword">return</span> 0.0
</pre>
</div>

<p>
For the north face:
</p>

\begin{align}
  \delta\phi_{\text{loc}} &= \phi_{i,j+1} - \phi{i,j} \\
  \nonumber \\
  \delta\phi_{\text{up}} &= \begin{cases}
                              \phi_{i,j} - \phi_{i,j-1} & \text{for}\ u_{y,i,j} > 0 \\
                              \phi_{i,j+2} - \phi_{i,j+1} & \text{for}\ u_{y,i,j} < 0
                            \end{cases} \\
  \nonumber \\
  \phi_{\text{north}} &= \begin{cases}
                           \phi_{i,j} + \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{y,i,j} > 0 \\
                           \phi_{i,j+1} - \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{y,i,j} < 0
                         \end{cases}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="orgd70830e"><span class="org-keyword">def</span> <span class="org-function-name">calc_phi_north</span>(phi, u_y, x, y):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">dphi_loc</span> <span class="org-operator">=</span> phi[y<span class="org-operator">-</span>1][x] <span class="org-operator">-</span> phi[y][x]
    <span class="org-variable-name">u_yij</span> <span class="org-operator">=</span> u_y[y][x]
    <span class="org-keyword">if</span> u_yij <span class="org-operator">&gt;</span> 0:
        <span class="org-variable-name">dphi_up</span> <span class="org-operator">=</span> phi[y][x] <span class="org-operator">-</span> phi[y<span class="org-operator">+</span>1][x]
        <span class="org-variable-name">B</span> <span class="org-operator">=</span> calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span class="org-keyword">return</span> phi[y][x] <span class="org-operator">+</span> 0.5 <span class="org-operator">*</span> B <span class="org-operator">*</span> dphi_loc
    <span class="org-keyword">elif</span> u_yij <span class="org-operator">&lt;</span> 0:
        <span class="org-variable-name">dphi_up</span> <span class="org-operator">=</span> phi[y<span class="org-operator">-</span>2][x] <span class="org-operator">-</span> phi[y<span class="org-operator">-</span>1][x]
        <span class="org-variable-name">B</span> <span class="org-operator">=</span> calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span class="org-keyword">return</span> phi[y<span class="org-operator">-</span>1][x] <span class="org-operator">-</span> 0.5 <span class="org-operator">*</span> B <span class="org-operator">*</span> dphi_loc
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: What is the correct value for this case? Update the equation above accordingly.</span>
        <span class="org-keyword">return</span> 0.0
</pre>
</div>

<p>
For the south face:
</p>

\begin{align}
  \delta\phi_{\text{loc}} &= \phi_{i,j-1} - \phi{i,j} \\
  \nonumber \\
  \delta\phi_{\text{up}} &= \begin{cases}
                              \phi_{i,j-2} - \phi_{i,j-1} & \text{for}\ u_{y,i,j} > 0 \\
                              \phi_{i,j} - \phi_{i,j+1} & \text{for}\ u_{y,i,j} < 0
                            \end{cases} \\
  \nonumber \\
  \phi_{\text{south}} &= \begin{cases}
                           \phi_{i,j-1} - \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{y,i,j} > 0 \\
                           \phi_{i,j} + \frac{1}{2}B(r)\delta\phi_{loc} & \text{for}\ u_{y,i,j} < 0
                         \end{cases}
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="orge1ed9d1"><span class="org-keyword">def</span> <span class="org-function-name">calc_phi_south</span>(phi, u_y, x, y):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">dphi_loc</span> <span class="org-operator">=</span> phi[y<span class="org-operator">+</span>1][x] <span class="org-operator">-</span> phi[y][x]
    <span class="org-variable-name">u_yij</span> <span class="org-operator">=</span> u_y[y][x]
    <span class="org-keyword">if</span> u_yij <span class="org-operator">&gt;</span> 0:
        <span class="org-variable-name">dphi_up</span> <span class="org-operator">=</span> phi[y<span class="org-operator">+</span>2][x] <span class="org-operator">-</span> phi[y<span class="org-operator">+</span>1][x]
        <span class="org-variable-name">B</span> <span class="org-operator">=</span> calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span class="org-keyword">return</span> phi[y<span class="org-operator">+</span>1][x] <span class="org-operator">-</span> 0.5 <span class="org-operator">*</span> B <span class="org-operator">*</span> dphi_loc
    <span class="org-keyword">elif</span> u_yij <span class="org-operator">&lt;</span> 0:
        <span class="org-variable-name">dphi_up</span> <span class="org-operator">=</span> phi[y][x] <span class="org-operator">-</span> phi[y<span class="org-operator">-</span>1][x]
        <span class="org-variable-name">B</span> <span class="org-operator">=</span> calc_superbee_flux_limiter(dphi_up, dphi_loc)
        <span class="org-keyword">return</span> phi[y][x] <span class="org-operator">+</span> 0.5 <span class="org-operator">*</span> B <span class="org-operator">*</span> dphi_loc
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: What is the correct value for this case? Update the equation above accordingly.</span>
        <span class="org-keyword">return</span> 0.0
</pre>
</div>

<p>
Once the various spatial partial derivatives have been calculated, we
can march the \(\phi\) field solution forward in time using a second
order Runge Kutta method as follows:
</p>

\begin{align}
  \phi^* &= \phi^t - \Delta t \left(U_x \frac{\phi^t_{\text{east}} - \phi^t_{\text{west}}}{\Delta x} + U_y \frac{\phi^t_{\text{north}} - \phi^t_{\text{south}}}{\Delta y} \right) \\
  \nonumber \\
  \phi^{t + \Delta t} &= \frac{1}{2}\phi^t + \frac{1}{2} \left( \phi^* - \Delta t \left(U_x \frac{\phi^*_{\text{east}} - \phi^*_{\text{west}}}{\Delta x} + U_y \frac{\phi^*_{\text{north}} - \phi^*_{\text{south}}}{\Delta y} \right) \right)
\end{align}

<div class="org-src-container">
<pre class="src src-python" id="org774cf15"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np

<span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: stub</span>
<span class="org-keyword">def</span> <span class="org-function-name">identify_perimeter_cells</span>(phi):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> [[0,0]]


<span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: stub</span>
<span class="org-keyword">def</span> <span class="org-function-name">calc_u_x</span>(phi, y, x):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> 0.5


<span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: stub</span>
<span class="org-keyword">def</span> <span class="org-function-name">calc_u_y</span>(phi, y, x):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> 0.5


<span class="org-keyword">def</span> <span class="org-function-name">calc_phi_star</span>(phi, u_x, u_y, dx, dy, dt, x, y):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">phi_east</span>  <span class="org-operator">=</span> calc_phi_east(phi, u_x, x, y)
    <span class="org-variable-name">phi_west</span>  <span class="org-operator">=</span> calc_phi_west(phi, u_x, x, y)
    <span class="org-variable-name">phi_north</span> <span class="org-operator">=</span> calc_phi_north(phi, u_y, x, y)
    <span class="org-variable-name">phi_south</span> <span class="org-operator">=</span> calc_phi_south(phi, u_y, x, y)
    <span class="org-variable-name">dphi_dx</span>   <span class="org-operator">=</span> calc_dphi_dx(phi_east, phi_west, dx)
    <span class="org-variable-name">dphi_dy</span>   <span class="org-operator">=</span> calc_dphi_dy(phi_north, phi_south, dy)
    <span class="org-variable-name">dphi_dt</span>   <span class="org-operator">=</span> u_x[y][x] <span class="org-operator">*</span> dphi_dx <span class="org-operator">+</span> u_y[y][x] <span class="org-operator">*</span> dphi_dy
    <span class="org-keyword">return</span> phi[y][x] <span class="org-operator">-</span> dphi_dt <span class="org-operator">*</span> dt


<span class="org-keyword">def</span> <span class="org-function-name">calc_phi_next_timestep</span>(phi, u_x, u_y, dx, dy, dt, perimeter_cells):
    <span class="org-doc">"""</span>
<span class="org-doc">    TODO: Add docstring</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">phi_star</span> <span class="org-operator">=</span> np.copy(phi)
    <span class="org-keyword">for</span> [y, x] <span class="org-keyword">in</span> perimeter_cells:
        phi_star[y][x] <span class="org-operator">=</span> calc_phi_star(phi, u_x, u_y, dx, dy, dt, x, y)

    <span class="org-variable-name">perimeter_cells_star</span> <span class="org-operator">=</span> identify_perimeter_cells(phi_star)

    <span class="org-variable-name">u_x_star</span> <span class="org-operator">=</span> np.zeros_like(u_x)
    <span class="org-variable-name">u_y_star</span> <span class="org-operator">=</span> np.zeros_like(u_y)
    <span class="org-keyword">for</span> [y, x] <span class="org-keyword">in</span> perimeter_cells_star:
        u_x_star[y][x] <span class="org-operator">=</span> calc_u_x(phi_star, y, x)
        u_y_star[y][x] <span class="org-operator">=</span> calc_u_y(phi_star, y, x)

    <span class="org-variable-name">phi_star_star</span> <span class="org-operator">=</span> np.copy(phi_star)
    <span class="org-keyword">for</span> [y, x] <span class="org-keyword">in</span> perimeter_cells_star:
        phi_star_star[y][x] <span class="org-operator">=</span> calc_phi_star(phi_star, u_x_star, u_y_star, dx, dy, dt, x, y)

    <span class="org-keyword">return</span> (phi <span class="org-operator">+</span> phi_star_star) <span class="org-operator">/</span> 2.0
</pre>
</div>

<p>
In the above equations, timestep (\(\Delta t\)) is constrained by the
Courant-Friedrichs-Lewy (CFL) condition. The location of the fire
perimeter is determined by interpolation of the \(\phi\) field as the
level set corresponding to \(\phi = 0\).
</p>

<p>
&#x2026;RESUME HERE&#x2026;
</p>

<p>
<a href="https://github.com/lautenberger/elmfire/blob/main/docs/tech_ref.rst">https://github.com/lautenberger/elmfire/blob/main/docs/tech_ref.rst</a>
</p>
</div>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org59f7996" class="outline-2">
<h2 id="org59f7996"><span class="section-number-2">10.</span> [WIP] Fire Suppression Algorithms (pyretechnics.suppression)</h2>
<div class="outline-text-2" id="text-10">
</div>
<div id="outline-container-org91fa720" class="outline-3">
<h3 id="org91fa720"><span class="section-number-3">10.1.</span> For Developers</h3>
<div class="outline-text-3" id="text-10-1">
</div>
</div>
<div id="outline-container-org7a10282" class="outline-3">
<h3 id="org7a10282"><span class="section-number-3">10.2.</span> For Users</h3>
<div class="outline-text-3" id="text-10-2">
</div>
</div>
</div>
<div id="outline-container-org68d02a7" class="outline-2">
<h2 id="org68d02a7"><span class="section-number-2">11.</span> [WIP] Fire Spread API</h2>
<div class="outline-text-2" id="text-11">
<p>
Pyretechnics provides two main functions for simulating fire behavior over a region of space-time:
</p>
</div>
<div id="outline-container-orgfc31810" class="outline-3">
<h3 id="orgfc31810"><span class="section-number-3">11.1.</span> grow_fire</h3>
<div class="outline-text-3" id="text-11-1">
<p>
Simulates the growth of a fire over space and time starting from one
or more actively burning cells. Suppression effects may be optionally
applied, and several different stop conditions may be specified. A
random seed may be optionally provided to ensure deterministically
reproducible runs, despite the presence of stochastic calculations
within the fire spread algorithm.
</p>
</div>
<div id="outline-container-orga38c036" class="outline-4">
<h4 id="orga38c036"><span class="section-number-4">11.1.1.</span> Inputs</h4>
<div class="outline-text-4" id="text-11-1-1">
<p>
The <code>grow_fire</code> function takes a single <code>world_state</code> dictionary as input with these fields:
</p>

<dl class="org-dl">
<dt>simulation_clock</dt><dd>a float specifying the number of minutes from the start time of the simulated space-time cube to begin the simulation</dd>

<dt>config_dict</dt><dd><p>
a dictionary of parameter names to their values with the following types:
</p>

<p>
<b>TODO</b>: Determine whether rectangular cells will work for the GridFire and ELMFIRE spread algorithms. If not, eliminate this degree of freedom from the API.
<b>TODO</b>: Add interpolation options to the gridded data source class
<b>TODO</b>: simulation_north_angle may be dropped if we require inputs to use North-up projections for both fuels and weather
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Parameter Name</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Units</th>
<th scope="col" class="org-left">Optional?</th>
<th scope="col" class="org-left">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">simulation_shape</td>
<td class="org-left">Tuple (int, int, int)</td>
<td class="org-left">(num timesteps, num rows, num cols)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">simulation_resolution</td>
<td class="org-left">Tuple (float, float, float)</td>
<td class="org-left">(minutes per timestep, meters per row, meters per column)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">simulation_north_angle</td>
<td class="org-left">float</td>
<td class="org-left">degrees clockwise from the top of the circle [0,360)</td>
<td class="org-left">Yes</td>
<td class="org-left">0.0</td>
</tr>

<tr>
<td class="org-left">simulation_stop_condition</td>
<td class="org-left">Dictionary {string: float}</td>
<td class="org-left">either {'max_burn_duration': minutes} or {'max_burned_area': square_meters}</td>
<td class="org-left">Yes</td>
<td class="org-left">None</td>
</tr>

<tr>
<td class="org-left">random_seed</td>
<td class="org-left">number or string</td>
<td class="org-left">the seed value to initialize the random number generator</td>
<td class="org-left">Yes</td>
<td class="org-left">None</td>
</tr>

<tr>
<td class="org-left">overwrite_outputs</td>
<td class="org-left">boolean</td>
<td class="org-left">True or False, whether to mutate or copy the Numpy arrays provided in <b>output_layer_dict</b></td>
<td class="org-left">Yes</td>
<td class="org-left">False</td>
</tr>

<tr>
<td class="org-left">alpha_suppression</td>
<td class="org-left">Dictionary {string: float}</td>
<td class="org-left">parameters for the <b>alpha</b> suppression algorithm (see table below)</td>
<td class="org-left">Yes</td>
<td class="org-left">None</td>
</tr>

<tr>
<td class="org-left">sdi_suppression</td>
<td class="org-left">Dictionary {string: float}</td>
<td class="org-left">parameters for the <b>sdi</b> suppression algorithm (see table below)</td>
<td class="org-left">Yes</td>
<td class="org-left">None</td>
</tr>

<tr>
<td class="org-left">spotting</td>
<td class="org-left">Dictionary {string: float}</td>
<td class="org-left">parameters for the spotting algorithm (see table below)</td>
<td class="org-left">Yes</td>
<td class="org-left">None</td>
</tr>
</tbody>
</table>

<dl class="org-dl">
<dt>alpha_suppression</dt><dd>a dictionary of parameter names to their values for the <b>alpha</b> suppression algorithm:</dd>
</dl>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Parameter Name</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Units</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">suppression_timestep</td>
<td class="org-left">float</td>
<td class="org-left">minutes between suppression events</td>
</tr>

<tr>
<td class="org-left">suppression_coefficient</td>
<td class="org-left">float</td>
<td class="org-left">unitless</td>
</tr>
</tbody>
</table>

<dl class="org-dl">
<dt>sdi_suppression</dt><dd>a dictionary of parameter names to their values for the <b>sdi</b> suppression algorithm:</dd>
</dl>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Parameter Name</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Units</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">suppression_timestep</td>
<td class="org-left">float</td>
<td class="org-left">minutes between suppression events</td>
</tr>

<tr>
<td class="org-left">sdi_sensitivity_to_difficulty</td>
<td class="org-left">float</td>
<td class="org-left">unitless</td>
</tr>

<tr>
<td class="org-left">sdi_containment_overwhelming_area_growth_rate</td>
<td class="org-left">float</td>
<td class="org-left">hectares/day</td>
</tr>

<tr>
<td class="org-left">sdi_reference_suppression_speed</td>
<td class="org-left">float</td>
<td class="org-left">percent/day</td>
</tr>
</tbody>
</table>

<dl class="org-dl">
<dt>spotting</dt><dd>a dictionary of parameter names to their values for the spotting algorithm:</dd>
</dl>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Parameter Name</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Units</th>
<th scope="col" class="org-left">Fire Model</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">firebrands_per_cell</td>
<td class="org-left">int</td>
<td class="org-left">number of embers to cast from each spotting cell</td>
<td class="org-left">GridFire</td>
</tr>

<tr>
<td class="org-left">decay_constant</td>
<td class="org-left">float</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">GridFire</td>
</tr>

<tr>
<td class="org-left">mean_distance</td>
<td class="org-left">float</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">GridFire</td>
</tr>

<tr>
<td class="org-left">flin_exp</td>
<td class="org-left">float</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">GridFire</td>
</tr>

<tr>
<td class="org-left">ws_exp</td>
<td class="org-left">float</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">GridFire</td>
</tr>

<tr>
<td class="org-left">normalized_distance_variance</td>
<td class="org-left">float</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">GridFire</td>
</tr>

<tr>
<td class="org-left">delta_y_sigma</td>
<td class="org-left">float</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">GridFire</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">ember_gr</td>
<td class="org-left">int</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">pign</td>
<td class="org-left">float</td>
<td class="org-left">percent [0-100]</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">pign_max</td>
<td class="org-left">float</td>
<td class="org-left">percent [0-100]</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">pign_min</td>
<td class="org-left">float</td>
<td class="org-left">percent [0-100]</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">tau_embergen</td>
<td class="org-left">float</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">use_umd_spotting_model</td>
<td class="org-left">boolean</td>
<td class="org-left">True or False</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">p_eps</td>
<td class="org-left">float</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">use_physical_spotting_duration</td>
<td class="org-left">boolean</td>
<td class="org-left">True or False</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">use_physical_ember_number</td>
<td class="org-left">boolean</td>
<td class="org-left">True or False</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">ember_sampling_factor</td>
<td class="org-left">float</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">ELMFIRE</td>
</tr>

<tr>
<td class="org-left">use_superseded_spotting</td>
<td class="org-left">boolean</td>
<td class="org-left">True or False</td>
<td class="org-left">ELMFIRE</td>
</tr>
</tbody>
</table></dd>

<dt>input_layer_dict</dt><dd><p>
a dictionary of layer names to either 2-arity (2D) or 3-arity (3D) functions for accessing the numeric values at each <code>(y,x)</code> or <code>(z,y,x)</code> coordinate in the simulated space-time cube:
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Layer Name</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Units</th>
<th scope="col" class="org-left">Optional?</th>
<th scope="col" class="org-right">Arity</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">elevation</td>
<td class="org-left">float32</td>
<td class="org-left">meters above sea level [0-8850]</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">slope</td>
<td class="org-left">float32</td>
<td class="org-left">meters rise / meters run [0-4]</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">aspect</td>
<td class="org-left">int16</td>
<td class="org-left">degrees clockwise from North [0-359)</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">fuel_model</td>
<td class="org-left">int16</td>
<td class="org-left">integer classes [1-204]</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">canopy_cover</td>
<td class="org-left">float32</td>
<td class="org-left">canopy area / total area [0-0.95]</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">canopy_height</td>
<td class="org-left">float32</td>
<td class="org-left">meters  [0-51]</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">canopy_base_height</td>
<td class="org-left">float32</td>
<td class="org-left">meters  [0-10]</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">canopy_bulk_density</td>
<td class="org-left">float32</td>
<td class="org-left">kilograms/meters^3 [0-0.45]</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">fuel_spread_adjustment</td>
<td class="org-left">float</td>
<td class="org-left">real number &gt;= 0.0 (1.0 means no adjustment)</td>
<td class="org-left">Yes</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">suppression_difficulty_index</td>
<td class="org-left">float</td>
<td class="org-left">integer &gt;= 0  (TODO: What is the correct value range?)</td>
<td class="org-left">Yes</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">surface_spotting_fire_line_intensity</td>
<td class="org-left">float</td>
<td class="org-left">kilowatts/meter</td>
<td class="org-left">Yes</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">surface_spotting_percent (TODO: min, max?)</td>
<td class="org-left">float</td>
<td class="org-left">percent [0-1]</td>
<td class="org-left">Yes</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">crown_spotting_percent   (TODO: min, max?)</td>
<td class="org-left">float</td>
<td class="org-left">percent [0-1]</td>
<td class="org-left">Yes</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">temperature</td>
<td class="org-left">float</td>
<td class="org-left">degrees Celsius</td>
<td class="org-left">Yes</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">relative_humidity</td>
<td class="org-left">float</td>
<td class="org-left">percent [0-1+]</td>
<td class="org-left">Yes</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">wind_speed_10m_x</td>
<td class="org-left">float</td>
<td class="org-left">meters/minute</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">wind_speed_10m_y</td>
<td class="org-left">float</td>
<td class="org-left">meters/minute</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">fuel_moisture_dead_1hr</td>
<td class="org-left">float</td>
<td class="org-left">ratio [0-1+] grams moisture/grams ovendry wood</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">fuel_moisture_dead_10hr</td>
<td class="org-left">float</td>
<td class="org-left">ratio [0-1+] grams moisture/grams ovendry wood</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">fuel_moisture_dead_100hr</td>
<td class="org-left">float</td>
<td class="org-left">ratio [0-1+] grams moisture/grams ovendry wood</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">fuel_moisture_live_herbaceous</td>
<td class="org-left">float</td>
<td class="org-left">ratio [0-1+] grams moisture/grams ovendry wood</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">fuel_moisture_live_woody</td>
<td class="org-left">float</td>
<td class="org-left">ratio [0-1+] grams moisture/grams ovendry wood</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">foliar_moisture</td>
<td class="org-left">float</td>
<td class="org-left">ratio [0-1+] grams moisture/grams ovendry foliage</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">weather_spread_adjustment</td>
<td class="org-left">float</td>
<td class="org-left">real number &gt;= 0.0 (1.0 means no adjustment)</td>
<td class="org-left">Yes</td>
<td class="org-right">3</td>
</tr>
</tbody>
</table></dd>

<dt>output_layer_dict</dt><dd><p>
an <b>optional</b> dictionary of layer names to 2D Numpy arrays with the following units to pre-populate the simulation output arrays:
<b>TODO</b> Consider whether some of these layers should be kept as internal state and not returned to the user.
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Parameter Name</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Units</th>
<th scope="col" class="org-left">Optional?</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">eulerian_level_set_phi_field</td>
<td class="org-left">float16</td>
<td class="org-left">TODO: find units range</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">time_of_arrival</td>
<td class="org-left">float32</td>
<td class="org-left">minutes from the start time of the simulated space-time cube</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">max_surface_spread_direction</td>
<td class="org-left">float16</td>
<td class="org-left">degrees clockwise from North</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">max_crown_spread_direction</td>
<td class="org-left">float16</td>
<td class="org-left">degrees clockwise from North</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">perimeter_spread_direction</td>
<td class="org-left">float16</td>
<td class="org-left">degrees clockwise from North</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">max_surface_spread_rate</td>
<td class="org-left">float16</td>
<td class="org-left">meters/second</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">max_crown_spread_rate</td>
<td class="org-left">float16</td>
<td class="org-left">meters/second</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">perimeter_spread_rate</td>
<td class="org-left">float16</td>
<td class="org-left">meters/second</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">surface_eccentricity</td>
<td class="org-left">float16</td>
<td class="org-left">dimensionless (0: circular fire, &gt;0: elliptical fire)</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">crown_eccentricity</td>
<td class="org-left">float16</td>
<td class="org-left">dimensionless (0: circular fire, &gt;0: elliptical fire)</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">max_surface_fire_line_intensity</td>
<td class="org-left">float32</td>
<td class="org-left">kilowatts/meter</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">max_crown_fire_line_intensity</td>
<td class="org-left">float32</td>
<td class="org-left">kilowatts/meter</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">perimeter_fire_line_intensity</td>
<td class="org-left">float32</td>
<td class="org-left">kilowatts/meter</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">max_surface_flame_length</td>
<td class="org-left">float16</td>
<td class="org-left">meters</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">max_crown_flame_length</td>
<td class="org-left">float16</td>
<td class="org-left">meters</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">perimeter_flame_length</td>
<td class="org-left">float16</td>
<td class="org-left">meters</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">fire_type</td>
<td class="org-left">uint8</td>
<td class="org-left">0 = no_fire, 1 = surface_fire, 2 = passive_crown_fire, 3 = active_crown_fire</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">ember_count</td>
<td class="org-left">uint32</td>
<td class="org-left">number of embers landing in each cell</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">ember_ignition</td>
<td class="org-left">bool8</td>
<td class="org-left">True for cells ignited by embers, False otherwise</td>
<td class="org-left">Yes</td>
</tr>
</tbody>
</table></dd>

<dt>ignited_cells_set</dt><dd>set of cells that are actively burning at the simulation start time, specified as 3D coordinates <code>(z,y,x)</code> in the simulated space-time cube</dd>
</dl>
</div>
</div>
<div id="outline-container-org93e1ef6" class="outline-4">
<h4 id="org93e1ef6"><span class="section-number-4">11.1.2.</span> Outputs</h4>
<div class="outline-text-4" id="text-11-1-2">
<p>
The <code>grow_fire</code> function will return a dictionary with these fields:
</p>

<dl class="org-dl">
<dt>simulation_clock</dt><dd>a float specifying the number of minutes from the start time of the simulated space-time cube at which the simulation stopped</dd>

<dt>simulation_stop_condition_encountered</dt><dd>max_burn_duration | max_burned_area | no_burnable_fuel | end_of_temporal_data | fully_suppressed</dd>

<dt>config_dict</dt><dd>a dictionary of parameter names to their values as defined in section <a href="#orga38c036">11.1.1</a> above</dd>

<dt>input_layer_dict</dt><dd>a dictionary of layer names to either 2-arity (2D) or 3-arity (3D) functions as defined in section <a href="#orga38c036">11.1.1</a> above</dd>

<dt>output_layer_dict</dt><dd>a dictionary of layer names to 2D Numpy arrays as defined in section <a href="#orga38c036">11.1.1</a> above</dd>

<dt>ignited_cells_set</dt><dd>set of cells that are actively burning at the simulation stop time, specified as 3D coordinates <code>(z,y,x)</code> in the simulated space-time cube</dd>
</dl>

<p>
Note that <code>config_dict</code> and <code>input_layer_dict</code> will be unchanged from
the input dictionary that was provided to <code>grow_fire</code>. All other
fields will contain values updated by the fire spread simulation.
</p>
</div>
</div>
<div id="outline-container-orgba47f93" class="outline-4">
<h4 id="orgba47f93"><span class="section-number-4">11.1.3.</span> Play/Pause/Continue Workflow</h4>
<div class="outline-text-4" id="text-11-1-3">
<p>
The inputs and outputs of <code>grow_fire</code> are structured so as to enable
you to simulate fire spread from <code>simulation_clock</code> until a stop
condition is encountered and then to easily resume the fire spread
simulation from the output <code>simulation_clock</code> until the next stop
condition is met. Here is an example of how to do this.
</p>

<div class="org-src-container">
<pre class="src src-python" id="org862fa24"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np

<span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Phase 1: Initial fire simulation - first 12 hours</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================</span>

<span class="org-variable-name">world_state</span> <span class="org-operator">=</span> {
    simulation_clock: 0.0,

    config_dict: {
        <span class="org-string">"simulation_shape"</span>         : (24, 1000, 1000),
        <span class="org-string">"simulation_resolution"</span>    : (60, 30, 30),
        <span class="org-string">"simulation_stop_condition"</span>: {<span class="org-string">"max_burn_duration"</span>: 720.0},
    },

    input_layer_dict: {
        <span class="org-comment-delimiter"># </span><span class="org-comment">2D Arrays (e.g. 30m x 30m resolution, 30km x 30km extent)</span>
        <span class="org-string">"elevation"</span>                    : <span class="org-keyword">lambda</span> y,x: 0.0,
        <span class="org-string">"slope"</span>                        : <span class="org-keyword">lambda</span> y,x: 0.0,
        <span class="org-string">"aspect"</span>                       : <span class="org-keyword">lambda</span> y,x: 0.0,
        <span class="org-string">"fuel_model"</span>                   : <span class="org-keyword">lambda</span> y,x: 100,
        <span class="org-string">"canopy_cover"</span>                 : <span class="org-keyword">lambda</span> y,x: 0.0,
        <span class="org-string">"canopy_height"</span>                : <span class="org-keyword">lambda</span> y,x: 0.0,
        <span class="org-string">"canopy_base_height"</span>           : <span class="org-keyword">lambda</span> y,x: 0.0,
        <span class="org-string">"canopy_bulk_density"</span>          : <span class="org-keyword">lambda</span> y,x: 0.0,
        <span class="org-comment-delimiter"># </span><span class="org-comment">3D Arrays (e.g. 1hr x 300m x 300m resolution, 1day x 30km x 30km extent)</span>
        <span class="org-string">"temperature"</span>                  : <span class="org-keyword">lambda</span> z,y,x: 10.0,
        <span class="org-string">"relative_humidity"</span>            : <span class="org-keyword">lambda</span> z,y,x: 10.0,
        <span class="org-string">"wind_speed_10m_x"</span>             : <span class="org-keyword">lambda</span> z,y,x: 0.0,
        <span class="org-string">"wind_speed_10m_y"</span>             : <span class="org-keyword">lambda</span> z,y,x: 0.0,
        <span class="org-string">"fuel_moisture_dead_1hr"</span>       : <span class="org-keyword">lambda</span> z,y,x: 10.0,
        <span class="org-string">"fuel_moisture_dead_10hr"</span>      : <span class="org-keyword">lambda</span> z,y,x: 10.0,
        <span class="org-string">"fuel_moisture_dead_100hr"</span>     : <span class="org-keyword">lambda</span> z,y,x: 10.0,
        <span class="org-string">"fuel_moisture_live_herbaceous"</span>: <span class="org-keyword">lambda</span> z,y,x: 10.0,
        <span class="org-string">"fuel_moisture_live_woody"</span>     : <span class="org-keyword">lambda</span> z,y,x: 10.0,
        <span class="org-string">"foliar_moisture"</span>              : <span class="org-keyword">lambda</span> z,y,x: 10.0,
    },

    output_layer_dict: {
        <span class="org-string">"eulerian_level_set_phi_field"</span> : np.full((1000, 1000), 0.0, dtype<span class="org-operator">=</span><span class="org-string">"float16"</span>),
    },

    ignited_cells_set: <span class="org-builtin">set</span>([(0, 100, 100)]),
}

<span class="org-variable-name">world_state2</span> <span class="org-operator">=</span> grow_fire(world_state)

<span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Phase 2: Continued fire simulation - second 12 hours</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================</span>

<span class="org-variable-name">world_state3</span> <span class="org-operator">=</span> grow_fire(world_state2)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org8c95a34" class="outline-3">
<h3 id="org8c95a34"><span class="section-number-3">11.2.</span> burn_cells</h3>
<div class="outline-text-3" id="text-11-2">
<p>
TODO: stub
</p>
</div>
</div>
</div>
<div id="outline-container-orgc5148dd" class="outline-2">
<h2 id="orgc5148dd"><span class="section-number-2">12.</span> [WIP] Fire Spread Functions</h2>
<div class="outline-text-2" id="text-12">
<div class="org-src-container">
<pre class="src src-python" id="orgc479f9d"><span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Compare this with numpy.random (is there a generator object that I can use here?)</span>
<span class="org-keyword">import</span> random
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np

<span class="org-keyword">def</span> <span class="org-function-name">supply_layer</span>(layer_dict, layer_name, layer_shape, layer_type, initial_value, overwrite_layers):
    <span class="org-variable-name">layer</span> <span class="org-operator">=</span> layer_dict.get(layer_name)
    <span class="org-keyword">if</span> layer:
        <span class="org-keyword">if</span> overwrite_layers:
            <span class="org-keyword">return</span> layer
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> layer.copy()
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> np.full(layer_shape, initial_value, dtype<span class="org-operator">=</span>layer_type)


<span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: stub</span>
<span class="org-keyword">def</span> <span class="org-function-name">burn_cells</span>(world_state):
    <span class="org-doc">"""</span>
<span class="org-doc">    1. Validate inputs</span>
<span class="org-doc">       - Make sure that all required parameters are present in config_dict</span>
<span class="org-doc">       - Make sure that all required entries are present in layer_dict</span>
<span class="org-doc">       - Check for entries in output_layer_dict; if present, copy/use as new output layers</span>
<span class="org-doc">         - Use time of arrival raster to identify the burn scar(s); if missing, we are simulating point ignitions</span>
<span class="org-doc">       - Make sure that ignited_cells_set is a set of integer 3-tuples</span>
<span class="org-doc">    2. Iterate through all cells in (rows, cols), compute the maximum spread rate and severity values, and store them in output arrays</span>
<span class="org-doc">       - Run surface and crown equations per cell</span>
<span class="org-doc">    3. Return a dictionary of the outputs</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">simulation_clock</span>  <span class="org-operator">=</span> world_state[<span class="org-string">"simulation_clock"</span>]
    <span class="org-variable-name">config_dict</span>       <span class="org-operator">=</span> world_state[<span class="org-string">"config_dict"</span>]
    <span class="org-variable-name">input_layer_dict</span>  <span class="org-operator">=</span> world_state[<span class="org-string">"input_layer_dict"</span>]
    <span class="org-variable-name">output_layer_dict</span> <span class="org-operator">=</span> world_state.get(<span class="org-string">"output_layer_dict"</span>, {})
    <span class="org-variable-name">ignited_cells_set</span> <span class="org-operator">=</span> world_state[<span class="org-string">"ignited_cells_set"</span>]

    <span class="org-comment-delimiter"># </span><span class="org-comment">The random seed affects input layer perturbations.</span>
    <span class="org-keyword">if</span> config_dict.get(<span class="org-string">"random_seed"</span>):
        random.seed(config_dict.get(<span class="org-string">"random_seed"</span>))

    <span class="org-keyword">return</span> <span class="org-constant">None</span>


<span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: stub</span>
<span class="org-keyword">def</span> <span class="org-function-name">grow_fire</span>(world_state):
    <span class="org-doc">"""</span>
<span class="org-doc">    1. Validate inputs</span>
<span class="org-doc">       - Make sure that all required parameters are present in config_dict</span>
<span class="org-doc">       - Make sure that all required entries are present in layer_dict</span>
<span class="org-doc">       - Check for entries in output_layer_dict; if present, copy/use as new output layers</span>
<span class="org-doc">         - Use time of arrival raster to identify the burn scar(s); if missing, we are simulating point ignitions</span>
<span class="org-doc">       - Make sure that ignited_cells_set is a set of integer 3-tuples</span>
<span class="org-doc">    2. Iterate through all cells in ignited_cells_set, compute the perimeter-oriented spread rate and severity values, and store them in output arrays</span>
<span class="org-doc">    3. Perform constant spread out over the landscape in all directions</span>
<span class="org-doc">       - Run surface, crown, and spot equations per ignited cell</span>
<span class="org-doc">    4. Record the time_of_arrival in each cell as it spreads</span>
<span class="org-doc">    5. Continue until a stop condition is met (e.g., max_burn_duration or max_burned_area)</span>
<span class="org-doc">    6. Return a dictionary of the outputs</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">simulation_clock</span>  <span class="org-operator">=</span> world_state[<span class="org-string">"simulation_clock"</span>]
    <span class="org-variable-name">config_dict</span>       <span class="org-operator">=</span> world_state[<span class="org-string">"config_dict"</span>]
    <span class="org-variable-name">input_layer_dict</span>  <span class="org-operator">=</span> world_state[<span class="org-string">"input_layer_dict"</span>]
    <span class="org-variable-name">output_layer_dict</span> <span class="org-operator">=</span> world_state.get(<span class="org-string">"output_layer_dict"</span>, {})
    <span class="org-variable-name">ignited_cells_set</span> <span class="org-operator">=</span> world_state[<span class="org-string">"ignited_cells_set"</span>]

    <span class="org-comment-delimiter"># </span><span class="org-comment">The random seed affects input layer perturbations and spotting calculations.</span>
    <span class="org-keyword">if</span> config_dict.get(<span class="org-string">"random_seed"</span>):
        random.seed(config_dict.get(<span class="org-string">"random_seed"</span>))

    <span class="org-comment-delimiter"># </span><span class="org-comment">GridFire initializes the following 2D arrays for its spread algorithm:</span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:burn-time-matrix                [float32] time_of_arrival (with -1 for values in the interior of the burn scar)</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:eccentricity-matrix             [float32] -1 in burn scar, 0 otherwise</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:fire-line-intensity-matrix      [float32] -1 in burn scar, 0 otherwise</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:fire-spread-matrix              [float32] +1 in burn scar, 0 otherwise</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:fire-type-matrix                [float32] -1 in burn scar, 0 otherwise</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:firebrand-count-matrix          [ int32 ]  0 everywhere (when spotting params are passed)</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:flame-length-matrix             [float32] -1 in burn scar, 0 otherwise</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:directional-flame-length-matrix [float32] -1 in burn scar, 0 otherwise (when compute-directional-values? = true)</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:max-spread-direction-matrix     [float32] -1 in burn scar, 0 otherwise</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:max-spread-rate-matrix          [float32] -1 in burn scar, 0 otherwise</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:modified-time-matrix            [ int32 ]  0 everywhere</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:residence-time-matrix           [float32] -1 in burn scar, 0 otherwise (when compute-directional-values? = true)</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:reaction-intensity-matrix       [float32] -1 in burn scar, 0 otherwise (when compute-directional-values? = true)</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:spot-matrix                     [float32]  0 everywhere (when spotting params are passed)</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:spread-rate-matrix              [float32] -1 in burn scar, 0 otherwise</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:spread-rate-sum-matrix          [float32]  0 everywhere (when compute-directional-values? = true)</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:travel-lines-matrix             [ int16 ]  0 everywhere</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:x-magnitude-sum-matrix          [float32]  0 everywhere (when compute-directional-values? = true)</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:y-magnitude-sum-matrix          [float32]  0 everywhere (when compute-directional-values? = true)</span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Equivalent Pyretechnics 2D arrays in output_layer_dict:</span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">========================= Output 2D Arrays =========================</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">time_of_arrival                  :burn-time-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">max_surface_spread_direction     :max-spread-direction-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">max_crown_spread_direction       :max-spread-direction-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">perimeter_spread_direction       N/A</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">max_surface_spread_rate          :max-spread-rate-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">max_crown_spread_rate            :max-spread-rate-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">perimeter_spread_rate            :spread-rate-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">max_surface_fire_line_intensity  :fire-line-intensity-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">max_crown_fire_line_intensity    :fire-line-intensity-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">perimeter_fire_line_intensity    :fire-line-intensity-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">max_surface_flame_length         :flame-length-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">max_crown_flame_length           :flame-length-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">perimeter_flame_length           :directional-flame-length-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">fire_type                        :fire-type-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">ember_count                      :firebrand-count-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">ember_ignition                   :spot-matrix</span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">======================== Internal 2D Arrays ========================</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">surface_eccentricity             :eccentricity-matrix</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">crown_eccentricity               :eccentricity-matrix</span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">GridFire 2D arrays that are not needed by Pyretechnics:</span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">======================== Replaced 2D Arrays ========================</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:fire-spread-matrix              time_of_arrival</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:residence-time-matrix           max_surface_fire_line_intensity, max_crown_fire_line_intensity, surface_eccentricity, crown_eccentricity</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:reaction-intensity-matrix       max_surface_fire_line_intensity, max_crown_fire_line_intensity, surface_eccentricity, crown_eccentricity</span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">======================== Internal 2D Arrays ========================</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:modified-time-matrix            \</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:travel-lines-matrix              |</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:spread-rate-sum-matrix           |-- for its 2D spread algorithm</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:x-magnitude-sum-matrix           |</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">:y-magnitude-sum-matrix          /</span>

    (<span class="org-variable-name">num_timesteps</span>, <span class="org-variable-name">num_rows</span>, <span class="org-variable-name">num_cols</span>) <span class="org-operator">=</span> config_dict[<span class="org-string">"simulation_shape"</span>]
    <span class="org-variable-name">layer_shape</span> <span class="org-operator">=</span> (num_rows, num_cols)
    <span class="org-variable-name">overwrite_outputs</span> <span class="org-operator">=</span> config_dict[<span class="org-string">"overwrite_outputs"</span>]

    <span class="org-variable-name">output_layer_dict</span> <span class="org-operator">=</span> {
        <span class="org-string">"eulerian_level_set_phi_field"</span>   : supply_layer(output_layer_dict, <span class="org-string">"eulerian_level_set_phi_field"</span>   , layer_shape, <span class="org-string">"float16"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"time_of_arrival"</span>                : supply_layer(output_layer_dict, <span class="org-string">"time_of_arrival"</span>                , layer_shape, <span class="org-string">"float32"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"max_surface_spread_direction"</span>   : supply_layer(output_layer_dict, <span class="org-string">"max_surface_spread_direction"</span>   , layer_shape, <span class="org-string">"float16"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"max_crown_spread_direction"</span>     : supply_layer(output_layer_dict, <span class="org-string">"max_crown_spread_direction"</span>     , layer_shape, <span class="org-string">"float16"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"perimeter_spread_direction"</span>     : supply_layer(output_layer_dict, <span class="org-string">"perimeter_spread_direction"</span>     , layer_shape, <span class="org-string">"float16"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"max_surface_spread_rate"</span>        : supply_layer(output_layer_dict, <span class="org-string">"max_surface_spread_rate"</span>        , layer_shape, <span class="org-string">"float16"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"max_crown_spread_rate"</span>          : supply_layer(output_layer_dict, <span class="org-string">"max_crown_spread_rate"</span>          , layer_shape, <span class="org-string">"float16"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"perimeter_spread_rate"</span>          : supply_layer(output_layer_dict, <span class="org-string">"perimeter_spread_rate"</span>          , layer_shape, <span class="org-string">"float16"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"surface_eccentricity"</span>           : supply_layer(output_layer_dict, <span class="org-string">"surface_eccentricity"</span>           , layer_shape, <span class="org-string">"float16"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"crown_eccentricity"</span>             : supply_layer(output_layer_dict, <span class="org-string">"crown_eccentricity"</span>             , layer_shape, <span class="org-string">"float16"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"max_surface_fire_line_intensity"</span>: supply_layer(output_layer_dict, <span class="org-string">"max_surface_fire_line_intensity"</span>, layer_shape, <span class="org-string">"float32"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"max_crown_fire_line_intensity"</span>  : supply_layer(output_layer_dict, <span class="org-string">"max_crown_fire_line_intensity"</span>  , layer_shape, <span class="org-string">"float32"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"perimeter_fire_line_intensity"</span>  : supply_layer(output_layer_dict, <span class="org-string">"perimeter_fire_line_intensity"</span>  , layer_shape, <span class="org-string">"float32"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"max_surface_flame_length"</span>       : supply_layer(output_layer_dict, <span class="org-string">"max_surface_flame_length"</span>       , layer_shape, <span class="org-string">"float16"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"max_crown_flame_length"</span>         : supply_layer(output_layer_dict, <span class="org-string">"max_crown_flame_length"</span>         , layer_shape, <span class="org-string">"float16"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"perimeter_flame_length"</span>         : supply_layer(output_layer_dict, <span class="org-string">"perimeter_flame_length"</span>         , layer_shape, <span class="org-string">"float16"</span>, np.nan, overwrite_outputs),
        <span class="org-string">"fire_type"</span>                      : supply_layer(output_layer_dict, <span class="org-string">"fire_type"</span>                      , layer_shape, <span class="org-string">"uint8"</span>  ,      0, overwrite_outputs),
        <span class="org-string">"ember_count"</span>                    : supply_layer(output_layer_dict, <span class="org-string">"ember_count"</span>                    , layer_shape, <span class="org-string">"uint32"</span> ,      0, overwrite_outputs),
        <span class="org-string">"ember_ignition"</span>                 : supply_layer(output_layer_dict, <span class="org-string">"ember_ignition"</span>                 , layer_shape, <span class="org-string">"bool8"</span>  ,  <span class="org-constant">False</span>, overwrite_outputs),
    }

    <span class="org-comment-delimiter"># </span><span class="org-comment">RESUME at [[file:~/code/sig-gis/gridfire/src/gridfire/fire_spread.clj::(defn- run-loop]]</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Investigate ELMFIRE's inputs to determine if we are missing anything needed by its API.</span>

    <span class="org-keyword">return</span> <span class="org-constant">None</span>
</pre>
</div>
</div>
<div id="outline-container-org00e9a8e" class="outline-3">
<h3 id="org00e9a8e"><span class="section-number-3">12.1.</span> ELMFIRE Inputs</h3>
<div class="outline-text-3" id="text-12-1">
<p>
This section lists the full set of inputs used in any <code>elmfire.data</code> or <code>elmfire.data.in</code> file in:
</p>

<ul class="org-ul">
<li>the current <code>main</code> branch of the <code>elmfire</code> repository located here: <a href="https://github.com/lautenberger/elmfire">https://github.com/lautenberger/elmfire</a></li>
<li>the current <code>main</code> branch of the <code>runway-scripts</code> repository located here: <a href="https://gitlab.sig-gis.com/sig-gis/runway-scripts">https://gitlab.sig-gis.com/sig-gis/runway-scripts</a></li>
</ul>

<p>
The following table contains the current mapping from ELMFIRE parameters to Pyretechnics parameters:
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">ELMFIRE</th>
<th scope="col" class="org-left">Pyretechnics Group</th>
<th scope="col" class="org-left">Pyretechnics Parameter</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">DT_METEOROLOGY</td>
<td class="org-left">config_dict</td>
<td class="org-left">simulation_resolution[0]</td>
</tr>

<tr>
<td class="org-left">COMPUTATIONAL_DOMAIN_CELLSIZE</td>
<td class="org-left">config_dict</td>
<td class="org-left">simulation_resolution[1:]</td>
</tr>

<tr>
<td class="org-left">SIMULATION_TSTART</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">SIMULATION_TSTOP</td>
<td class="org-left">config_dict.simulation_stop_condition</td>
<td class="org-left">max_burn_duration</td>
</tr>

<tr>
<td class="org-left">EMBER_GR</td>
<td class="org-left">config_dict.spotting</td>
<td class="org-left">ember_gr</td>
</tr>

<tr>
<td class="org-left">EMBER_SAMPLING_FACTOR</td>
<td class="org-left">config_dict.spotting</td>
<td class="org-left">ember_sampling_factor</td>
</tr>

<tr>
<td class="org-left">ENABLE_SPOTTING</td>
<td class="org-left">config_dict.spotting</td>
<td class="org-left">Enabled if dictionary is present</td>
</tr>

<tr>
<td class="org-left">P_EPS</td>
<td class="org-left">config_dict.spotting</td>
<td class="org-left">p_eps</td>
</tr>

<tr>
<td class="org-left">PIGN</td>
<td class="org-left">config_dict.spotting</td>
<td class="org-left">pign</td>
</tr>

<tr>
<td class="org-left">PIGN_MAX</td>
<td class="org-left">config_dict.spotting</td>
<td class="org-left">pign_max</td>
</tr>

<tr>
<td class="org-left">PIGN_MIN</td>
<td class="org-left">config_dict.spotting</td>
<td class="org-left">pign_min</td>
</tr>

<tr>
<td class="org-left">TAU_EMBERGEN</td>
<td class="org-left">config_dict.spotting</td>
<td class="org-left">tau_embergen</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">DEM_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">elevation</td>
</tr>

<tr>
<td class="org-left">SLP_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">slope</td>
</tr>

<tr>
<td class="org-left">ASP_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">aspect</td>
</tr>

<tr>
<td class="org-left">FBFM_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">fuel_model</td>
</tr>

<tr>
<td class="org-left">CC_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">canopy_cover</td>
</tr>

<tr>
<td class="org-left">CH_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">canopy_height</td>
</tr>

<tr>
<td class="org-left">CBH_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">canopy_base_height</td>
</tr>

<tr>
<td class="org-left">CBD_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">canopy_bulk_density</td>
</tr>

<tr>
<td class="org-left">ADJ_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">fuel_spread_adjustment</td>
</tr>

<tr>
<td class="org-left">CRITICAL_SPOTTING_FIRELINE_INTENSITY(:)</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">surface_spotting_fire_line_intensity</td>
</tr>

<tr>
<td class="org-left">GLOBAL_SURFACE_FIRE_SPOTTING_PERCENT_MAX</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">surface_spotting_percent</td>
</tr>

<tr>
<td class="org-left">GLOBAL_SURFACE_FIRE_SPOTTING_PERCENT_MIN</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">surface_spotting_percent</td>
</tr>

<tr>
<td class="org-left">WS_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">wind_speed_10m_x, wind_speed_10m_y</td>
</tr>

<tr>
<td class="org-left">WD_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">wind_speed_10m_x, wind_speed_10m_y</td>
</tr>

<tr>
<td class="org-left">M1_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">fuel_moisture_dead_1hr</td>
</tr>

<tr>
<td class="org-left">M10_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">fuel_moisture_dead_10hr</td>
</tr>

<tr>
<td class="org-left">M100_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">fuel_moisture_dead_100hr</td>
</tr>

<tr>
<td class="org-left">MLH_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">fuel_moisture_live_herbaceous</td>
</tr>

<tr>
<td class="org-left">MLW_FILENAME</td>
<td class="org-left">input_layer_dict</td>
<td class="org-left">fuel_moisture_live_woody</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">PHI_FILENAME</td>
<td class="org-left">output_layer_dict</td>
<td class="org-left">eulerian_level_set_phi_field</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">T_IGN(1)</td>
<td class="org-left">ignited_cells_set</td>
<td class="org-left">(t, _, _)</td>
</tr>

<tr>
<td class="org-left">Y_IGN(1)</td>
<td class="org-left">ignited_cells_set</td>
<td class="org-left">(_, y, _)</td>
</tr>

<tr>
<td class="org-left">X_IGN(1)</td>
<td class="org-left">ignited_cells_set</td>
<td class="org-left">(_, _, x)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">BANDTHICKNESS</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">METEOROLOGY_BAND_SKIP_INTERVAL</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">METEOROLOGY_BAND_START</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">METEOROLOGY_BAND_STOP</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">NUM_METEOROLOGY_TIMES</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">CROWN_FIRE_MODEL</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">MODE</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">SIMULATION_DT</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">SIMULATION_DTMAX</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">TARGET_CFL</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">USE_BLDG_SPREAD_MODEL</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">USE_EULERIAN_FRAMEWORK</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">USE_PHYSICAL_EMBER_NUMBER</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">USE_PHYSICAL_SPOTTING_DURATION</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">USE_SUPERSEDED_SPOTTING</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">USE_UMD_SPOTTING_MODEL</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">WX_BILINEAR_INTERPOLATION</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">ALLOW_MULTIPLE_IGNITIONS_AT_A_PIXEL</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">?</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">FUELS_AND_TOPOGRAPHY_DIRECTORY</td>
<td class="org-left">N/A</td>
<td class="org-left">Input reading managed externally</td>
</tr>

<tr>
<td class="org-left">A_SRS</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">LATITUDE</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">LONGITUDE</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">COMPUTATIONAL_DOMAIN_XLLCORNER</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">COMPUTATIONAL_DOMAIN_YLLCORNER</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">FORECAST_START_HOUR</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">UTC_OFFSET_HOURS</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">CURRENT_YEAR</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">HOUR_OF_YEAR</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">PATH_TO_GDAL</td>
<td class="org-left">N/A</td>
<td class="org-left">GIS operations managed externally</td>
</tr>

<tr>
<td class="org-left">NUM_ENSEMBLE_MEMBERS</td>
<td class="org-left">N/A</td>
<td class="org-left">Random sampling managed externally</td>
</tr>

<tr>
<td class="org-left">NUM_IGNITIONS</td>
<td class="org-left">N/A</td>
<td class="org-left">Random sampling managed externally</td>
</tr>

<tr>
<td class="org-left">RANDOM_IGNITIONS</td>
<td class="org-left">N/A</td>
<td class="org-left">Random sampling managed externally</td>
</tr>

<tr>
<td class="org-left">USE_IGNITION_MASK</td>
<td class="org-left">N/A</td>
<td class="org-left">Random sampling managed externally</td>
</tr>

<tr>
<td class="org-left">USE_CONSTANT_LH</td>
<td class="org-left">N/A</td>
<td class="org-left">Replaced by abstract gridded datasource</td>
</tr>

<tr>
<td class="org-left">USE_CONSTANT_LW</td>
<td class="org-left">N/A</td>
<td class="org-left">Replaced by abstract gridded datasource</td>
</tr>

<tr>
<td class="org-left">LH_MOISTURE_CONTENT</td>
<td class="org-left">N/A</td>
<td class="org-left">Replaced by abstract gridded datasource</td>
</tr>

<tr>
<td class="org-left">LW_MOISTURE_CONTENT</td>
<td class="org-left">N/A</td>
<td class="org-left">Replaced by abstract gridded datasource</td>
</tr>

<tr>
<td class="org-left">OUTPUTS_DIRECTORY</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">SCRATCH</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">CONVERT_TO_GEOTIFF</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">DTDUMP</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">DT_DUMP_EMBER_FLUX</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">DUMP_EMBER_FLUX_UMD</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">DUMP_FLAME_LENGTH</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">DUMP_FLIN</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">DUMP_SPOTTING_OUTPUTS</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">DUMP_SPREAD_RATE</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>

<tr>
<td class="org-left">DUMP_TIME_OF_ARRIVAL</td>
<td class="org-left">N/A</td>
<td class="org-left">Output writing managed externally</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-orgc902ec4" class="outline-2">
<h2 id="orgc902ec4"><span class="section-number-2">13.</span> [WIP] Burning All Cells as a Head-Fire (similar to FLAMMAP)</h2>
<div class="outline-text-2" id="text-13">
<div class="org-src-container">
<pre class="src src-python" id="orgdc19657"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> sqrt, atan2, degrees
<span class="org-keyword">from</span> pyretechnics.conversion <span class="org-keyword">import</span> wind_speed_10m_to_wind_speed_20ft, m_to_ft, Btu_ft_s_to_kW_m, kW_m_to_Btu_ft_s, m_min_to_km_hr, m_min_to_mph, ft_to_m, Btu_lb_to_kJ_kg
<span class="org-keyword">from</span> pyretechnics.fuel_models <span class="org-keyword">import</span> fuel_model_table, moisturize
<span class="org-keyword">import</span> pyretechnics.surface_fire <span class="org-keyword">as</span> sf
<span class="org-keyword">import</span> pyretechnics.crown_fire <span class="org-keyword">as</span> cf

<span class="org-keyword">def</span> <span class="org-function-name">one_everywhere</span>(t, y, x):
    <span class="org-doc">"""</span>
<span class="org-doc">    Return 1.0 for all t, y, x values.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> 1.0


<span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: Name change (no more !)</span>
<span class="org-keyword">def</span> <span class="org-function-name">compute_max_in_situ_values</span>(inputs, t, y, x):
    <span class="org-doc">"""</span>
<span class="org-doc">    Returns the following fire behavior values for the space-time cell at location (t,y,x):</span>
<span class="org-doc">    - max_spread_rate        : m/min</span>
<span class="org-doc">    - max_spread_direction   : deg</span>
<span class="org-doc">    - max_fire_line_intensity: kW/m</span>
<span class="org-doc">    - max_flame_length       : m</span>
<span class="org-doc">    - fire_type              : 0=unburned, 1=surface, 2=passive crown, 3=active crown</span>
<span class="org-doc">    - eccentricity           : unitless (0: circular fire, &gt;0: elliptical fire)</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Topography, Fuel Model, and Vegetation</span>
    <span class="org-variable-name">slope</span>                         <span class="org-operator">=</span> inputs[<span class="org-string">"slope"</span>](t,y,x)
    <span class="org-variable-name">aspect</span>                        <span class="org-operator">=</span> inputs[<span class="org-string">"aspect"</span>](t,y,x)
    <span class="org-variable-name">fuel_model_number</span>             <span class="org-operator">=</span> inputs[<span class="org-string">"fuel_model"</span>](t,y,x)
    <span class="org-variable-name">canopy_cover</span>                  <span class="org-operator">=</span> inputs[<span class="org-string">"canopy_cover"</span>](t,y,x)
    <span class="org-variable-name">canopy_height</span>                 <span class="org-operator">=</span> inputs[<span class="org-string">"canopy_height"</span>](t,y,x)
    <span class="org-variable-name">canopy_base_height</span>            <span class="org-operator">=</span> inputs[<span class="org-string">"canopy_base_height"</span>](t,y,x)
    <span class="org-variable-name">canopy_bulk_density</span>           <span class="org-operator">=</span> inputs[<span class="org-string">"canopy_bulk_density"</span>](t,y,x)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Wind, Surface Moisture, and Foliar Moisture</span>
    <span class="org-variable-name">wind_speed_10m_x</span>              <span class="org-operator">=</span> inputs[<span class="org-string">"wind_speed_10m_x"</span>](t,y,x)
    <span class="org-variable-name">wind_speed_10m_y</span>              <span class="org-operator">=</span> inputs[<span class="org-string">"wind_speed_10m_y"</span>](t,y,x)
    <span class="org-variable-name">fuel_moisture_dead_1hr</span>        <span class="org-operator">=</span> inputs[<span class="org-string">"fuel_moisture_dead_1hr"</span>](t,y,x)
    <span class="org-variable-name">fuel_moisture_dead_10hr</span>       <span class="org-operator">=</span> inputs[<span class="org-string">"fuel_moisture_dead_10hr"</span>](t,y,x)
    <span class="org-variable-name">fuel_moisture_dead_100hr</span>      <span class="org-operator">=</span> inputs[<span class="org-string">"fuel_moisture_dead_100hr"</span>](t,y,x)
    <span class="org-variable-name">fuel_moisture_live_herbaceous</span> <span class="org-operator">=</span> inputs[<span class="org-string">"fuel_moisture_live_herbaceous"</span>](t,y,x)
    <span class="org-variable-name">fuel_moisture_live_woody</span>      <span class="org-operator">=</span> inputs[<span class="org-string">"fuel_moisture_live_woody"</span>](t,y,x)
    <span class="org-variable-name">foliar_moisture</span>               <span class="org-operator">=</span> inputs[<span class="org-string">"foliar_moisture"</span>](t,y,x)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Spread Rate Adjustments</span>
    <span class="org-variable-name">fuel_spread_adjustment</span>        <span class="org-operator">=</span> inputs.get(<span class="org-string">"fuel_spread_adjustment"</span>   , one_everywhere)(t,y,x)
    <span class="org-variable-name">weather_spread_adjustment</span>     <span class="org-operator">=</span> inputs.get(<span class="org-string">"weather_spread_adjustment"</span>, one_everywhere)(t,y,x)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Check Whether Cell is Burnable</span>
    <span class="org-variable-name">fuel_model</span> <span class="org-operator">=</span> fuel_model_table.get(fuel_model_number)
    <span class="org-keyword">if</span> <span class="org-keyword">not</span> (fuel_model <span class="org-keyword">and</span> fuel_model[<span class="org-string">"burnable"</span>]):
        <span class="org-keyword">return</span> {
            <span class="org-string">"max_spread_rate"</span>        : 0.0, <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
            <span class="org-string">"max_spread_direction"</span>   : 0.0, <span class="org-comment-delimiter"># </span><span class="org-comment">deg</span>
            <span class="org-string">"max_fire_line_intensity"</span>: 0.0, <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
            <span class="org-string">"max_flame_length"</span>       : 0.0, <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
            <span class="org-string">"fire_type"</span>              : 0,   <span class="org-comment-delimiter"># </span><span class="org-comment">0=unburned</span>
            <span class="org-string">"eccentricity"</span>           : 0.0, <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
        }
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Moisturized Fuel Model</span>
        <span class="org-variable-name">fuel_moisture</span>           <span class="org-operator">=</span> [fuel_moisture_dead_1hr,
                                   fuel_moisture_dead_10hr,
                                   fuel_moisture_dead_100hr,
                                   0.0, <span class="org-comment-delimiter"># </span><span class="org-comment">fuel_moisture_dead_herbaceous</span>
                                   fuel_moisture_live_herbaceous,
                                   fuel_moisture_live_woody]
        <span class="org-variable-name">moisturized_fuel_model</span>  <span class="org-operator">=</span> moisturize(fuel_model, fuel_moisture)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Baseline Surface Spread Rate, Residence Time, and Reaction Intensity</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Memoize rothermel_surface_fire_spread_no_wind_no_slope</span>
        <span class="org-variable-name">surface_fire_min</span>        <span class="org-operator">=</span> sf.rothermel_surface_fire_spread_no_wind_no_slope(moisturized_fuel_model)
        <span class="org-variable-name">residence_time</span>          <span class="org-operator">=</span> surface_fire_min[<span class="org-string">"residence_time"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">min</span>
        <span class="org-variable-name">reaction_intensity</span>      <span class="org-operator">=</span> surface_fire_min[<span class="org-string">"reaction_intensity"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">Btu/ft^2/min</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Midflame Wind Speed</span>
        <span class="org-variable-name">wind_speed_10m</span>          <span class="org-operator">=</span> sqrt(wind_speed_10m_x <span class="org-operator">**</span> 2.0 <span class="org-operator">+</span> wind_speed_10m_y <span class="org-operator">**</span> 2.0) <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
        <span class="org-variable-name">wind_speed_20ft</span>         <span class="org-operator">=</span> wind_speed_10m_to_wind_speed_20ft(wind_speed_10m) <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
        <span class="org-variable-name">wind_from_direction</span>     <span class="org-operator">=</span> (90.0 <span class="org-operator">-</span> degrees(atan2(wind_speed_10m_y, wind_speed_10m_x)) <span class="org-operator">%</span> 360.0) <span class="org-operator">%</span> 360.0 <span class="org-comment-delimiter"># </span><span class="org-comment">deg</span>
        <span class="org-variable-name">wind_adj_factor</span>         <span class="org-operator">=</span> sf.wind_adjustment_factor(fuel_model[<span class="org-string">"delta"</span>],
                                                            m_to_ft(canopy_height),
                                                            canopy_cover) <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
        <span class="org-variable-name">midflame_wind_speed</span>     <span class="org-operator">=</span> m_to_ft(wind_speed_20ft <span class="org-operator">*</span> wind_adj_factor) <span class="org-comment-delimiter"># </span><span class="org-comment">ft/min</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Max Surface Spread Rate/Direction and Surface Eccentricity</span>
        <span class="org-variable-name">spread_rate_adjustment</span>  <span class="org-operator">=</span> fuel_spread_adjustment <span class="org-operator">*</span> weather_spread_adjustment <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
        <span class="org-variable-name">surface_fire_max</span>        <span class="org-operator">=</span> sf.rothermel_surface_fire_spread_max(surface_fire_min,
                                                                       midflame_wind_speed,
                                                                       wind_from_direction,
                                                                       slope,
                                                                       aspect,
                                                                       spread_rate_adjustment)
        <span class="org-variable-name">max_surface_spread_rate</span> <span class="org-operator">=</span> surface_fire_max[<span class="org-string">"max_spread_rate"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">ft/min</span>
        <span class="org-variable-name">max_spread_direction</span>    <span class="org-operator">=</span> surface_fire_max[<span class="org-string">"max_spread_direction"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">deg</span>
        <span class="org-variable-name">surface_eccentricity</span>    <span class="org-operator">=</span> surface_fire_max[<span class="org-string">"eccentricity"</span>] <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Max Surface Intensity</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: The calculations to determine the fireline_normal_spread_rate have been elided.</span>
        <span class="org-comment-delimiter">#       </span><span class="org-comment">Consider ending this function here and making another function to compute the</span>
        <span class="org-comment-delimiter">#       </span><span class="org-comment">surface/crown values based on the provided perimeter spread direction.</span>
        <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>
        <span class="org-variable-name">max_flame_depth</span>         <span class="org-operator">=</span> sf.calc_flame_depth(max_surface_spread_rate, residence_time) <span class="org-comment-delimiter"># </span><span class="org-comment">ft</span>
        <span class="org-variable-name">max_surface_intensity</span>   <span class="org-operator">=</span> Btu_ft_s_to_kW_m(sf.calc_fire_line_intensity(reaction_intensity,
                                                                               max_flame_depth)) <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Check for Crown Fire Initiation</span>
        <span class="org-keyword">if</span> cf.van_wagner_crown_fire_initiation(canopy_cover,
                                               canopy_base_height,
                                               foliar_moisture,
                                               max_surface_intensity):
            <span class="org-comment-delimiter"># </span><span class="org-comment">Max Crown Spread Rate, Fire Type, and Crown Eccentricity</span>
            <span class="org-variable-name">max_crown_spread_rate</span> <span class="org-operator">=</span> m_to_ft(cf.cruz_crown_fire_spread(m_min_to_km_hr(wind_speed_10m),
                                                                      canopy_bulk_density,
                                                                      fuel_moisture_dead_1hr)) <span class="org-comment-delimiter"># </span><span class="org-comment">ft/min</span>
            <span class="org-variable-name">fire_type</span>             <span class="org-operator">=</span> 2 <span class="org-keyword">if</span> (max_crown_spread_rate <span class="org-operator">&lt;</span> 0.0) <span class="org-keyword">else</span> 3 <span class="org-comment-delimiter"># </span><span class="org-comment">2=passive crown, 3=active crown</span>
            <span class="org-variable-name">max_crown_spread_rate</span> <span class="org-operator">=</span> <span class="org-builtin">abs</span>(max_crown_spread_rate) <span class="org-comment-delimiter"># </span><span class="org-comment">ft/min</span>
            <span class="org-variable-name">crown_eccentricity</span>    <span class="org-operator">=</span> (surface_eccentricity
                                     <span class="org-keyword">if</span> (max_surface_spread_rate <span class="org-operator">&gt;</span> max_crown_spread_rate)
                                     <span class="org-keyword">else</span> cf.crown_fire_eccentricity(m_min_to_mph(wind_speed_20ft))) <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: The calculations to determine the fireline_normal_spread_rate have been elided.</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">=======================================================================================</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Max Crown Intensity</span>
            <span class="org-variable-name">max_crown_intensity</span>   <span class="org-operator">=</span> cf.crown_fire_line_intensity(ft_to_m(max_crown_spread_rate),
                                                                 canopy_bulk_density,
                                                                 (canopy_height <span class="org-operator">-</span> canopy_base_height),
                                                                 Btu_lb_to_kJ_kg(fuel_model[<span class="org-string">"h"</span>][0])) <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Max Combined Spread Rate, Intensity, and Flame Length</span>
            <span class="org-variable-name">max_spread_rate</span>       <span class="org-operator">=</span> ft_to_m(<span class="org-builtin">max</span>(max_surface_spread_rate, max_crown_spread_rate)) <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
            <span class="org-variable-name">max_intensity</span>         <span class="org-operator">=</span> max_surface_intensity <span class="org-operator">+</span> max_crown_intensity <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
            <span class="org-variable-name">max_flame_length</span>      <span class="org-operator">=</span> ft_to_m(sf.calc_flame_length(kW_m_to_Btu_ft_s(max_intensity))) <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Return Fire Behavior Values</span>
            <span class="org-keyword">return</span> {
                <span class="org-string">"max_spread_rate"</span>        : max_spread_rate,      <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
                <span class="org-string">"max_spread_direction"</span>   : max_spread_direction, <span class="org-comment-delimiter"># </span><span class="org-comment">deg</span>
                <span class="org-string">"max_fire_line_intensity"</span>: max_intensity,        <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
                <span class="org-string">"max_flame_length"</span>       : max_flame_length,     <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
                <span class="org-string">"fire_type"</span>              : fire_type,            <span class="org-comment-delimiter"># </span><span class="org-comment">2=passive crown, 3=active crown</span>
                <span class="org-string">"eccentricity"</span>           : crown_eccentricity,   <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
            }
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">fire_type</span>                <span class="org-operator">=</span> 1 <span class="org-comment-delimiter"># </span><span class="org-comment">1=surface</span>
            <span class="org-variable-name">max_surface_flame_length</span> <span class="org-operator">=</span> ft_to_m(sf.calc_flame_length(kW_m_to_Btu_ft_s(max_surface_intensity))) <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
            <span class="org-keyword">return</span> {
                <span class="org-string">"max_spread_rate"</span>        : ft_to_m(max_surface_spread_rate), <span class="org-comment-delimiter"># </span><span class="org-comment">m/min</span>
                <span class="org-string">"max_spread_direction"</span>   : max_spread_direction,             <span class="org-comment-delimiter"># </span><span class="org-comment">deg</span>
                <span class="org-string">"max_fire_line_intensity"</span>: max_surface_intensity,            <span class="org-comment-delimiter"># </span><span class="org-comment">kW/m</span>
                <span class="org-string">"max_flame_length"</span>       : max_surface_flame_length,         <span class="org-comment-delimiter"># </span><span class="org-comment">m</span>
                <span class="org-string">"fire_type"</span>              : fire_type,                        <span class="org-comment-delimiter"># </span><span class="org-comment">1=surface</span>
                <span class="org-string">"eccentricity"</span>           : surface_eccentricity,             <span class="org-comment-delimiter"># </span><span class="org-comment">unitless</span>
            }
</pre>
</div>
</div>
</div>
<div id="outline-container-orgdafc07e" class="outline-2">
<h2 id="orgdafc07e"><span class="section-number-2">14.</span> [WIP] Loading LANDFIRE Inputs</h2>
<div class="outline-text-2" id="text-14">
<p>
To test out the <code>burn_cells</code> function, we will need to populate a 3D
space-time world cube with all of the values that it requires. In this
section, we will provide the space-varying topography, fuels, and
vegetation layers by using the latest 30m raster layers from the US
LANDFIRE program.<sup><a id="fnr.27" class="footref" href="#fn.27" role="doc-backlink">27</a></sup>
</p>

<table id="org51b3d6f">
<caption class="t-above"><span class="table-number">Table 3:</span> 2022 LANDFIRE Raster Layers</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Layer Name</th>
<th scope="col" class="org-left">Label</th>
<th scope="col" class="org-left">Units</th>
<th scope="col" class="org-right">Min</th>
<th scope="col" class="org-right">Max</th>
<th scope="col" class="org-right">NoData</th>
<th scope="col" class="org-left">Notes</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">SRID</th>
<th scope="col" class="org-left">Cell Size</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Elevation</td>
<td class="org-left">DEM</td>
<td class="org-left">meters above sea level</td>
<td class="org-right">0</td>
<td class="org-right">8850</td>
<td class="org-right">32767</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Slope</td>
<td class="org-left">SLP</td>
<td class="org-left">percent (100 * meters rise / meters run)</td>
<td class="org-right">0</td>
<td class="org-right">400</td>
<td class="org-right">32767</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Aspect</td>
<td class="org-left">ASP</td>
<td class="org-left">degrees CW from North</td>
<td class="org-right">0</td>
<td class="org-right">359</td>
<td class="org-right">32767</td>
<td class="org-left">-1 = no slope</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Fuel Model (S&amp;B 40)</td>
<td class="org-left">FBFM40</td>
<td class="org-left">integer classes</td>
<td class="org-right">91</td>
<td class="org-right">204</td>
<td class="org-right">32767</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Canopy Cover</td>
<td class="org-left">CC</td>
<td class="org-left">percent (100 * canopy area / total area)</td>
<td class="org-right">0</td>
<td class="org-right">95</td>
<td class="org-right">32767</td>
<td class="org-left">0 = no canopy</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Canopy Height</td>
<td class="org-left">CH</td>
<td class="org-left">meters * 10</td>
<td class="org-right">0</td>
<td class="org-right">510</td>
<td class="org-right">32767</td>
<td class="org-left">0 = no canopy</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Canopy Base Height</td>
<td class="org-left">CBH</td>
<td class="org-left">meters * 10</td>
<td class="org-right">0</td>
<td class="org-right">100</td>
<td class="org-right">32767</td>
<td class="org-left">0 = no canopy</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>

<tr>
<td class="org-left">Canopy Bulk Density</td>
<td class="org-left">CBD</td>
<td class="org-left">kg/m^3 * 100</td>
<td class="org-right">0</td>
<td class="org-right">45</td>
<td class="org-right">32767</td>
<td class="org-left">0 = no canopy</td>
<td class="org-left">int16</td>
<td class="org-left">EPSG:5070</td>
<td class="org-left">30m x 30m</td>
</tr>
</tbody>
</table>
</div>
<div id="outline-container-orgfaa8441" class="outline-3">
<h3 id="orgfaa8441"><span class="section-number-3">14.1.</span> Loading Raster Files with Python Rasterio</h3>
<div class="outline-text-3" id="text-14-1">
<p>
We will begin by defining a <code>load_raster</code> function that takes a path
to a raster file (e.g., a GeoTIFF) and returns a dictionary containing
these keys:
</p>

<dl class="org-dl">
<dt>array</dt><dd>raster data as a 3D Numpy array <code>(bands, rows, cols)</code> of the specified <code>dtype</code> (default: <code>float32</code>)</dd>
<dt>metadata</dt><dd>dictionary of raster metadata values (e.g., number of bands/rows/cols, band dtypes, nodata value, georeferencing info)</dd>
</dl>

<div class="org-src-container">
<pre class="src src-python" id="org5cb50e2"><span class="org-keyword">import</span> rasterio

<span class="org-keyword">def</span> <span class="org-function-name">raster_metadata</span>(raster):
    <span class="org-keyword">return</span> {
        <span class="org-string">"name"</span>      : raster.name,
        <span class="org-string">"bands"</span>     : raster.count,
        <span class="org-string">"rows"</span>      : raster.height,
        <span class="org-string">"cols"</span>      : raster.width,
        <span class="org-string">"band_types"</span>: {i: dtype <span class="org-keyword">for</span> i, dtype <span class="org-keyword">in</span> <span class="org-builtin">zip</span>(raster.indexes, raster.dtypes)},
        <span class="org-string">"nodata"</span>    : raster.nodata,
        <span class="org-string">"crs"</span>       : raster.crs,
        <span class="org-string">"bounds"</span>    : raster.bounds,
        <span class="org-string">"transform"</span> : raster.transform,
    }


<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: rasterio.open can also load chunks of a raster file: https://pypi.org/project/rasterio/</span>
<span class="org-keyword">def</span> <span class="org-function-name">load_raster</span>(file_path, dtype<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-keyword">with</span> rasterio.<span class="org-builtin">open</span>(file_path, <span class="org-string">"r"</span>) <span class="org-keyword">as</span> input_raster:
        <span class="org-keyword">return</span> {
            <span class="org-string">"array"</span>   : input_raster.read(out_dtype<span class="org-operator">=</span>dtype),
            <span class="org-string">"metadata"</span>: raster_metadata(input_raster),
        }
</pre>
</div>
</div>
</div>
<div id="outline-container-org1f80f77" class="outline-3">
<h3 id="org1f80f77"><span class="section-number-3">14.2.</span> Convert LANDFIRE Units and Datatypes</h3>
<div class="outline-text-3" id="text-14-2">
<p>
The units and datatypes of our LANDFIRE GeoTIFFs are documented in
Table <a href="#org51b3d6f">3</a>. In order to make them match those required
by the Pyretechnics Fire Spread API, we need to apply some conversions
during the layer loading process.
</p>

<div class="org-src-container">
<pre class="src src-python" id="orgf0d2fb6"><span class="org-variable-name">landfire_array_conversions</span> <span class="org-operator">=</span> {
    <span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Layer Name         : (New dtype, Mult), # New Units                [Min-Max]</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================================</span>
    <span class="org-string">"elevation"</span>          : (<span class="org-string">"float32"</span>, 1.00), <span class="org-comment-delimiter"># </span><span class="org-comment">meters above sea level   [0-8850]</span>
    <span class="org-string">"slope"</span>              : (<span class="org-string">"float32"</span>, 0.01), <span class="org-comment-delimiter"># </span><span class="org-comment">meters rise / meters run [0-4]</span>
    <span class="org-string">"aspect"</span>             : (<span class="org-string">"int16"</span>  , 1   ), <span class="org-comment-delimiter"># </span><span class="org-comment">degrees CW from North    [0-359]</span>
    <span class="org-string">"fuel_model"</span>         : (<span class="org-string">"int16"</span>  , 1   ), <span class="org-comment-delimiter"># </span><span class="org-comment">integer classes          [1-204]</span>
    <span class="org-string">"canopy_cover"</span>       : (<span class="org-string">"float32"</span>, 0.01), <span class="org-comment-delimiter"># </span><span class="org-comment">canopy area / total area [0-0.95]</span>
    <span class="org-string">"canopy_height"</span>      : (<span class="org-string">"float32"</span>, 0.10), <span class="org-comment-delimiter"># </span><span class="org-comment">meters                   [0-51]</span>
    <span class="org-string">"canopy_base_height"</span> : (<span class="org-string">"float32"</span>, 0.10), <span class="org-comment-delimiter"># </span><span class="org-comment">meters                   [0-10]</span>
    <span class="org-string">"canopy_bulk_density"</span>: (<span class="org-string">"float32"</span>, 0.01), <span class="org-comment-delimiter"># </span><span class="org-comment">kilograms/meters^3       [0-0.45]</span>
}


<span class="org-keyword">def</span> <span class="org-function-name">load_and_convert_landfire_rasters</span>(landfire_file_paths):
    <span class="org-variable-name">landfire_rasters</span> <span class="org-operator">=</span> {}

    <span class="org-keyword">for</span> name, path <span class="org-keyword">in</span> landfire_file_paths.items():
        (<span class="org-variable-name">dtype</span>, <span class="org-variable-name">multiplier</span>) <span class="org-operator">=</span> landfire_array_conversions[name]
        <span class="org-variable-name">landfire_rasters</span>[name] <span class="org-operator">=</span> load_raster(path, dtype)
        <span class="org-keyword">if</span> multiplier <span class="org-operator">!=</span> 1:
            <span class="org-variable-name">array</span>  <span class="org-operator">=</span> landfire_rasters[name][<span class="org-string">"array"</span>]
            <span class="org-variable-name">nodata</span> <span class="org-operator">=</span> landfire_rasters[name][<span class="org-string">"metadata"</span>][<span class="org-string">"nodata"</span>]
            <span class="org-variable-name">array</span>[array <span class="org-operator">!=</span> nodata] <span class="org-operator">*=</span> multiplier

    <span class="org-keyword">return</span> landfire_rasters
</pre>
</div>
</div>
</div>
<div id="outline-container-orge299621" class="outline-3">
<h3 id="orge299621"><span class="section-number-3">14.3.</span> Verifying Raster Constraints</h3>
<div class="outline-text-3" id="text-14-3">
<p>
In order to work with the Pyretechnics Fire Spread API, all rasters
must meet certain requirements:
</p>

<p>
<b>TODO: Extend this to support multi-resolution rasters.</b>
</p>

<ol class="org-ol">
<li>All rasters must share the same array shape <code>(bands, rows, cols)</code>.</li>
<li>All rasters must share the same spatial extent and projection.</li>
</ol>

<p>
Below we implement functions to check these constraints:
</p>

<div class="org-src-container">
<pre class="src src-python" id="org70412a7"><span class="org-keyword">def</span> <span class="org-function-name">verify_same_dimensions</span>(rasters):
    <span class="org-variable-name">dimensions</span> <span class="org-operator">=</span> [
        (r[<span class="org-string">"metadata"</span>][<span class="org-string">"bands"</span>],
         r[<span class="org-string">"metadata"</span>][<span class="org-string">"rows"</span>],
         r[<span class="org-string">"metadata"</span>][<span class="org-string">"cols"</span>])
        <span class="org-keyword">for</span> r <span class="org-keyword">in</span> rasters
    ]
    <span class="org-keyword">if</span> <span class="org-builtin">len</span>(<span class="org-builtin">set</span>(dimensions)) <span class="org-operator">==</span> 1:
        <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">else</span>:
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"All rasters do not share the same dimensions."</span>)


<span class="org-keyword">def</span> <span class="org-function-name">verify_same_georeferences</span>(rasters):
    <span class="org-variable-name">georeferences</span> <span class="org-operator">=</span> [
        (r[<span class="org-string">"metadata"</span>][<span class="org-string">"crs"</span>],
         r[<span class="org-string">"metadata"</span>][<span class="org-string">"bounds"</span>],
         r[<span class="org-string">"metadata"</span>][<span class="org-string">"transform"</span>])
        <span class="org-keyword">for</span> r <span class="org-keyword">in</span> rasters
    ]
    <span class="org-keyword">if</span> <span class="org-builtin">len</span>(<span class="org-builtin">set</span>(georeferences)) <span class="org-operator">==</span> 1:
        <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">else</span>:
        <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">"All rasters do not share the same georeferences."</span>)


<span class="org-keyword">def</span> <span class="org-function-name">verify_raster_constraints</span>(rasters):
    <span class="org-keyword">return</span> verify_same_dimensions(rasters) <span class="org-keyword">and</span> verify_same_georeferences(rasters)
</pre>
</div>
</div>
</div>
<div id="outline-container-org8a87c26" class="outline-3">
<h3 id="org8a87c26"><span class="section-number-3">14.4.</span> Converting Rasters to 3D Lookup Functions</h3>
<div class="outline-text-3" id="text-14-4">
<p>
Another requirement of the Pyretechnics Fire Spread API is that each
input layer must be specified as a 3D space-time lookup function. This
abstracts away the underlying data representation (e.g. an ND array, a
single constant value, a random sampling function), allowing many
different sources of information to interoperate through a simple
unified interface.
</p>

<p>
For our LANDFIRE use case, the following function converts a
dictionary of single-band rasters <code>(1, rows, cols)</code> into a dictionary
of 3D anonymous functions, that always return the same value for each
<code>(t,y,x)</code> coordinate regardless of the time value <code>t</code> specified.
</p>

<div class="org-src-container">
<pre class="src src-python" id="orgc1c8e17"><span class="org-comment-delimiter"># </span><span class="org-comment">TODO: This does not use the lazy chunking, multi-resolution functions defined earlier.</span>
<span class="org-keyword">def</span> <span class="org-function-name">convert_rasters_to_2d_fns</span>(raster_dict):
    <span class="org-variable-name">fn_dict</span> <span class="org-operator">=</span> {}

    <span class="org-keyword">for</span> name, raster <span class="org-keyword">in</span> raster_dict.items():
        <span class="org-variable-name">fn_dict</span>[name] <span class="org-operator">=</span> (<span class="org-keyword">lambda</span> array: <span class="org-keyword">lambda</span> t,y,x: array[0,y,x])(raster[<span class="org-string">"array"</span>])

    <span class="org-keyword">return</span> fn_dict
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf7e7390" class="outline-3">
<h3 id="orgf7e7390"><span class="section-number-3">14.5.</span> Putting It All Together</h3>
<div class="outline-text-3" id="text-14-5">
<p>
By combining the functions defined in the previous sections, we can
now read in a dictionary of layer names to file paths, load the
associated rasters and apply the correct dtype and unit conversions,
verify all of our raster constraints, and wrap each raster's array
with a 3D lookup function.
</p>

<div class="org-src-container">
<pre class="src src-python" id="orga361ad6"><span class="org-keyword">def</span> <span class="org-function-name">read_landfire_rasters_as_pyretechnics_inputs</span>(landfire_file_paths):
    <span class="org-variable-name">landfire_rasters</span> <span class="org-operator">=</span> load_and_convert_landfire_rasters(landfire_file_paths)
    <span class="org-keyword">if</span> verify_raster_constraints(landfire_rasters.values()):
        <span class="org-keyword">return</span> convert_rasters_to_2d_fns(landfire_rasters)
</pre>
</div>

<p>
We will use this function to load a clipped set of LANDFIRE GeoTIFFs
in section <a href="#org77115bf">15</a>.
</p>
</div>
</div>
</div>
<div id="outline-container-org77115bf" class="outline-2">
<h2 id="org77115bf"><span class="section-number-2">15.</span> [WIP] Testing burn_cells on Worcester, VT</h2>
<div class="outline-text-2" id="text-15">
<p>
For testing purposes, we have downloaded these layers, clipped to a
small region in central Vermont, and stored them in the
<a href="../test/data/landfire_inputs">../test/data/landfire_inputs</a> directory of this repository.
</p>
</div>
<div id="outline-container-org3f77282" class="outline-3">
<h3 id="org3f77282"><span class="section-number-3">15.1.</span> Loading Topography, Fuel Model, and Vegetation Inputs from LANDFIRE GeoTIFFs</h3>
<div class="outline-text-3" id="text-15-1">
<p>
We begin by loading in the eight LANDFIRE GeoTIFFs that we downloaded
from <a href="https://landfire.gov">https://landfire.gov</a>, using the function we defined in section
<a href="#orgf7e7390">14.5</a>.
</p>

<div class="org-src-container">
<pre class="src src-python" id="orgba5c562"><span class="org-keyword">import</span> os
<span class="org-keyword">from</span> pyretechnics.load_landfire <span class="org-keyword">import</span> read_landfire_rasters_as_pyretechnics_inputs

<span class="org-keyword">def</span> <span class="org-function-name">get_project_root</span>(current_dir<span class="org-operator">=</span>os.curdir):
    <span class="org-doc">"""</span>
<span class="org-doc">    Search up the directory tree from current_dir until we find a directory containing guix.scm,</span>
<span class="org-doc">    and return this directory path. If the filesystem root directory (/) is reached, return None.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">if</span> current_dir <span class="org-operator">==</span> <span class="org-string">"/"</span>:
        <span class="org-keyword">return</span> <span class="org-constant">None</span>
    <span class="org-keyword">elif</span> os.path.exists(current_dir <span class="org-operator">+</span> <span class="org-string">"/guix.scm"</span>):
        <span class="org-keyword">return</span> current_dir
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> get_project_root(os.path.dirname(os.path.abspath(current_dir)))


<span class="org-variable-name">project_root</span> <span class="org-operator">=</span> get_project_root()


<span class="org-variable-name">landfire_file_paths</span> <span class="org-operator">=</span> {
    <span class="org-string">"elevation"</span>          : project_root <span class="org-operator">+</span> <span class="org-string">"/test/data/landfire_inputs/LF2020_Elev_220_CONUS/LC20_Elev_220.tif"</span>,
    <span class="org-string">"slope"</span>              : project_root <span class="org-operator">+</span> <span class="org-string">"/test/data/landfire_inputs/LF2020_SlpP_220_CONUS/LC20_SlpP_220.tif"</span>,
    <span class="org-string">"aspect"</span>             : project_root <span class="org-operator">+</span> <span class="org-string">"/test/data/landfire_inputs/LF2020_Asp_220_CONUS/LC20_Asp_220.tif"</span>,
    <span class="org-string">"fuel_model"</span>         : project_root <span class="org-operator">+</span> <span class="org-string">"/test/data/landfire_inputs/LF2022_FBFM40_230_CONUS/LC22_F40_230.tif"</span>,
    <span class="org-string">"canopy_cover"</span>       : project_root <span class="org-operator">+</span> <span class="org-string">"/test/data/landfire_inputs/LF2022_CC_230_CONUS/LC22_CC_230.tif"</span>,
    <span class="org-string">"canopy_height"</span>      : project_root <span class="org-operator">+</span> <span class="org-string">"/test/data/landfire_inputs/LF2022_CH_230_CONUS/LC22_CH_230.tif"</span>,
    <span class="org-string">"canopy_base_height"</span> : project_root <span class="org-operator">+</span> <span class="org-string">"/test/data/landfire_inputs/LF2022_CBH_230_CONUS/LC22_CBH_230.tif"</span>,
    <span class="org-string">"canopy_bulk_density"</span>: project_root <span class="org-operator">+</span> <span class="org-string">"/test/data/landfire_inputs/LF2022_CBD_230_CONUS/LC22_CBD_230.tif"</span>,
}


<span class="org-keyword">def</span> <span class="org-function-name">test_read_landfire_rasters</span>():
    <span class="org-variable-name">input_layer_dict</span> <span class="org-operator">=</span> read_landfire_rasters_as_pyretechnics_inputs(landfire_file_paths)
    <span class="org-keyword">assert</span> <span class="org-builtin">type</span>(input_layer_dict) <span class="org-operator">==</span> <span class="org-builtin">dict</span>
    <span class="org-keyword">assert</span> input_layer_dict.keys() <span class="org-operator">==</span> landfire_file_paths.keys()
    <span class="org-keyword">assert</span> <span class="org-builtin">all</span>(<span class="org-builtin">map</span>(<span class="org-keyword">lambda</span> v: <span class="org-builtin">callable</span>(v), input_layer_dict.values()))
    <span class="org-keyword">return</span> input_layer_dict
</pre>
</div>
</div>
</div>
<div id="outline-container-orgdeb9a46" class="outline-3">
<h3 id="orgdeb9a46"><span class="section-number-3">15.2.</span> Adding Constant Wind and Moisture Values</h3>
<div class="outline-text-3" id="text-15-2">
<p>
In order to complete our input dataset for a test run of the
<code>burn_cells</code> function, we need to provide the remaining required wind
and moisture layers as 3D lookup functions. The following example
shows how we can easily set constant values for each of these layers:
</p>

<div class="org-src-container">
<pre class="src src-python" id="org8a149f1"><span class="org-variable-name">weather_functions</span> <span class="org-operator">=</span> {
    <span class="org-string">"wind_speed_10m_x"</span>             : <span class="org-keyword">lambda</span> t,y,x: 0.00, <span class="org-comment-delimiter"># </span><span class="org-comment">meters/minute</span>
    <span class="org-string">"wind_speed_10m_y"</span>             : <span class="org-keyword">lambda</span> t,y,x: 0.00, <span class="org-comment-delimiter"># </span><span class="org-comment">meters/minute</span>
    <span class="org-string">"fuel_moisture_dead_1hr"</span>       : <span class="org-keyword">lambda</span> t,y,x: 0.06, <span class="org-comment-delimiter"># </span><span class="org-comment">ratio [0-1+] grams moisture/grams ovendry wood</span>
    <span class="org-string">"fuel_moisture_dead_10hr"</span>      : <span class="org-keyword">lambda</span> t,y,x: 0.08, <span class="org-comment-delimiter"># </span><span class="org-comment">ratio [0-1+] grams moisture/grams ovendry wood</span>
    <span class="org-string">"fuel_moisture_dead_100hr"</span>     : <span class="org-keyword">lambda</span> t,y,x: 0.10, <span class="org-comment-delimiter"># </span><span class="org-comment">ratio [0-1+] grams moisture/grams ovendry wood</span>
    <span class="org-string">"fuel_moisture_live_herbaceous"</span>: <span class="org-keyword">lambda</span> t,y,x: 0.75, <span class="org-comment-delimiter"># </span><span class="org-comment">ratio [0-1+] grams moisture/grams ovendry wood</span>
    <span class="org-string">"fuel_moisture_live_woody"</span>     : <span class="org-keyword">lambda</span> t,y,x: 0.60, <span class="org-comment-delimiter"># </span><span class="org-comment">ratio [0-1+] grams moisture/grams ovendry wood</span>
    <span class="org-string">"foliar_moisture"</span>              : <span class="org-keyword">lambda</span> t,y,x: 1.20, <span class="org-comment-delimiter"># </span><span class="org-comment">ratio [0-1+] grams moisture/grams ovendry foliage</span>
}


<span class="org-keyword">def</span> <span class="org-function-name">test_add_weather_functions</span>():
    <span class="org-variable-name">input_layer_dict</span> <span class="org-operator">=</span> test_read_landfire_rasters()
    input_layer_dict.update(weather_functions)
    <span class="org-keyword">assert</span> <span class="org-builtin">type</span>(input_layer_dict) <span class="org-operator">==</span> <span class="org-builtin">dict</span>
    <span class="org-keyword">assert</span> <span class="org-builtin">set</span>(input_layer_dict.keys()) <span class="org-operator">==</span> <span class="org-builtin">set</span>(landfire_file_paths.keys()).union(<span class="org-builtin">set</span>(weather_functions.keys()))
    <span class="org-keyword">assert</span> <span class="org-builtin">all</span>(<span class="org-builtin">map</span>(<span class="org-keyword">lambda</span> v: <span class="org-builtin">callable</span>(v), input_layer_dict.values()))
    <span class="org-keyword">return</span> input_layer_dict
</pre>
</div>
</div>
</div>
<div id="outline-container-org97d1bbf" class="outline-3">
<h3 id="org97d1bbf"><span class="section-number-3">15.3.</span> Burning a Single Cell in the Dataset</h3>
<div class="outline-text-3" id="text-15-3">
<p>
Now that our input layers are all loaded, our next step will be to
make sure that we can burn a single cell as a head fire and get back
meaningful results.
</p>

<div class="org-src-container">
<pre class="src src-python" id="org4a8e0cb"><span class="org-keyword">from</span> pyretechnics.burn_cells <span class="org-keyword">import</span> compute_max_in_situ_values

<span class="org-keyword">def</span> <span class="org-function-name">test_burn_one_cell</span>():
    <span class="org-variable-name">input_layer_dict</span> <span class="org-operator">=</span> test_add_weather_functions()
    (<span class="org-variable-name">t</span>,<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>) <span class="org-operator">=</span> (0,100,100)
    <span class="org-variable-name">result</span> <span class="org-operator">=</span> compute_max_in_situ_values(input_layer_dict, t, y, x)
    <span class="org-keyword">assert</span> result <span class="org-operator">==</span> {
        <span class="org-string">"max_spread_rate"</span>        : 0.32044995422500566,
        <span class="org-string">"max_spread_direction"</span>   : 41.0,
        <span class="org-string">"max_fire_line_intensity"</span>: 26.661398424207746,
        <span class="org-string">"max_flame_length"</span>       : 0.35078585296988984,
        <span class="org-string">"fire_type"</span>              : 1,
        <span class="org-string">"eccentricity"</span>           : 0.5583790663230914,
    }
    <span class="org-keyword">return</span> result
</pre>
</div>
</div>
</div>
<div id="outline-container-org291f40e" class="outline-3">
<h3 id="org291f40e"><span class="section-number-3">15.4.</span> Running Burn Cells on the Test Dataset</h3>
<div class="outline-text-3" id="text-15-4">
<div class="org-src-container">
<pre class="src src-python" id="orgd9a6bd9"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np

<span class="org-keyword">def</span> <span class="org-function-name">slow_test_burn_all_cells</span>():
    <span class="org-comment-delimiter"># </span><span class="org-comment">TODO: Extract these dimensions from the input layers</span>
    <span class="org-variable-name">rows</span> <span class="org-operator">=</span> 613
    <span class="org-variable-name">cols</span> <span class="org-operator">=</span> 549

    <span class="org-variable-name">max_spread_rate_matrix</span>         <span class="org-operator">=</span> np.zeros((rows, cols), dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)
    <span class="org-variable-name">max_spread_direction_matrix</span>    <span class="org-operator">=</span> np.zeros((rows, cols), dtype<span class="org-operator">=</span><span class="org-string">"int16"</span>)
    <span class="org-variable-name">max_fire_line_intensity_matrix</span> <span class="org-operator">=</span> np.zeros((rows, cols), dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)
    <span class="org-variable-name">max_flame_length_matrix</span>        <span class="org-operator">=</span> np.zeros((rows, cols), dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)
    <span class="org-variable-name">fire_type_matrix</span>               <span class="org-operator">=</span> np.zeros((rows, cols), dtype<span class="org-operator">=</span><span class="org-string">"uint8"</span>)
    <span class="org-variable-name">eccentricity_matrix</span>            <span class="org-operator">=</span> np.zeros((rows, cols), dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)

    <span class="org-variable-name">input_layer_dict</span> <span class="org-operator">=</span> test_add_weather_functions()

    <span class="org-keyword">for</span> y <span class="org-keyword">in</span> <span class="org-builtin">range</span>(rows):
        <span class="org-keyword">for</span> x <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cols):
            <span class="org-variable-name">results</span>                             <span class="org-operator">=</span> compute_max_in_situ_values(input_layer_dict, 0, y, x)
            <span class="org-variable-name">max_spread_rate_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]         <span class="org-operator">=</span> results[<span class="org-string">"max_spread_rate"</span>]
            <span class="org-variable-name">max_spread_direction_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]    <span class="org-operator">=</span> results[<span class="org-string">"max_spread_direction"</span>]
            <span class="org-variable-name">max_fire_line_intensity_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>] <span class="org-operator">=</span> results[<span class="org-string">"max_fire_line_intensity"</span>]
            <span class="org-variable-name">max_flame_length_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]        <span class="org-operator">=</span> results[<span class="org-string">"max_flame_length"</span>]
            <span class="org-variable-name">fire_type_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]               <span class="org-operator">=</span> results[<span class="org-string">"fire_type"</span>]
            <span class="org-variable-name">eccentricity_matrix</span>[<span class="org-variable-name">y</span>,<span class="org-variable-name">x</span>]            <span class="org-operator">=</span> results[<span class="org-string">"eccentricity"</span>]

    <span class="org-keyword">return</span> {
        <span class="org-string">"max_spread_rate"</span>        : max_spread_rate_matrix,
        <span class="org-string">"max_spread_direction"</span>   : max_spread_direction_matrix,
        <span class="org-string">"max_fire_line_intensity"</span>: max_fire_line_intensity_matrix,
        <span class="org-string">"max_flame_length"</span>       : max_flame_length_matrix,
        <span class="org-string">"fire_type"</span>              : fire_type_matrix,
        <span class="org-string">"eccentricity"</span>           : eccentricity_matrix,
    }
</pre>
</div>
</div>
</div>
<div id="outline-container-org29e515e" class="outline-3">
<h3 id="org29e515e"><span class="section-number-3">15.5.</span> Visualizing the Burned Layers</h3>
<div class="outline-text-3" id="text-15-5">
<div class="org-src-container">
<pre class="src src-python" id="org129ccd9"><span class="org-keyword">from</span> pyretechnics_test.test_burn_cells <span class="org-keyword">import</span> slow_test_burn_all_cells, slow_test_read_flammap_outputs

<span class="org-variable-name">pyretechnics</span> <span class="org-operator">=</span> slow_test_burn_all_cells()
<span class="org-variable-name">flammap</span>      <span class="org-operator">=</span> slow_test_read_flammap_outputs()
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python" id="orgb51ba7d"><span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt

<span class="org-variable-name">title</span>     <span class="org-operator">=</span> <span class="org-string">"Worcester, VT - "</span> <span class="org-operator">+</span> title
<span class="org-variable-name">file_name</span> <span class="org-operator">=</span> <span class="org-string">"../doc/pics/worcester_"</span> <span class="org-operator">+</span> layer <span class="org-operator">+</span> <span class="org-string">".png"</span>
<span class="org-variable-name">image</span>     <span class="org-operator">=</span> plt.imshow(pyretechnics[layer], cmap<span class="org-operator">=</span>colors)
<span class="org-comment-delimiter"># </span><span class="org-comment">image     = plt.imshow(flammap[layer][0], cmap=colors)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">image     = plt.imshow(pyretechnics[layer] - flammap[layer][0], cmap=colors)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">copy      = np.zeros((613, 549))</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">copy[crown_fire == 0] = (pyretechnics[layer][crown_fire == 0] - flammap[layer][0][crown_fire == 0])</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">image     = plt.imshow(copy, clim=(-0.05,0.05))</span>
<span class="org-variable-name">colorbar</span>  <span class="org-operator">=</span> plt.colorbar(image, orientation<span class="org-operator">=</span><span class="org-string">"vertical"</span>)

colorbar.set_label(units)
plt.title(title)
plt.savefig(file_name)
plt.close(<span class="org-string">"all"</span>)
file_name
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">frq</span>, <span class="org-variable-name">edges</span> <span class="org-operator">=</span> np.histogram(copy)
<span class="org-variable-name">fig</span>, <span class="org-variable-name">ax</span> <span class="org-operator">=</span> plt.subplots()
ax.bar(edges[:<span class="org-operator">-</span>1], frq, width<span class="org-operator">=</span>np.diff(edges), edgecolor<span class="org-operator">=</span><span class="org-string">"black"</span>, align<span class="org-operator">=</span><span class="org-string">"edge"</span>)
plt.savefig(<span class="org-string">"../doc/pics/worcester_max_spread_rate_diff.png"</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-operator">&lt;&lt;</span>savefig(title<span class="org-operator">=</span><span class="org-string">"Max Spread Rate"</span>, layer<span class="org-operator">=</span><span class="org-string">"max_spread_rate"</span>, units<span class="org-operator">=</span><span class="org-string">"m/min"</span>, colors<span class="org-operator">=</span><span class="org-string">"hot"</span>)<span class="org-operator">&gt;&gt;</span>
</pre>
</div>


<div id="org8360875" class="figure">
<p><img src="../doc/pics/worcester_max_spread_rate.png" alt="worcester_max_spread_rate.png">
</p>
</div>

<p>
Layer Disagreement: [-10.93608, 8.9857025] inches/min
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-operator">&lt;&lt;</span>savefig(title<span class="org-operator">=</span><span class="org-string">"Max Spread Direction"</span>, layer<span class="org-operator">=</span><span class="org-string">"max_spread_direction"</span>, units<span class="org-operator">=</span><span class="org-string">"degrees"</span>, colors<span class="org-operator">=</span><span class="org-string">"viridis"</span>)<span class="org-operator">&gt;&gt;</span>
</pre>
</div>


<div id="org2b15c5b" class="figure">
<p><img src="../doc/pics/worcester_max_spread_direction.png" alt="worcester_max_spread_direction.png">
</p>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-operator">&lt;&lt;</span>savefig(title<span class="org-operator">=</span><span class="org-string">"Max Fire Line Intensity"</span>, layer<span class="org-operator">=</span><span class="org-string">"max_fire_line_intensity"</span>, units<span class="org-operator">=</span><span class="org-string">"kW/m"</span>, colors<span class="org-operator">=</span><span class="org-string">"hot"</span>)<span class="org-operator">&gt;&gt;</span>
</pre>
</div>


<div id="org1a4aff0" class="figure">
<p><img src="../doc/pics/worcester_max_fire_line_intensity.png" alt="worcester_max_fire_line_intensity.png">
</p>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-operator">&lt;&lt;</span>savefig(title<span class="org-operator">=</span><span class="org-string">"Max Flame Length"</span>, layer<span class="org-operator">=</span><span class="org-string">"max_flame_length"</span>, units<span class="org-operator">=</span><span class="org-string">"m"</span>, colors<span class="org-operator">=</span><span class="org-string">"hot"</span>)<span class="org-operator">&gt;&gt;</span>
</pre>
</div>


<div id="org8612b13" class="figure">
<p><img src="../doc/pics/worcester_max_flame_length.png" alt="worcester_max_flame_length.png">
</p>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-operator">&lt;&lt;</span>savefig(title<span class="org-operator">=</span><span class="org-string">"Fire Type"</span>, layer<span class="org-operator">=</span><span class="org-string">"fire_type"</span>, units<span class="org-operator">=</span><span class="org-string">"1=surface,2=passive crown,3=active crown"</span>, colors<span class="org-operator">=</span><span class="org-string">"viridis"</span>)<span class="org-operator">&gt;&gt;</span>
</pre>
</div>


<div id="orgae64978" class="figure">
<p><img src="../doc/pics/worcester_fire_type.png" alt="worcester_fire_type.png">
</p>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-operator">&lt;&lt;</span>savefig(title<span class="org-operator">=</span><span class="org-string">"Eccentricity"</span>, layer<span class="org-operator">=</span><span class="org-string">"eccentricity"</span>, units<span class="org-operator">=</span><span class="org-string">"0=circular,&gt;0=elliptical"</span>, colors<span class="org-operator">=</span><span class="org-string">"viridis"</span>)<span class="org-operator">&gt;&gt;</span>
</pre>
</div>


<div id="org59d0431" class="figure">
<p><img src="../doc/pics/worcester_eccentricity.png" alt="worcester_eccentricity.png">
</p>
</div>
</div>
</div>
<div id="outline-container-org31cbc8e" class="outline-3">
<h3 id="org31cbc8e"><span class="section-number-3">15.6.</span> Comparing Pyretechnics Outputs with FLAMMAP Outputs</h3>
<div class="outline-text-3" id="text-15-6">
<div class="org-src-container">
<pre class="src src-python" id="org3e03dde"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pyretechnics.load_landfire <span class="org-keyword">import</span> load_raster, verify_raster_constraints

<span class="org-variable-name">flammap_file_paths</span> <span class="org-operator">=</span> {
    <span class="org-string">"max_spread_rate"</span>        : project_root <span class="org-operator">+</span> <span class="org-string">"/test/data/flammap_outputs/ROS_ch_hr.tif"</span>,
    <span class="org-string">"max_spread_direction"</span>   : project_root <span class="org-operator">+</span> <span class="org-string">"/test/data/flammap_outputs/max_spread_direction_radians.tif"</span>,
    <span class="org-string">"max_fire_line_intensity"</span>: project_root <span class="org-operator">+</span> <span class="org-string">"/test/data/flammap_outputs/FLI_BTU_ft-s.tif"</span>,
    <span class="org-string">"max_flame_length"</span>       : project_root <span class="org-operator">+</span> <span class="org-string">"/test/data/flammap_outputs/FL_ft.tif"</span>,
    <span class="org-string">"fire_type"</span>              : project_root <span class="org-operator">+</span> <span class="org-string">"/test/data/flammap_outputs/fire_type.tif"</span>,
}


<span class="org-variable-name">flammap_array_conversions</span> <span class="org-operator">=</span> {
    <span class="org-comment-delimiter">#</span><span class="org-comment">====================================================================================</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Layer Name             : (New dtype, Mult),                # In Units -&gt; Out Units</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">====================================================================================</span>
    <span class="org-string">"max_spread_rate"</span>        : (<span class="org-string">"float32"</span>, 0.33528),             <span class="org-comment-delimiter"># </span><span class="org-comment">ch/hr -&gt; m/min</span>
    <span class="org-string">"max_spread_direction"</span>   : (<span class="org-string">"int16"</span>  , 1),                   <span class="org-comment-delimiter"># </span><span class="org-comment">rad -&gt; rad</span>
    <span class="org-string">"max_fire_line_intensity"</span>: (<span class="org-string">"float32"</span>, 3.46165186),          <span class="org-comment-delimiter"># </span><span class="org-comment">Btu/ft/s -&gt; kW/m</span>
    <span class="org-string">"max_flame_length"</span>       : (<span class="org-string">"float32"</span>, 0.30478512648582745), <span class="org-comment-delimiter"># </span><span class="org-comment">ft -&gt; m</span>
    <span class="org-string">"fire_type"</span>              : (<span class="org-string">"uint8"</span>  , 1.0),                 <span class="org-comment-delimiter"># </span><span class="org-comment">0=unburned,1=surface,2=passive crown,3=active crown</span>
}


<span class="org-keyword">def</span> <span class="org-function-name">load_and_convert_flammap_rasters</span>(flammap_file_paths):
    <span class="org-variable-name">flammap_rasters</span> <span class="org-operator">=</span> {}

    <span class="org-keyword">for</span> name, path <span class="org-keyword">in</span> flammap_file_paths.items():
        (<span class="org-variable-name">dtype</span>, <span class="org-variable-name">multiplier</span>)   <span class="org-operator">=</span> flammap_array_conversions[name]
        <span class="org-variable-name">flammap_rasters</span>[name] <span class="org-operator">=</span> load_raster(path, dtype)
        <span class="org-variable-name">array</span>                 <span class="org-operator">=</span> flammap_rasters[name][<span class="org-string">"array"</span>]
        <span class="org-variable-name">nodata</span>                <span class="org-operator">=</span> flammap_rasters[name][<span class="org-string">"metadata"</span>][<span class="org-string">"nodata"</span>]
        <span class="org-variable-name">array</span>[array <span class="org-operator">==</span> nodata] <span class="org-operator">=</span> 0
        <span class="org-keyword">if</span> multiplier <span class="org-operator">!=</span> 1:
            <span class="org-variable-name">array</span>[array <span class="org-operator">!=</span> nodata] <span class="org-operator">*=</span> multiplier

    <span class="org-keyword">return</span> flammap_rasters


<span class="org-keyword">def</span> <span class="org-function-name">read_flammap_outputs</span>(flammap_file_paths):
    <span class="org-variable-name">raster_dict</span> <span class="org-operator">=</span> load_and_convert_flammap_rasters(flammap_file_paths)
    <span class="org-keyword">if</span> verify_raster_constraints(raster_dict.values()):
        <span class="org-variable-name">array_dict</span> <span class="org-operator">=</span> {name: raster[<span class="org-string">"array"</span>] <span class="org-keyword">for</span> name, raster <span class="org-keyword">in</span> raster_dict.items()}
        <span class="org-variable-name">array_dict</span>[<span class="org-string">"max_spread_direction"</span>] <span class="org-operator">=</span> np.rad2deg(array_dict[<span class="org-string">"max_spread_direction"</span>]) <span class="org-comment-delimiter"># </span><span class="org-comment">rad -&gt; deg</span>
        <span class="org-keyword">return</span> array_dict


<span class="org-keyword">def</span> <span class="org-function-name">slow_test_read_flammap_outputs</span>():
    <span class="org-keyword">return</span> read_flammap_outputs(flammap_file_paths)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgcebff7c" class="outline-2">
<h2 id="orgcebff7c"><span class="section-number-2">16.</span> Appendix</h2>
<div class="outline-text-2" id="text-16">
</div>
<div id="outline-container-org97a9436" class="outline-3">
<h3 id="org97a9436"><span class="section-number-3">16.1.</span> Units Conversion Functions (pyretechnics.conversion)</h3>
<div class="outline-text-3" id="text-16-1">
<div class="org-src-container">
<pre class="src src-python" id="orgb5cce4c"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> degrees, radians, tan, atan


<span class="org-keyword">def</span> <span class="org-function-name">F_to_K</span>(degrees):
    <span class="org-doc">"""Convert fahrenheit to kelvin."""</span>
    <span class="org-keyword">return</span> (degrees <span class="org-operator">+</span> 459.67) <span class="org-operator">*</span> 0.5555555555555556


<span class="org-keyword">def</span> <span class="org-function-name">K_to_F</span>(degrees):
    <span class="org-doc">"""Convert kelvin to fahrenheit."""</span>
    <span class="org-keyword">return</span> (degrees <span class="org-operator">*</span> 1.8) <span class="org-operator">-</span> 459.67


<span class="org-keyword">def</span> <span class="org-function-name">F_to_C</span>(degrees):
    <span class="org-doc">"""Convert fahrenheit to celsius."""</span>
    <span class="org-keyword">return</span> (degrees <span class="org-operator">-</span> 32.0) <span class="org-operator">*</span> 0.5555555555555556


<span class="org-keyword">def</span> <span class="org-function-name">C_to_F</span>(degrees):
    <span class="org-doc">"""Convert celsius to fahrenheit."""</span>
    <span class="org-keyword">return</span> (degrees <span class="org-operator">*</span> 1.8) <span class="org-operator">+</span> 32.0


<span class="org-keyword">def</span> <span class="org-function-name">deg_to_ratio</span>(degrees):
    <span class="org-doc">"""Convert degrees to ratio."""</span>
    <span class="org-keyword">return</span> tan(radians(degrees))


<span class="org-keyword">def</span> <span class="org-function-name">ratio_to_deg</span>(ratio):
    <span class="org-doc">"""Convert ratio to degrees."""</span>
    <span class="org-keyword">return</span> degrees(atan(ratio))


<span class="org-keyword">def</span> <span class="org-function-name">ch_to_m</span>(ch):
    <span class="org-doc">"""Convert chains to meters."""</span>
    <span class="org-keyword">return</span> ch <span class="org-operator">*</span> 20.1168


<span class="org-keyword">def</span> <span class="org-function-name">m_to_ch</span>(m):
    <span class="org-doc">"""Convert meters to chains."""</span>
    <span class="org-keyword">return</span> m <span class="org-operator">*</span> 0.0497097


<span class="org-keyword">def</span> <span class="org-function-name">m_to_ft</span>(m):
    <span class="org-doc">"""Convert meters to feet."""</span>
    <span class="org-keyword">return</span> m <span class="org-operator">*</span> 3.281


<span class="org-keyword">def</span> <span class="org-function-name">ft_to_m</span>(ft):
    <span class="org-doc">"""Convert feet to meters."""</span>
    <span class="org-keyword">return</span> ft <span class="org-operator">*</span> 0.30478512648582745


<span class="org-keyword">def</span> <span class="org-function-name">mph_to_mps</span>(mph):
    <span class="org-doc">"""Convert miles per hour to meters per second."""</span>
    <span class="org-keyword">return</span> mph <span class="org-operator">*</span> 0.44701818551254696


<span class="org-keyword">def</span> <span class="org-function-name">mps_to_mph</span>(mps):
    <span class="org-doc">"""Convert meters per second to miles per hour."""</span>
    <span class="org-keyword">return</span> mps <span class="org-operator">*</span> 2.237045454545455


<span class="org-keyword">def</span> <span class="org-function-name">mph_to_km_hr</span>(mph):
    <span class="org-doc">"""Convert miles per hour to kilometers per hour."""</span>
    <span class="org-keyword">return</span> mph <span class="org-operator">*</span> 1.609344


<span class="org-keyword">def</span> <span class="org-function-name">km_hr_to_mph</span>(km_hr):
    <span class="org-doc">"""Convert kilometers per hour to miles per hour."""</span>
    <span class="org-keyword">return</span> km_hr <span class="org-operator">*</span> 0.621371192237334


<span class="org-keyword">def</span> <span class="org-function-name">m_min_to_km_hr</span>(m_min):
    <span class="org-doc">"""Convert meters per minute to kilometers per hour."""</span>
    <span class="org-keyword">return</span> m_min <span class="org-operator">*</span> 0.06


<span class="org-keyword">def</span> <span class="org-function-name">km_hr_to_m_min</span>(km_hr):
    <span class="org-doc">"""Convert kilometers per hour to meters per minute."""</span>
    <span class="org-keyword">return</span> km_hr <span class="org-operator">/</span> 0.06


<span class="org-keyword">def</span> <span class="org-function-name">m_min_to_mph</span>(m_min):
    <span class="org-doc">"""Convert meters per minute to miles per hour."""</span>
    <span class="org-keyword">return</span> m_min <span class="org-operator">*</span> 0.0372840909091


<span class="org-keyword">def</span> <span class="org-function-name">mph_to_m_min</span>(mph):
    <span class="org-doc">"""Convert miles per hour to meters per minute."""</span>
    <span class="org-keyword">return</span> mph <span class="org-operator">*</span> 26.8210911307


<span class="org-keyword">def</span> <span class="org-function-name">mps_to_fpm</span>(mps):
    <span class="org-doc">"""Convert meters per second to feet per minute."""</span>
    <span class="org-keyword">return</span> mps <span class="org-operator">*</span> 196.86


<span class="org-keyword">def</span> <span class="org-function-name">fpm_to_mps</span>(fpm):
    <span class="org-doc">"""Convert feet per minute to meters per second."""</span>
    <span class="org-keyword">return</span> fpm <span class="org-operator">/</span> 196.86


<span class="org-keyword">def</span> <span class="org-function-name">mph_to_fpm</span>(mph):
    <span class="org-doc">"""Convert miles per hour to feet per minute."""</span>
    <span class="org-keyword">return</span> mph <span class="org-operator">*</span> 88.0


<span class="org-keyword">def</span> <span class="org-function-name">fpm_to_mph</span>(fpm):
    <span class="org-doc">"""Convert feet per minute to miles per hour."""</span>
    <span class="org-keyword">return</span> fpm <span class="org-operator">/</span> 88.0


<span class="org-keyword">def</span> <span class="org-function-name">wind_speed_20ft_to_wind_speed_10m</span>(wind_speed_20ft):
    <span class="org-doc">"""Convert wind speed at 20ft to wind speed at 10m."""</span>
    <span class="org-keyword">return</span> wind_speed_20ft <span class="org-operator">/</span> 0.87


<span class="org-keyword">def</span> <span class="org-function-name">wind_speed_10m_to_wind_speed_20ft</span>(wind_speed_10m):
    <span class="org-doc">"""Convert wind speed at 10m to wind speed at 20ft."""</span>
    <span class="org-keyword">return</span> 0.87 <span class="org-operator">*</span> wind_speed_10m


<span class="org-keyword">def</span> <span class="org-function-name">Btu_ft_s_to_kW_m</span>(Btu_ft_s):
    <span class="org-doc">"""Convert BTU per feet per second to kilowatt per meter."""</span>
    <span class="org-keyword">return</span> Btu_ft_s <span class="org-operator">*</span> 3.46165186


<span class="org-keyword">def</span> <span class="org-function-name">kW_m_to_Btu_ft_s</span>(kW_m):
    <span class="org-doc">"""Convert kilowatt per meter to BTU per feet per second."""</span>
    <span class="org-keyword">return</span> kW_m <span class="org-operator">*</span> 0.28887942532730604


<span class="org-keyword">def</span> <span class="org-function-name">Btu_lb_to_kJ_kg</span>(Btu_lb):
    <span class="org-doc">"""Convert BTU per lb to kilojoule per kilogram."""</span>
    <span class="org-keyword">return</span> Btu_lb <span class="org-operator">*</span> 2.3259999996185


<span class="org-keyword">def</span> <span class="org-function-name">kJ_kg_to_Btu_lb</span>(kJ_kg):
    <span class="org-doc">"""Convert kilojoule per kilogram to BTU per lb."""</span>
    <span class="org-keyword">return</span> kJ_kg <span class="org-operator">/</span> 2.3259999996185


<span class="org-keyword">def</span> <span class="org-function-name">kg_m3_to_lb_ft3</span>(kg_m3):
    <span class="org-doc">"""Convert kilogram per cubic meter to pound per cubic foot."""</span>
    <span class="org-keyword">return</span> kg_m3 <span class="org-operator">*</span> 0.0624


<span class="org-keyword">def</span> <span class="org-function-name">lb_ft3_to_kg_m3</span>(lb_ft3):
    <span class="org-doc">"""Convert pound per cubic foot to kilogram per cubic meter."""</span>
    <span class="org-keyword">return</span> lb_ft3 <span class="org-operator">*</span> 16.025641025641026


<span class="org-keyword">def</span> <span class="org-function-name">percent_to_dec</span>(percent):
    <span class="org-doc">"""Convert percent to decimal."""</span>
    <span class="org-keyword">return</span> percent <span class="org-operator">*</span> 0.01


<span class="org-keyword">def</span> <span class="org-function-name">dec_to_percent</span>(decimal):
    <span class="org-doc">"""Convert decimal to percent."""</span>
    <span class="org-keyword">return</span> decimal <span class="org-operator">*</span> 100.0


<span class="org-keyword">def</span> <span class="org-function-name">sec_to_min</span>(seconds):
    <span class="org-doc">"""Convert seconds to minutes."""</span>
    <span class="org-keyword">return</span> seconds <span class="org-operator">*</span> 0.016666666666666666


<span class="org-keyword">def</span> <span class="org-function-name">min_to_sec</span>(minutes):
    <span class="org-doc">"""Convert minutes to seconds."""</span>
    <span class="org-keyword">return</span> minutes <span class="org-operator">*</span> 60.0


<span class="org-keyword">def</span> <span class="org-function-name">ms_to_min</span>(milliseconds):
    <span class="org-doc">"""Convert milliseconds to minutes."""</span>
    <span class="org-keyword">return</span> milliseconds <span class="org-operator">*</span> 0.000016667


<span class="org-keyword">def</span> <span class="org-function-name">min_to_ms</span>(minutes):
    <span class="org-doc">"""Convert minutes to milliseconds."""</span>
    <span class="org-keyword">return</span> <span class="org-builtin">int</span>(minutes <span class="org-operator">*</span> 60000.0)


<span class="org-keyword">def</span> <span class="org-function-name">hour_to_min</span>(hours):
    <span class="org-doc">"""Converts hours to minutes."""</span>
    <span class="org-keyword">return</span> hours <span class="org-operator">*</span> 60.0


<span class="org-keyword">def</span> <span class="org-function-name">min_to_hour</span>(minutes):
    <span class="org-doc">"""Converts minutes to hours. (rounds down)"""</span>
    <span class="org-keyword">return</span> <span class="org-builtin">int</span>(minutes <span class="org-operator">/</span> 60.0)


<span class="org-keyword">def</span> <span class="org-function-name">day_to_min</span>(days):
    <span class="org-doc">"""Convert days to minutes."""</span>
    <span class="org-keyword">return</span> days <span class="org-operator">*</span> 1440.0


<span class="org-keyword">def</span> <span class="org-function-name">min_to_day</span>(minutes):
    <span class="org-doc">"""Convert minutes to days."""</span>
    <span class="org-keyword">return</span> minutes <span class="org-operator">/</span> 1440.0
</pre>
</div>
</div>
</div>
<div id="outline-container-orgebedc9d" class="outline-3">
<h3 id="orgebedc9d"><span class="section-number-3">16.2.</span> SpaceTimeCube and LazySpaceTimeCube Tests (pyretechnics_test.test_space_time_cube)</h3>
<div class="outline-text-3" id="text-16-2">
<div class="org-src-container">
<pre class="src src-python" id="orgf2c1a6e"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> pyretechnics.space_time_cube <span class="org-keyword">import</span> SpaceTimeCube, LazySpaceTimeCube

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Raw Data - Managed by the Caller</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">2D Arrays (e.g. 30m x 30m resolution, 30km x 30km extent)</span>
<span class="org-variable-name">elevation_layer</span>                    <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">slope_layer</span>                        <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">aspect_layer</span>                       <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">fuel_model_layer</span>                   <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">canopy_cover_layer</span>                 <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">canopy_height_layer</span>                <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">canopy_base_height_layer</span>           <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">canopy_bulk_density_layer</span>          <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000)
<span class="org-variable-name">fuel_spread_adjustment_layer</span>       <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000) <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>
<span class="org-variable-name">suppression_difficulty_index_layer</span> <span class="org-operator">=</span> np.arange(0,1000000).reshape(1000,1000) <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">3D Arrays (e.g. 1hr x 300m x 300m resolution, 1day x 30km x 30km extent)</span>
<span class="org-variable-name">temperature_layer</span>                   <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">relative_humidity_layer</span>             <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">wind_speed_10m_x_layer</span>              <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">wind_speed_10m_y_layer</span>              <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">fuel_moisture_dead_1hr_layer</span>        <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">fuel_moisture_dead_10hr_layer</span>       <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">fuel_moisture_dead_100hr_layer</span>      <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">fuel_moisture_live_herbaceous_layer</span> <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">fuel_moisture_live_woody_layer</span>      <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">foliar_moisture_layer</span>               <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100)
<span class="org-variable-name">weather_spread_adjustment_layer</span>     <span class="org-operator">=</span> np.arange(240000).reshape(24,100,100) <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Specify the SpaceTimeCube Dimensions</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

<span class="org-variable-name">cube_shape</span> <span class="org-operator">=</span> (
    24,   <span class="org-comment-delimiter"># </span><span class="org-comment">bands: 1 day @ 1 hour/band</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">rows:  30 km @ 30 meters/row</span>
    1000, <span class="org-comment-delimiter"># </span><span class="org-comment">cols:  30 km @ 30 meters/col</span>
)

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Create the Dictionary of Layer Names to SpaceTimeCubes</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

<span class="org-keyword">def</span> <span class="org-function-name">test_make_layer_lookup</span>():
    <span class="org-variable-name">layer_lookup</span> <span class="org-operator">=</span> {
        <span class="org-comment-delimiter"># </span><span class="org-comment">2D Arrays (e.g. 30m x 30m resolution, 30km x 30km extent)</span>
        <span class="org-string">"elevation"</span>                    : SpaceTimeCube(cube_shape, elevation_layer),
        <span class="org-string">"slope"</span>                        : SpaceTimeCube(cube_shape, slope_layer),
        <span class="org-string">"aspect"</span>                       : SpaceTimeCube(cube_shape, aspect_layer),
        <span class="org-string">"fuel_model"</span>                   : SpaceTimeCube(cube_shape, fuel_model_layer),
        <span class="org-string">"canopy_cover"</span>                 : SpaceTimeCube(cube_shape, canopy_cover_layer),
        <span class="org-string">"canopy_height"</span>                : SpaceTimeCube(cube_shape, canopy_height_layer),
        <span class="org-string">"canopy_base_height"</span>           : SpaceTimeCube(cube_shape, canopy_base_height_layer),
        <span class="org-string">"canopy_bulk_density"</span>          : SpaceTimeCube(cube_shape, canopy_bulk_density_layer),
        <span class="org-string">"fuel_spread_adjustment"</span>       : SpaceTimeCube(cube_shape, fuel_spread_adjustment_layer),       <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>
        <span class="org-string">"suppression_difficulty_index"</span> : SpaceTimeCube(cube_shape, suppression_difficulty_index_layer), <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">3D Arrays (e.g. 1hr x 300m x 300m resolution, 1day x 30km x 30km extent)</span>
        <span class="org-string">"temperature"</span>                  : SpaceTimeCube(cube_shape, temperature_layer),
        <span class="org-string">"relative_humidity"</span>            : SpaceTimeCube(cube_shape, relative_humidity_layer),
        <span class="org-string">"wind_speed_10m_x"</span>             : SpaceTimeCube(cube_shape, wind_speed_10m_x_layer),
        <span class="org-string">"wind_speed_10m_y"</span>             : SpaceTimeCube(cube_shape, wind_speed_10m_y_layer),
        <span class="org-string">"fuel_moisture_dead_1hr"</span>       : SpaceTimeCube(cube_shape, fuel_moisture_dead_1hr_layer),
        <span class="org-string">"fuel_moisture_dead_10hr"</span>      : SpaceTimeCube(cube_shape, fuel_moisture_dead_10hr_layer),
        <span class="org-string">"fuel_moisture_dead_100hr"</span>     : SpaceTimeCube(cube_shape, fuel_moisture_dead_100hr_layer),
        <span class="org-string">"fuel_moisture_live_herbaceous"</span>: SpaceTimeCube(cube_shape, fuel_moisture_live_herbaceous_layer),
        <span class="org-string">"fuel_moisture_live_woody"</span>     : SpaceTimeCube(cube_shape, fuel_moisture_live_woody_layer),
        <span class="org-string">"foliar_moisture"</span>              : SpaceTimeCube(cube_shape, foliar_moisture_layer),
        <span class="org-string">"weather_spread_adjustment"</span>    : SpaceTimeCube(cube_shape, weather_spread_adjustment_layer),    <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>
    }
    <span class="org-keyword">assert</span> <span class="org-builtin">all</span>(<span class="org-builtin">map</span>(<span class="org-keyword">lambda</span> cube: <span class="org-builtin">isinstance</span>(cube.data, np.ndarray), layer_lookup.values()))
    <span class="org-keyword">return</span> layer_lookup

<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Looking Up Values in the Layers</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">==============================================================</span>

<span class="org-keyword">def</span> <span class="org-function-name">test_use_layer_lookup_2d</span>():
    <span class="org-variable-name">layer_lookup</span> <span class="org-operator">=</span> test_make_layer_lookup()
    <span class="org-variable-name">dem_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"elevation"</span>].get(0,100,100)
    <span class="org-variable-name">slp_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"slope"</span>].get(0,100,100)
    <span class="org-variable-name">asp_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"aspect"</span>].get(0,100,100)
    <span class="org-variable-name">fbfm_100_100</span> <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_model"</span>].get(0,100,100)
    <span class="org-variable-name">cc_100_100</span>   <span class="org-operator">=</span> layer_lookup[<span class="org-string">"canopy_cover"</span>].get(0,100,100)
    <span class="org-variable-name">ch_100_100</span>   <span class="org-operator">=</span> layer_lookup[<span class="org-string">"canopy_height"</span>].get(0,100,100)
    <span class="org-variable-name">cbh_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"canopy_base_height"</span>].get(0,100,100)
    <span class="org-variable-name">cbd_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"canopy_bulk_density"</span>].get(0,100,100)
    <span class="org-variable-name">fsa_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_spread_adjustment"</span>].get(0,100,100)           <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>
    <span class="org-variable-name">sdi_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"suppression_difficulty_index"</span>].get(0,100,100)     <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>
    <span class="org-keyword">assert</span> dem_100_100  <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> slp_100_100  <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> asp_100_100  <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> fbfm_100_100 <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> cc_100_100   <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> ch_100_100   <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> cbh_100_100  <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> cbd_100_100  <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> fsa_100_100  <span class="org-operator">==</span> 100100
    <span class="org-keyword">assert</span> sdi_100_100  <span class="org-operator">==</span> 100100


<span class="org-keyword">def</span> <span class="org-function-name">test_use_layer_lookup_3d</span>():
    <span class="org-variable-name">layer_lookup</span>     <span class="org-operator">=</span> test_make_layer_lookup()
    <span class="org-variable-name">temp_12_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"temperature"</span>].get(12,100,100)
    <span class="org-variable-name">rh_12_100_100</span>    <span class="org-operator">=</span> layer_lookup[<span class="org-string">"relative_humidity"</span>].get(12,100,100)
    <span class="org-variable-name">wspx_12_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"wind_speed_10m_x"</span>].get(12,100,100)
    <span class="org-variable-name">wspy_12_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"wind_speed_10m_y"</span>].get(12,100,100)
    <span class="org-variable-name">md1_12_100_100</span>   <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_moisture_dead_1hr"</span>].get(12,100,100)
    <span class="org-variable-name">md10_12_100_100</span>  <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_moisture_dead_10hr"</span>].get(12,100,100)
    <span class="org-variable-name">md100_12_100_100</span> <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_moisture_dead_100hr"</span>].get(12,100,100)
    <span class="org-variable-name">mlh_12_100_100</span>   <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_moisture_live_herbaceous"</span>].get(12,100,100)
    <span class="org-variable-name">mlw_12_100_100</span>   <span class="org-operator">=</span> layer_lookup[<span class="org-string">"fuel_moisture_live_woody"</span>].get(12,100,100)
    <span class="org-variable-name">fm_12_100_100</span>    <span class="org-operator">=</span> layer_lookup[<span class="org-string">"foliar_moisture"</span>].get(12,100,100)
    <span class="org-variable-name">wsa_12_100_100</span>   <span class="org-operator">=</span> layer_lookup[<span class="org-string">"weather_spread_adjustment"</span>].get(12,100,100) <span class="org-comment-delimiter"># </span><span class="org-comment">Optional</span>
    <span class="org-keyword">assert</span> temp_12_100_100  <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> rh_12_100_100    <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> wspx_12_100_100  <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> wspy_12_100_100  <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> md1_12_100_100   <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> md10_12_100_100  <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> md100_12_100_100 <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> mlh_12_100_100   <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> mlw_12_100_100   <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> fm_12_100_100    <span class="org-operator">==</span> 121010
    <span class="org-keyword">assert</span> wsa_12_100_100   <span class="org-operator">==</span> 121010
</pre>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://en.wikipedia.org/wiki/Literate_programming">https://en.wikipedia.org/wiki/Literate_programming</a></p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://guix.gnu.org">https://guix.gnu.org</a></p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://landfire.gov">https://landfire.gov</a></p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://www.nco.ncep.noaa.gov/pmb/products/rtma/">https://www.nco.ncep.noaa.gov/pmb/products/rtma/</a></p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5" role="doc-backlink">5</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Anderson1982</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6" role="doc-backlink">6</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Scott2005</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7" role="doc-backlink">7</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Burgan1979</p></div></div>

<div class="footdef"><sup><a id="fn.8" class="footnum" href="#fnr.8" role="doc-backlink">8</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Rothermel1972</p></div></div>

<div class="footdef"><sup><a id="fn.9" class="footnum" href="#fnr.9" role="doc-backlink">9</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Rothermel1972</p></div></div>

<div class="footdef"><sup><a id="fn.10" class="footnum" href="#fnr.10" role="doc-backlink">10</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1976</p></div></div>

<div class="footdef"><sup><a id="fn.11" class="footnum" href="#fnr.11" role="doc-backlink">11</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Rothermel1972</p></div></div>

<div class="footdef"><sup><a id="fn.12" class="footnum" href="#fnr.12" role="doc-backlink">12</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1976</p></div></div>

<div class="footdef"><sup><a id="fn.13" class="footnum" href="#fnr.13" role="doc-backlink">13</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Andrews2018</p></div></div>

<div class="footdef"><sup><a id="fn.14" class="footnum" href="#fnr.14" role="doc-backlink">14</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Anderson1969</p></div></div>

<div class="footdef"><sup><a id="fn.15" class="footnum" href="#fnr.15" role="doc-backlink">15</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Byram1959</p></div></div>

<div class="footdef"><sup><a id="fn.16" class="footnum" href="#fnr.16" role="doc-backlink">16</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Rothermel1983</p></div></div>

<div class="footdef"><sup><a id="fn.17" class="footnum" href="#fnr.17" role="doc-backlink">17</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1979</p></div></div>

<div class="footdef"><sup><a id="fn.18" class="footnum" href="#fnr.18" role="doc-backlink">18</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Andrews2012</p></div></div>

<div class="footdef"><sup><a id="fn.19" class="footnum" href="#fnr.19" role="doc-backlink">19</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1976</p></div></div>

<div class="footdef"><sup><a id="fn.20" class="footnum" href="#fnr.20" role="doc-backlink">20</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Rothermel1991</p></div></div>

<div class="footdef"><sup><a id="fn.21" class="footnum" href="#fnr.21" role="doc-backlink">21</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1980</p></div></div>

<div class="footdef"><sup><a id="fn.22" class="footnum" href="#fnr.22" role="doc-backlink">22</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">VanWagner1977</p></div></div>

<div class="footdef"><sup><a id="fn.23" class="footnum" href="#fnr.23" role="doc-backlink">23</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Cruz2005</p></div></div>

<div class="footdef"><sup><a id="fn.24" class="footnum" href="#fnr.24" role="doc-backlink">24</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Rothermel1991</p></div></div>

<div class="footdef"><sup><a id="fn.25" class="footnum" href="#fnr.25" role="doc-backlink">25</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Albini1980</p></div></div>

<div class="footdef"><sup><a id="fn.26" class="footnum" href="#fnr.26" role="doc-backlink">26</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://elmfire.io">https://elmfire.io</a></p></div></div>

<div class="footdef"><sup><a id="fn.27" class="footnum" href="#fnr.27" role="doc-backlink">27</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://landfire.gov">https://landfire.gov</a></p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Gary W. Johnson, Valentin Waeselynck, Chris Lautenberger</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
